(() => {
    var __webpack_modules__ = ({
        "./node_modules/@splidejs/splide/dist/js/splide.esm.js":
            /*!*************************************************************!*\
              !*** ./node_modules/@splidejs/splide/dist/js/splide.esm.js ***!
              \*************************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (Splide)
                });

                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        if ("value" in descriptor) descriptor.writable = !0;
                        Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    Object.defineProperty(Constructor, "prototype", {
                        writable: !1
                    });
                    return Constructor
                }
                /*!
                 * Splide.js
                 * Version  : 4.1.4
                 * License  : MIT
                 * Copyright: 2022 Naotoshi Fujita
                 */
                var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
                var CREATED = 1;
                var MOUNTED = 2;
                var IDLE = 3;
                var MOVING = 4;
                var SCROLLING = 5;
                var DRAGGING = 6;
                var DESTROYED = 7;
                var STATES = {
                    CREATED: CREATED,
                    MOUNTED: MOUNTED,
                    IDLE: IDLE,
                    MOVING: MOVING,
                    SCROLLING: SCROLLING,
                    DRAGGING: DRAGGING,
                    DESTROYED: DESTROYED
                };

                function empty(array) {
                    array.length = 0
                }

                function slice(arrayLike, start, end) {
                    return Array.prototype.slice.call(arrayLike, start, end)
                }

                function apply(func) {
                    return func.bind.apply(func, [null].concat(slice(arguments, 1)))
                }
                var nextTick = setTimeout;
                var noop = function noop() {};

                function raf(func) {
                    return requestAnimationFrame(func)
                }

                function typeOf(type, subject) {
                    return typeof subject === type
                }

                function isObject(subject) {
                    return !isNull(subject) && typeOf("object", subject)
                }
                var isArray = Array.isArray;
                var isFunction = apply(typeOf, "function");
                var isString = apply(typeOf, "string");
                var isUndefined = apply(typeOf, "undefined");

                function isNull(subject) {
                    return subject === null
                }

                function isHTMLElement(subject) {
                    try {
                        return subject instanceof(subject.ownerDocument.defaultView || window).HTMLElement
                    } catch (e) {
                        return !1
                    }
                }

                function toArray(value) {
                    return isArray(value) ? value : [value]
                }

                function forEach(values, iteratee) {
                    toArray(values).forEach(iteratee)
                }

                function includes(array, value) {
                    return array.indexOf(value) > -1
                }

                function push(array, items) {
                    array.push.apply(array, toArray(items));
                    return array
                }

                function toggleClass(elm, classes, add) {
                    if (elm) {
                        forEach(classes, function(name) {
                            if (name) {
                                elm.classList[add ? "add" : "remove"](name)
                            }
                        })
                    }
                }

                function addClass(elm, classes) {
                    toggleClass(elm, isString(classes) ? classes.split(" ") : classes, !0)
                }

                function append(parent, children) {
                    forEach(children, parent.appendChild.bind(parent))
                }

                function before(nodes, ref) {
                    forEach(nodes, function(node) {
                        var parent = (ref || node).parentNode;
                        if (parent) {
                            parent.insertBefore(node, ref)
                        }
                    })
                }

                function matches(elm, selector) {
                    return isHTMLElement(elm) && (elm.msMatchesSelector || elm.matches).call(elm, selector)
                }

                function children(parent, selector) {
                    var children2 = parent ? slice(parent.children) : [];
                    return selector ? children2.filter(function(child) {
                        return matches(child, selector)
                    }) : children2
                }

                function child(parent, selector) {
                    return selector ? children(parent, selector)[0] : parent.firstElementChild
                }
                var ownKeys = Object.keys;

                function forOwn(object, iteratee, right) {
                    if (object) {
                        (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function(key) {
                            key !== "__proto__" && iteratee(object[key], key)
                        })
                    }
                    return object
                }

                function assign(object) {
                    slice(arguments, 1).forEach(function(source) {
                        forOwn(source, function(value, key) {
                            object[key] = source[key]
                        })
                    });
                    return object
                }

                function merge(object) {
                    slice(arguments, 1).forEach(function(source) {
                        forOwn(source, function(value, key) {
                            if (isArray(value)) {
                                object[key] = value.slice()
                            } else if (isObject(value)) {
                                object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value)
                            } else {
                                object[key] = value
                            }
                        })
                    });
                    return object
                }

                function omit(object, keys) {
                    forEach(keys || ownKeys(object), function(key) {
                        delete object[key]
                    })
                }

                function removeAttribute(elms, attrs) {
                    forEach(elms, function(elm) {
                        forEach(attrs, function(attr) {
                            elm && elm.removeAttribute(attr)
                        })
                    })
                }

                function setAttribute(elms, attrs, value) {
                    if (isObject(attrs)) {
                        forOwn(attrs, function(value2, name) {
                            setAttribute(elms, name, value2)
                        })
                    } else {
                        forEach(elms, function(elm) {
                            isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value))
                        })
                    }
                }

                function create(tag, attrs, parent) {
                    var elm = document.createElement(tag);
                    if (attrs) {
                        isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs)
                    }
                    parent && append(parent, elm);
                    return elm
                }

                function style(elm, prop, value) {
                    if (isUndefined(value)) {
                        return getComputedStyle(elm)[prop]
                    }
                    if (!isNull(value)) {
                        elm.style[prop] = "" + value
                    }
                }

                function display(elm, display2) {
                    style(elm, "display", display2)
                }

                function focus(elm) {
                    elm.setActive && elm.setActive() || elm.focus({
                        preventScroll: !0
                    })
                }

                function getAttribute(elm, attr) {
                    return elm.getAttribute(attr)
                }

                function hasClass(elm, className) {
                    return elm && elm.classList.contains(className)
                }

                function rect(target) {
                    return target.getBoundingClientRect()
                }

                function remove(nodes) {
                    forEach(nodes, function(node) {
                        if (node && node.parentNode) {
                            node.parentNode.removeChild(node)
                        }
                    })
                }

                function parseHtml(html) {
                    return child(new DOMParser().parseFromString(html, "text/html").body)
                }

                function prevent(e, stopPropagation) {
                    e.preventDefault();
                    if (stopPropagation) {
                        e.stopPropagation();
                        e.stopImmediatePropagation()
                    }
                }

                function query(parent, selector) {
                    return parent && parent.querySelector(selector)
                }

                function queryAll(parent, selector) {
                    return selector ? slice(parent.querySelectorAll(selector)) : []
                }

                function removeClass(elm, classes) {
                    toggleClass(elm, classes, !1)
                }

                function timeOf(e) {
                    return e.timeStamp
                }

                function unit(value) {
                    return isString(value) ? value : value ? value + "px" : ""
                }
                var PROJECT_CODE = "splide";
                var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

                function assert(condition, message) {
                    if (!condition) {
                        throw new Error("[" + PROJECT_CODE + "] " + (message || ""))
                    }
                }
                var min = Math.min,
                    max = Math.max,
                    floor = Math.floor,
                    ceil = Math.ceil,
                    abs = Math.abs;

                function approximatelyEqual(x, y, epsilon) {
                    return abs(x - y) < epsilon
                }

                function between(number, x, y, exclusive) {
                    var minimum = min(x, y);
                    var maximum = max(x, y);
                    return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum
                }

                function clamp(number, x, y) {
                    var minimum = min(x, y);
                    var maximum = max(x, y);
                    return min(max(minimum, number), maximum)
                }

                function sign(x) {
                    return +(x > 0) - +(x < 0)
                }

                function camelToKebab(string) {
                    return string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
                }

                function format(string, replacements) {
                    forEach(replacements, function(replacement) {
                        string = string.replace("%s", "" + replacement)
                    });
                    return string
                }

                function pad(number) {
                    return number < 10 ? "0" + number : "" + number
                }
                var ids = {};

                function uniqueId(prefix) {
                    return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1)
                }

                function EventBinder() {
                    var listeners = [];

                    function bind(targets, events, callback, options) {
                        forEachEvent(targets, events, function(target, event, namespace) {
                            var isEventTarget = ("addEventListener" in target);
                            var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target.removeListener.bind(target, callback);
                            isEventTarget ? target.addEventListener(event, callback, options) : target.addListener(callback);
                            listeners.push([target, event, namespace, callback, remover])
                        })
                    }

                    function unbind(targets, events, callback) {
                        forEachEvent(targets, events, function(target, event, namespace) {
                            listeners = listeners.filter(function(listener) {
                                if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
                                    listener[4]();
                                    return !1
                                }
                                return !0
                            })
                        })
                    }

                    function dispatch(target, type, detail) {
                        var e;
                        var bubbles = !0;
                        if (typeof CustomEvent === "function") {
                            e = new CustomEvent(type, {
                                bubbles: bubbles,
                                detail: detail
                            })
                        } else {
                            e = document.createEvent("CustomEvent");
                            e.initCustomEvent(type, bubbles, !1, detail)
                        }
                        target.dispatchEvent(e);
                        return e
                    }

                    function forEachEvent(targets, events, iteratee) {
                        forEach(targets, function(target) {
                            target && forEach(events, function(events2) {
                                events2.split(" ").forEach(function(eventNS) {
                                    var fragment = eventNS.split(".");
                                    iteratee(target, fragment[0], fragment[1])
                                })
                            })
                        })
                    }

                    function destroy() {
                        listeners.forEach(function(data) {
                            data[4]()
                        });
                        empty(listeners)
                    }
                    return {
                        bind: bind,
                        unbind: unbind,
                        dispatch: dispatch,
                        destroy: destroy
                    }
                }
                var EVENT_MOUNTED = "mounted";
                var EVENT_READY = "ready";
                var EVENT_MOVE = "move";
                var EVENT_MOVED = "moved";
                var EVENT_CLICK = "click";
                var EVENT_ACTIVE = "active";
                var EVENT_INACTIVE = "inactive";
                var EVENT_VISIBLE = "visible";
                var EVENT_HIDDEN = "hidden";
                var EVENT_REFRESH = "refresh";
                var EVENT_UPDATED = "updated";
                var EVENT_RESIZE = "resize";
                var EVENT_RESIZED = "resized";
                var EVENT_DRAG = "drag";
                var EVENT_DRAGGING = "dragging";
                var EVENT_DRAGGED = "dragged";
                var EVENT_SCROLL = "scroll";
                var EVENT_SCROLLED = "scrolled";
                var EVENT_OVERFLOW = "overflow";
                var EVENT_DESTROY = "destroy";
                var EVENT_ARROWS_MOUNTED = "arrows:mounted";
                var EVENT_ARROWS_UPDATED = "arrows:updated";
                var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
                var EVENT_PAGINATION_UPDATED = "pagination:updated";
                var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
                var EVENT_AUTOPLAY_PLAY = "autoplay:play";
                var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
                var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
                var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
                var EVENT_SLIDE_KEYDOWN = "sk";
                var EVENT_SHIFTED = "sh";
                var EVENT_END_INDEX_CHANGED = "ei";

                function EventInterface(Splide2) {
                    var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
                    var binder = EventBinder();

                    function on(events, callback) {
                        binder.bind(bus, toArray(events).join(" "), function(e) {
                            callback.apply(callback, isArray(e.detail) ? e.detail : [])
                        })
                    }

                    function emit(event) {
                        binder.dispatch(bus, event, slice(arguments, 1))
                    }
                    if (Splide2) {
                        Splide2.event.on(EVENT_DESTROY, binder.destroy)
                    }
                    return assign(binder, {
                        bus: bus,
                        on: on,
                        off: apply(binder.unbind, bus),
                        emit: emit
                    })
                }

                function RequestInterval(interval, onInterval, onUpdate, limit) {
                    var now = Date.now;
                    var startTime;
                    var rate = 0;
                    var id;
                    var paused = !0;
                    var count = 0;

                    function update() {
                        if (!paused) {
                            rate = interval ? min((now() - startTime) / interval, 1) : 1;
                            onUpdate && onUpdate(rate);
                            if (rate >= 1) {
                                onInterval();
                                startTime = now();
                                if (limit && ++count >= limit) {
                                    return pause()
                                }
                            }
                            id = raf(update)
                        }
                    }

                    function start(resume) {
                        resume || cancel();
                        startTime = now() - (resume ? rate * interval : 0);
                        paused = !1;
                        id = raf(update)
                    }

                    function pause() {
                        paused = !0
                    }

                    function rewind() {
                        startTime = now();
                        rate = 0;
                        if (onUpdate) {
                            onUpdate(rate)
                        }
                    }

                    function cancel() {
                        id && cancelAnimationFrame(id);
                        rate = 0;
                        id = 0;
                        paused = !0
                    }

                    function set(time) {
                        interval = time
                    }

                    function isPaused() {
                        return paused
                    }
                    return {
                        start: start,
                        rewind: rewind,
                        pause: pause,
                        cancel: cancel,
                        set: set,
                        isPaused: isPaused
                    }
                }

                function State(initialState) {
                    var state = initialState;

                    function set(value) {
                        state = value
                    }

                    function is(states) {
                        return includes(toArray(states), state)
                    }
                    return {
                        set: set,
                        is: is
                    }
                }

                function Throttle(func, duration) {
                    var interval = RequestInterval(duration || 0, func, null, 1);
                    return function() {
                        interval.isPaused() && interval.start()
                    }
                }

                function Media(Splide2, Components2, options) {
                    var state = Splide2.state;
                    var breakpoints = options.breakpoints || {};
                    var reducedMotion = options.reducedMotion || {};
                    var binder = EventBinder();
                    var queries = [];

                    function setup() {
                        var isMin = options.mediaQuery === "min";
                        ownKeys(breakpoints).sort(function(n, m) {
                            return isMin ? +n - +m : +m - +n
                        }).forEach(function(key) {
                            register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)")
                        });
                        register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
                        update()
                    }

                    function destroy(completely) {
                        if (completely) {
                            binder.destroy()
                        }
                    }

                    function register(options2, query) {
                        var queryList = matchMedia(query);
                        binder.bind(queryList, "change", update);
                        queries.push([options2, queryList])
                    }

                    function update() {
                        var destroyed = state.is(DESTROYED);
                        var direction = options.direction;
                        var merged = queries.reduce(function(merged2, entry) {
                            return merge(merged2, entry[1].matches ? entry[0] : {})
                        }, {});
                        omit(options);
                        set(merged);
                        if (options.destroy) {
                            Splide2.destroy(options.destroy === "completely")
                        } else if (destroyed) {
                            destroy(!0);
                            Splide2.mount()
                        } else {
                            direction !== options.direction && Splide2.refresh()
                        }
                    }

                    function reduce(enable) {
                        if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
                            enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion))
                        }
                    }

                    function set(opts, base, notify) {
                        merge(options, opts);
                        base && merge(Object.getPrototypeOf(options), opts);
                        if (notify || !state.is(CREATED)) {
                            Splide2.emit(EVENT_UPDATED, options)
                        }
                    }
                    return {
                        setup: setup,
                        destroy: destroy,
                        reduce: reduce,
                        set: set
                    }
                }
                var ARROW = "Arrow";
                var ARROW_LEFT = ARROW + "Left";
                var ARROW_RIGHT = ARROW + "Right";
                var ARROW_UP = ARROW + "Up";
                var ARROW_DOWN = ARROW + "Down";
                var LTR = "ltr";
                var RTL = "rtl";
                var TTB = "ttb";
                var ORIENTATION_MAP = {
                    width: ["height"],
                    left: ["top", "right"],
                    right: ["bottom", "left"],
                    x: ["y"],
                    X: ["Y"],
                    Y: ["X"],
                    ArrowLeft: [ARROW_UP, ARROW_RIGHT],
                    ArrowRight: [ARROW_DOWN, ARROW_LEFT]
                };

                function Direction(Splide2, Components2, options) {
                    function resolve(prop, axisOnly, direction) {
                        direction = direction || options.direction;
                        var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
                        return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function(match, offset) {
                            var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
                            return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement
                        })
                    }

                    function orient(value) {
                        return value * (options.direction === RTL ? 1 : -1)
                    }
                    return {
                        resolve: resolve,
                        orient: orient
                    }
                }
                var ROLE = "role";
                var TAB_INDEX = "tabindex";
                var DISABLED = "disabled";
                var ARIA_PREFIX = "aria-";
                var ARIA_CONTROLS = ARIA_PREFIX + "controls";
                var ARIA_CURRENT = ARIA_PREFIX + "current";
                var ARIA_SELECTED = ARIA_PREFIX + "selected";
                var ARIA_LABEL = ARIA_PREFIX + "label";
                var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
                var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
                var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
                var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
                var ARIA_LIVE = ARIA_PREFIX + "live";
                var ARIA_BUSY = ARIA_PREFIX + "busy";
                var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
                var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
                var CLASS_PREFIX = PROJECT_CODE + "__";
                var STATUS_CLASS_PREFIX = "is-";
                var CLASS_ROOT = PROJECT_CODE;
                var CLASS_TRACK = CLASS_PREFIX + "track";
                var CLASS_LIST = CLASS_PREFIX + "list";
                var CLASS_SLIDE = CLASS_PREFIX + "slide";
                var CLASS_CLONE = CLASS_SLIDE + "--clone";
                var CLASS_CONTAINER = CLASS_SLIDE + "__container";
                var CLASS_ARROWS = CLASS_PREFIX + "arrows";
                var CLASS_ARROW = CLASS_PREFIX + "arrow";
                var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
                var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
                var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
                var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
                var CLASS_PROGRESS = CLASS_PREFIX + "progress";
                var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
                var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
                var CLASS_TOGGLE_PLAY = CLASS_TOGGLE + "__play";
                var CLASS_TOGGLE_PAUSE = CLASS_TOGGLE + "__pause";
                var CLASS_SPINNER = CLASS_PREFIX + "spinner";
                var CLASS_SR = CLASS_PREFIX + "sr";
                var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
                var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
                var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
                var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
                var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
                var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
                var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
                var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
                var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
                var CLASSES = {
                    slide: CLASS_SLIDE,
                    clone: CLASS_CLONE,
                    arrows: CLASS_ARROWS,
                    arrow: CLASS_ARROW,
                    prev: CLASS_ARROW_PREV,
                    next: CLASS_ARROW_NEXT,
                    pagination: CLASS_PAGINATION,
                    page: CLASS_PAGINATION_PAGE,
                    spinner: CLASS_SPINNER
                };

                function closest(from, selector) {
                    if (isFunction(from.closest)) {
                        return from.closest(selector)
                    }
                    var elm = from;
                    while (elm && elm.nodeType === 1) {
                        if (matches(elm, selector)) {
                            break
                        }
                        elm = elm.parentElement
                    }
                    return elm
                }
                var FRICTION = 5;
                var LOG_INTERVAL = 200;
                var POINTER_DOWN_EVENTS = "touchstart mousedown";
                var POINTER_MOVE_EVENTS = "touchmove mousemove";
                var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

                function Elements(Splide2, Components2, options) {
                    var _EventInterface = EventInterface(Splide2),
                        on = _EventInterface.on,
                        bind = _EventInterface.bind;
                    var root = Splide2.root;
                    var i18n = options.i18n;
                    var elements = {};
                    var slides = [];
                    var rootClasses = [];
                    var trackClasses = [];
                    var track;
                    var list;
                    var isUsingKey;

                    function setup() {
                        collect();
                        init();
                        update()
                    }

                    function mount() {
                        on(EVENT_REFRESH, destroy);
                        on(EVENT_REFRESH, setup);
                        on(EVENT_UPDATED, update);
                        bind(document, POINTER_DOWN_EVENTS + " keydown", function(e) {
                            isUsingKey = e.type === "keydown"
                        }, {
                            capture: !0
                        });
                        bind(root, "focusin", function() {
                            toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey)
                        })
                    }

                    function destroy(completely) {
                        var attrs = ALL_ATTRIBUTES.concat("style");
                        empty(slides);
                        removeClass(root, rootClasses);
                        removeClass(track, trackClasses);
                        removeAttribute([track, list], attrs);
                        removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION])
                    }

                    function update() {
                        removeClass(root, rootClasses);
                        removeClass(track, trackClasses);
                        rootClasses = getClasses(CLASS_ROOT);
                        trackClasses = getClasses(CLASS_TRACK);
                        addClass(root, rootClasses);
                        addClass(track, trackClasses);
                        setAttribute(root, ARIA_LABEL, options.label);
                        setAttribute(root, ARIA_LABELLEDBY, options.labelledby)
                    }

                    function collect() {
                        track = find("." + CLASS_TRACK);
                        list = child(track, "." + CLASS_LIST);
                        assert(track && list, "A track/list element is missing.");
                        push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
                        forOwn({
                            arrows: CLASS_ARROWS,
                            pagination: CLASS_PAGINATION,
                            prev: CLASS_ARROW_PREV,
                            next: CLASS_ARROW_NEXT,
                            bar: CLASS_PROGRESS_BAR,
                            toggle: CLASS_TOGGLE
                        }, function(className, key) {
                            elements[key] = find("." + className)
                        });
                        assign(elements, {
                            root: root,
                            track: track,
                            list: list,
                            slides: slides
                        })
                    }

                    function init() {
                        var id = root.id || uniqueId(PROJECT_CODE);
                        var role = options.role;
                        root.id = id;
                        track.id = track.id || id + "-track";
                        list.id = list.id || id + "-list";
                        if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
                            setAttribute(root, ROLE, role)
                        }
                        setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
                        setAttribute(list, ROLE, "presentation")
                    }

                    function find(selector) {
                        var elm = query(root, selector);
                        return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0
                    }

                    function getClasses(base) {
                        return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE]
                    }
                    return assign(elements, {
                        setup: setup,
                        mount: mount,
                        destroy: destroy
                    })
                }
                var SLIDE = "slide";
                var LOOP = "loop";
                var FADE = "fade";

                function Slide$1(Splide2, index, slideIndex, slide) {
                    var event = EventInterface(Splide2);
                    var on = event.on,
                        emit = event.emit,
                        bind = event.bind;
                    var Components = Splide2.Components,
                        root = Splide2.root,
                        options = Splide2.options;
                    var isNavigation = options.isNavigation,
                        updateOnMove = options.updateOnMove,
                        i18n = options.i18n,
                        pagination = options.pagination,
                        slideFocus = options.slideFocus;
                    var resolve = Components.Direction.resolve;
                    var styles = getAttribute(slide, "style");
                    var label = getAttribute(slide, ARIA_LABEL);
                    var isClone = slideIndex > -1;
                    var container = child(slide, "." + CLASS_CONTAINER);
                    var destroyed;

                    function mount() {
                        if (!isClone) {
                            slide.id = root.id + "-slide" + pad(index + 1);
                            setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
                            setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
                            setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]))
                        }
                        listen()
                    }

                    function listen() {
                        bind(slide, "click", apply(emit, EVENT_CLICK, self));
                        bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
                        on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
                        on(EVENT_NAVIGATION_MOUNTED, initNavigation);
                        if (updateOnMove) {
                            on(EVENT_MOVE, onMove)
                        }
                    }

                    function destroy() {
                        destroyed = !0;
                        event.destroy();
                        removeClass(slide, STATUS_CLASSES);
                        removeAttribute(slide, ALL_ATTRIBUTES);
                        setAttribute(slide, "style", styles);
                        setAttribute(slide, ARIA_LABEL, label || "")
                    }

                    function initNavigation() {
                        var controls = Splide2.splides.map(function(target) {
                            var Slide2 = target.splide.Components.Slides.getAt(index);
                            return Slide2 ? Slide2.slide.id : ""
                        }).join(" ");
                        setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
                        setAttribute(slide, ARIA_CONTROLS, controls);
                        setAttribute(slide, ROLE, slideFocus ? "button" : "");
                        slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION)
                    }

                    function onMove() {
                        if (!destroyed) {
                            update()
                        }
                    }

                    function update() {
                        if (!destroyed) {
                            var curr = Splide2.index;
                            updateActivity();
                            updateVisibility();
                            toggleClass(slide, CLASS_PREV, index === curr - 1);
                            toggleClass(slide, CLASS_NEXT, index === curr + 1)
                        }
                    }

                    function updateActivity() {
                        var active = isActive();
                        if (active !== hasClass(slide, CLASS_ACTIVE)) {
                            toggleClass(slide, CLASS_ACTIVE, active);
                            setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
                            emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self)
                        }
                    }

                    function updateVisibility() {
                        var visible = isVisible();
                        var hidden = !visible && (!isActive() || isClone);
                        if (!Splide2.state.is([MOVING, SCROLLING])) {
                            setAttribute(slide, ARIA_HIDDEN, hidden || "")
                        }
                        setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");
                        if (slideFocus) {
                            setAttribute(slide, TAB_INDEX, hidden ? -1 : 0)
                        }
                        if (visible !== hasClass(slide, CLASS_VISIBLE)) {
                            toggleClass(slide, CLASS_VISIBLE, visible);
                            emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self)
                        }
                        if (!visible && document.activeElement === slide) {
                            var Slide2 = Components.Slides.getAt(Splide2.index);
                            Slide2 && focus(Slide2.slide)
                        }
                    }

                    function style$1(prop, value, useContainer) {
                        style(useContainer && container || slide, prop, value)
                    }

                    function isActive() {
                        var curr = Splide2.index;
                        return curr === index || options.cloneStatus && curr === slideIndex
                    }

                    function isVisible() {
                        if (Splide2.is(FADE)) {
                            return isActive()
                        }
                        var trackRect = rect(Components.Elements.track);
                        var slideRect = rect(slide);
                        var left = resolve("left", !0);
                        var right = resolve("right", !0);
                        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right])
                    }

                    function isWithin(from, distance) {
                        var diff = abs(from - index);
                        if (!isClone && (options.rewind || Splide2.is(LOOP))) {
                            diff = min(diff, Splide2.length - diff)
                        }
                        return diff <= distance
                    }
                    var self = {
                        index: index,
                        slideIndex: slideIndex,
                        slide: slide,
                        container: container,
                        isClone: isClone,
                        mount: mount,
                        destroy: destroy,
                        update: update,
                        style: style$1,
                        isWithin: isWithin
                    };
                    return self
                }

                function Slides(Splide2, Components2, options) {
                    var _EventInterface2 = EventInterface(Splide2),
                        on = _EventInterface2.on,
                        emit = _EventInterface2.emit,
                        bind = _EventInterface2.bind;
                    var _Components2$Elements = Components2.Elements,
                        slides = _Components2$Elements.slides,
                        list = _Components2$Elements.list;
                    var Slides2 = [];

                    function mount() {
                        init();
                        on(EVENT_REFRESH, destroy);
                        on(EVENT_REFRESH, init)
                    }

                    function init() {
                        slides.forEach(function(slide, index) {
                            register(slide, index, -1)
                        })
                    }

                    function destroy() {
                        forEach$1(function(Slide2) {
                            Slide2.destroy()
                        });
                        empty(Slides2)
                    }

                    function update() {
                        forEach$1(function(Slide2) {
                            Slide2.update()
                        })
                    }

                    function register(slide, index, slideIndex) {
                        var object = Slide$1(Splide2, index, slideIndex, slide);
                        object.mount();
                        Slides2.push(object);
                        Slides2.sort(function(Slide1, Slide2) {
                            return Slide1.index - Slide2.index
                        })
                    }

                    function get(excludeClones) {
                        return excludeClones ? filter(function(Slide2) {
                            return !Slide2.isClone
                        }) : Slides2
                    }

                    function getIn(page) {
                        var Controller = Components2.Controller;
                        var index = Controller.toIndex(page);
                        var max = Controller.hasFocus() ? 1 : options.perPage;
                        return filter(function(Slide2) {
                            return between(Slide2.index, index, index + max - 1)
                        })
                    }

                    function getAt(index) {
                        return filter(index)[0]
                    }

                    function add(items, index) {
                        forEach(items, function(slide) {
                            if (isString(slide)) {
                                slide = parseHtml(slide)
                            }
                            if (isHTMLElement(slide)) {
                                var ref = slides[index];
                                ref ? before(slide, ref) : append(list, slide);
                                addClass(slide, options.classes.slide);
                                observeImages(slide, apply(emit, EVENT_RESIZE))
                            }
                        });
                        emit(EVENT_REFRESH)
                    }

                    function remove$1(matcher) {
                        remove(filter(matcher).map(function(Slide2) {
                            return Slide2.slide
                        }));
                        emit(EVENT_REFRESH)
                    }

                    function forEach$1(iteratee, excludeClones) {
                        get(excludeClones).forEach(iteratee)
                    }

                    function filter(matcher) {
                        return Slides2.filter(isFunction(matcher) ? matcher : function(Slide2) {
                            return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index)
                        })
                    }

                    function style(prop, value, useContainer) {
                        forEach$1(function(Slide2) {
                            Slide2.style(prop, value, useContainer)
                        })
                    }

                    function observeImages(elm, callback) {
                        var images = queryAll(elm, "img");
                        var length = images.length;
                        if (length) {
                            images.forEach(function(img) {
                                bind(img, "load error", function() {
                                    if (!--length) {
                                        callback()
                                    }
                                })
                            })
                        } else {
                            callback()
                        }
                    }

                    function getLength(excludeClones) {
                        return excludeClones ? slides.length : Slides2.length
                    }

                    function isEnough() {
                        return Slides2.length > options.perPage
                    }
                    return {
                        mount: mount,
                        destroy: destroy,
                        update: update,
                        register: register,
                        get: get,
                        getIn: getIn,
                        getAt: getAt,
                        add: add,
                        remove: remove$1,
                        forEach: forEach$1,
                        filter: filter,
                        style: style,
                        getLength: getLength,
                        isEnough: isEnough
                    }
                }

                function Layout(Splide2, Components2, options) {
                    var _EventInterface3 = EventInterface(Splide2),
                        on = _EventInterface3.on,
                        bind = _EventInterface3.bind,
                        emit = _EventInterface3.emit;
                    var Slides = Components2.Slides;
                    var resolve = Components2.Direction.resolve;
                    var _Components2$Elements2 = Components2.Elements,
                        root = _Components2$Elements2.root,
                        track = _Components2$Elements2.track,
                        list = _Components2$Elements2.list;
                    var getAt = Slides.getAt,
                        styleSlides = Slides.style;
                    var vertical;
                    var rootRect;
                    var overflow;

                    function mount() {
                        init();
                        bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
                        on([EVENT_UPDATED, EVENT_REFRESH], init);
                        on(EVENT_RESIZE, resize)
                    }

                    function init() {
                        vertical = options.direction === TTB;
                        style(root, "maxWidth", unit(options.width));
                        style(track, resolve("paddingLeft"), cssPadding(!1));
                        style(track, resolve("paddingRight"), cssPadding(!0));
                        resize(!0)
                    }

                    function resize(force) {
                        var newRect = rect(root);
                        if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
                            style(track, "height", cssTrackHeight());
                            styleSlides(resolve("marginRight"), unit(options.gap));
                            styleSlides("width", cssSlideWidth());
                            styleSlides("height", cssSlideHeight(), !0);
                            rootRect = newRect;
                            emit(EVENT_RESIZED);
                            if (overflow !== (overflow = isOverflow())) {
                                toggleClass(root, CLASS_OVERFLOW, overflow);
                                emit(EVENT_OVERFLOW, overflow)
                            }
                        }
                    }

                    function cssPadding(right) {
                        var padding = options.padding;
                        var prop = resolve(right ? "right" : "left");
                        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px"
                    }

                    function cssTrackHeight() {
                        var height = "";
                        if (vertical) {
                            height = cssHeight();
                            assert(height, "height or heightRatio is missing.");
                            height = "calc(" + height + " - " + cssPadding(!1) + " - " + cssPadding(!0) + ")"
                        }
                        return height
                    }

                    function cssHeight() {
                        return unit(options.height || rect(list).width * options.heightRatio)
                    }

                    function cssSlideWidth() {
                        return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize())
                    }

                    function cssSlideHeight() {
                        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight())
                    }

                    function cssSlideSize() {
                        var gap = unit(options.gap);
                        return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")"
                    }

                    function listSize() {
                        return rect(list)[resolve("width")]
                    }

                    function slideSize(index, withoutGap) {
                        var Slide = getAt(index || 0);
                        return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0
                    }

                    function totalSize(index, withoutGap) {
                        var Slide = getAt(index);
                        if (Slide) {
                            var right = rect(Slide.slide)[resolve("right")];
                            var left = rect(list)[resolve("left")];
                            return abs(right - left) + (withoutGap ? 0 : getGap())
                        }
                        return 0
                    }

                    function sliderSize(withoutGap) {
                        return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap)
                    }

                    function getGap() {
                        var Slide = getAt(0);
                        return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0
                    }

                    function getPadding(right) {
                        return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0
                    }

                    function isOverflow() {
                        return Splide2.is(FADE) || sliderSize(!0) > listSize()
                    }
                    return {
                        mount: mount,
                        resize: resize,
                        listSize: listSize,
                        slideSize: slideSize,
                        sliderSize: sliderSize,
                        totalSize: totalSize,
                        getPadding: getPadding,
                        isOverflow: isOverflow
                    }
                }
                var MULTIPLIER = 2;

                function Clones(Splide2, Components2, options) {
                    var event = EventInterface(Splide2);
                    var on = event.on;
                    var Elements = Components2.Elements,
                        Slides = Components2.Slides;
                    var resolve = Components2.Direction.resolve;
                    var clones = [];
                    var cloneCount;

                    function mount() {
                        on(EVENT_REFRESH, remount);
                        on([EVENT_UPDATED, EVENT_RESIZE], observe);
                        if (cloneCount = computeCloneCount()) {
                            generate(cloneCount);
                            Components2.Layout.resize(!0)
                        }
                    }

                    function remount() {
                        destroy();
                        mount()
                    }

                    function destroy() {
                        remove(clones);
                        empty(clones);
                        event.destroy()
                    }

                    function observe() {
                        var count = computeCloneCount();
                        if (cloneCount !== count) {
                            if (cloneCount < count || !count) {
                                event.emit(EVENT_REFRESH)
                            }
                        }
                    }

                    function generate(count) {
                        var slides = Slides.get().slice();
                        var length = slides.length;
                        if (length) {
                            while (slides.length < count) {
                                push(slides, slides)
                            }
                            push(slides.slice(-count), slides.slice(0, count)).forEach(function(Slide, index) {
                                var isHead = index < count;
                                var clone = cloneDeep(Slide.slide, index);
                                isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
                                push(clones, clone);
                                Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index)
                            })
                        }
                    }

                    function cloneDeep(elm, index) {
                        var clone = elm.cloneNode(!0);
                        addClass(clone, options.classes.clone);
                        clone.id = Splide2.root.id + "-clone" + pad(index + 1);
                        return clone
                    }

                    function computeCloneCount() {
                        var clones2 = options.clones;
                        if (!Splide2.is(LOOP)) {
                            clones2 = 0
                        } else if (isUndefined(clones2)) {
                            var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
                            var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
                            clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER
                        }
                        return clones2
                    }
                    return {
                        mount: mount,
                        destroy: destroy
                    }
                }

                function Move(Splide2, Components2, options) {
                    var _EventInterface4 = EventInterface(Splide2),
                        on = _EventInterface4.on,
                        emit = _EventInterface4.emit;
                    var set = Splide2.state.set;
                    var _Components2$Layout = Components2.Layout,
                        slideSize = _Components2$Layout.slideSize,
                        getPadding = _Components2$Layout.getPadding,
                        totalSize = _Components2$Layout.totalSize,
                        listSize = _Components2$Layout.listSize,
                        sliderSize = _Components2$Layout.sliderSize;
                    var _Components2$Directio = Components2.Direction,
                        resolve = _Components2$Directio.resolve,
                        orient = _Components2$Directio.orient;
                    var _Components2$Elements3 = Components2.Elements,
                        list = _Components2$Elements3.list,
                        track = _Components2$Elements3.track;
                    var Transition;

                    function mount() {
                        Transition = Components2.Transition;
                        on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition)
                    }

                    function reposition() {
                        if (!Components2.Controller.isBusy()) {
                            Components2.Scroll.cancel();
                            jump(Splide2.index);
                            Components2.Slides.update()
                        }
                    }

                    function move(dest, index, prev, callback) {
                        if (dest !== index && canShift(dest > prev)) {
                            cancel();
                            translate(shift(getPosition(), dest > prev), !0)
                        }
                        set(MOVING);
                        emit(EVENT_MOVE, index, prev, dest);
                        Transition.start(index, function() {
                            set(IDLE);
                            emit(EVENT_MOVED, index, prev, dest);
                            callback && callback()
                        })
                    }

                    function jump(index) {
                        translate(toPosition(index, !0))
                    }

                    function translate(position, preventLoop) {
                        if (!Splide2.is(FADE)) {
                            var destination = preventLoop ? position : loop(position);
                            style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
                            position !== destination && emit(EVENT_SHIFTED)
                        }
                    }

                    function loop(position) {
                        if (Splide2.is(LOOP)) {
                            var index = toIndex(position);
                            var exceededMax = index > Components2.Controller.getEnd();
                            var exceededMin = index < 0;
                            if (exceededMin || exceededMax) {
                                position = shift(position, exceededMax)
                            }
                        }
                        return position
                    }

                    function shift(position, backwards) {
                        var excess = position - getLimit(backwards);
                        var size = sliderSize();
                        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
                        return position
                    }

                    function cancel() {
                        translate(getPosition(), !0);
                        Transition.cancel()
                    }

                    function toIndex(position) {
                        var Slides = Components2.Slides.get();
                        var index = 0;
                        var minDistance = Infinity;
                        for (var i = 0; i < Slides.length; i++) {
                            var slideIndex = Slides[i].index;
                            var distance = abs(toPosition(slideIndex, !0) - position);
                            if (distance <= minDistance) {
                                minDistance = distance;
                                index = slideIndex
                            } else {
                                break
                            }
                        }
                        return index
                    }

                    function toPosition(index, trimming) {
                        var position = orient(totalSize(index - 1) - offset(index));
                        return trimming ? trim(position) : position
                    }

                    function getPosition() {
                        var left = resolve("left");
                        return rect(list)[left] - rect(track)[left] + orient(getPadding(!1))
                    }

                    function trim(position) {
                        if (options.trimSpace && Splide2.is(SLIDE)) {
                            position = clamp(position, 0, orient(sliderSize(!0) - listSize()))
                        }
                        return position
                    }

                    function offset(index) {
                        var focus = options.focus;
                        return focus === "center" ? (listSize() - slideSize(index, !0)) / 2 : +focus * slideSize(index) || 0
                    }

                    function getLimit(max) {
                        return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace)
                    }

                    function canShift(backwards) {
                        var shifted = orient(shift(getPosition(), backwards));
                        return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")]
                    }

                    function exceededLimit(max, position) {
                        position = isUndefined(position) ? getPosition() : position;
                        var exceededMin = max !== !0 && orient(position) < orient(getLimit(!1));
                        var exceededMax = max !== !1 && orient(position) > orient(getLimit(!0));
                        return exceededMin || exceededMax
                    }
                    return {
                        mount: mount,
                        move: move,
                        jump: jump,
                        translate: translate,
                        shift: shift,
                        cancel: cancel,
                        toIndex: toIndex,
                        toPosition: toPosition,
                        getPosition: getPosition,
                        getLimit: getLimit,
                        exceededLimit: exceededLimit,
                        reposition: reposition
                    }
                }

                function Controller(Splide2, Components2, options) {
                    var _EventInterface5 = EventInterface(Splide2),
                        on = _EventInterface5.on,
                        emit = _EventInterface5.emit;
                    var Move = Components2.Move;
                    var getPosition = Move.getPosition,
                        getLimit = Move.getLimit,
                        toPosition = Move.toPosition;
                    var _Components2$Slides = Components2.Slides,
                        isEnough = _Components2$Slides.isEnough,
                        getLength = _Components2$Slides.getLength;
                    var omitEnd = options.omitEnd;
                    var isLoop = Splide2.is(LOOP);
                    var isSlide = Splide2.is(SLIDE);
                    var getNext = apply(getAdjacent, !1);
                    var getPrev = apply(getAdjacent, !0);
                    var currIndex = options.start || 0;
                    var endIndex;
                    var prevIndex = currIndex;
                    var slideCount;
                    var perMove;
                    var perPage;

                    function mount() {
                        init();
                        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
                        on(EVENT_RESIZED, onResized)
                    }

                    function init() {
                        slideCount = getLength(!0);
                        perMove = options.perMove;
                        perPage = options.perPage;
                        endIndex = getEnd();
                        var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);
                        if (index !== currIndex) {
                            currIndex = index;
                            Move.reposition()
                        }
                    }

                    function onResized() {
                        if (endIndex !== getEnd()) {
                            emit(EVENT_END_INDEX_CHANGED)
                        }
                    }

                    function go(control, allowSameIndex, callback) {
                        if (!isBusy()) {
                            var dest = parse(control);
                            var index = loop(dest);
                            if (index > -1 && (allowSameIndex || index !== currIndex)) {
                                setIndex(index);
                                Move.move(dest, index, prevIndex, callback)
                            }
                        }
                    }

                    function scroll(destination, duration, snap, callback) {
                        Components2.Scroll.scroll(destination, duration, snap, function() {
                            var index = loop(Move.toIndex(getPosition()));
                            setIndex(omitEnd ? min(index, endIndex) : index);
                            callback && callback()
                        })
                    }

                    function parse(control) {
                        var index = currIndex;
                        if (isString(control)) {
                            var _ref = control.match(/([+\-<>])(\d+)?/) || [],
                                indicator = _ref[1],
                                number = _ref[2];
                            if (indicator === "+" || indicator === "-") {
                                index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex)
                            } else if (indicator === ">") {
                                index = number ? toIndex(+number) : getNext(!0)
                            } else if (indicator === "<") {
                                index = getPrev(!0)
                            }
                        } else {
                            index = isLoop ? control : clamp(control, 0, endIndex)
                        }
                        return index
                    }

                    function getAdjacent(prev, destination) {
                        var number = perMove || (hasFocus() ? 1 : perPage);
                        var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));
                        if (dest === -1 && isSlide) {
                            if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
                                return prev ? 0 : endIndex
                            }
                        }
                        return destination ? dest : loop(dest)
                    }

                    function computeDestIndex(dest, from, snapPage) {
                        if (isEnough() || hasFocus()) {
                            var index = computeMovableDestIndex(dest);
                            if (index !== dest) {
                                from = dest;
                                dest = index;
                                snapPage = !1
                            }
                            if (dest < 0 || dest > endIndex) {
                                if (!perMove && (between(0, dest, from, !0) || between(endIndex, from, dest, !0))) {
                                    dest = toIndex(toPage(dest))
                                } else {
                                    if (isLoop) {
                                        dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest
                                    } else if (options.rewind) {
                                        dest = dest < 0 ? endIndex : 0
                                    } else {
                                        dest = -1
                                    }
                                }
                            } else {
                                if (snapPage && dest !== from) {
                                    dest = toIndex(toPage(from) + (dest < from ? -1 : 1))
                                }
                            }
                        } else {
                            dest = -1
                        }
                        return dest
                    }

                    function computeMovableDestIndex(dest) {
                        if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
                            var position = getPosition();
                            while (position === toPosition(dest, !0) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
                                dest < currIndex ? --dest : ++dest
                            }
                        }
                        return dest
                    }

                    function loop(index) {
                        return isLoop ? (index + slideCount) % slideCount || 0 : index
                    }

                    function getEnd() {
                        var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);
                        while (omitEnd && end-- > 0) {
                            if (toPosition(slideCount - 1, !0) !== toPosition(end, !0)) {
                                end++;
                                break
                            }
                        }
                        return clamp(end, 0, slideCount - 1)
                    }

                    function toIndex(page) {
                        return clamp(hasFocus() ? page : perPage * page, 0, endIndex)
                    }

                    function toPage(index) {
                        return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage)
                    }

                    function toDest(destination) {
                        var closest = Move.toIndex(destination);
                        return isSlide ? clamp(closest, 0, endIndex) : closest
                    }

                    function setIndex(index) {
                        if (index !== currIndex) {
                            prevIndex = currIndex;
                            currIndex = index
                        }
                    }

                    function getIndex(prev) {
                        return prev ? prevIndex : currIndex
                    }

                    function hasFocus() {
                        return !isUndefined(options.focus) || options.isNavigation
                    }

                    function isBusy() {
                        return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition
                    }
                    return {
                        mount: mount,
                        go: go,
                        scroll: scroll,
                        getNext: getNext,
                        getPrev: getPrev,
                        getAdjacent: getAdjacent,
                        getEnd: getEnd,
                        setIndex: setIndex,
                        getIndex: getIndex,
                        toIndex: toIndex,
                        toPage: toPage,
                        toDest: toDest,
                        hasFocus: hasFocus,
                        isBusy: isBusy
                    }
                }
                var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
                var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
                var SIZE = 40;

                function Arrows(Splide2, Components2, options) {
                    var event = EventInterface(Splide2);
                    var on = event.on,
                        bind = event.bind,
                        emit = event.emit;
                    var classes = options.classes,
                        i18n = options.i18n;
                    var Elements = Components2.Elements,
                        Controller = Components2.Controller;
                    var placeholder = Elements.arrows,
                        track = Elements.track;
                    var wrapper = placeholder;
                    var prev = Elements.prev;
                    var next = Elements.next;
                    var created;
                    var wrapperClasses;
                    var arrows = {};

                    function mount() {
                        init();
                        on(EVENT_UPDATED, remount)
                    }

                    function remount() {
                        destroy();
                        mount()
                    }

                    function init() {
                        var enabled = options.arrows;
                        if (enabled && !(prev && next)) {
                            createArrows()
                        }
                        if (prev && next) {
                            assign(arrows, {
                                prev: prev,
                                next: next
                            });
                            display(wrapper, enabled ? "" : "none");
                            addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);
                            if (enabled) {
                                listen();
                                update();
                                setAttribute([prev, next], ARIA_CONTROLS, track.id);
                                emit(EVENT_ARROWS_MOUNTED, prev, next)
                            }
                        }
                    }

                    function destroy() {
                        event.destroy();
                        removeClass(wrapper, wrapperClasses);
                        if (created) {
                            remove(placeholder ? [prev, next] : wrapper);
                            prev = next = null
                        } else {
                            removeAttribute([prev, next], ALL_ATTRIBUTES)
                        }
                    }

                    function listen() {
                        on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
                        bind(next, "click", apply(go, ">"));
                        bind(prev, "click", apply(go, "<"))
                    }

                    function go(control) {
                        Controller.go(control, !0)
                    }

                    function createArrows() {
                        wrapper = placeholder || create("div", classes.arrows);
                        prev = createArrow(!0);
                        next = createArrow(!1);
                        created = !0;
                        append(wrapper, [prev, next]);
                        !placeholder && before(wrapper, track)
                    }

                    function createArrow(prev2) {
                        var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
                        return parseHtml(arrow)
                    }

                    function update() {
                        if (prev && next) {
                            var index = Splide2.index;
                            var prevIndex = Controller.getPrev();
                            var nextIndex = Controller.getNext();
                            var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
                            var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
                            prev.disabled = prevIndex < 0;
                            next.disabled = nextIndex < 0;
                            setAttribute(prev, ARIA_LABEL, prevLabel);
                            setAttribute(next, ARIA_LABEL, nextLabel);
                            emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex)
                        }
                    }
                    return {
                        arrows: arrows,
                        mount: mount,
                        destroy: destroy,
                        update: update
                    }
                }
                var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

                function Autoplay(Splide2, Components2, options) {
                    var _EventInterface6 = EventInterface(Splide2),
                        on = _EventInterface6.on,
                        bind = _EventInterface6.bind,
                        emit = _EventInterface6.emit;
                    var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
                    var isPaused = interval.isPaused;
                    var Elements = Components2.Elements,
                        _Components2$Elements4 = Components2.Elements,
                        root = _Components2$Elements4.root,
                        toggle = _Components2$Elements4.toggle;
                    var autoplay = options.autoplay;
                    var hovered;
                    var focused;
                    var stopped = autoplay === "pause";

                    function mount() {
                        if (autoplay) {
                            listen();
                            toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
                            stopped || play();
                            update()
                        }
                    }

                    function listen() {
                        if (options.pauseOnHover) {
                            bind(root, "mouseenter mouseleave", function(e) {
                                hovered = e.type === "mouseenter";
                                autoToggle()
                            })
                        }
                        if (options.pauseOnFocus) {
                            bind(root, "focusin focusout", function(e) {
                                focused = e.type === "focusin";
                                autoToggle()
                            })
                        }
                        if (toggle) {
                            bind(toggle, "click", function() {
                                stopped ? play() : pause(!0)
                            })
                        }
                        on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
                        on(EVENT_MOVE, onMove)
                    }

                    function play() {
                        if (isPaused() && Components2.Slides.isEnough()) {
                            interval.start(!options.resetProgress);
                            focused = hovered = stopped = !1;
                            update();
                            emit(EVENT_AUTOPLAY_PLAY)
                        }
                    }

                    function pause(stop) {
                        if (stop === void 0) {
                            stop = !0
                        }
                        stopped = !!stop;
                        update();
                        if (!isPaused()) {
                            interval.pause();
                            emit(EVENT_AUTOPLAY_PAUSE)
                        }
                    }

                    function autoToggle() {
                        if (!stopped) {
                            hovered || focused ? pause(!1) : play()
                        }
                    }

                    function update() {
                        if (toggle) {
                            toggleClass(toggle, CLASS_ACTIVE, !stopped);
                            setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"])
                        }
                    }

                    function onAnimationFrame(rate) {
                        var bar = Elements.bar;
                        bar && style(bar, "width", rate * 100 + "%");
                        emit(EVENT_AUTOPLAY_PLAYING, rate)
                    }

                    function onMove(index) {
                        var Slide = Components2.Slides.getAt(index);
                        interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval)
                    }
                    return {
                        mount: mount,
                        destroy: interval.cancel,
                        play: play,
                        pause: pause,
                        isPaused: isPaused
                    }
                }

                function Cover(Splide2, Components2, options) {
                    var _EventInterface7 = EventInterface(Splide2),
                        on = _EventInterface7.on;

                    function mount() {
                        if (options.cover) {
                            on(EVENT_LAZYLOAD_LOADED, apply(toggle, !0));
                            on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, !0))
                        }
                    }

                    function cover(cover2) {
                        Components2.Slides.forEach(function(Slide) {
                            var img = child(Slide.container || Slide.slide, "img");
                            if (img && img.src) {
                                toggle(cover2, img, Slide)
                            }
                        })
                    }

                    function toggle(cover2, img, Slide) {
                        Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", !0);
                        display(img, cover2 ? "none" : "")
                    }
                    return {
                        mount: mount,
                        destroy: apply(cover, !1)
                    }
                }
                var BOUNCE_DIFF_THRESHOLD = 10;
                var BOUNCE_DURATION = 600;
                var FRICTION_FACTOR = 0.6;
                var BASE_VELOCITY = 1.5;
                var MIN_DURATION = 800;

                function Scroll(Splide2, Components2, options) {
                    var _EventInterface8 = EventInterface(Splide2),
                        on = _EventInterface8.on,
                        emit = _EventInterface8.emit;
                    var set = Splide2.state.set;
                    var Move = Components2.Move;
                    var getPosition = Move.getPosition,
                        getLimit = Move.getLimit,
                        exceededLimit = Move.exceededLimit,
                        translate = Move.translate;
                    var isSlide = Splide2.is(SLIDE);
                    var interval;
                    var callback;
                    var friction = 1;

                    function mount() {
                        on(EVENT_MOVE, clear);
                        on([EVENT_UPDATED, EVENT_REFRESH], cancel)
                    }

                    function scroll(destination, duration, snap, onScrolled, noConstrain) {
                        var from = getPosition();
                        clear();
                        if (snap && (!isSlide || !exceededLimit())) {
                            var size = Components2.Layout.sliderSize();
                            var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
                            destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset
                        }
                        var noDistance = approximatelyEqual(from, destination, 1);
                        friction = 1;
                        duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
                        callback = onScrolled;
                        interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
                        set(SCROLLING);
                        emit(EVENT_SCROLL);
                        interval.start()
                    }

                    function onEnd() {
                        set(IDLE);
                        callback && callback();
                        emit(EVENT_SCROLLED)
                    }

                    function update(from, to, noConstrain, rate) {
                        var position = getPosition();
                        var target = from + (to - from) * easing(rate);
                        var diff = (target - position) * friction;
                        translate(position + diff);
                        if (isSlide && !noConstrain && exceededLimit()) {
                            friction *= FRICTION_FACTOR;
                            if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
                                scroll(getLimit(exceededLimit(!0)), BOUNCE_DURATION, !1, callback, !0)
                            }
                        }
                    }

                    function clear() {
                        if (interval) {
                            interval.cancel()
                        }
                    }

                    function cancel() {
                        if (interval && !interval.isPaused()) {
                            clear();
                            onEnd()
                        }
                    }

                    function easing(t) {
                        var easingFunc = options.easingFunc;
                        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4)
                    }
                    return {
                        mount: mount,
                        destroy: clear,
                        scroll: scroll,
                        cancel: cancel
                    }
                }
                var SCROLL_LISTENER_OPTIONS = {
                    passive: !1,
                    capture: !0
                };

                function Drag(Splide2, Components2, options) {
                    var _EventInterface9 = EventInterface(Splide2),
                        on = _EventInterface9.on,
                        emit = _EventInterface9.emit,
                        bind = _EventInterface9.bind,
                        unbind = _EventInterface9.unbind;
                    var state = Splide2.state;
                    var Move = Components2.Move,
                        Scroll = Components2.Scroll,
                        Controller = Components2.Controller,
                        track = Components2.Elements.track,
                        reduce = Components2.Media.reduce;
                    var _Components2$Directio2 = Components2.Direction,
                        resolve = _Components2$Directio2.resolve,
                        orient = _Components2$Directio2.orient;
                    var getPosition = Move.getPosition,
                        exceededLimit = Move.exceededLimit;
                    var basePosition;
                    var baseEvent;
                    var prevBaseEvent;
                    var isFree;
                    var dragging;
                    var exceeded = !1;
                    var clickPrevented;
                    var disabled;
                    var target;

                    function mount() {
                        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
                        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
                        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
                        bind(track, "click", onClick, {
                            capture: !0
                        });
                        bind(track, "dragstart", prevent);
                        on([EVENT_MOUNTED, EVENT_UPDATED], init)
                    }

                    function init() {
                        var drag = options.drag;
                        disable(!drag);
                        isFree = drag === "free"
                    }

                    function onPointerDown(e) {
                        clickPrevented = !1;
                        if (!disabled) {
                            var isTouch = isTouchEvent(e);
                            if (isDraggable(e.target) && (isTouch || !e.button)) {
                                if (!Controller.isBusy()) {
                                    target = isTouch ? track : window;
                                    dragging = state.is([MOVING, SCROLLING]);
                                    prevBaseEvent = null;
                                    bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
                                    bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
                                    Move.cancel();
                                    Scroll.cancel();
                                    save(e)
                                } else {
                                    prevent(e, !0)
                                }
                            }
                        }
                    }

                    function onPointerMove(e) {
                        if (!state.is(DRAGGING)) {
                            state.set(DRAGGING);
                            emit(EVENT_DRAG)
                        }
                        if (e.cancelable) {
                            if (dragging) {
                                Move.translate(basePosition + constrain(diffCoord(e)));
                                var expired = diffTime(e) > LOG_INTERVAL;
                                var hasExceeded = exceeded !== (exceeded = exceededLimit());
                                if (expired || hasExceeded) {
                                    save(e)
                                }
                                clickPrevented = !0;
                                emit(EVENT_DRAGGING);
                                prevent(e)
                            } else if (isSliderDirection(e)) {
                                dragging = shouldStart(e);
                                prevent(e)
                            }
                        }
                    }

                    function onPointerUp(e) {
                        if (state.is(DRAGGING)) {
                            state.set(IDLE);
                            emit(EVENT_DRAGGED)
                        }
                        if (dragging) {
                            move(e);
                            prevent(e)
                        }
                        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
                        unbind(target, POINTER_UP_EVENTS, onPointerUp);
                        dragging = !1
                    }

                    function onClick(e) {
                        if (!disabled && clickPrevented) {
                            prevent(e, !0)
                        }
                    }

                    function save(e) {
                        prevBaseEvent = baseEvent;
                        baseEvent = e;
                        basePosition = getPosition()
                    }

                    function move(e) {
                        var velocity = computeVelocity(e);
                        var destination = computeDestination(velocity);
                        var rewind = options.rewind && options.rewindByDrag;
                        reduce(!1);
                        if (isFree) {
                            Controller.scroll(destination, 0, options.snap)
                        } else if (Splide2.is(FADE)) {
                            Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+")
                        } else if (Splide2.is(SLIDE) && exceeded && rewind) {
                            Controller.go(exceededLimit(!0) ? ">" : "<")
                        } else {
                            Controller.go(Controller.toDest(destination), !0)
                        }
                        reduce(!0)
                    }

                    function shouldStart(e) {
                        var thresholds = options.dragMinThreshold;
                        var isObj = isObject(thresholds);
                        var mouse = isObj && thresholds.mouse || 0;
                        var touch = (isObj ? thresholds.touch : +thresholds) || 10;
                        return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse)
                    }

                    function isSliderDirection(e) {
                        return abs(diffCoord(e)) > abs(diffCoord(e, !0))
                    }

                    function computeVelocity(e) {
                        if (Splide2.is(LOOP) || !exceeded) {
                            var time = diffTime(e);
                            if (time && time < LOG_INTERVAL) {
                                return diffCoord(e) / time
                            }
                        }
                        return 0
                    }

                    function computeDestination(velocity) {
                        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1))
                    }

                    function diffCoord(e, orthogonal) {
                        return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal)
                    }

                    function diffTime(e) {
                        return timeOf(e) - timeOf(getBaseEvent(e))
                    }

                    function getBaseEvent(e) {
                        return baseEvent === e && prevBaseEvent || baseEvent
                    }

                    function coordOf(e, orthogonal) {
                        return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")]
                    }

                    function constrain(diff) {
                        return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1)
                    }

                    function isDraggable(target2) {
                        var noDrag = options.noDrag;
                        return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag))
                    }

                    function isTouchEvent(e) {
                        return typeof TouchEvent !== "undefined" && e instanceof TouchEvent
                    }

                    function isDragging() {
                        return dragging
                    }

                    function disable(value) {
                        disabled = value
                    }
                    return {
                        mount: mount,
                        disable: disable,
                        isDragging: isDragging
                    }
                }
                var NORMALIZATION_MAP = {
                    Spacebar: " ",
                    Right: ARROW_RIGHT,
                    Left: ARROW_LEFT,
                    Up: ARROW_UP,
                    Down: ARROW_DOWN
                };

                function normalizeKey(key) {
                    key = isString(key) ? key : key.key;
                    return NORMALIZATION_MAP[key] || key
                }
                var KEYBOARD_EVENT = "keydown";

                function Keyboard(Splide2, Components2, options) {
                    var _EventInterface10 = EventInterface(Splide2),
                        on = _EventInterface10.on,
                        bind = _EventInterface10.bind,
                        unbind = _EventInterface10.unbind;
                    var root = Splide2.root;
                    var resolve = Components2.Direction.resolve;
                    var target;
                    var disabled;

                    function mount() {
                        init();
                        on(EVENT_UPDATED, destroy);
                        on(EVENT_UPDATED, init);
                        on(EVENT_MOVE, onMove)
                    }

                    function init() {
                        var keyboard = options.keyboard;
                        if (keyboard) {
                            target = keyboard === "global" ? window : root;
                            bind(target, KEYBOARD_EVENT, onKeydown)
                        }
                    }

                    function destroy() {
                        unbind(target, KEYBOARD_EVENT)
                    }

                    function disable(value) {
                        disabled = value
                    }

                    function onMove() {
                        var _disabled = disabled;
                        disabled = !0;
                        nextTick(function() {
                            disabled = _disabled
                        })
                    }

                    function onKeydown(e) {
                        if (!disabled) {
                            var key = normalizeKey(e);
                            if (key === resolve(ARROW_LEFT)) {
                                Splide2.go("<")
                            } else if (key === resolve(ARROW_RIGHT)) {
                                Splide2.go(">")
                            }
                        }
                    }
                    return {
                        mount: mount,
                        destroy: destroy,
                        disable: disable
                    }
                }
                var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
                var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
                var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

                function LazyLoad(Splide2, Components2, options) {
                    var _EventInterface11 = EventInterface(Splide2),
                        on = _EventInterface11.on,
                        off = _EventInterface11.off,
                        bind = _EventInterface11.bind,
                        emit = _EventInterface11.emit;
                    var isSequential = options.lazyLoad === "sequential";
                    var events = [EVENT_MOVED, EVENT_SCROLLED];
                    var entries = [];

                    function mount() {
                        if (options.lazyLoad) {
                            init();
                            on(EVENT_REFRESH, init)
                        }
                    }

                    function init() {
                        empty(entries);
                        register();
                        if (isSequential) {
                            loadNext()
                        } else {
                            off(events);
                            on(events, check);
                            check()
                        }
                    }

                    function register() {
                        Components2.Slides.forEach(function(Slide) {
                            queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function(img) {
                                var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
                                var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);
                                if (src !== img.src || srcset !== img.srcset) {
                                    var className = options.classes.spinner;
                                    var parent = img.parentElement;
                                    var spinner = child(parent, "." + className) || create("span", className, parent);
                                    entries.push([img, Slide, spinner]);
                                    img.src || display(img, "none")
                                }
                            })
                        })
                    }

                    function check() {
                        entries = entries.filter(function(data) {
                            var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
                            return data[1].isWithin(Splide2.index, distance) ? load(data) : !0
                        });
                        entries.length || off(events)
                    }

                    function load(data) {
                        var img = data[0];
                        addClass(data[1].slide, CLASS_LOADING);
                        bind(img, "load error", apply(onLoad, data));
                        setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
                        setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
                        removeAttribute(img, SRC_DATA_ATTRIBUTE);
                        removeAttribute(img, SRCSET_DATA_ATTRIBUTE)
                    }

                    function onLoad(data, e) {
                        var img = data[0],
                            Slide = data[1];
                        removeClass(Slide.slide, CLASS_LOADING);
                        if (e.type !== "error") {
                            remove(data[2]);
                            display(img, "");
                            emit(EVENT_LAZYLOAD_LOADED, img, Slide);
                            emit(EVENT_RESIZE)
                        }
                        isSequential && loadNext()
                    }

                    function loadNext() {
                        entries.length && load(entries.shift())
                    }
                    return {
                        mount: mount,
                        destroy: apply(empty, entries),
                        check: check
                    }
                }

                function Pagination(Splide2, Components2, options) {
                    var event = EventInterface(Splide2);
                    var on = event.on,
                        emit = event.emit,
                        bind = event.bind;
                    var Slides = Components2.Slides,
                        Elements = Components2.Elements,
                        Controller = Components2.Controller;
                    var hasFocus = Controller.hasFocus,
                        getIndex = Controller.getIndex,
                        go = Controller.go;
                    var resolve = Components2.Direction.resolve;
                    var placeholder = Elements.pagination;
                    var items = [];
                    var list;
                    var paginationClasses;

                    function mount() {
                        destroy();
                        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
                        var enabled = options.pagination;
                        placeholder && display(placeholder, enabled ? "" : "none");
                        if (enabled) {
                            on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
                            createPagination();
                            update();
                            emit(EVENT_PAGINATION_MOUNTED, {
                                list: list,
                                items: items
                            }, getAt(Splide2.index))
                        }
                    }

                    function destroy() {
                        if (list) {
                            remove(placeholder ? slice(list.children) : list);
                            removeClass(list, paginationClasses);
                            empty(items);
                            list = null
                        }
                        event.destroy()
                    }

                    function createPagination() {
                        var length = Splide2.length;
                        var classes = options.classes,
                            i18n = options.i18n,
                            perPage = options.perPage;
                        var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
                        list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
                        addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
                        setAttribute(list, ROLE, "tablist");
                        setAttribute(list, ARIA_LABEL, i18n.select);
                        setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");
                        for (var i = 0; i < max; i++) {
                            var li = create("li", null, list);
                            var button = create("button", {
                                class: classes.page,
                                type: "button"
                            }, li);
                            var controls = Slides.getIn(i).map(function(Slide) {
                                return Slide.slide.id
                            });
                            var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
                            bind(button, "click", apply(onClick, i));
                            if (options.paginationKeyboard) {
                                bind(button, "keydown", apply(onKeydown, i))
                            }
                            setAttribute(li, ROLE, "presentation");
                            setAttribute(button, ROLE, "tab");
                            setAttribute(button, ARIA_CONTROLS, controls.join(" "));
                            setAttribute(button, ARIA_LABEL, format(text, i + 1));
                            setAttribute(button, TAB_INDEX, -1);
                            items.push({
                                li: li,
                                button: button,
                                page: i
                            })
                        }
                    }

                    function onClick(page) {
                        go(">" + page, !0)
                    }

                    function onKeydown(page, e) {
                        var length = items.length;
                        var key = normalizeKey(e);
                        var dir = getDirection();
                        var nextPage = -1;
                        if (key === resolve(ARROW_RIGHT, !1, dir)) {
                            nextPage = ++page % length
                        } else if (key === resolve(ARROW_LEFT, !1, dir)) {
                            nextPage = (--page + length) % length
                        } else if (key === "Home") {
                            nextPage = 0
                        } else if (key === "End") {
                            nextPage = length - 1
                        }
                        var item = items[nextPage];
                        if (item) {
                            focus(item.button);
                            go(">" + nextPage);
                            prevent(e, !0)
                        }
                    }

                    function getDirection() {
                        return options.paginationDirection || options.direction
                    }

                    function getAt(index) {
                        return items[Controller.toPage(index)]
                    }

                    function update() {
                        var prev = getAt(getIndex(!0));
                        var curr = getAt(getIndex());
                        if (prev) {
                            var button = prev.button;
                            removeClass(button, CLASS_ACTIVE);
                            removeAttribute(button, ARIA_SELECTED);
                            setAttribute(button, TAB_INDEX, -1)
                        }
                        if (curr) {
                            var _button = curr.button;
                            addClass(_button, CLASS_ACTIVE);
                            setAttribute(_button, ARIA_SELECTED, !0);
                            setAttribute(_button, TAB_INDEX, "")
                        }
                        emit(EVENT_PAGINATION_UPDATED, {
                            list: list,
                            items: items
                        }, prev, curr)
                    }
                    return {
                        items: items,
                        mount: mount,
                        destroy: destroy,
                        getAt: getAt,
                        update: update
                    }
                }
                var TRIGGER_KEYS = [" ", "Enter"];

                function Sync(Splide2, Components2, options) {
                    var isNavigation = options.isNavigation,
                        slideFocus = options.slideFocus;
                    var events = [];

                    function mount() {
                        Splide2.splides.forEach(function(target) {
                            if (!target.isParent) {
                                sync(Splide2, target.splide);
                                sync(target.splide, Splide2)
                            }
                        });
                        if (isNavigation) {
                            navigate()
                        }
                    }

                    function destroy() {
                        events.forEach(function(event) {
                            event.destroy()
                        });
                        empty(events)
                    }

                    function remount() {
                        destroy();
                        mount()
                    }

                    function sync(splide, target) {
                        var event = EventInterface(splide);
                        event.on(EVENT_MOVE, function(index, prev, dest) {
                            target.go(target.is(LOOP) ? dest : index)
                        });
                        events.push(event)
                    }

                    function navigate() {
                        var event = EventInterface(Splide2);
                        var on = event.on;
                        on(EVENT_CLICK, onClick);
                        on(EVENT_SLIDE_KEYDOWN, onKeydown);
                        on([EVENT_MOUNTED, EVENT_UPDATED], update);
                        events.push(event);
                        event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides)
                    }

                    function update() {
                        setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "")
                    }

                    function onClick(Slide) {
                        Splide2.go(Slide.index)
                    }

                    function onKeydown(Slide, e) {
                        if (includes(TRIGGER_KEYS, normalizeKey(e))) {
                            onClick(Slide);
                            prevent(e)
                        }
                    }
                    return {
                        setup: apply(Components2.Media.set, {
                            slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
                        }, !0),
                        mount: mount,
                        destroy: destroy,
                        remount: remount
                    }
                }

                function Wheel(Splide2, Components2, options) {
                    var _EventInterface12 = EventInterface(Splide2),
                        bind = _EventInterface12.bind;
                    var lastTime = 0;

                    function mount() {
                        if (options.wheel) {
                            bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS)
                        }
                    }

                    function onWheel(e) {
                        if (e.cancelable) {
                            var deltaY = e.deltaY;
                            var backwards = deltaY < 0;
                            var timeStamp = timeOf(e);
                            var _min = options.wheelMinThreshold || 0;
                            var sleep = options.wheelSleep || 0;
                            if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
                                Splide2.go(backwards ? "<" : ">");
                                lastTime = timeStamp
                            }
                            shouldPrevent(backwards) && prevent(e)
                        }
                    }

                    function shouldPrevent(backwards) {
                        return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1
                    }
                    return {
                        mount: mount
                    }
                }
                var SR_REMOVAL_DELAY = 90;

                function Live(Splide2, Components2, options) {
                    var _EventInterface13 = EventInterface(Splide2),
                        on = _EventInterface13.on;
                    var track = Components2.Elements.track;
                    var enabled = options.live && !options.isNavigation;
                    var sr = create("span", CLASS_SR);
                    var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, !1));

                    function mount() {
                        if (enabled) {
                            disable(!Components2.Autoplay.isPaused());
                            setAttribute(track, ARIA_ATOMIC, !0);
                            sr.textContent = "\u2026";
                            on(EVENT_AUTOPLAY_PLAY, apply(disable, !0));
                            on(EVENT_AUTOPLAY_PAUSE, apply(disable, !1));
                            on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, !0))
                        }
                    }

                    function toggle(active) {
                        setAttribute(track, ARIA_BUSY, active);
                        if (active) {
                            append(track, sr);
                            interval.start()
                        } else {
                            remove(sr);
                            interval.cancel()
                        }
                    }

                    function destroy() {
                        removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
                        remove(sr)
                    }

                    function disable(disabled) {
                        if (enabled) {
                            setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite")
                        }
                    }
                    return {
                        mount: mount,
                        disable: disable,
                        destroy: destroy
                    }
                }
                var ComponentConstructors = Object.freeze({
                    __proto__: null,
                    Media: Media,
                    Direction: Direction,
                    Elements: Elements,
                    Slides: Slides,
                    Layout: Layout,
                    Clones: Clones,
                    Move: Move,
                    Controller: Controller,
                    Arrows: Arrows,
                    Autoplay: Autoplay,
                    Cover: Cover,
                    Scroll: Scroll,
                    Drag: Drag,
                    Keyboard: Keyboard,
                    LazyLoad: LazyLoad,
                    Pagination: Pagination,
                    Sync: Sync,
                    Wheel: Wheel,
                    Live: Live
                });
                var I18N = {
                    prev: "Previous slide",
                    next: "Next slide",
                    first: "Go to first slide",
                    last: "Go to last slide",
                    slideX: "Go to slide %s",
                    pageX: "Go to page %s",
                    play: "Start autoplay",
                    pause: "Pause autoplay",
                    carousel: "carousel",
                    slide: "slide",
                    select: "Select a slide to show",
                    slideLabel: "%s of %s"
                };
                var DEFAULTS = {
                    type: "slide",
                    role: "region",
                    speed: 400,
                    perPage: 1,
                    cloneStatus: !0,
                    arrows: !0,
                    pagination: !0,
                    paginationKeyboard: !0,
                    interval: 5e3,
                    pauseOnHover: !0,
                    pauseOnFocus: !0,
                    resetProgress: !0,
                    easing: "cubic-bezier(0.25, 1, 0.5, 1)",
                    drag: !0,
                    direction: "ltr",
                    trimSpace: !0,
                    focusableNodes: "a, button, textarea, input, select, iframe",
                    live: !0,
                    classes: CLASSES,
                    i18n: I18N,
                    reducedMotion: {
                        speed: 0,
                        rewindSpeed: 0,
                        autoplay: "pause"
                    }
                };

                function Fade(Splide2, Components2, options) {
                    var Slides = Components2.Slides;

                    function mount() {
                        EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init)
                    }

                    function init() {
                        Slides.forEach(function(Slide) {
                            Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)")
                        })
                    }

                    function start(index, done) {
                        Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
                        nextTick(done)
                    }
                    return {
                        mount: mount,
                        start: start,
                        cancel: noop
                    }
                }

                function Slide(Splide2, Components2, options) {
                    var Move = Components2.Move,
                        Controller = Components2.Controller,
                        Scroll = Components2.Scroll;
                    var list = Components2.Elements.list;
                    var transition = apply(style, list, "transition");
                    var endCallback;

                    function mount() {
                        EventInterface(Splide2).bind(list, "transitionend", function(e) {
                            if (e.target === list && endCallback) {
                                cancel();
                                endCallback()
                            }
                        })
                    }

                    function start(index, done) {
                        var destination = Move.toPosition(index, !0);
                        var position = Move.getPosition();
                        var speed = getSpeed(index);
                        if (abs(destination - position) >= 1 && speed >= 1) {
                            if (options.useScroll) {
                                Scroll.scroll(destination, speed, !1, done)
                            } else {
                                transition("transform " + speed + "ms " + options.easing);
                                Move.translate(destination, !0);
                                endCallback = done
                            }
                        } else {
                            Move.jump(index);
                            done()
                        }
                    }

                    function cancel() {
                        transition("");
                        Scroll.cancel()
                    }

                    function getSpeed(index) {
                        var rewindSpeed = options.rewindSpeed;
                        if (Splide2.is(SLIDE) && rewindSpeed) {
                            var prev = Controller.getIndex(!0);
                            var end = Controller.getEnd();
                            if (prev === 0 && index >= end || prev >= end && index === 0) {
                                return rewindSpeed
                            }
                        }
                        return options.speed
                    }
                    return {
                        mount: mount,
                        start: start,
                        cancel: cancel
                    }
                }
                var _Splide = function() {
                    function _Splide(target, options) {
                        this.event = EventInterface();
                        this.Components = {};
                        this.state = State(CREATED);
                        this.splides = [];
                        this._o = {};
                        this._E = {};
                        var root = isString(target) ? query(document, target) : target;
                        assert(root, root + " is invalid.");
                        this.root = root;
                        options = merge({
                            label: getAttribute(root, ARIA_LABEL) || "",
                            labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
                        }, DEFAULTS, _Splide.defaults, options || {});
                        try {
                            merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)))
                        } catch (e) {
                            assert(!1, "Invalid JSON")
                        }
                        this._o = Object.create(merge({}, options))
                    }
                    var _proto = _Splide.prototype;
                    _proto.mount = function mount(Extensions, Transition) {
                        var _this = this;
                        var state = this.state,
                            Components2 = this.Components;
                        assert(state.is([CREATED, DESTROYED]), "Already mounted!");
                        state.set(CREATED);
                        this._C = Components2;
                        this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
                        this._E = Extensions || this._E;
                        var Constructors = assign({}, ComponentConstructors, this._E, {
                            Transition: this._T
                        });
                        forOwn(Constructors, function(Component, key) {
                            var component = Component(_this, Components2, _this._o);
                            Components2[key] = component;
                            component.setup && component.setup()
                        });
                        forOwn(Components2, function(component) {
                            component.mount && component.mount()
                        });
                        this.emit(EVENT_MOUNTED);
                        addClass(this.root, CLASS_INITIALIZED);
                        state.set(IDLE);
                        this.emit(EVENT_READY);
                        return this
                    };
                    _proto.sync = function sync(splide) {
                        this.splides.push({
                            splide: splide
                        });
                        splide.splides.push({
                            splide: this,
                            isParent: !0
                        });
                        if (this.state.is(IDLE)) {
                            this._C.Sync.remount();
                            splide.Components.Sync.remount()
                        }
                        return this
                    };
                    _proto.go = function go(control) {
                        this._C.Controller.go(control);
                        return this
                    };
                    _proto.on = function on(events, callback) {
                        this.event.on(events, callback);
                        return this
                    };
                    _proto.off = function off(events) {
                        this.event.off(events);
                        return this
                    };
                    _proto.emit = function emit(event) {
                        var _this$event;
                        (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));
                        return this
                    };
                    _proto.add = function add(slides, index) {
                        this._C.Slides.add(slides, index);
                        return this
                    };
                    _proto.remove = function remove(matcher) {
                        this._C.Slides.remove(matcher);
                        return this
                    };
                    _proto.is = function is(type) {
                        return this._o.type === type
                    };
                    _proto.refresh = function refresh() {
                        this.emit(EVENT_REFRESH);
                        return this
                    };
                    _proto.destroy = function destroy(completely) {
                        if (completely === void 0) {
                            completely = !0
                        }
                        var event = this.event,
                            state = this.state;
                        if (state.is(CREATED)) {
                            EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely))
                        } else {
                            forOwn(this._C, function(component) {
                                component.destroy && component.destroy(completely)
                            }, !0);
                            event.emit(EVENT_DESTROY);
                            event.destroy();
                            completely && empty(this.splides);
                            state.set(DESTROYED)
                        }
                        return this
                    };
                    _createClass(_Splide, [{
                        key: "options",
                        get: function get() {
                            return this._o
                        },
                        set: function set(options) {
                            this._C.Media.set(options, !0, !0)
                        }
                    }, {
                        key: "length",
                        get: function get() {
                            return this._C.Slides.getLength(!0)
                        }
                    }, {
                        key: "index",
                        get: function get() {
                            return this._C.Controller.getIndex()
                        }
                    }]);
                    return _Splide
                }();
                var Splide = _Splide;
                Splide.defaults = {};
                Splide.STATES = STATES;
                var CLASS_RENDERED = "is-rendered";
                var RENDERER_DEFAULT_CONFIG = {
                    listTag: "ul",
                    slideTag: "li"
                };
                var Style = function() {
                    function Style(id, options) {
                        this.styles = {};
                        this.id = id;
                        this.options = options
                    }
                    var _proto2 = Style.prototype;
                    _proto2.rule = function rule(selector, prop, value, breakpoint) {
                        breakpoint = breakpoint || "default";
                        var selectors = this.styles[breakpoint] = this.styles[breakpoint] || {};
                        var styles = selectors[selector] = selectors[selector] || {};
                        styles[prop] = value
                    };
                    _proto2.build = function build() {
                        var _this2 = this;
                        var css = "";
                        if (this.styles.default) {
                            css += this.buildSelectors(this.styles.default)
                        }
                        Object.keys(this.styles).sort(function(n, m) {
                            return _this2.options.mediaQuery === "min" ? +n - +m : +m - +n
                        }).forEach(function(breakpoint) {
                            if (breakpoint !== "default") {
                                css += "@media screen and (max-width: " + breakpoint + "px) {";
                                css += _this2.buildSelectors(_this2.styles[breakpoint]);
                                css += "}"
                            }
                        });
                        return css
                    };
                    _proto2.buildSelectors = function buildSelectors(selectors) {
                        var _this3 = this;
                        var css = "";
                        forOwn(selectors, function(styles, selector) {
                            selector = ("#" + _this3.id + " " + selector).trim();
                            css += selector + " {";
                            forOwn(styles, function(value, prop) {
                                if (value || value === 0) {
                                    css += prop + ": " + value + ";"
                                }
                            });
                            css += "}"
                        });
                        return css
                    };
                    return Style
                }();
                var SplideRenderer = function() {
                    function SplideRenderer(contents, options, config, defaults) {
                        this.slides = [];
                        this.options = {};
                        this.breakpoints = [];
                        merge(DEFAULTS, defaults || {});
                        merge(merge(this.options, DEFAULTS), options || {});
                        this.contents = contents;
                        this.config = assign({}, RENDERER_DEFAULT_CONFIG, config || {});
                        this.id = this.config.id || uniqueId("splide");
                        this.Style = new Style(this.id, this.options);
                        this.Direction = Direction(null, null, this.options);
                        assert(this.contents.length, "Provide at least 1 content.");
                        this.init()
                    }
                    SplideRenderer.clean = function clean(splide) {
                        var _EventInterface14 = EventInterface(splide),
                            on = _EventInterface14.on;
                        var root = splide.root;
                        var clones = queryAll(root, "." + CLASS_CLONE);
                        on(EVENT_MOUNTED, function() {
                            remove(child(root, "style"))
                        });
                        remove(clones)
                    };
                    var _proto3 = SplideRenderer.prototype;
                    _proto3.init = function init() {
                        this.parseBreakpoints();
                        this.initSlides();
                        this.registerRootStyles();
                        this.registerTrackStyles();
                        this.registerSlideStyles();
                        this.registerListStyles()
                    };
                    _proto3.initSlides = function initSlides() {
                        var _this4 = this;
                        push(this.slides, this.contents.map(function(content, index) {
                            content = isString(content) ? {
                                html: content
                            } : content;
                            content.styles = content.styles || {};
                            content.attrs = content.attrs || {};
                            _this4.cover(content);
                            var classes = _this4.options.classes.slide + " " + (index === 0 ? CLASS_ACTIVE : "");
                            assign(content.attrs, {
                                class: (classes + " " + (content.attrs.class || "")).trim(),
                                style: _this4.buildStyles(content.styles)
                            });
                            return content
                        }));
                        if (this.isLoop()) {
                            this.generateClones(this.slides)
                        }
                    };
                    _proto3.registerRootStyles = function registerRootStyles() {
                        var _this5 = this;
                        this.breakpoints.forEach(function(_ref2) {
                            var width = _ref2[0],
                                options = _ref2[1];
                            _this5.Style.rule(" ", "max-width", unit(options.width), width)
                        })
                    };
                    _proto3.registerTrackStyles = function registerTrackStyles() {
                        var _this6 = this;
                        var Style2 = this.Style;
                        var selector = "." + CLASS_TRACK;
                        this.breakpoints.forEach(function(_ref3) {
                            var width = _ref3[0],
                                options = _ref3[1];
                            Style2.rule(selector, _this6.resolve("paddingLeft"), _this6.cssPadding(options, !1), width);
                            Style2.rule(selector, _this6.resolve("paddingRight"), _this6.cssPadding(options, !0), width);
                            Style2.rule(selector, "height", _this6.cssTrackHeight(options), width)
                        })
                    };
                    _proto3.registerListStyles = function registerListStyles() {
                        var _this7 = this;
                        var Style2 = this.Style;
                        var selector = "." + CLASS_LIST;
                        this.breakpoints.forEach(function(_ref4) {
                            var width = _ref4[0],
                                options = _ref4[1];
                            Style2.rule(selector, "transform", _this7.buildTranslate(options), width);
                            if (!_this7.cssSlideHeight(options)) {
                                Style2.rule(selector, "aspect-ratio", _this7.cssAspectRatio(options), width)
                            }
                        })
                    };
                    _proto3.registerSlideStyles = function registerSlideStyles() {
                        var _this8 = this;
                        var Style2 = this.Style;
                        var selector = "." + CLASS_SLIDE;
                        this.breakpoints.forEach(function(_ref5) {
                            var width = _ref5[0],
                                options = _ref5[1];
                            Style2.rule(selector, "width", _this8.cssSlideWidth(options), width);
                            Style2.rule(selector, "height", _this8.cssSlideHeight(options) || "100%", width);
                            Style2.rule(selector, _this8.resolve("marginRight"), unit(options.gap) || "0px", width);
                            Style2.rule(selector + " > img", "display", options.cover ? "none" : "inline", width)
                        })
                    };
                    _proto3.buildTranslate = function buildTranslate(options) {
                        var _this$Direction = this.Direction,
                            resolve = _this$Direction.resolve,
                            orient = _this$Direction.orient;
                        var values = [];
                        values.push(this.cssOffsetClones(options));
                        values.push(this.cssOffsetGaps(options));
                        if (this.isCenter(options)) {
                            values.push(this.buildCssValue(orient(-50), "%"));
                            values.push.apply(values, this.cssOffsetCenter(options))
                        }
                        return values.filter(Boolean).map(function(value) {
                            return "translate" + resolve("X") + "(" + value + ")"
                        }).join(" ")
                    };
                    _proto3.cssOffsetClones = function cssOffsetClones(options) {
                        var _this$Direction2 = this.Direction,
                            resolve = _this$Direction2.resolve,
                            orient = _this$Direction2.orient;
                        var cloneCount = this.getCloneCount();
                        if (this.isFixedWidth(options)) {
                            var _this$parseCssValue = this.parseCssValue(options[resolve("fixedWidth")]),
                                value = _this$parseCssValue.value,
                                unit2 = _this$parseCssValue.unit;
                            return this.buildCssValue(orient(value) * cloneCount, unit2)
                        }
                        var percent = 100 * cloneCount / options.perPage;
                        return orient(percent) + "%"
                    };
                    _proto3.cssOffsetCenter = function cssOffsetCenter(options) {
                        var _this$Direction3 = this.Direction,
                            resolve = _this$Direction3.resolve,
                            orient = _this$Direction3.orient;
                        if (this.isFixedWidth(options)) {
                            var _this$parseCssValue2 = this.parseCssValue(options[resolve("fixedWidth")]),
                                value = _this$parseCssValue2.value,
                                unit2 = _this$parseCssValue2.unit;
                            return [this.buildCssValue(orient(value / 2), unit2)]
                        }
                        var values = [];
                        var perPage = options.perPage,
                            gap = options.gap;
                        values.push(orient(50 / perPage) + "%");
                        if (gap) {
                            var _this$parseCssValue3 = this.parseCssValue(gap),
                                _value = _this$parseCssValue3.value,
                                _unit = _this$parseCssValue3.unit;
                            var gapOffset = (_value / perPage - _value) / 2;
                            values.push(this.buildCssValue(orient(gapOffset), _unit))
                        }
                        return values
                    };
                    _proto3.cssOffsetGaps = function cssOffsetGaps(options) {
                        var cloneCount = this.getCloneCount();
                        if (cloneCount && options.gap) {
                            var orient = this.Direction.orient;
                            var _this$parseCssValue4 = this.parseCssValue(options.gap),
                                value = _this$parseCssValue4.value,
                                unit2 = _this$parseCssValue4.unit;
                            if (this.isFixedWidth(options)) {
                                return this.buildCssValue(orient(value * cloneCount), unit2)
                            }
                            var perPage = options.perPage;
                            var gaps = cloneCount / perPage;
                            return this.buildCssValue(orient(gaps * value), unit2)
                        }
                        return ""
                    };
                    _proto3.resolve = function resolve(prop) {
                        return camelToKebab(this.Direction.resolve(prop))
                    };
                    _proto3.cssPadding = function cssPadding(options, right) {
                        var padding = options.padding;
                        var prop = this.Direction.resolve(right ? "right" : "left", !0);
                        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px"
                    };
                    _proto3.cssTrackHeight = function cssTrackHeight(options) {
                        var height = "";
                        if (this.isVertical()) {
                            height = this.cssHeight(options);
                            assert(height, '"height" is missing.');
                            height = "calc(" + height + " - " + this.cssPadding(options, !1) + " - " + this.cssPadding(options, !0) + ")"
                        }
                        return height
                    };
                    _proto3.cssHeight = function cssHeight(options) {
                        return unit(options.height)
                    };
                    _proto3.cssSlideWidth = function cssSlideWidth(options) {
                        return options.autoWidth ? "" : unit(options.fixedWidth) || (this.isVertical() ? "" : this.cssSlideSize(options))
                    };
                    _proto3.cssSlideHeight = function cssSlideHeight(options) {
                        return unit(options.fixedHeight) || (this.isVertical() ? options.autoHeight ? "" : this.cssSlideSize(options) : this.cssHeight(options))
                    };
                    _proto3.cssSlideSize = function cssSlideSize(options) {
                        var gap = unit(options.gap);
                        return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")"
                    };
                    _proto3.cssAspectRatio = function cssAspectRatio(options) {
                        var heightRatio = options.heightRatio;
                        return heightRatio ? "" + 1 / heightRatio : ""
                    };
                    _proto3.buildCssValue = function buildCssValue(value, unit2) {
                        return "" + value + unit2
                    };
                    _proto3.parseCssValue = function parseCssValue(value) {
                        if (isString(value)) {
                            var number = parseFloat(value) || 0;
                            var unit2 = value.replace(/\d*(\.\d*)?/, "") || "px";
                            return {
                                value: number,
                                unit: unit2
                            }
                        }
                        return {
                            value: value,
                            unit: "px"
                        }
                    };
                    _proto3.parseBreakpoints = function parseBreakpoints() {
                        var _this9 = this;
                        var breakpoints = this.options.breakpoints;
                        this.breakpoints.push(["default", this.options]);
                        if (breakpoints) {
                            forOwn(breakpoints, function(options, width) {
                                _this9.breakpoints.push([width, merge(merge({}, _this9.options), options)])
                            })
                        }
                    };
                    _proto3.isFixedWidth = function isFixedWidth(options) {
                        return !!options[this.Direction.resolve("fixedWidth")]
                    };
                    _proto3.isLoop = function isLoop() {
                        return this.options.type === LOOP
                    };
                    _proto3.isCenter = function isCenter(options) {
                        if (options.focus === "center") {
                            if (this.isLoop()) {
                                return !0
                            }
                            if (this.options.type === SLIDE) {
                                return !this.options.trimSpace
                            }
                        }
                        return !1
                    };
                    _proto3.isVertical = function isVertical() {
                        return this.options.direction === TTB
                    };
                    _proto3.buildClasses = function buildClasses() {
                        var options = this.options;
                        return [CLASS_ROOT, CLASS_ROOT + "--" + options.type, CLASS_ROOT + "--" + options.direction, options.drag && CLASS_ROOT + "--draggable", options.isNavigation && CLASS_ROOT + "--nav", CLASS_ACTIVE, !this.config.hidden && CLASS_RENDERED].filter(Boolean).join(" ")
                    };
                    _proto3.buildAttrs = function buildAttrs(attrs) {
                        var attr = "";
                        forOwn(attrs, function(value, key) {
                            attr += value ? " " + camelToKebab(key) + "=\"" + value + "\"" : ""
                        });
                        return attr.trim()
                    };
                    _proto3.buildStyles = function buildStyles(styles) {
                        var style = "";
                        forOwn(styles, function(value, key) {
                            style += " " + camelToKebab(key) + ":" + value + ";"
                        });
                        return style.trim()
                    };
                    _proto3.renderSlides = function renderSlides() {
                        var _this10 = this;
                        var tag = this.config.slideTag;
                        return this.slides.map(function(content) {
                            return "<" + tag + " " + _this10.buildAttrs(content.attrs) + ">" + (content.html || "") + "</" + tag + ">"
                        }).join("")
                    };
                    _proto3.cover = function cover(content) {
                        var styles = content.styles,
                            _content$html = content.html,
                            html = _content$html === void 0 ? "" : _content$html;
                        if (this.options.cover && !this.options.lazyLoad) {
                            var src = html.match(/<img.*?src\s*=\s*(['"])(.+?)\1.*?>/);
                            if (src && src[2]) {
                                styles.background = "center/cover no-repeat url('" + src[2] + "')"
                            }
                        }
                    };
                    _proto3.generateClones = function generateClones(contents) {
                        var classes = this.options.classes;
                        var count = this.getCloneCount();
                        var slides = contents.slice();
                        while (slides.length < count) {
                            push(slides, slides)
                        }
                        push(slides.slice(-count).reverse(), slides.slice(0, count)).forEach(function(content, index) {
                            var attrs = assign({}, content.attrs, {
                                class: content.attrs.class + " " + classes.clone
                            });
                            var clone = assign({}, content, {
                                attrs: attrs
                            });
                            index < count ? contents.unshift(clone) : contents.push(clone)
                        })
                    };
                    _proto3.getCloneCount = function getCloneCount() {
                        if (this.isLoop()) {
                            var options = this.options;
                            if (options.clones) {
                                return options.clones
                            }
                            var perPage = max.apply(void 0, this.breakpoints.map(function(_ref6) {
                                var options2 = _ref6[1];
                                return options2.perPage
                            }));
                            return perPage * ((options.flickMaxPages || 1) + 1)
                        }
                        return 0
                    };
                    _proto3.renderArrows = function renderArrows() {
                        var html = "";
                        html += "<div class=\"" + this.options.classes.arrows + "\">";
                        html += this.renderArrow(!0);
                        html += this.renderArrow(!1);
                        html += "</div>";
                        return html
                    };
                    _proto3.renderArrow = function renderArrow(prev) {
                        var _this$options = this.options,
                            classes = _this$options.classes,
                            i18n = _this$options.i18n;
                        var attrs = {
                            class: classes.arrow + " " + (prev ? classes.prev : classes.next),
                            type: "button",
                            ariaLabel: prev ? i18n.prev : i18n.next
                        };
                        return "<button " + this.buildAttrs(attrs) + "><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\"><path d=\"" + (this.options.arrowPath || PATH) + "\" /></svg></button>"
                    };
                    _proto3.html = function html() {
                        var _this$config = this.config,
                            rootClass = _this$config.rootClass,
                            listTag = _this$config.listTag,
                            arrows = _this$config.arrows,
                            beforeTrack = _this$config.beforeTrack,
                            afterTrack = _this$config.afterTrack,
                            slider = _this$config.slider,
                            beforeSlider = _this$config.beforeSlider,
                            afterSlider = _this$config.afterSlider;
                        var html = "";
                        html += "<div id=\"" + this.id + "\" class=\"" + this.buildClasses() + " " + (rootClass || "") + "\">";
                        html += "<style>" + this.Style.build() + "</style>";
                        if (slider) {
                            html += beforeSlider || "";
                            html += "<div class=\"splide__slider\">"
                        }
                        html += beforeTrack || "";
                        if (arrows) {
                            html += this.renderArrows()
                        }
                        html += "<div class=\"splide__track\">";
                        html += "<" + listTag + " class=\"splide__list\">";
                        html += this.renderSlides();
                        html += "</" + listTag + ">";
                        html += "</div>";
                        html += afterTrack || "";
                        if (slider) {
                            html += "</div>";
                            html += afterSlider || ""
                        }
                        html += "</div>";
                        return html
                    };
                    return SplideRenderer
                }()
            }),
        "./node_modules/gsap/CSSPlugin.js":
            /*!****************************************!*\
              !*** ./node_modules/gsap/CSSPlugin.js ***!
              \****************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    CSSPlugin: () => (CSSPlugin)
                });
                var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
                /*!
                 * CSSPlugin 3.12.5
                 * https://gsap.com
                 *
                 * Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                var _win, _doc, _docElement, _pluginInitted, _tempDiv, _tempDivStyler, _recentSetterPlugin, _reverting, _windowExists = function _windowExists() {
                        return typeof window !== "undefined"
                    },
                    _transformProps = {},
                    _RAD2DEG = 180 / Math.PI,
                    _DEG2RAD = Math.PI / 180,
                    _atan2 = Math.atan2,
                    _bigNum = 1e8,
                    _capsExp = /([A-Z])/g,
                    _horizontalExp = /(left|right|width|margin|padding|x)/i,
                    _complexExp = /[\s,\(]\S/,
                    _propertyAliases = {
                        autoAlpha: "opacity,visibility",
                        scale: "scaleX,scaleY",
                        alpha: "opacity"
                    },
                    _renderCSSProp = function _renderCSSProp(ratio, data) {
                        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data)
                    },
                    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data)
                    },
                    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
                        return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data)
                    },
                    _renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
                        var value = data.s + data.c * ratio;
                        data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data)
                    },
                    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
                        return data.set(data.t, data.p, ratio ? data.e : data.b, data)
                    },
                    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
                        return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data)
                    },
                    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
                        return target.style[property] = value
                    },
                    _setterCSSProp = function _setterCSSProp(target, property, value) {
                        return target.style.setProperty(property, value)
                    },
                    _setterTransform = function _setterTransform(target, property, value) {
                        return target._gsap[property] = value
                    },
                    _setterScale = function _setterScale(target, property, value) {
                        return target._gsap.scaleX = target._gsap.scaleY = value
                    },
                    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache.scaleX = cache.scaleY = value;
                        cache.renderTransform(ratio, cache)
                    },
                    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
                        var cache = target._gsap;
                        cache[property] = value;
                        cache.renderTransform(ratio, cache)
                    },
                    _transformProp = "transform",
                    _transformOriginProp = _transformProp + "Origin",
                    _saveStyle = function _saveStyle(property, isNotCSS) {
                        var _this = this;
                        var target = this.target,
                            style = target.style,
                            cache = target._gsap;
                        if (property in _transformProps && style) {
                            this.tfm = this.tfm || {};
                            if (property !== "transform") {
                                property = _propertyAliases[property] || property;
                                ~property.indexOf(",") ? property.split(",").forEach(function(a) {
                                    return _this.tfm[a] = _get(target, a)
                                }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
                                property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin)
                            } else {
                                return _propertyAliases.transform.split(",").forEach(function(p) {
                                    return _saveStyle.call(_this, p, isNotCSS)
                                })
                            }
                            if (this.props.indexOf(_transformProp) >= 0) {
                                return
                            }
                            if (cache.svg) {
                                this.svgo = target.getAttribute("data-svg-origin");
                                this.props.push(_transformOriginProp, isNotCSS, "")
                            }
                            property = _transformProp
                        }(style || isNotCSS) && this.props.push(property, isNotCSS, style[property])
                    },
                    _removeIndependentTransforms = function _removeIndependentTransforms(style) {
                        if (style.translate) {
                            style.removeProperty("translate");
                            style.removeProperty("scale");
                            style.removeProperty("rotate")
                        }
                    },
                    _revertStyle = function _revertStyle() {
                        var props = this.props,
                            target = this.target,
                            style = target.style,
                            cache = target._gsap,
                            i, p;
                        for (i = 0; i < props.length; i += 3) {
                            props[i + 1] ? target[props[i]] = props[i + 2] : props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase())
                        }
                        if (this.tfm) {
                            for (p in this.tfm) {
                                cache[p] = this.tfm[p]
                            }
                            if (cache.svg) {
                                cache.renderTransform();
                                target.setAttribute("data-svg-origin", this.svgo || "")
                            }
                            i = _reverting();
                            if ((!i || !i.isStart) && !style[_transformProp]) {
                                _removeIndependentTransforms(style);
                                if (cache.zOrigin && style[_transformOriginProp]) {
                                    style[_transformOriginProp] += " " + cache.zOrigin + "px";
                                    cache.zOrigin = 0;
                                    cache.renderTransform()
                                }
                                cache.uncache = 1
                            }
                        }
                    },
                    _getStyleSaver = function _getStyleSaver(target, properties) {
                        var saver = {
                            target: target,
                            props: [],
                            revert: _revertStyle,
                            save: _saveStyle
                        };
                        target._gsap || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getCache(target);
                        properties && properties.split(",").forEach(function(p) {
                            return saver.save(p)
                        });
                        return saver
                    },
                    _supports3D, _createElement = function _createElement(type, ns) {
                        var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type);
                        return e && e.style ? e : _doc.createElement(type)
                    },
                    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
                        var cs = getComputedStyle(target);
                        return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""
                    },
                    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
                    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
                        var e = element || _tempDiv,
                            s = e.style,
                            i = 5;
                        if (property in s && !preferPrefix) {
                            return property
                        }
                        property = property.charAt(0).toUpperCase() + property.substr(1);
                        while (i-- && !(_prefixes[i] + property in s)) {}
                        return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property
                    },
                    _initCore = function _initCore() {
                        if (_windowExists() && window.document) {
                            _win = window;
                            _doc = _win.document;
                            _docElement = _doc.documentElement;
                            _tempDiv = _createElement("div") || {
                                style: {}
                            };
                            _tempDivStyler = _createElement("div");
                            _transformProp = _checkPropPrefix(_transformProp);
                            _transformOriginProp = _transformProp + "Origin";
                            _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
                            _supports3D = !!_checkPropPrefix("perspective");
                            _reverting = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.reverting;
                            _pluginInitted = 1
                        }
                    },
                    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
                        var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                            oldParent = this.parentNode,
                            oldSibling = this.nextSibling,
                            oldCSS = this.style.cssText,
                            bbox;
                        _docElement.appendChild(svg);
                        svg.appendChild(this);
                        this.style.display = "block";
                        if (swapIfPossible) {
                            try {
                                bbox = this.getBBox();
                                this._gsapBBox = this.getBBox;
                                this.getBBox = _getBBoxHack
                            } catch (e) {}
                        } else if (this._gsapBBox) {
                            bbox = this._gsapBBox()
                        }
                        if (oldParent) {
                            if (oldSibling) {
                                oldParent.insertBefore(this, oldSibling)
                            } else {
                                oldParent.appendChild(this)
                            }
                        }
                        _docElement.removeChild(svg);
                        this.style.cssText = oldCSS;
                        return bbox
                    },
                    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
                        var i = attributesArray.length;
                        while (i--) {
                            if (target.hasAttribute(attributesArray[i])) {
                                return target.getAttribute(attributesArray[i])
                            }
                        }
                    },
                    _getBBox = function _getBBox(target) {
                        var bounds;
                        try {
                            bounds = target.getBBox()
                        } catch (error) {
                            bounds = _getBBoxHack.call(target, !0)
                        }
                        bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, !0));
                        return bounds && !bounds.width && !bounds.x && !bounds.y ? {
                            x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
                            y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
                            width: 0,
                            height: 0
                        } : bounds
                    },
                    _isSVG = function _isSVG(e) {
                        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e))
                    },
                    _removeProperty = function _removeProperty(target, property) {
                        if (property) {
                            var style = target.style,
                                first2Chars;
                            if (property in _transformProps && property !== _transformOriginProp) {
                                property = _transformProp
                            }
                            if (style.removeProperty) {
                                first2Chars = property.substr(0, 2);
                                if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
                                    property = "-" + property
                                }
                                style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase())
                            } else {
                                style.removeAttribute(property)
                            }
                        }
                    },
                    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
                        var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
                        plugin._pt = pt;
                        pt.b = beginning;
                        pt.e = end;
                        plugin._props.push(property);
                        return pt
                    },
                    _nonConvertibleUnits = {
                        deg: 1,
                        rad: 1,
                        turn: 1
                    },
                    _nonStandardLayouts = {
                        grid: 1,
                        flex: 1
                    },
                    _convertToUnit = function _convertToUnit(target, property, value, unit) {
                        var curValue = parseFloat(value) || 0,
                            curUnit = (value + "").trim().substr((curValue + "").length) || "px",
                            style = _tempDiv.style,
                            horizontal = _horizontalExp.test(property),
                            isRootSVG = target.tagName.toLowerCase() === "svg",
                            measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
                            amount = 100,
                            toPixels = unit === "px",
                            toPercent = unit === "%",
                            px, parent, cache, isSVG;
                        if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
                            return curValue
                        }
                        curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
                        isSVG = target.getCTM && _isSVG(target);
                        if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
                            px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
                            return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px)
                        }
                        style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
                        parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
                        if (isSVG) {
                            parent = (target.ownerSVGElement || {}).parentNode
                        }
                        if (!parent || parent === _doc || !parent.appendChild) {
                            parent = _doc.body
                        }
                        cache = parent._gsap;
                        if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time && !cache.uncache) {
                            return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount)
                        } else {
                            if (toPercent && (property === "height" || property === "width")) {
                                var v = target.style[property];
                                target.style[property] = amount + unit;
                                px = target[measureProperty];
                                v ? target.style[property] = v : _removeProperty(target, property)
                            } else {
                                (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent, "display")] && (style.position = _getComputedProperty(target, "position"));
                                parent === target && (style.position = "static");
                                parent.appendChild(_tempDiv);
                                px = _tempDiv[measureProperty];
                                parent.removeChild(_tempDiv);
                                style.position = "absolute"
                            }
                            if (horizontal && toPercent) {
                                cache = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
                                cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
                                cache.width = parent[measureProperty]
                            }
                        }
                        return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0)
                    },
                    _get = function _get(target, property, unit, uncache) {
                        var value;
                        _pluginInitted || _initCore();
                        if (property in _propertyAliases && property !== "transform") {
                            property = _propertyAliases[property];
                            if (~property.indexOf(",")) {
                                property = property.split(",")[0]
                            }
                        }
                        if (_transformProps[property] && property !== "transform") {
                            value = _parseTransform(target, uncache);
                            value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px"
                        } else {
                            value = target.style[property];
                            if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
                                value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0)
                            }
                        }
                        return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value
                    },
                    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
                        if (!start || start === "none") {
                            var p = _checkPropPrefix(prop, target, 1),
                                s = p && _getComputedProperty(target, p, 1);
                            if (s && s !== start) {
                                prop = p;
                                start = s
                            } else if (prop === "borderColor") {
                                start = _getComputedProperty(target, "borderTopColor")
                            }
                        }
                        var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
                            index = 0,
                            matchIndex = 0,
                            a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
                        pt.b = start;
                        pt.e = end;
                        start += "";
                        end += "";
                        if (end === "auto") {
                            startValue = target.style[prop];
                            target.style[prop] = end;
                            end = _getComputedProperty(target, prop) || end;
                            startValue ? target.style[prop] = startValue : _removeProperty(target, prop)
                        }
                        a = [start, end];
                        (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a);
                        start = a[0];
                        end = a[1];
                        startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
                        endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
                        if (endValues.length) {
                            while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
                                endValue = result[0];
                                chunk = end.substring(index, result.index);
                                if (color) {
                                    color = (color + 1) % 5
                                } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
                                    color = 1
                                }
                                if (endValue !== (startValue = startValues[matchIndex++] || "")) {
                                    startNum = parseFloat(startValue) || 0;
                                    startUnit = startValue.substr((startNum + "").length);
                                    endValue.charAt(1) === "=" && (endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, endValue) + startUnit);
                                    endNum = parseFloat(endValue);
                                    endUnit = endValue.substr((endNum + "").length);
                                    index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;
                                    if (!endUnit) {
                                        endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;
                                        if (index === end.length) {
                                            end += endUnit;
                                            pt.e += endUnit
                                        }
                                    }
                                    if (startUnit !== endUnit) {
                                        startNum = _convertToUnit(target, prop, startValue, endUnit) || 0
                                    }
                                    pt._pt = {
                                        _next: pt._pt,
                                        p: chunk || matchIndex === 1 ? chunk : ",",
                                        s: startNum,
                                        c: endNum - startNum,
                                        m: color && color < 4 || prop === "zIndex" ? Math.round : 0
                                    }
                                }
                            }
                            pt.c = index < end.length ? end.substring(index, end.length) : ""
                        } else {
                            pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue
                        }
                        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0);
                        this._pt = pt;
                        return pt
                    },
                    _keywordToPercent = {
                        top: "0%",
                        bottom: "100%",
                        left: "0%",
                        right: "100%",
                        center: "50%"
                    },
                    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
                        var split = value.split(" "),
                            x = split[0],
                            y = split[1] || "50%";
                        if (x === "top" || x === "bottom" || y === "left" || y === "right") {
                            value = x;
                            x = y;
                            y = value
                        }
                        split[0] = _keywordToPercent[x] || x;
                        split[1] = _keywordToPercent[y] || y;
                        return split.join(" ")
                    },
                    _renderClearProps = function _renderClearProps(ratio, data) {
                        if (data.tween && data.tween._time === data.tween._dur) {
                            var target = data.t,
                                style = target.style,
                                props = data.u,
                                cache = target._gsap,
                                prop, clearTransforms, i;
                            if (props === "all" || props === !0) {
                                style.cssText = "";
                                clearTransforms = 1
                            } else {
                                props = props.split(",");
                                i = props.length;
                                while (--i > -1) {
                                    prop = props[i];
                                    if (_transformProps[prop]) {
                                        clearTransforms = 1;
                                        prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp
                                    }
                                    _removeProperty(target, prop)
                                }
                            }
                            if (clearTransforms) {
                                _removeProperty(target, _transformProp);
                                if (cache) {
                                    cache.svg && target.removeAttribute("transform");
                                    _parseTransform(target, 1);
                                    cache.uncache = 1;
                                    _removeIndependentTransforms(style)
                                }
                            }
                        }
                    },
                    _specialProps = {
                        clearProps: function clearProps(plugin, target, property, endValue, tween) {
                            if (tween.data !== "isFromStart") {
                                var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
                                pt.u = endValue;
                                pt.pr = -10;
                                pt.tween = tween;
                                plugin._props.push(property);
                                return 1
                            }
                        }
                    },
                    _identity2DMatrix = [1, 0, 0, 1, 0, 0],
                    _rotationalProperties = {},
                    _isNullTransform = function _isNullTransform(value) {
                        return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value
                    },
                    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
                        var matrixString = _getComputedProperty(target, _transformProp);
                        return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)
                    },
                    _getMatrix = function _getMatrix(target, force2D) {
                        var cache = target._gsap || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
                            style = target.style,
                            matrix = _getComputedTransformMatrixAsArray(target),
                            parent, nextSibling, temp, addedToDOM;
                        if (cache.svg && target.getAttribute("transform")) {
                            temp = target.transform.baseVal.consolidate().matrix;
                            matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
                            return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix
                        } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
                            temp = style.display;
                            style.display = "block";
                            parent = target.parentNode;
                            if (!parent || !target.offsetParent) {
                                addedToDOM = 1;
                                nextSibling = target.nextElementSibling;
                                _docElement.appendChild(target)
                            }
                            matrix = _getComputedTransformMatrixAsArray(target);
                            temp ? style.display = temp : _removeProperty(target, "display");
                            if (addedToDOM) {
                                nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target)
                            }
                        }
                        return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix
                    },
                    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
                        var cache = target._gsap,
                            matrix = matrixArray || _getMatrix(target, !0),
                            xOriginOld = cache.xOrigin || 0,
                            yOriginOld = cache.yOrigin || 0,
                            xOffsetOld = cache.xOffset || 0,
                            yOffsetOld = cache.yOffset || 0,
                            a = matrix[0],
                            b = matrix[1],
                            c = matrix[2],
                            d = matrix[3],
                            tx = matrix[4],
                            ty = matrix[5],
                            originSplit = origin.split(" "),
                            xOrigin = parseFloat(originSplit[0]) || 0,
                            yOrigin = parseFloat(originSplit[1]) || 0,
                            bounds, determinant, x, y;
                        if (!originIsAbsolute) {
                            bounds = _getBBox(target);
                            xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
                            yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin)
                        } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
                            x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
                            y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
                            xOrigin = x;
                            yOrigin = y
                        }
                        if (smooth || smooth !== !1 && cache.smooth) {
                            tx = xOrigin - xOriginOld;
                            ty = yOrigin - yOriginOld;
                            cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
                            cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty
                        } else {
                            cache.xOffset = cache.yOffset = 0
                        }
                        cache.xOrigin = xOrigin;
                        cache.yOrigin = yOrigin;
                        cache.smooth = !!smooth;
                        cache.origin = origin;
                        cache.originIsAbsolute = !!originIsAbsolute;
                        target.style[_transformOriginProp] = "0px 0px";
                        if (pluginToAddPropTweensTo) {
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
                            _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset)
                        }
                        target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin)
                    },
                    _parseTransform = function _parseTransform(target, uncache) {
                        var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);
                        if ("x" in cache && !uncache && !cache.uncache) {
                            return cache
                        }
                        var style = target.style,
                            invertedScaleX = cache.scaleX < 0,
                            px = "px",
                            deg = "deg",
                            cs = getComputedStyle(target),
                            origin = _getComputedProperty(target, _transformOriginProp) || "0",
                            x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
                        x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
                        scaleX = scaleY = 1;
                        cache.svg = !!(target.getCTM && _isSVG(target));
                        if (cs.translate) {
                            if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
                                style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "")
                            }
                            style.scale = style.rotate = style.translate = "none"
                        }
                        matrix = _getMatrix(target, cache.svg);
                        if (cache.svg) {
                            if (cache.uncache) {
                                t2 = target.getBBox();
                                origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
                                t1 = ""
                            } else {
                                t1 = !uncache && target.getAttribute("data-svg-origin")
                            }
                            _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== !1, matrix)
                        }
                        xOrigin = cache.xOrigin || 0;
                        yOrigin = cache.yOrigin || 0;
                        if (matrix !== _identity2DMatrix) {
                            a = matrix[0];
                            b = matrix[1];
                            c = matrix[2];
                            d = matrix[3];
                            x = a12 = matrix[4];
                            y = a22 = matrix[5];
                            if (matrix.length === 6) {
                                scaleX = Math.sqrt(a * a + b * b);
                                scaleY = Math.sqrt(d * d + c * c);
                                rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
                                skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
                                skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
                                if (cache.svg) {
                                    x -= xOrigin - (xOrigin * a + yOrigin * c);
                                    y -= yOrigin - (xOrigin * b + yOrigin * d)
                                }
                            } else {
                                a32 = matrix[6];
                                a42 = matrix[7];
                                a13 = matrix[8];
                                a23 = matrix[9];
                                a33 = matrix[10];
                                a43 = matrix[11];
                                x = matrix[12];
                                y = matrix[13];
                                z = matrix[14];
                                angle = _atan2(a32, a33);
                                rotationX = angle * _RAD2DEG;
                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a12 * cos + a13 * sin;
                                    t2 = a22 * cos + a23 * sin;
                                    t3 = a32 * cos + a33 * sin;
                                    a13 = a12 * -sin + a13 * cos;
                                    a23 = a22 * -sin + a23 * cos;
                                    a33 = a32 * -sin + a33 * cos;
                                    a43 = a42 * -sin + a43 * cos;
                                    a12 = t1;
                                    a22 = t2;
                                    a32 = t3
                                }
                                angle = _atan2(-c, a33);
                                rotationY = angle * _RAD2DEG;
                                if (angle) {
                                    cos = Math.cos(-angle);
                                    sin = Math.sin(-angle);
                                    t1 = a * cos - a13 * sin;
                                    t2 = b * cos - a23 * sin;
                                    t3 = c * cos - a33 * sin;
                                    a43 = d * sin + a43 * cos;
                                    a = t1;
                                    b = t2;
                                    c = t3
                                }
                                angle = _atan2(b, a);
                                rotation = angle * _RAD2DEG;
                                if (angle) {
                                    cos = Math.cos(angle);
                                    sin = Math.sin(angle);
                                    t1 = a * cos + b * sin;
                                    t2 = a12 * cos + a22 * sin;
                                    b = b * cos - a * sin;
                                    a22 = a22 * cos - a12 * sin;
                                    a = t1;
                                    a12 = t2
                                }
                                if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
                                    rotationX = rotation = 0;
                                    rotationY = 180 - rotationY
                                }
                                scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
                                scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
                                angle = _atan2(a12, a22);
                                skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
                                perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0
                            }
                            if (cache.svg) {
                                t1 = target.getAttribute("transform");
                                cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
                                t1 && target.setAttribute("transform", t1)
                            }
                        }
                        if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
                            if (invertedScaleX) {
                                scaleX *= -1;
                                skewX += rotation <= 0 ? 180 : -180;
                                rotation += rotation <= 0 ? 180 : -180
                            } else {
                                scaleY *= -1;
                                skewX += skewX <= 0 ? 180 : -180
                            }
                        }
                        uncache = uncache || cache.uncache;
                        cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
                        cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
                        cache.z = z + px;
                        cache.scaleX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
                        cache.scaleY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
                        cache.rotation = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
                        cache.rotationX = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
                        cache.rotationY = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
                        cache.skewX = skewX + deg;
                        cache.skewY = skewY + deg;
                        cache.transformPerspective = perspective + px;
                        if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
                            style[_transformOriginProp] = _firstTwoOnly(origin)
                        }
                        cache.xOffset = cache.yOffset = 0;
                        cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
                        cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
                        cache.uncache = 0;
                        return cache
                    },
                    _firstTwoOnly = function _firstTwoOnly(value) {
                        return (value = value.split(" "))[0] + " " + value[1]
                    },
                    _addPxTranslate = function _addPxTranslate(target, start, value) {
                        var unit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
                        return (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit
                    },
                    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
                        cache.z = "0px";
                        cache.rotationY = cache.rotationX = "0deg";
                        cache.force3D = 0;
                        _renderCSSTransforms(ratio, cache)
                    },
                    _zeroDeg = "0deg",
                    _zeroPx = "0px",
                    _endParenthesis = ") ",
                    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
                        var _ref = cache || this,
                            xPercent = _ref.xPercent,
                            yPercent = _ref.yPercent,
                            x = _ref.x,
                            y = _ref.y,
                            z = _ref.z,
                            rotation = _ref.rotation,
                            rotationY = _ref.rotationY,
                            rotationX = _ref.rotationX,
                            skewX = _ref.skewX,
                            skewY = _ref.skewY,
                            scaleX = _ref.scaleX,
                            scaleY = _ref.scaleY,
                            transformPerspective = _ref.transformPerspective,
                            force3D = _ref.force3D,
                            target = _ref.target,
                            zOrigin = _ref.zOrigin,
                            transforms = "",
                            use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === !0;
                        if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
                            var angle = parseFloat(rotationY) * _DEG2RAD,
                                a13 = Math.sin(angle),
                                a33 = Math.cos(angle),
                                cos;
                            angle = parseFloat(rotationX) * _DEG2RAD;
                            cos = Math.cos(angle);
                            x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
                            y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
                            z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin)
                        }
                        if (transformPerspective !== _zeroPx) {
                            transforms += "perspective(" + transformPerspective + _endParenthesis
                        }
                        if (xPercent || yPercent) {
                            transforms += "translate(" + xPercent + "%, " + yPercent + "%) "
                        }
                        if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
                            transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis
                        }
                        if (rotation !== _zeroDeg) {
                            transforms += "rotate(" + rotation + _endParenthesis
                        }
                        if (rotationY !== _zeroDeg) {
                            transforms += "rotateY(" + rotationY + _endParenthesis
                        }
                        if (rotationX !== _zeroDeg) {
                            transforms += "rotateX(" + rotationX + _endParenthesis
                        }
                        if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
                            transforms += "skew(" + skewX + ", " + skewY + _endParenthesis
                        }
                        if (scaleX !== 1 || scaleY !== 1) {
                            transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis
                        }
                        target.style[_transformProp] = transforms || "translate(0, 0)"
                    },
                    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
                        var _ref2 = cache || this,
                            xPercent = _ref2.xPercent,
                            yPercent = _ref2.yPercent,
                            x = _ref2.x,
                            y = _ref2.y,
                            rotation = _ref2.rotation,
                            skewX = _ref2.skewX,
                            skewY = _ref2.skewY,
                            scaleX = _ref2.scaleX,
                            scaleY = _ref2.scaleY,
                            target = _ref2.target,
                            xOrigin = _ref2.xOrigin,
                            yOrigin = _ref2.yOrigin,
                            xOffset = _ref2.xOffset,
                            yOffset = _ref2.yOffset,
                            forceCSS = _ref2.forceCSS,
                            tx = parseFloat(x),
                            ty = parseFloat(y),
                            a11, a21, a12, a22, temp;
                        rotation = parseFloat(rotation);
                        skewX = parseFloat(skewX);
                        skewY = parseFloat(skewY);
                        if (skewY) {
                            skewY = parseFloat(skewY);
                            skewX += skewY;
                            rotation += skewY
                        }
                        if (rotation || skewX) {
                            rotation *= _DEG2RAD;
                            skewX *= _DEG2RAD;
                            a11 = Math.cos(rotation) * scaleX;
                            a21 = Math.sin(rotation) * scaleX;
                            a12 = Math.sin(rotation - skewX) * -scaleY;
                            a22 = Math.cos(rotation - skewX) * scaleY;
                            if (skewX) {
                                skewY *= _DEG2RAD;
                                temp = Math.tan(skewX - skewY);
                                temp = Math.sqrt(1 + temp * temp);
                                a12 *= temp;
                                a22 *= temp;
                                if (skewY) {
                                    temp = Math.tan(skewY);
                                    temp = Math.sqrt(1 + temp * temp);
                                    a11 *= temp;
                                    a21 *= temp
                                }
                            }
                            a11 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
                            a21 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
                            a12 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
                            a22 = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22)
                        } else {
                            a11 = scaleX;
                            a22 = scaleY;
                            a21 = a12 = 0
                        }
                        if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
                            tx = _convertToUnit(target, "x", x, "px");
                            ty = _convertToUnit(target, "y", y, "px")
                        }
                        if (xOrigin || yOrigin || xOffset || yOffset) {
                            tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
                            ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset)
                        }
                        if (xPercent || yPercent) {
                            temp = target.getBBox();
                            tx = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
                            ty = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height)
                        }
                        temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
                        target.setAttribute("transform", temp);
                        forceCSS && (target.style[_transformProp] = temp)
                    },
                    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue) {
                        var cap = 360,
                            isString = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
                            endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
                            change = endNum - startNum,
                            finalValue = startNum + change + "deg",
                            direction, pt;
                        if (isString) {
                            direction = endValue.split("_")[1];
                            if (direction === "short") {
                                change %= cap;
                                if (change !== change % (cap / 2)) {
                                    change += change < 0 ? cap : -cap
                                }
                            }
                            if (direction === "cw" && change < 0) {
                                change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap
                            } else if (direction === "ccw" && change > 0) {
                                change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap
                            }
                        }
                        plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
                        pt.e = finalValue;
                        pt.u = "deg";
                        plugin._props.push(property);
                        return pt
                    },
                    _assign = function _assign(target, source) {
                        for (var p in source) {
                            target[p] = source[p]
                        }
                        return target
                    },
                    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
                        var startCache = _assign({}, target._gsap),
                            exclude = "perspective,force3D,transformOrigin,svgOrigin",
                            style = target.style,
                            endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
                        if (startCache.svg) {
                            startValue = target.getAttribute("transform");
                            target.setAttribute("transform", "");
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);
                            _removeProperty(target, _transformProp);
                            target.setAttribute("transform", startValue)
                        } else {
                            startValue = getComputedStyle(target)[_transformProp];
                            style[_transformProp] = transforms;
                            endCache = _parseTransform(target, 1);
                            style[_transformProp] = startValue
                        }
                        for (p in _transformProps) {
                            startValue = startCache[p];
                            endValue = endCache[p];
                            if (startValue !== endValue && exclude.indexOf(p) < 0) {
                                startUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
                                endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
                                startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
                                endNum = parseFloat(endValue);
                                plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
                                plugin._pt.u = endUnit || 0;
                                plugin._props.push(p)
                            }
                        }
                        _assign(endCache, startCache)
                    };
                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function(name, index) {
                    var t = "Top",
                        r = "Right",
                        b = "Bottom",
                        l = "Left",
                        props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
                            return index < 2 ? name + side : "border" + side + name
                        });
                    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
                        var a, vars;
                        if (arguments.length < 4) {
                            a = props.map(function(prop) {
                                return _get(plugin, prop, property)
                            });
                            vars = a.join(" ");
                            return vars.split(a[0]).length === 5 ? a[0] : vars
                        }
                        a = (endValue + "").split(" ");
                        vars = {};
                        props.forEach(function(prop, i) {
                            return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0]
                        });
                        plugin.init(target, vars, tween)
                    }
                });
                var CSSPlugin = {
                    name: "css",
                    register: _initCore,
                    targetTest: function targetTest(target) {
                        return target.style && target.nodeType
                    },
                    init: function init(target, vars, tween, index, targets) {
                        var props = this._props,
                            style = target.style,
                            startAt = tween.vars.startAt,
                            startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
                        _pluginInitted || _initCore();
                        this.styles = this.styles || _getStyleSaver(target);
                        inlineProps = this.styles.props;
                        this.tween = tween;
                        for (p in vars) {
                            if (p === "autoRound") {
                                continue
                            }
                            endValue = vars[p];
                            if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
                                continue
                            }
                            type = typeof endValue;
                            specialProp = _specialProps[p];
                            if (type === "function") {
                                endValue = endValue.call(tween, index, target, targets);
                                type = typeof endValue
                            }
                            if (type === "string" && ~endValue.indexOf("random(")) {
                                endValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue)
                            }
                            if (specialProp) {
                                specialProp(this, target, p, endValue, tween) && (hasPriority = 1)
                            } else if (p.substr(0, 2) === "--") {
                                startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
                                endValue += "";
                                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;
                                if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
                                    startUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
                                    endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue)
                                }
                                endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
                                this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
                                props.push(p);
                                inlineProps.push(p, 0, style[p])
                            } else if (type !== "undefined") {
                                if (startAt && p in startAt) {
                                    startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
                                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
                                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || startValue === "auto" || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || "");
                                    (startValue + "").charAt(1) === "=" && (startValue = _get(target, p))
                                } else {
                                    startValue = _get(target, p)
                                }
                                startNum = parseFloat(startValue);
                                relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
                                relative && (endValue = endValue.substr(2));
                                endNum = parseFloat(endValue);
                                if (p in _propertyAliases) {
                                    if (p === "autoAlpha") {
                                        if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                                            startNum = 0
                                        }
                                        inlineProps.push("visibility", 0, style.visibility);
                                        _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum)
                                    }
                                    if (p !== "scale" && p !== "transform") {
                                        p = _propertyAliases[p];
                                        ~p.indexOf(",") && (p = p.split(",")[0])
                                    }
                                }
                                isTransformRelated = p in _transformProps;
                                if (isTransformRelated) {
                                    this.styles.save(p);
                                    if (!transformPropTween) {
                                        cache = target._gsap;
                                        cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
                                        smooth = vars.smoothOrigin !== !1 && cache.smooth;
                                        transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
                                        transformPropTween.dep = 1
                                    }
                                    if (p === "scale") {
                                        this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
                                        this._pt.u = 0;
                                        props.push("scaleY", p);
                                        p += "X"
                                    } else if (p === "transformOrigin") {
                                        inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
                                        endValue = _convertKeywordsToPercentages(endValue);
                                        if (cache.svg) {
                                            _applySVGOrigin(target, endValue, 0, smooth, 0, this)
                                        } else {
                                            endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                                            endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                                            _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue))
                                        }
                                        continue
                                    } else if (p === "svgOrigin") {
                                        _applySVGOrigin(target, endValue, 1, smooth, 0, this);
                                        continue
                                    } else if (p in _rotationalProperties) {
                                        _addRotationalPropTween(this, cache, p, startNum, relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endValue) : endValue);
                                        continue
                                    } else if (p === "smoothOrigin") {
                                        _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
                                        continue
                                    } else if (p === "force3D") {
                                        cache[p] = endValue;
                                        continue
                                    } else if (p === "transform") {
                                        _addRawTransformPTs(this, endValue, target);
                                        continue
                                    }
                                } else if (!(p in style)) {
                                    p = _checkPropPrefix(p) || p
                                }
                                if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
                                    startUnit = (startValue + "").substr((startNum + "").length);
                                    endNum || (endNum = 0);
                                    endUnit = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
                                    startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
                                    this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._parseRelative)(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== !1 ? _renderRoundedCSSProp : _renderCSSProp);
                                    this._pt.u = endUnit || 0;
                                    if (startUnit !== endUnit && endUnit !== "%") {
                                        this._pt.b = startValue;
                                        this._pt.r = _renderCSSPropWithBeginning
                                    }
                                } else if (!(p in style)) {
                                    if (p in target) {
                                        this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets)
                                    } else if (p !== "parseTransform") {
                                        (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);
                                        continue
                                    }
                                } else {
                                    _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue)
                                }
                                isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : inlineProps.push(p, 1, startValue || target[p]));
                                props.push(p)
                            }
                        }
                        hasPriority && (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this)
                    },
                    render: function render(ratio, data) {
                        if (data.tween._time || !_reverting()) {
                            var pt = data._pt;
                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next
                            }
                        } else {
                            data.styles.revert()
                        }
                    },
                    get: _get,
                    aliases: _propertyAliases,
                    getSetter: function getSetter(target, property, plugin) {
                        var p = _propertyAliases[property];
                        p && p.indexOf(",") < 0 && (property = p);
                        return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property)
                    },
                    core: {
                        _removeProperty: _removeProperty,
                        _getMatrix: _getMatrix
                    }
                };
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.core.getStyleSaver = _getStyleSaver;
                (function(positionAndScale, rotation, others, aliases) {
                    var all = (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function(name) {
                        _transformProps[name] = 1
                    });
                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function(name) {
                        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
                        _rotationalProperties[name] = 1
                    });
                    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
                    (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function(name) {
                        var split = name.split(":");
                        _propertyAliases[split[1]] = all[split[0]]
                    })
                })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
                (0, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
                    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px"
                });
                _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin)
            }),
        "./node_modules/gsap/Observer.js":
            /*!***************************************!*\
              !*** ./node_modules/gsap/Observer.js ***!
              \***************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    Observer: () => (Observer),
                    _getProxyProp: () => (_getProxyProp),
                    _getScrollFunc: () => (_getScrollFunc),
                    _getTarget: () => (_getTarget),
                    _getVelocityProp: () => (_getVelocityProp),
                    _horizontal: () => (_horizontal),
                    _proxies: () => (_proxies),
                    _scrollers: () => (_scrollers),
                    _vertical: () => (_vertical)
                });

                function _defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || !1;
                        descriptor.configurable = !0;
                        if ("value" in descriptor) descriptor.writable = !0;
                        Object.defineProperty(target, descriptor.key, descriptor)
                    }
                }

                function _createClass(Constructor, protoProps, staticProps) {
                    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) _defineProperties(Constructor, staticProps);
                    return Constructor
                }
                /*!
                 * Observer 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                var gsap, _coreInitted, _clamp, _win, _doc, _docEl, _body, _isTouch, _pointerType, ScrollTrigger, _root, _normalizer, _eventTypes, _context, _getGSAP = function _getGSAP() {
                        return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _startup = 1,
                    _observers = [],
                    _scrollers = [],
                    _proxies = [],
                    _getTime = Date.now,
                    _bridge = function _bridge(name, value) {
                        return value
                    },
                    _integrate = function _integrate() {
                        var core = ScrollTrigger.core,
                            data = core.bridge || {},
                            scrollers = core._scrollers,
                            proxies = core._proxies;
                        scrollers.push.apply(scrollers, _scrollers);
                        proxies.push.apply(proxies, _proxies);
                        _scrollers = scrollers;
                        _proxies = proxies;
                        _bridge = function _bridge(name, value) {
                            return data[name](value)
                        }
                    },
                    _getProxyProp = function _getProxyProp(element, property) {
                        return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property]
                    },
                    _isViewport = function _isViewport(el) {
                        return !!~_root.indexOf(el)
                    },
                    _addListener = function _addListener(element, type, func, passive, capture) {
                        return element.addEventListener(type, func, {
                            passive: passive !== !1,
                            capture: !!capture
                        })
                    },
                    _removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture)
                    },
                    _scrollLeft = "scrollLeft",
                    _scrollTop = "scrollTop",
                    _onScroll = function _onScroll() {
                        return _normalizer && _normalizer.isPressed || _scrollers.cache++
                    },
                    _scrollCacheFunc = function _scrollCacheFunc(f, doNotCache) {
                        var cachingFunc = function cachingFunc(value) {
                            if (value || value === 0) {
                                _startup && (_win.history.scrollRestoration = "manual");
                                var isNormalizing = _normalizer && _normalizer.isPressed;
                                value = cachingFunc.v = Math.round(value) || (_normalizer && _normalizer.iOS ? 1 : 0);
                                f(value);
                                cachingFunc.cacheID = _scrollers.cache;
                                isNormalizing && _bridge("ss", value)
                            } else if (doNotCache || _scrollers.cache !== cachingFunc.cacheID || _bridge("ref")) {
                                cachingFunc.cacheID = _scrollers.cache;
                                cachingFunc.v = f()
                            }
                            return cachingFunc.v + cachingFunc.offset
                        };
                        cachingFunc.offset = 0;
                        return f && cachingFunc
                    },
                    _horizontal = {
                        s: _scrollLeft,
                        p: "left",
                        p2: "Left",
                        os: "right",
                        os2: "Right",
                        d: "width",
                        d2: "Width",
                        a: "x",
                        sc: _scrollCacheFunc(function(value) {
                            return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0
                        })
                    },
                    _vertical = {
                        s: _scrollTop,
                        p: "top",
                        p2: "Top",
                        os: "bottom",
                        os2: "Bottom",
                        d: "height",
                        d2: "Height",
                        a: "y",
                        op: _horizontal,
                        sc: _scrollCacheFunc(function(value) {
                            return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0
                        })
                    },
                    _getTarget = function _getTarget(t, self) {
                        return (self && self._ctx && self._ctx.selector || gsap.utils.toArray)(t)[0] || (typeof t === "string" && gsap.config().nullTargetWarn !== !1 ? console.warn("Element not found:", t) : null)
                    },
                    _getScrollFunc = function _getScrollFunc(element, _ref) {
                        var s = _ref.s,
                            sc = _ref.sc;
                        _isViewport(element) && (element = _doc.scrollingElement || _docEl);
                        var i = _scrollers.indexOf(element),
                            offset = sc === _vertical.sc ? 1 : 2;
                        !~i && (i = _scrollers.push(element) - 1);
                        _scrollers[i + offset] || _addListener(element, "scroll", _onScroll);
                        var prev = _scrollers[i + offset],
                            func = prev || (_scrollers[i + offset] = _scrollCacheFunc(_getProxyProp(element, s), !0) || (_isViewport(element) ? sc : _scrollCacheFunc(function(value) {
                                return arguments.length ? element[s] = value : element[s]
                            })));
                        func.target = element;
                        prev || (func.smooth = gsap.getProperty(element, "scrollBehavior") === "smooth");
                        return func
                    },
                    _getVelocityProp = function _getVelocityProp(value, minTimeRefresh, useDelta) {
                        var v1 = value,
                            v2 = value,
                            t1 = _getTime(),
                            t2 = t1,
                            min = minTimeRefresh || 50,
                            dropToZeroTime = Math.max(500, min * 3),
                            update = function update(value, force) {
                                var t = _getTime();
                                if (force || t - t1 > min) {
                                    v2 = v1;
                                    v1 = value;
                                    t2 = t1;
                                    t1 = t
                                } else if (useDelta) {
                                    v1 += value
                                } else {
                                    v1 = v2 + (value - v2) / (t - t2) * (t1 - t2)
                                }
                            },
                            reset = function reset() {
                                v2 = v1 = useDelta ? 0 : v1;
                                t2 = t1 = 0
                            },
                            getVelocity = function getVelocity(latestValue) {
                                var tOld = t2,
                                    vOld = v2,
                                    t = _getTime();
                                (latestValue || latestValue === 0) && latestValue !== v1 && update(latestValue);
                                return t1 === t2 || t - t2 > dropToZeroTime ? 0 : (v1 + (useDelta ? vOld : -vOld)) / ((useDelta ? t : t1) - tOld) * 1000
                            };
                        return {
                            update: update,
                            reset: reset,
                            getVelocity: getVelocity
                        }
                    },
                    _getEvent = function _getEvent(e, preventDefault) {
                        preventDefault && !e._gsapAllow && e.preventDefault();
                        return e.changedTouches ? e.changedTouches[0] : e
                    },
                    _getAbsoluteMax = function _getAbsoluteMax(a) {
                        var max = Math.max.apply(Math, a),
                            min = Math.min.apply(Math, a);
                        return Math.abs(max) >= Math.abs(min) ? max : min
                    },
                    _setScrollTrigger = function _setScrollTrigger() {
                        ScrollTrigger = gsap.core.globals().ScrollTrigger;
                        ScrollTrigger && ScrollTrigger.core && _integrate()
                    },
                    _initCore = function _initCore(core) {
                        gsap = core || _getGSAP();
                        if (!_coreInitted && gsap && typeof document !== "undefined" && document.body) {
                            _win = window;
                            _doc = document;
                            _docEl = _doc.documentElement;
                            _body = _doc.body;
                            _root = [_win, _doc, _docEl, _body];
                            _clamp = gsap.utils.clamp;
                            _context = gsap.core.context || function() {};
                            _pointerType = "onpointerenter" in _body ? "pointer" : "mouse";
                            _isTouch = Observer.isTouch = _win.matchMedia && _win.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in _win || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0;
                            _eventTypes = Observer.eventTypes = ("ontouchstart" in _docEl ? "touchstart,touchmove,touchcancel,touchend" : !("onpointerdown" in _docEl) ? "mousedown,mousemove,mouseup,mouseup" : "pointerdown,pointermove,pointercancel,pointerup").split(",");
                            setTimeout(function() {
                                return _startup = 0
                            }, 500);
                            _setScrollTrigger();
                            _coreInitted = 1
                        }
                        return _coreInitted
                    };
                _horizontal.op = _vertical;
                _scrollers.cache = 0;
                var Observer = function() {
                    function Observer(vars) {
                        this.init(vars)
                    }
                    var _proto = Observer.prototype;
                    _proto.init = function init(vars) {
                        _coreInitted || _initCore(gsap) || console.warn("Please gsap.registerPlugin(Observer)");
                        ScrollTrigger || _setScrollTrigger();
                        var tolerance = vars.tolerance,
                            dragMinimum = vars.dragMinimum,
                            type = vars.type,
                            target = vars.target,
                            lineHeight = vars.lineHeight,
                            debounce = vars.debounce,
                            preventDefault = vars.preventDefault,
                            onStop = vars.onStop,
                            onStopDelay = vars.onStopDelay,
                            ignore = vars.ignore,
                            wheelSpeed = vars.wheelSpeed,
                            event = vars.event,
                            onDragStart = vars.onDragStart,
                            onDragEnd = vars.onDragEnd,
                            onDrag = vars.onDrag,
                            onPress = vars.onPress,
                            onRelease = vars.onRelease,
                            onRight = vars.onRight,
                            onLeft = vars.onLeft,
                            onUp = vars.onUp,
                            onDown = vars.onDown,
                            onChangeX = vars.onChangeX,
                            onChangeY = vars.onChangeY,
                            onChange = vars.onChange,
                            onToggleX = vars.onToggleX,
                            onToggleY = vars.onToggleY,
                            onHover = vars.onHover,
                            onHoverEnd = vars.onHoverEnd,
                            onMove = vars.onMove,
                            ignoreCheck = vars.ignoreCheck,
                            isNormalizer = vars.isNormalizer,
                            onGestureStart = vars.onGestureStart,
                            onGestureEnd = vars.onGestureEnd,
                            onWheel = vars.onWheel,
                            onEnable = vars.onEnable,
                            onDisable = vars.onDisable,
                            onClick = vars.onClick,
                            scrollSpeed = vars.scrollSpeed,
                            capture = vars.capture,
                            allowClicks = vars.allowClicks,
                            lockAxis = vars.lockAxis,
                            onLockAxis = vars.onLockAxis;
                        this.target = target = _getTarget(target) || _docEl;
                        this.vars = vars;
                        ignore && (ignore = gsap.utils.toArray(ignore));
                        tolerance = tolerance || 1e-9;
                        dragMinimum = dragMinimum || 0;
                        wheelSpeed = wheelSpeed || 1;
                        scrollSpeed = scrollSpeed || 1;
                        type = type || "wheel,touch,pointer";
                        debounce = debounce !== !1;
                        lineHeight || (lineHeight = parseFloat(_win.getComputedStyle(_body).lineHeight) || 22);
                        var id, onStopDelayedCall, dragged, moved, wheeled, locked, axis, self = this,
                            prevDeltaX = 0,
                            prevDeltaY = 0,
                            passive = vars.passive || !preventDefault,
                            scrollFuncX = _getScrollFunc(target, _horizontal),
                            scrollFuncY = _getScrollFunc(target, _vertical),
                            scrollX = scrollFuncX(),
                            scrollY = scrollFuncY(),
                            limitToTouch = ~type.indexOf("touch") && !~type.indexOf("pointer") && _eventTypes[0] === "pointerdown",
                            isViewport = _isViewport(target),
                            ownerDoc = target.ownerDocument || _doc,
                            deltaX = [0, 0, 0],
                            deltaY = [0, 0, 0],
                            onClickTime = 0,
                            clickCapture = function clickCapture() {
                                return onClickTime = _getTime()
                            },
                            _ignoreCheck = function _ignoreCheck(e, isPointerOrTouch) {
                                return (self.event = e) && ignore && ~ignore.indexOf(e.target) || isPointerOrTouch && limitToTouch && e.pointerType !== "touch" || ignoreCheck && ignoreCheck(e, isPointerOrTouch)
                            },
                            onStopFunc = function onStopFunc() {
                                self._vx.reset();
                                self._vy.reset();
                                onStopDelayedCall.pause();
                                onStop && onStop(self)
                            },
                            update = function update() {
                                var dx = self.deltaX = _getAbsoluteMax(deltaX),
                                    dy = self.deltaY = _getAbsoluteMax(deltaY),
                                    changedX = Math.abs(dx) >= tolerance,
                                    changedY = Math.abs(dy) >= tolerance;
                                onChange && (changedX || changedY) && onChange(self, dx, dy, deltaX, deltaY);
                                if (changedX) {
                                    onRight && self.deltaX > 0 && onRight(self);
                                    onLeft && self.deltaX < 0 && onLeft(self);
                                    onChangeX && onChangeX(self);
                                    onToggleX && self.deltaX < 0 !== prevDeltaX < 0 && onToggleX(self);
                                    prevDeltaX = self.deltaX;
                                    deltaX[0] = deltaX[1] = deltaX[2] = 0
                                }
                                if (changedY) {
                                    onDown && self.deltaY > 0 && onDown(self);
                                    onUp && self.deltaY < 0 && onUp(self);
                                    onChangeY && onChangeY(self);
                                    onToggleY && self.deltaY < 0 !== prevDeltaY < 0 && onToggleY(self);
                                    prevDeltaY = self.deltaY;
                                    deltaY[0] = deltaY[1] = deltaY[2] = 0
                                }
                                if (moved || dragged) {
                                    onMove && onMove(self);
                                    if (dragged) {
                                        onDrag(self);
                                        dragged = !1
                                    }
                                    moved = !1
                                }
                                locked && !(locked = !1) && onLockAxis && onLockAxis(self);
                                if (wheeled) {
                                    onWheel(self);
                                    wheeled = !1
                                }
                                id = 0
                            },
                            onDelta = function onDelta(x, y, index) {
                                deltaX[index] += x;
                                deltaY[index] += y;
                                self._vx.update(x);
                                self._vy.update(y);
                                debounce ? id || (id = requestAnimationFrame(update)) : update()
                            },
                            onTouchOrPointerDelta = function onTouchOrPointerDelta(x, y) {
                                if (lockAxis && !axis) {
                                    self.axis = axis = Math.abs(x) > Math.abs(y) ? "x" : "y";
                                    locked = !0
                                }
                                if (axis !== "y") {
                                    deltaX[2] += x;
                                    self._vx.update(x, !0)
                                }
                                if (axis !== "x") {
                                    deltaY[2] += y;
                                    self._vy.update(y, !0)
                                }
                                debounce ? id || (id = requestAnimationFrame(update)) : update()
                            },
                            _onDrag = function _onDrag(e) {
                                if (_ignoreCheck(e, 1)) {
                                    return
                                }
                                e = _getEvent(e, preventDefault);
                                var x = e.clientX,
                                    y = e.clientY,
                                    dx = x - self.x,
                                    dy = y - self.y,
                                    isDragging = self.isDragging;
                                self.x = x;
                                self.y = y;
                                if (isDragging || Math.abs(self.startX - x) >= dragMinimum || Math.abs(self.startY - y) >= dragMinimum) {
                                    onDrag && (dragged = !0);
                                    isDragging || (self.isDragging = !0);
                                    onTouchOrPointerDelta(dx, dy);
                                    isDragging || onDragStart && onDragStart(self)
                                }
                            },
                            _onPress = self.onPress = function(e) {
                                if (_ignoreCheck(e, 1) || e && e.button) {
                                    return
                                }
                                self.axis = axis = null;
                                onStopDelayedCall.pause();
                                self.isPressed = !0;
                                e = _getEvent(e);
                                prevDeltaX = prevDeltaY = 0;
                                self.startX = self.x = e.clientX;
                                self.startY = self.y = e.clientY;
                                self._vx.reset();
                                self._vy.reset();
                                _addListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, passive, !0);
                                self.deltaX = self.deltaY = 0;
                                onPress && onPress(self)
                            },
                            _onRelease = self.onRelease = function(e) {
                                if (_ignoreCheck(e, 1)) {
                                    return
                                }
                                _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, !0);
                                var isTrackingDrag = !isNaN(self.y - self.startY),
                                    wasDragging = self.isDragging,
                                    isDragNotClick = wasDragging && (Math.abs(self.x - self.startX) > 3 || Math.abs(self.y - self.startY) > 3),
                                    eventData = _getEvent(e);
                                if (!isDragNotClick && isTrackingDrag) {
                                    self._vx.reset();
                                    self._vy.reset();
                                    if (preventDefault && allowClicks) {
                                        gsap.delayedCall(0.08, function() {
                                            if (_getTime() - onClickTime > 300 && !e.defaultPrevented) {
                                                if (e.target.click) {
                                                    e.target.click()
                                                } else if (ownerDoc.createEvent) {
                                                    var syntheticEvent = ownerDoc.createEvent("MouseEvents");
                                                    syntheticEvent.initMouseEvent("click", !0, !0, _win, 1, eventData.screenX, eventData.screenY, eventData.clientX, eventData.clientY, !1, !1, !1, !1, 0, null);
                                                    e.target.dispatchEvent(syntheticEvent)
                                                }
                                            }
                                        })
                                    }
                                }
                                self.isDragging = self.isGesturing = self.isPressed = !1;
                                onStop && wasDragging && !isNormalizer && onStopDelayedCall.restart(!0);
                                onDragEnd && wasDragging && onDragEnd(self);
                                onRelease && onRelease(self, isDragNotClick)
                            },
                            _onGestureStart = function _onGestureStart(e) {
                                return e.touches && e.touches.length > 1 && (self.isGesturing = !0) && onGestureStart(e, self.isDragging)
                            },
                            _onGestureEnd = function _onGestureEnd() {
                                return (self.isGesturing = !1) || onGestureEnd(self)
                            },
                            onScroll = function onScroll(e) {
                                if (_ignoreCheck(e)) {
                                    return
                                }
                                var x = scrollFuncX(),
                                    y = scrollFuncY();
                                onDelta((x - scrollX) * scrollSpeed, (y - scrollY) * scrollSpeed, 1);
                                scrollX = x;
                                scrollY = y;
                                onStop && onStopDelayedCall.restart(!0)
                            },
                            _onWheel = function _onWheel(e) {
                                if (_ignoreCheck(e)) {
                                    return
                                }
                                e = _getEvent(e, preventDefault);
                                onWheel && (wheeled = !0);
                                var multiplier = (e.deltaMode === 1 ? lineHeight : e.deltaMode === 2 ? _win.innerHeight : 1) * wheelSpeed;
                                onDelta(e.deltaX * multiplier, e.deltaY * multiplier, 0);
                                onStop && !isNormalizer && onStopDelayedCall.restart(!0)
                            },
                            _onMove = function _onMove(e) {
                                if (_ignoreCheck(e)) {
                                    return
                                }
                                var x = e.clientX,
                                    y = e.clientY,
                                    dx = x - self.x,
                                    dy = y - self.y;
                                self.x = x;
                                self.y = y;
                                moved = !0;
                                onStop && onStopDelayedCall.restart(!0);
                                (dx || dy) && onTouchOrPointerDelta(dx, dy)
                            },
                            _onHover = function _onHover(e) {
                                self.event = e;
                                onHover(self)
                            },
                            _onHoverEnd = function _onHoverEnd(e) {
                                self.event = e;
                                onHoverEnd(self)
                            },
                            _onClick = function _onClick(e) {
                                return _ignoreCheck(e) || _getEvent(e, preventDefault) && onClick(self)
                            };
                        onStopDelayedCall = self._dc = gsap.delayedCall(onStopDelay || 0.25, onStopFunc).pause();
                        self.deltaX = self.deltaY = 0;
                        self._vx = _getVelocityProp(0, 50, !0);
                        self._vy = _getVelocityProp(0, 50, !0);
                        self.scrollX = scrollFuncX;
                        self.scrollY = scrollFuncY;
                        self.isDragging = self.isGesturing = self.isPressed = !1;
                        _context(this);
                        self.enable = function(e) {
                            if (!self.isEnabled) {
                                _addListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                                type.indexOf("scroll") >= 0 && _addListener(isViewport ? ownerDoc : target, "scroll", onScroll, passive, capture);
                                type.indexOf("wheel") >= 0 && _addListener(target, "wheel", _onWheel, passive, capture);
                                if (type.indexOf("touch") >= 0 && _isTouch || type.indexOf("pointer") >= 0) {
                                    _addListener(target, _eventTypes[0], _onPress, passive, capture);
                                    _addListener(ownerDoc, _eventTypes[2], _onRelease);
                                    _addListener(ownerDoc, _eventTypes[3], _onRelease);
                                    allowClicks && _addListener(target, "click", clickCapture, !0, !0);
                                    onClick && _addListener(target, "click", _onClick);
                                    onGestureStart && _addListener(ownerDoc, "gesturestart", _onGestureStart);
                                    onGestureEnd && _addListener(ownerDoc, "gestureend", _onGestureEnd);
                                    onHover && _addListener(target, _pointerType + "enter", _onHover);
                                    onHoverEnd && _addListener(target, _pointerType + "leave", _onHoverEnd);
                                    onMove && _addListener(target, _pointerType + "move", _onMove)
                                }
                                self.isEnabled = !0;
                                e && e.type && _onPress(e);
                                onEnable && onEnable(self)
                            }
                            return self
                        };
                        self.disable = function() {
                            if (self.isEnabled) {
                                _observers.filter(function(o) {
                                    return o !== self && _isViewport(o.target)
                                }).length || _removeListener(isViewport ? ownerDoc : target, "scroll", _onScroll);
                                if (self.isPressed) {
                                    self._vx.reset();
                                    self._vy.reset();
                                    _removeListener(isNormalizer ? target : ownerDoc, _eventTypes[1], _onDrag, !0)
                                }
                                _removeListener(isViewport ? ownerDoc : target, "scroll", onScroll, capture);
                                _removeListener(target, "wheel", _onWheel, capture);
                                _removeListener(target, _eventTypes[0], _onPress, capture);
                                _removeListener(ownerDoc, _eventTypes[2], _onRelease);
                                _removeListener(ownerDoc, _eventTypes[3], _onRelease);
                                _removeListener(target, "click", clickCapture, !0);
                                _removeListener(target, "click", _onClick);
                                _removeListener(ownerDoc, "gesturestart", _onGestureStart);
                                _removeListener(ownerDoc, "gestureend", _onGestureEnd);
                                _removeListener(target, _pointerType + "enter", _onHover);
                                _removeListener(target, _pointerType + "leave", _onHoverEnd);
                                _removeListener(target, _pointerType + "move", _onMove);
                                self.isEnabled = self.isPressed = self.isDragging = !1;
                                onDisable && onDisable(self)
                            }
                        };
                        self.kill = self.revert = function() {
                            self.disable();
                            var i = _observers.indexOf(self);
                            i >= 0 && _observers.splice(i, 1);
                            _normalizer === self && (_normalizer = 0)
                        };
                        _observers.push(self);
                        isNormalizer && _isViewport(target) && (_normalizer = self);
                        self.enable(event)
                    };
                    _createClass(Observer, [{
                        key: "velocityX",
                        get: function get() {
                            return this._vx.getVelocity()
                        }
                    }, {
                        key: "velocityY",
                        get: function get() {
                            return this._vy.getVelocity()
                        }
                    }]);
                    return Observer
                }();
                Observer.version = "3.12.5";
                Observer.create = function(vars) {
                    return new Observer(vars)
                };
                Observer.register = _initCore;
                Observer.getAll = function() {
                    return _observers.slice()
                };
                Observer.getById = function(id) {
                    return _observers.filter(function(o) {
                        return o.vars.id === id
                    })[0]
                };
                _getGSAP() && gsap.registerPlugin(Observer)
            }),
        "./node_modules/gsap/ScrollToPlugin.js":
            /*!*********************************************!*\
              !*** ./node_modules/gsap/ScrollToPlugin.js ***!
              \*********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    ScrollToPlugin: () => (ScrollToPlugin)
                });
                /*!
                 * ScrollToPlugin 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                var gsap, _coreInitted, _window, _docEl, _body, _toArray, _config, ScrollTrigger, _windowExists = function _windowExists() {
                        return typeof window !== "undefined"
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _isString = function _isString(value) {
                        return typeof value === "string"
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function"
                    },
                    _max = function _max(element, axis) {
                        var dim = axis === "x" ? "Width" : "Height",
                            scroll = "scroll" + dim,
                            client = "client" + dim;
                        return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim]
                    },
                    _buildGetter = function _buildGetter(e, axis) {
                        var p = "scroll" + (axis === "x" ? "Left" : "Top");
                        if (e === _window) {
                            if (e.pageXOffset != null) {
                                p = "page" + axis.toUpperCase() + "Offset"
                            } else {
                                e = _docEl[p] != null ? _docEl : _body
                            }
                        }
                        return function() {
                            return e[p]
                        }
                    },
                    _clean = function _clean(value, index, target, targets) {
                        _isFunction(value) && (value = value(index, target, targets));
                        if (typeof value !== "object") {
                            return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
                                x: value,
                                y: value
                            } : {
                                y: value
                            }
                        } else if (value.nodeType) {
                            return {
                                y: value,
                                x: value
                            }
                        } else {
                            var result = {},
                                p;
                            for (p in value) {
                                result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p]
                            }
                            return result
                        }
                    },
                    _getOffset = function _getOffset(element, container) {
                        element = _toArray(element)[0];
                        if (!element || !element.getBoundingClientRect) {
                            return console.warn("scrollTo target doesn't exist. Using 0") || {
                                x: 0,
                                y: 0
                            }
                        }
                        var rect = element.getBoundingClientRect(),
                            isRoot = !container || container === _window || container === _body,
                            cRect = isRoot ? {
                                top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
                                left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
                            } : container.getBoundingClientRect(),
                            offsets = {
                                x: rect.left - cRect.left,
                                y: rect.top - cRect.top
                            };
                        if (!isRoot && container) {
                            offsets.x += _buildGetter(container, "x")();
                            offsets.y += _buildGetter(container, "y")()
                        }
                        return offsets
                    },
                    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
                        return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset)
                    },
                    _initCore = function _initCore() {
                        gsap = _getGSAP();
                        if (_windowExists() && gsap && typeof document !== "undefined" && document.body) {
                            _window = window;
                            _body = document.body;
                            _docEl = document.documentElement;
                            _toArray = gsap.utils.toArray;
                            gsap.config({
                                autoKillThreshold: 7
                            });
                            _config = gsap.config();
                            _coreInitted = 1
                        }
                    };
                var ScrollToPlugin = {
                    version: "3.12.5",
                    name: "scrollTo",
                    rawVars: 1,
                    register: function register(core) {
                        gsap = core;
                        _initCore()
                    },
                    init: function init(target, value, tween, index, targets) {
                        _coreInitted || _initCore();
                        var data = this,
                            snapType = gsap.getProperty(target, "scrollSnapType");
                        data.isWin = target === _window;
                        data.target = target;
                        data.tween = tween;
                        value = _clean(value, index, target, targets);
                        data.vars = value;
                        data.autoKill = !!value.autoKill;
                        data.getX = _buildGetter(target, "x");
                        data.getY = _buildGetter(target, "y");
                        data.x = data.xPrev = data.getX();
                        data.y = data.yPrev = data.getY();
                        ScrollTrigger || (ScrollTrigger = gsap.core.globals().ScrollTrigger);
                        gsap.getProperty(target, "scrollBehavior") === "smooth" && gsap.set(target, {
                            scrollBehavior: "auto"
                        });
                        if (snapType && snapType !== "none") {
                            data.snap = 1;
                            data.snapInline = target.style.scrollSnapType;
                            target.style.scrollSnapType = "none"
                        }
                        if (value.x != null) {
                            data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
                            data._props.push("scrollTo_x")
                        } else {
                            data.skipX = 1
                        }
                        if (value.y != null) {
                            data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
                            data._props.push("scrollTo_y")
                        } else {
                            data.skipY = 1
                        }
                    },
                    render: function render(ratio, data) {
                        var pt = data._pt,
                            target = data.target,
                            tween = data.tween,
                            autoKill = data.autoKill,
                            xPrev = data.xPrev,
                            yPrev = data.yPrev,
                            isWin = data.isWin,
                            snap = data.snap,
                            snapInline = data.snapInline,
                            x, y, yDif, xDif, threshold;
                        while (pt) {
                            pt.r(ratio, pt.d);
                            pt = pt._next
                        }
                        x = isWin || !data.skipX ? data.getX() : xPrev;
                        y = isWin || !data.skipY ? data.getY() : yPrev;
                        yDif = y - yPrev;
                        xDif = x - xPrev;
                        threshold = _config.autoKillThreshold;
                        if (data.x < 0) {
                            data.x = 0
                        }
                        if (data.y < 0) {
                            data.y = 0
                        }
                        if (autoKill) {
                            if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
                                data.skipX = 1
                            }
                            if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
                                data.skipY = 1
                            }
                            if (data.skipX && data.skipY) {
                                tween.kill();
                                data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || [])
                            }
                        }
                        if (isWin) {
                            _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y)
                        } else {
                            data.skipY || (target.scrollTop = data.y);
                            data.skipX || (target.scrollLeft = data.x)
                        }
                        if (snap && (ratio === 1 || ratio === 0)) {
                            y = target.scrollTop;
                            x = target.scrollLeft;
                            snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
                            target.scrollTop = y + 1;
                            target.scrollLeft = x + 1;
                            target.scrollTop = y;
                            target.scrollLeft = x
                        }
                        data.xPrev = data.x;
                        data.yPrev = data.y;
                        ScrollTrigger && ScrollTrigger.update()
                    },
                    kill: function kill(property) {
                        var both = property === "scrollTo",
                            i = this._props.indexOf(property);
                        if (both || property === "scrollTo_x") {
                            this.skipX = 1
                        }
                        if (both || property === "scrollTo_y") {
                            this.skipY = 1
                        }
                        i > -1 && this._props.splice(i, 1);
                        return !this._props.length
                    }
                };
                ScrollToPlugin.max = _max;
                ScrollToPlugin.getOffset = _getOffset;
                ScrollToPlugin.buildGetter = _buildGetter;
                _getGSAP() && gsap.registerPlugin(ScrollToPlugin)
            }),
        "./node_modules/gsap/ScrollTrigger.js":
            /*!********************************************!*\
              !*** ./node_modules/gsap/ScrollTrigger.js ***!
              \********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    ScrollTrigger: () => (ScrollTrigger)
                });
                var _Observer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./Observer.js */ "./node_modules/gsap/Observer.js");
                /*!
                 * ScrollTrigger 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                var gsap, _coreInitted, _win, _doc, _docEl, _body, _root, _resizeDelay, _toArray, _clamp, _time2, _syncInterval, _refreshing, _pointerIsDown, _transformProp, _i, _prevWidth, _prevHeight, _autoRefresh, _sort, _suppressOverwrites, _ignoreResize, _normalizer, _ignoreMobileResize, _baseScreenHeight, _baseScreenWidth, _fixIOSBug, _context, _scrollRestoration, _div100vh, _100vh, _isReverted, _clampingMax, _limitCallbacks, _startup = 1,
                    _getTime = Date.now,
                    _time1 = _getTime(),
                    _lastScrollTime = 0,
                    _enabled = 0,
                    _parseClamp = function _parseClamp(value, type, self) {
                        var clamp = _isString(value) && (value.substr(0, 6) === "clamp(" || value.indexOf("max") > -1);
                        self["_" + type + "Clamp"] = clamp;
                        return clamp ? value.substr(6, value.length - 7) : value
                    },
                    _keepClamp = function _keepClamp(value, clamp) {
                        return clamp && (!_isString(value) || value.substr(0, 6) !== "clamp(") ? "clamp(" + value + ")" : value
                    },
                    _rafBugFix = function _rafBugFix() {
                        return _enabled && requestAnimationFrame(_rafBugFix)
                    },
                    _pointerDownHandler = function _pointerDownHandler() {
                        return _pointerIsDown = 1
                    },
                    _pointerUpHandler = function _pointerUpHandler() {
                        return _pointerIsDown = 0
                    },
                    _passThrough = function _passThrough(v) {
                        return v
                    },
                    _round = function _round(value) {
                        return Math.round(value * 100000) / 100000 || 0
                    },
                    _windowExists = function _windowExists() {
                        return typeof window !== "undefined"
                    },
                    _getGSAP = function _getGSAP() {
                        return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap
                    },
                    _isViewport = function _isViewport(e) {
                        return !!~_root.indexOf(e)
                    },
                    _getViewportDimension = function _getViewportDimension(dimensionProperty) {
                        return (dimensionProperty === "Height" ? _100vh : _win["inner" + dimensionProperty]) || _docEl["client" + dimensionProperty] || _body["client" + dimensionProperty]
                    },
                    _getBoundsFunc = function _getBoundsFunc(element) {
                        return (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, "getBoundingClientRect") || (_isViewport(element) ? function() {
                            _winOffsets.width = _win.innerWidth;
                            _winOffsets.height = _100vh;
                            return _winOffsets
                        } : function() {
                            return _getBounds(element)
                        })
                    },
                    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref) {
                        var d = _ref.d,
                            d2 = _ref.d2,
                            a = _ref.a;
                        return (a = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "getBoundingClientRect")) ? function() {
                            return a()[d]
                        } : function() {
                            return (isViewport ? _getViewportDimension(d2) : scroller["client" + d2]) || 0
                        }
                    },
                    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
                        return !isViewport || ~_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.indexOf(element) ? _getBoundsFunc(element) : function() {
                            return _winOffsets
                        }
                    },
                    _maxScroll = function _maxScroll(element, _ref2) {
                        var s = _ref2.s,
                            d2 = _ref2.d2,
                            d = _ref2.d,
                            a = _ref2.a;
                        return Math.max(0, (s = "scroll" + d2) && (a = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_docEl[s] || _body[s]) - _getViewportDimension(d2) : element[s] - element["offset" + d2])
                    },
                    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
                        for (var i = 0; i < _autoRefresh.length; i += 3) {
                            (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2])
                        }
                    },
                    _isString = function _isString(value) {
                        return typeof value === "string"
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function"
                    },
                    _isNumber = function _isNumber(value) {
                        return typeof value === "number"
                    },
                    _isObject = function _isObject(value) {
                        return typeof value === "object"
                    },
                    _endAnimation = function _endAnimation(animation, reversed, pause) {
                        return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause()
                    },
                    _callback = function _callback(self, func) {
                        if (self.enabled) {
                            var result = self._ctx ? self._ctx.add(function() {
                                return func(self)
                            }) : func(self);
                            result && result.totalTime && (self.callbackAnimation = result)
                        }
                    },
                    _abs = Math.abs,
                    _left = "left",
                    _top = "top",
                    _right = "right",
                    _bottom = "bottom",
                    _width = "width",
                    _height = "height",
                    _Right = "Right",
                    _Left = "Left",
                    _Top = "Top",
                    _Bottom = "Bottom",
                    _padding = "padding",
                    _margin = "margin",
                    _Width = "Width",
                    _Height = "Height",
                    _px = "px",
                    _getComputedStyle = function _getComputedStyle(element) {
                        return _win.getComputedStyle(element)
                    },
                    _makePositionable = function _makePositionable(element) {
                        var position = _getComputedStyle(element).position;
                        element.style.position = position === "absolute" || position === "fixed" ? position : "relative"
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) {
                            p in obj || (obj[p] = defaults[p])
                        }
                        return obj
                    },
                    _getBounds = function _getBounds(element, withoutTransforms) {
                        var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
                                x: 0,
                                y: 0,
                                xPercent: 0,
                                yPercent: 0,
                                rotation: 0,
                                rotationX: 0,
                                rotationY: 0,
                                scale: 1,
                                skewX: 0,
                                skewY: 0
                            }).progress(1),
                            bounds = element.getBoundingClientRect();
                        tween && tween.progress(0).kill();
                        return bounds
                    },
                    _getSize = function _getSize(element, _ref3) {
                        var d2 = _ref3.d2;
                        return element["offset" + d2] || element["client" + d2] || 0
                    },
                    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
                        var a = [],
                            labels = timeline.labels,
                            duration = timeline.duration(),
                            p;
                        for (p in labels) {
                            a.push(labels[p] / duration)
                        }
                        return a
                    },
                    _getClosestLabel = function _getClosestLabel(animation) {
                        return function(value) {
                            return gsap.utils.snap(_getLabelRatioArray(animation), value)
                        }
                    },
                    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
                        var snap = gsap.utils.snap(snapIncrementOrArray),
                            a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function(a, b) {
                                return a - b
                            });
                        return a ? function(value, direction, threshold) {
                            if (threshold === void 0) {
                                threshold = 1e-3
                            }
                            var i;
                            if (!direction) {
                                return snap(value)
                            }
                            if (direction > 0) {
                                value -= threshold;
                                for (i = 0; i < a.length; i++) {
                                    if (a[i] >= value) {
                                        return a[i]
                                    }
                                }
                                return a[i - 1]
                            } else {
                                i = a.length;
                                value += threshold;
                                while (i--) {
                                    if (a[i] <= value) {
                                        return a[i]
                                    }
                                }
                            }
                            return a[0]
                        } : function(value, direction, threshold) {
                            if (threshold === void 0) {
                                threshold = 1e-3
                            }
                            var snapped = snap(value);
                            return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray)
                        }
                    },
                    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
                        return function(value, st) {
                            return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction)
                        }
                    },
                    _multiListener = function _multiListener(func, element, types, callback) {
                        return types.split(",").forEach(function(type) {
                            return func(element, type, callback)
                        })
                    },
                    _addListener = function _addListener(element, type, func, nonPassive, capture) {
                        return element.addEventListener(type, func, {
                            passive: !nonPassive,
                            capture: !!capture
                        })
                    },
                    _removeListener = function _removeListener(element, type, func, capture) {
                        return element.removeEventListener(type, func, !!capture)
                    },
                    _wheelListener = function _wheelListener(func, el, scrollFunc) {
                        scrollFunc = scrollFunc && scrollFunc.wheelHandler;
                        if (scrollFunc) {
                            func(el, "wheel", scrollFunc);
                            func(el, "touchmove", scrollFunc)
                        }
                    },
                    _markerDefaults = {
                        startColor: "green",
                        endColor: "red",
                        indent: 0,
                        fontSize: "16px",
                        fontWeight: "normal"
                    },
                    _defaults = {
                        toggleActions: "play",
                        anticipatePin: 0
                    },
                    _keywords = {
                        top: 0,
                        left: 0,
                        center: 0.5,
                        bottom: 1,
                        right: 1
                    },
                    _offsetToPx = function _offsetToPx(value, size) {
                        if (_isString(value)) {
                            var eqIndex = value.indexOf("="),
                                relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;
                            if (~eqIndex) {
                                value.indexOf("%") > eqIndex && (relative *= size / 100);
                                value = value.substr(0, eqIndex - 1)
                            }
                            value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0)
                        }
                        return value
                    },
                    _createMarker = function _createMarker(type, name, container, direction, _ref4, offset, matchWidthEl, containerAnimation) {
                        var startColor = _ref4.startColor,
                            endColor = _ref4.endColor,
                            fontSize = _ref4.fontSize,
                            indent = _ref4.indent,
                            fontWeight = _ref4.fontWeight;
                        var e = _doc.createElement("div"),
                            useFixedPosition = _isViewport(container) || (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(container, "pinType") === "fixed",
                            isScroller = type.indexOf("scroller") !== -1,
                            parent = useFixedPosition ? _body : container,
                            isStart = type.indexOf("start") !== -1,
                            color = isStart ? startColor : endColor,
                            css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
                        css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
                        (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
                        matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
                        e._isStart = isStart;
                        e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
                        e.style.cssText = css;
                        e.innerText = name || name === 0 ? type + "-" + name : type;
                        parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
                        e._offset = e["offset" + direction.op.d2];
                        _positionMarker(e, 0, direction, isStart);
                        return e
                    },
                    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
                        var vars = {
                                display: "block"
                            },
                            side = direction[flipped ? "os2" : "p2"],
                            oppositeSide = direction[flipped ? "p2" : "os2"];
                        marker._isFlipped = flipped;
                        vars[direction.a + "Percent"] = flipped ? -100 : 0;
                        vars[direction.a] = flipped ? "1px" : 0;
                        vars["border" + side + _Width] = 1;
                        vars["border" + oppositeSide + _Width] = 0;
                        vars[direction.p] = start + "px";
                        gsap.set(marker, vars)
                    },
                    _triggers = [],
                    _ids = {},
                    _rafID, _sync = function _sync() {
                        return _getTime() - _lastScrollTime > 34 && (_rafID || (_rafID = requestAnimationFrame(_updateAll)))
                    },
                    _onScroll = function _onScroll() {
                        if (!_normalizer || !_normalizer.isPressed || _normalizer.startX > _body.clientWidth) {
                            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                            if (_normalizer) {
                                _rafID || (_rafID = requestAnimationFrame(_updateAll))
                            } else {
                                _updateAll()
                            }
                            _lastScrollTime || _dispatch("scrollStart");
                            _lastScrollTime = _getTime()
                        }
                    },
                    _setBaseDimensions = function _setBaseDimensions() {
                        _baseScreenWidth = _win.innerWidth;
                        _baseScreenHeight = _win.innerHeight
                    },
                    _onResize = function _onResize() {
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                        !_refreshing && !_ignoreResize && !_doc.fullscreenElement && !_doc.webkitFullscreenElement && (!_ignoreMobileResize || _baseScreenWidth !== _win.innerWidth || Math.abs(_win.innerHeight - _baseScreenHeight) > _win.innerHeight * 0.25) && _resizeDelay.restart(!0)
                    },
                    _listeners = {},
                    _emptyArray = [],
                    _softRefresh = function _softRefresh() {
                        return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(!0)
                    },
                    _dispatch = function _dispatch(type) {
                        return _listeners[type] && _listeners[type].map(function(f) {
                            return f()
                        }) || _emptyArray
                    },
                    _savedStyles = [],
                    _revertRecorded = function _revertRecorded(media) {
                        for (var i = 0; i < _savedStyles.length; i += 5) {
                            if (!media || _savedStyles[i + 4] && _savedStyles[i + 4].query === media) {
                                _savedStyles[i].style.cssText = _savedStyles[i + 1];
                                _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
                                _savedStyles[i + 3].uncache = 1
                            }
                        }
                    },
                    _revertAll = function _revertAll(kill, media) {
                        var trigger;
                        for (_i = 0; _i < _triggers.length; _i++) {
                            trigger = _triggers[_i];
                            if (trigger && (!media || trigger._ctx === media)) {
                                if (kill) {
                                    trigger.kill(1)
                                } else {
                                    trigger.revert(!0, !0)
                                }
                            }
                        }
                        _isReverted = !0;
                        media && _revertRecorded(media);
                        media || _dispatch("revert")
                    },
                    _clearScrollMemory = function _clearScrollMemory(scrollRestoration, force) {
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                        (force || !_refreshingAll) && _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {
                            return _isFunction(obj) && obj.cacheID++ && (obj.rec = 0)
                        });
                        _isString(scrollRestoration) && (_win.history.scrollRestoration = _scrollRestoration = scrollRestoration)
                    },
                    _refreshingAll, _refreshID = 0,
                    _queueRefreshID, _queueRefreshAll = function _queueRefreshAll() {
                        if (_queueRefreshID !== _refreshID) {
                            var id = _queueRefreshID = _refreshID;
                            requestAnimationFrame(function() {
                                return id === _refreshID && _refreshAll(!0)
                            })
                        }
                    },
                    _refresh100vh = function _refresh100vh() {
                        _body.appendChild(_div100vh);
                        _100vh = !_normalizer && _div100vh.offsetHeight || _win.innerHeight;
                        _body.removeChild(_div100vh)
                    },
                    _hideAllMarkers = function _hideAllMarkers(hide) {
                        return _toArray(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(el) {
                            return el.style.display = hide ? "none" : "block"
                        })
                    },
                    _refreshAll = function _refreshAll(force, skipRevert) {
                        if (_lastScrollTime && !force && !_isReverted) {
                            _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
                            return
                        }
                        _refresh100vh();
                        _refreshingAll = ScrollTrigger.isRefreshing = !0;
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {
                            return _isFunction(obj) && ++obj.cacheID && (obj.rec = obj())
                        });
                        var refreshInits = _dispatch("refreshInit");
                        _sort && ScrollTrigger.sort();
                        skipRevert || _revertAll();
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {
                            if (_isFunction(obj)) {
                                obj.smooth && (obj.target.style.scrollBehavior = "auto");
                                obj(0)
                            }
                        });
                        _triggers.slice(0).forEach(function(t) {
                            return t.refresh()
                        });
                        _isReverted = !1;
                        _triggers.forEach(function(t) {
                            if (t._subPinOffset && t.pin) {
                                var prop = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                                    original = t.pin[prop];
                                t.revert(!0, 1);
                                t.adjustPinSpacing(t.pin[prop] - original);
                                t.refresh()
                            }
                        });
                        _clampingMax = 1;
                        _hideAllMarkers(!0);
                        _triggers.forEach(function(t) {
                            var max = _maxScroll(t.scroller, t._dir),
                                endClamp = t.vars.end === "max" || t._endClamp && t.end > max,
                                startClamp = t._startClamp && t.start >= max;
                            (endClamp || startClamp) && t.setPositions(startClamp ? max - 1 : t.start, endClamp ? Math.max(startClamp ? max : t.start + 1, max) : t.end, !0)
                        });
                        _hideAllMarkers(!1);
                        _clampingMax = 0;
                        refreshInits.forEach(function(result) {
                            return result && result.render && result.render(-1)
                        });
                        _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(obj) {
                            if (_isFunction(obj)) {
                                obj.smooth && requestAnimationFrame(function() {
                                    return obj.target.style.scrollBehavior = "smooth"
                                });
                                obj.rec && obj(obj.rec)
                            }
                        });
                        _clearScrollMemory(_scrollRestoration, 1);
                        _resizeDelay.pause();
                        _refreshID++;
                        _refreshingAll = 2;
                        _updateAll(2);
                        _triggers.forEach(function(t) {
                            return _isFunction(t.vars.onRefresh) && t.vars.onRefresh(t)
                        });
                        _refreshingAll = ScrollTrigger.isRefreshing = !1;
                        _dispatch("refresh")
                    },
                    _lastScroll = 0,
                    _direction = 1,
                    _primary, _updateAll = function _updateAll(force) {
                        if (force === 2 || !_refreshingAll && !_isReverted) {
                            ScrollTrigger.isUpdating = !0;
                            _primary && _primary.update(0);
                            var l = _triggers.length,
                                time = _getTime(),
                                recordVelocity = time - _time1 >= 50,
                                scroll = l && _triggers[0].scroll();
                            _direction = _lastScroll > scroll ? -1 : 1;
                            _refreshingAll || (_lastScroll = scroll);
                            if (recordVelocity) {
                                if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
                                    _lastScrollTime = 0;
                                    _dispatch("scrollEnd")
                                }
                                _time2 = _time1;
                                _time1 = time
                            }
                            if (_direction < 0) {
                                _i = l;
                                while (_i-- > 0) {
                                    _triggers[_i] && _triggers[_i].update(0, recordVelocity)
                                }
                                _direction = 1
                            } else {
                                for (_i = 0; _i < l; _i++) {
                                    _triggers[_i] && _triggers[_i].update(0, recordVelocity)
                                }
                            }
                            ScrollTrigger.isUpdating = !1
                        }
                        _rafID = 0
                    },
                    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
                    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
                    _swapPinOut = function _swapPinOut(pin, spacer, state) {
                        _setState(state);
                        var cache = pin._gsap;
                        if (cache.spacerIsNative) {
                            _setState(cache.spacerState)
                        } else if (pin._gsap.swappedIn) {
                            var parent = spacer.parentNode;
                            if (parent) {
                                parent.insertBefore(pin, spacer);
                                parent.removeChild(spacer)
                            }
                        }
                        pin._gsap.swappedIn = !1
                    },
                    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
                        if (!pin._gsap.swappedIn) {
                            var i = _propNamesToCopy.length,
                                spacerStyle = spacer.style,
                                pinStyle = pin.style,
                                p;
                            while (i--) {
                                p = _propNamesToCopy[i];
                                spacerStyle[p] = cs[p]
                            }
                            spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
                            cs.display === "inline" && (spacerStyle.display = "inline-block");
                            pinStyle[_bottom] = pinStyle[_right] = "auto";
                            spacerStyle.flexBasis = cs.flexBasis || "auto";
                            spacerStyle.overflow = "visible";
                            spacerStyle.boxSizing = "border-box";
                            spacerStyle[_width] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal) + _px;
                            spacerStyle[_height] = _getSize(pin, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical) + _px;
                            spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";
                            _setState(spacerState);
                            pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
                            pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
                            pinStyle[_padding] = cs[_padding];
                            if (pin.parentNode !== spacer) {
                                pin.parentNode.insertBefore(spacer, pin);
                                spacer.appendChild(pin)
                            }
                            pin._gsap.swappedIn = !0
                        }
                    },
                    _capsExp = /([A-Z])/g,
                    _setState = function _setState(state) {
                        if (state) {
                            var style = state.t.style,
                                l = state.length,
                                i = 0,
                                p, value;
                            (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1;
                            for (; i < l; i += 2) {
                                value = state[i + 1];
                                p = state[i];
                                if (value) {
                                    style[p] = value
                                } else if (style[p]) {
                                    style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase())
                                }
                            }
                        }
                    },
                    _getState = function _getState(element) {
                        var l = _stateProps.length,
                            style = element.style,
                            state = [],
                            i = 0;
                        for (; i < l; i++) {
                            state.push(_stateProps[i], style[_stateProps[i]])
                        }
                        state.t = element;
                        return state
                    },
                    _copyState = function _copyState(state, override, omitOffsets) {
                        var result = [],
                            l = state.length,
                            i = omitOffsets ? 8 : 0,
                            p;
                        for (; i < l; i += 2) {
                            p = state[i];
                            result.push(p, p in override ? override[p] : state[i + 1])
                        }
                        result.t = state.t;
                        return result
                    },
                    _winOffsets = {
                        left: 0,
                        top: 0
                    },
                    _parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation, clampZeroProp) {
                        _isFunction(value) && (value = value(self));
                        if (_isString(value) && value.substr(0, 3) === "max") {
                            value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0)
                        }
                        var time = containerAnimation ? containerAnimation.time() : 0,
                            p1, p2, element;
                        containerAnimation && containerAnimation.seek(0);
                        isNaN(value) || (value = +value);
                        if (!_isNumber(value)) {
                            _isFunction(trigger) && (trigger = trigger(self));
                            var offsets = (value || "0").split(" "),
                                bounds, localOffset, globalOffset, display;
                            element = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger, self) || _body;
                            bounds = _getBounds(element) || {};
                            if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
                                display = element.style.display;
                                element.style.display = "block";
                                bounds = _getBounds(element);
                                display ? element.style.display = display : element.style.removeProperty("display")
                            }
                            localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
                            globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
                            value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
                            markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
                            scrollerSize -= scrollerSize - globalOffset
                        } else {
                            containerAnimation && (value = gsap.utils.mapRange(containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, 0, scrollerMax, value));
                            markerScroller && _positionMarker(markerScroller, scrollerSize, direction, !0)
                        }
                        if (clampZeroProp) {
                            self[clampZeroProp] = value || -0.001;
                            value < 0 && (value = 0)
                        }
                        if (marker) {
                            var position = value + scrollerSize,
                                isStart = marker._isStart;
                            p1 = "scroll" + direction.d2;
                            _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);
                            if (useFixedPosition) {
                                scrollerBounds = _getBounds(markerScroller);
                                useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px)
                            }
                        }
                        if (containerAnimation && element) {
                            p1 = _getBounds(element);
                            containerAnimation.seek(scrollerMax);
                            p2 = _getBounds(element);
                            containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
                            value = value / containerAnimation._caScrollDist * scrollerMax
                        }
                        containerAnimation && containerAnimation.seek(time);
                        return containerAnimation ? value : Math.round(value)
                    },
                    _prefixExp = /(webkit|moz|length|cssText|inset)/i,
                    _reparent = function _reparent(element, parent, top, left) {
                        if (element.parentNode !== parent) {
                            var style = element.style,
                                p, cs;
                            if (parent === _body) {
                                element._stOrig = style.cssText;
                                cs = _getComputedStyle(element);
                                for (p in cs) {
                                    if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
                                        style[p] = cs[p]
                                    }
                                }
                                style.top = top;
                                style.left = left
                            } else {
                                style.cssText = element._stOrig
                            }
                            gsap.core.getCache(element).uncache = 1;
                            parent.appendChild(element)
                        }
                    },
                    _interruptionTracker = function _interruptionTracker(getValueFunc, initialValue, onInterrupt) {
                        var last1 = initialValue,
                            last2 = last1;
                        return function(value) {
                            var current = Math.round(getValueFunc());
                            if (current !== last1 && current !== last2 && Math.abs(current - last1) > 3 && Math.abs(current - last2) > 3) {
                                value = current;
                                onInterrupt && onInterrupt()
                            }
                            last2 = last1;
                            last1 = value;
                            return value
                        }
                    },
                    _shiftMarker = function _shiftMarker(marker, direction, value) {
                        var vars = {};
                        vars[direction.p] = "+=" + value;
                        gsap.set(marker, vars)
                    },
                    _getTweenCreator = function _getTweenCreator(scroller, direction) {
                        var getScroll = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),
                            prop = "_scroll" + direction.p2,
                            getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
                                var tween = getTween.tween,
                                    onComplete = vars.onComplete,
                                    modifiers = {};
                                initialValue = initialValue || getScroll();
                                var checkForInterruption = _interruptionTracker(getScroll, initialValue, function() {
                                    tween.kill();
                                    getTween.tween = 0
                                });
                                change2 = change1 && change2 || 0;
                                change1 = change1 || scrollTo - initialValue;
                                tween && tween.kill();
                                vars[prop] = scrollTo;
                                vars.inherit = !1;
                                vars.modifiers = modifiers;
                                modifiers[prop] = function() {
                                    return checkForInterruption(initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio)
                                };
                                vars.onUpdate = function() {
                                    _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                                    getTween.tween && _updateAll()
                                };
                                vars.onComplete = function() {
                                    getTween.tween = 0;
                                    onComplete && onComplete.call(tween)
                                };
                                tween = getTween.tween = gsap.to(scroller, vars);
                                return tween
                            };
                        scroller[prop] = getScroll;
                        getScroll.wheelHandler = function() {
                            return getTween.tween && getTween.tween.kill() && (getTween.tween = 0)
                        };
                        _addListener(scroller, "wheel", getScroll.wheelHandler);
                        ScrollTrigger.isTouch && _addListener(scroller, "touchmove", getScroll.wheelHandler);
                        return getTween
                    };
                var ScrollTrigger = function() {
                    function ScrollTrigger(vars, animation) {
                        _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
                        _context(this);
                        this.init(vars, animation)
                    }
                    var _proto = ScrollTrigger.prototype;
                    _proto.init = function init(vars, animation) {
                        this.progress = this.start = 0;
                        this.vars && this.kill(!0, !0);
                        if (!_enabled) {
                            this.update = this.refresh = this.kill = _passThrough;
                            return
                        }
                        vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
                            trigger: vars
                        } : vars, _defaults);
                        var _vars = vars,
                            onUpdate = _vars.onUpdate,
                            toggleClass = _vars.toggleClass,
                            id = _vars.id,
                            onToggle = _vars.onToggle,
                            onRefresh = _vars.onRefresh,
                            scrub = _vars.scrub,
                            trigger = _vars.trigger,
                            pin = _vars.pin,
                            pinSpacing = _vars.pinSpacing,
                            invalidateOnRefresh = _vars.invalidateOnRefresh,
                            anticipatePin = _vars.anticipatePin,
                            onScrubComplete = _vars.onScrubComplete,
                            onSnapComplete = _vars.onSnapComplete,
                            once = _vars.once,
                            snap = _vars.snap,
                            pinReparent = _vars.pinReparent,
                            pinSpacer = _vars.pinSpacer,
                            containerAnimation = _vars.containerAnimation,
                            fastScrollEnd = _vars.fastScrollEnd,
                            preventOverlaps = _vars.preventOverlaps,
                            direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== !1 ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical,
                            isToggle = !scrub && scrub !== 0,
                            scroller = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.scroller || _win),
                            scrollerCache = gsap.core.getCache(scroller),
                            isViewport = _isViewport(scroller),
                            useFixedPosition = ("pinType" in vars ? vars.pinType : (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "pinType") || isViewport && "fixed") === "fixed",
                            callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
                            toggleActions = isToggle && vars.toggleActions.split(" "),
                            markers = "markers" in vars ? vars.markers : _defaults.markers,
                            borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
                            self = this,
                            onRefreshInit = vars.onRefreshInit && function() {
                                return vars.onRefreshInit(self)
                            },
                            getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
                            getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
                            lastSnap = 0,
                            lastRefresh = 0,
                            prevProgress = 0,
                            scrollFunc = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, direction),
                            tweenTo, pinCache, snapFunc, scroll1, scroll2, start, end, markerStart, markerEnd, markerStartTrigger, markerEndTrigger, markerVars, executingOnRefresh, change, pinOriginalState, pinActiveState, pinState, spacer, offset, pinGetter, pinSetter, pinStart, pinChange, spacingStart, spacerState, markerStartSetter, pinMoves, markerEndSetter, cs, snap1, snap2, scrubTween, scrubSmooth, snapDurClamp, snapDelayedCall, prevScroll, prevAnimProgress, caMarkerSetter, customRevertReturn;
                        self._startClamp = self._endClamp = !1;
                        self._dir = direction;
                        anticipatePin *= 45;
                        self.scroller = scroller;
                        self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
                        scroll1 = scrollFunc();
                        self.vars = vars;
                        animation = animation || vars.animation;
                        if ("refreshPriority" in vars) {
                            _sort = 1;
                            vars.refreshPriority === -9999 && (_primary = self)
                        }
                        scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
                            top: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),
                            left: _getTweenCreator(scroller, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)
                        };
                        self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];
                        self.scrubDuration = function(value) {
                            scrubSmooth = _isNumber(value) && value;
                            if (!scrubSmooth) {
                                scrubTween && scrubTween.progress(1).kill();
                                scrubTween = 0
                            } else {
                                scrubTween ? scrubTween.duration(value) : scrubTween = gsap.to(animation, {
                                    ease: "expo",
                                    totalProgress: "+=0",
                                    inherit: !1,
                                    duration: scrubSmooth,
                                    paused: !0,
                                    onComplete: function onComplete() {
                                        return onScrubComplete && onScrubComplete(self)
                                    }
                                })
                            }
                        };
                        if (animation) {
                            animation.vars.lazy = !1;
                            animation._initted && !self.isReverted || animation.vars.immediateRender !== !1 && vars.immediateRender !== !1 && animation.duration() && animation.render(0, !0, !0);
                            self.animation = animation.pause();
                            animation.scrollTrigger = self;
                            self.scrubDuration(scrub);
                            snap1 = 0;
                            id || (id = animation.vars.id)
                        }
                        if (snap) {
                            if (!_isObject(snap) || snap.push) {
                                snap = {
                                    snapTo: snap
                                }
                            }
                            "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
                                scrollBehavior: "auto"
                            });
                            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.forEach(function(o) {
                                return _isFunction(o) && o.target === (isViewport ? _doc.scrollingElement || _docEl : scroller) && (o.smooth = !1)
                            });
                            snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== !1 ? function(value, st) {
                                return _snapDirectional(snap.snapTo)(value, _getTime() - lastRefresh < 500 ? 0 : st.direction)
                            } : gsap.utils.snap(snap.snapTo);
                            snapDurClamp = snap.duration || {
                                min: 0.1,
                                max: 2
                            };
                            snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
                            snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function() {
                                var scroll = scrollFunc(),
                                    refreshedRecently = _getTime() - lastRefresh < 500,
                                    tween = tweenTo.tween;
                                if ((refreshedRecently || Math.abs(self.getVelocity()) < 10) && !tween && !_pointerIsDown && lastSnap !== scroll) {
                                    var progress = (scroll - start) / change,
                                        totalProgress = animation && !isToggle ? animation.totalProgress() : progress,
                                        velocity = refreshedRecently ? 0 : (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
                                        change1 = gsap.utils.clamp(-progress, 1 - progress, _abs(velocity / 2) * velocity / 0.185),
                                        naturalEnd = progress + (snap.inertia === !1 ? 0 : change1),
                                        endValue, endScroll, _snap = snap,
                                        onStart = _snap.onStart,
                                        _onInterrupt = _snap.onInterrupt,
                                        _onComplete = _snap.onComplete;
                                    endValue = snapFunc(naturalEnd, self);
                                    _isNumber(endValue) || (endValue = naturalEnd);
                                    endScroll = Math.round(start + endValue * change);
                                    if (scroll <= end && scroll >= start && endScroll !== scroll) {
                                        if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
                                            return
                                        }
                                        if (snap.inertia === !1) {
                                            change1 = endValue - progress
                                        }
                                        tweenTo(endScroll, {
                                            duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
                                            ease: snap.ease || "power3",
                                            data: _abs(endScroll - scroll),
                                            onInterrupt: function onInterrupt() {
                                                return snapDelayedCall.restart(!0) && _onInterrupt && _onInterrupt(self)
                                            },
                                            onComplete: function onComplete() {
                                                self.update();
                                                lastSnap = scrollFunc();
                                                if (animation) {
                                                    scrubTween ? scrubTween.resetTo("totalProgress", endValue, animation._tTime / animation._tDur) : animation.progress(endValue)
                                                }
                                                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                                                onSnapComplete && onSnapComplete(self);
                                                _onComplete && _onComplete(self)
                                            }
                                        }, scroll, change1 * change, endScroll - scroll - change1 * change);
                                        onStart && onStart(self, tweenTo.tween)
                                    }
                                } else if (self.isActive && lastSnap !== scroll) {
                                    snapDelayedCall.restart(!0)
                                }
                            }).pause()
                        }
                        id && (_ids[id] = self);
                        trigger = self.trigger = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(trigger || pin !== !0 && pin);
                        customRevertReturn = trigger && trigger._gsap && trigger._gsap.stRevert;
                        customRevertReturn && (customRevertReturn = customRevertReturn(self));
                        pin = pin === !0 ? trigger : (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pin);
                        _isString(toggleClass) && (toggleClass = {
                            targets: trigger,
                            className: toggleClass
                        });
                        if (pin) {
                            pinSpacing === !1 || pinSpacing === _margin || (pinSpacing = !pinSpacing && pin.parentNode && pin.parentNode.style && _getComputedStyle(pin.parentNode).display === "flex" ? !1 : _padding);
                            self.pin = pin;
                            pinCache = gsap.core.getCache(pin);
                            if (!pinCache.spacer) {
                                if (pinSpacer) {
                                    pinSpacer = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(pinSpacer);
                                    pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement);
                                    pinCache.spacerIsNative = !!pinSpacer;
                                    pinSpacer && (pinCache.spacerState = _getState(pinSpacer))
                                }
                                pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
                                spacer.classList.add("pin-spacer");
                                id && spacer.classList.add("pin-spacer-" + id);
                                pinCache.pinState = pinOriginalState = _getState(pin)
                            } else {
                                pinOriginalState = pinCache.pinState
                            }
                            vars.force3D !== !1 && gsap.set(pin, {
                                force3D: !0
                            });
                            self.spacer = spacer = pinCache.spacer;
                            cs = _getComputedStyle(pin);
                            spacingStart = cs[pinSpacing + direction.os2];
                            pinGetter = gsap.getProperty(pin);
                            pinSetter = gsap.quickSetter(pin, direction.a, _px);
                            _swapPinIn(pin, spacer, cs);
                            pinState = _getState(pin)
                        }
                        if (markers) {
                            markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
                            markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
                            markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
                            offset = markerStartTrigger["offset" + direction.op.d2];
                            var content = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)((0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "content") || scroller);
                            markerStart = this.markerStart = _createMarker("start", id, content, direction, markerVars, offset, 0, containerAnimation);
                            markerEnd = this.markerEnd = _createMarker("end", id, content, direction, markerVars, offset, 0, containerAnimation);
                            containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));
                            if (!useFixedPosition && !(_Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.length && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getProxyProp)(scroller, "fixedMarkers") === !0)) {
                                _makePositionable(isViewport ? _body : scroller);
                                gsap.set([markerStartTrigger, markerEndTrigger], {
                                    force3D: !0
                                });
                                markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
                                markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px)
                            }
                        }
                        if (containerAnimation) {
                            var oldOnUpdate = containerAnimation.vars.onUpdate,
                                oldParams = containerAnimation.vars.onUpdateParams;
                            containerAnimation.eventCallback("onUpdate", function() {
                                self.update(0, 0, 1);
                                oldOnUpdate && oldOnUpdate.apply(containerAnimation, oldParams || [])
                            })
                        }
                        self.previous = function() {
                            return _triggers[_triggers.indexOf(self) - 1]
                        };
                        self.next = function() {
                            return _triggers[_triggers.indexOf(self) + 1]
                        };
                        self.revert = function(revert, temp) {
                            if (!temp) {
                                return self.kill(!0)
                            }
                            var r = revert !== !1 || !self.enabled,
                                prevRefreshing = _refreshing;
                            if (r !== self.isReverted) {
                                if (r) {
                                    prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0);
                                    prevProgress = self.progress;
                                    prevAnimProgress = animation && animation.progress()
                                }
                                markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                                    return m.style.display = r ? "none" : "block"
                                });
                                if (r) {
                                    _refreshing = self;
                                    self.update(r)
                                }
                                if (pin && (!pinReparent || !self.isActive)) {
                                    if (r) {
                                        _swapPinOut(pin, spacer, pinOriginalState)
                                    } else {
                                        _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState)
                                    }
                                }
                                r || self.update(r);
                                _refreshing = prevRefreshing;
                                self.isReverted = r
                            }
                        };
                        self.refresh = function(soft, force, position, pinOffset) {
                            if ((_refreshing || !self.enabled) && !force) {
                                return
                            }
                            if (pin && soft && _lastScrollTime) {
                                _addListener(ScrollTrigger, "scrollEnd", _softRefresh);
                                return
                            }!_refreshingAll && onRefreshInit && onRefreshInit(self);
                            _refreshing = self;
                            if (tweenTo.tween && !position) {
                                tweenTo.tween.kill();
                                tweenTo.tween = 0
                            }
                            scrubTween && scrubTween.pause();
                            invalidateOnRefresh && animation && animation.revert({
                                kill: !1
                            }).invalidate();
                            self.isReverted || self.revert(!0, !0);
                            self._subPinOffset = !1;
                            var size = getScrollerSize(),
                                scrollerBounds = getScrollerOffsets(),
                                max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
                                isFirstRefresh = change <= 0.01,
                                offset = 0,
                                otherPinOffset = pinOffset || 0,
                                parsedEnd = _isObject(position) ? position.end : vars.end,
                                parsedEndTrigger = vars.endTrigger || trigger,
                                parsedStart = _isObject(position) ? position.start : vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
                                pinnedContainer = self.pinnedContainer = vars.pinnedContainer && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.pinnedContainer, self),
                                triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
                                i = triggerIndex,
                                cs, bounds, scroll, isVertical, override, curTrigger, curPin, oppositeScroll, initted, revertedPins, forcedOverflow, markerStartOffset, markerEndOffset;
                            if (markers && _isObject(position)) {
                                markerStartOffset = gsap.getProperty(markerStartTrigger, direction.p);
                                markerEndOffset = gsap.getProperty(markerEndTrigger, direction.p)
                            }
                            while (i--) {
                                curTrigger = _triggers[i];
                                curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = self);
                                curPin = curTrigger.pin;
                                if (curPin && (curPin === trigger || curPin === pin || curPin === pinnedContainer) && !curTrigger.isReverted) {
                                    revertedPins || (revertedPins = []);
                                    revertedPins.unshift(curTrigger);
                                    curTrigger.revert(!0, !0)
                                }
                                if (curTrigger !== _triggers[i]) {
                                    triggerIndex--;
                                    i--
                                }
                            }
                            _isFunction(parsedStart) && (parsedStart = parsedStart(self));
                            parsedStart = _parseClamp(parsedStart, "start", self);
                            start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._startClamp && "_startClamp") || (pin ? -0.001 : 0);
                            _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));
                            if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
                                if (~parsedEnd.indexOf(" ")) {
                                    parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd
                                } else {
                                    offset = _offsetToPx(parsedEnd.substr(2), size);
                                    parsedEnd = _isString(parsedStart) ? parsedStart : (containerAnimation ? gsap.utils.mapRange(0, containerAnimation.duration(), containerAnimation.scrollTrigger.start, containerAnimation.scrollTrigger.end, start) : start) + offset;
                                    parsedEndTrigger = trigger
                                }
                            }
                            parsedEnd = _parseClamp(parsedEnd, "end", self);
                            end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation, self._endClamp && "_endClamp")) || -0.001;
                            offset = 0;
                            i = triggerIndex;
                            while (i--) {
                                curTrigger = _triggers[i];
                                curPin = curTrigger.pin;
                                if (curPin && curTrigger.start - curTrigger._pinPush <= start && !containerAnimation && curTrigger.end > 0) {
                                    cs = curTrigger.end - (self._startClamp ? Math.max(0, curTrigger.start) : curTrigger.start);
                                    if ((curPin === trigger && curTrigger.start - curTrigger._pinPush < start || curPin === pinnedContainer) && isNaN(parsedStart)) {
                                        offset += cs * (1 - curTrigger.progress)
                                    }
                                    curPin === pin && (otherPinOffset += cs)
                                }
                            }
                            start += offset;
                            end += offset;
                            self._startClamp && (self._startClamp += offset);
                            if (self._endClamp && !_refreshingAll) {
                                self._endClamp = end || -0.001;
                                end = Math.min(end, _maxScroll(scroller, direction))
                            }
                            change = end - start || (start -= 0.01) && 0.001;
                            if (isFirstRefresh) {
                                prevProgress = gsap.utils.clamp(0, 1, gsap.utils.normalize(start, end, prevScroll))
                            }
                            self._pinPush = otherPinOffset;
                            if (markerStart && offset) {
                                cs = {};
                                cs[direction.a] = "+=" + offset;
                                pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
                                gsap.set([markerStart, markerEnd], cs)
                            }
                            if (pin && !(_clampingMax && self.end >= _maxScroll(scroller, direction))) {
                                cs = _getComputedStyle(pin);
                                isVertical = direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical;
                                scroll = scrollFunc();
                                pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
                                if (!max && end > 1) {
                                    forcedOverflow = (isViewport ? _doc.scrollingElement || _docEl : scroller).style;
                                    forcedOverflow = {
                                        style: forcedOverflow,
                                        value: forcedOverflow["overflow" + direction.a.toUpperCase()]
                                    };
                                    if (isViewport && _getComputedStyle(_body)["overflow" + direction.a.toUpperCase()] !== "scroll") {
                                        forcedOverflow.style["overflow" + direction.a.toUpperCase()] = "scroll"
                                    }
                                }
                                _swapPinIn(pin, spacer, cs);
                                pinState = _getState(pin);
                                bounds = _getBounds(pin, !0);
                                oppositeScroll = useFixedPosition && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(scroller, isVertical ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)();
                                if (pinSpacing) {
                                    spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
                                    spacerState.t = spacer;
                                    i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
                                    if (i) {
                                        spacerState.push(direction.d, i + _px);
                                        spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px)
                                    }
                                    _setState(spacerState);
                                    if (pinnedContainer) {
                                        _triggers.forEach(function(t) {
                                            if (t.pin === pinnedContainer && t.vars.pinSpacing !== !1) {
                                                t._subPinOffset = !0
                                            }
                                        })
                                    }
                                    useFixedPosition && scrollFunc(prevScroll)
                                } else {
                                    i = _getSize(pin, direction);
                                    i && spacer.style.flexBasis !== "auto" && (spacer.style.flexBasis = i + _px)
                                }
                                if (useFixedPosition) {
                                    override = {
                                        top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
                                        left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
                                        boxSizing: "border-box",
                                        position: "fixed"
                                    };
                                    override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
                                    override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
                                    override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
                                    override[_padding] = cs[_padding];
                                    override[_padding + _Top] = cs[_padding + _Top];
                                    override[_padding + _Right] = cs[_padding + _Right];
                                    override[_padding + _Bottom] = cs[_padding + _Bottom];
                                    override[_padding + _Left] = cs[_padding + _Left];
                                    pinActiveState = _copyState(pinOriginalState, override, pinReparent);
                                    _refreshingAll && scrollFunc(0)
                                }
                                if (animation) {
                                    initted = animation._initted;
                                    _suppressOverwrites(1);
                                    animation.render(animation.duration(), !0, !0);
                                    pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
                                    pinMoves = Math.abs(change - pinChange) > 1;
                                    useFixedPosition && pinMoves && pinActiveState.splice(pinActiveState.length - 2, 2);
                                    animation.render(0, !0, !0);
                                    initted || animation.invalidate(!0);
                                    animation.parent || animation.totalTime(animation.totalTime());
                                    _suppressOverwrites(0)
                                } else {
                                    pinChange = change
                                }
                                forcedOverflow && (forcedOverflow.value ? forcedOverflow.style["overflow" + direction.a.toUpperCase()] = forcedOverflow.value : forcedOverflow.style.removeProperty("overflow-" + direction.a))
                            } else if (trigger && scrollFunc() && !containerAnimation) {
                                bounds = trigger.parentNode;
                                while (bounds && bounds !== _body) {
                                    if (bounds._pinOffset) {
                                        start -= bounds._pinOffset;
                                        end -= bounds._pinOffset
                                    }
                                    bounds = bounds.parentNode
                                }
                            }
                            revertedPins && revertedPins.forEach(function(t) {
                                return t.revert(!1, !0)
                            });
                            self.start = start;
                            self.end = end;
                            scroll1 = scroll2 = _refreshingAll ? prevScroll : scrollFunc();
                            if (!containerAnimation && !_refreshingAll) {
                                scroll1 < prevScroll && scrollFunc(prevScroll);
                                self.scroll.rec = 0
                            }
                            self.revert(!1, !0);
                            lastRefresh = _getTime();
                            if (snapDelayedCall) {
                                lastSnap = -1;
                                snapDelayedCall.restart(!0)
                            }
                            _refreshing = 0;
                            animation && isToggle && (animation._initted || prevAnimProgress) && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress || 0, !0).render(animation.time(), !0, !0);
                            if (isFirstRefresh || prevProgress !== self.progress || containerAnimation || invalidateOnRefresh) {
                                animation && !isToggle && animation.totalProgress(containerAnimation && start < -0.001 && !prevProgress ? gsap.utils.normalize(start, end, 0) : prevProgress, !0);
                                self.progress = isFirstRefresh || (scroll1 - start) / change === prevProgress ? 0 : prevProgress
                            }
                            pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
                            scrubTween && scrubTween.invalidate();
                            if (!isNaN(markerStartOffset)) {
                                markerStartOffset -= gsap.getProperty(markerStartTrigger, direction.p);
                                markerEndOffset -= gsap.getProperty(markerEndTrigger, direction.p);
                                _shiftMarker(markerStartTrigger, direction, markerStartOffset);
                                _shiftMarker(markerStart, direction, markerStartOffset - (pinOffset || 0));
                                _shiftMarker(markerEndTrigger, direction, markerEndOffset);
                                _shiftMarker(markerEnd, direction, markerEndOffset - (pinOffset || 0))
                            }
                            isFirstRefresh && !_refreshingAll && self.update();
                            if (onRefresh && !_refreshingAll && !executingOnRefresh) {
                                executingOnRefresh = !0;
                                onRefresh(self);
                                executingOnRefresh = !1
                            }
                        };
                        self.getVelocity = function() {
                            return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0
                        };
                        self.endAnimation = function() {
                            _endAnimation(self.callbackAnimation);
                            if (animation) {
                                scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1)
                            }
                        };
                        self.labelToScroll = function(label) {
                            return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0
                        };
                        self.getTrailing = function(name) {
                            var i = _triggers.indexOf(self),
                                a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);
                            return (_isString(name) ? a.filter(function(t) {
                                return t.vars.preventOverlaps === name
                            }) : a).filter(function(t) {
                                return self.direction > 0 ? t.end <= start : t.start >= end
                            })
                        };
                        self.update = function(reset, recordVelocity, forceFake) {
                            if (containerAnimation && !forceFake && !reset) {
                                return
                            }
                            var scroll = _refreshingAll === !0 ? prevScroll : self.scroll(),
                                p = reset ? 0 : (scroll - start) / change,
                                clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
                                prevProgress = self.progress,
                                isActive, wasActive, toggleState, action, stateChanged, toggled, isAtMax, isTakingAction;
                            if (recordVelocity) {
                                scroll2 = scroll1;
                                scroll1 = containerAnimation ? scrollFunc() : scroll;
                                if (snap) {
                                    snap2 = snap1;
                                    snap1 = animation && !isToggle ? animation.totalProgress() : clipped
                                }
                            }
                            if (anticipatePin && pin && !_refreshing && !_startup && _lastScrollTime) {
                                if (!clipped && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
                                    clipped = 0.0001
                                } else if (clipped === 1 && end > scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin) {
                                    clipped = 0.9999
                                }
                            }
                            if (clipped !== prevProgress && self.enabled) {
                                isActive = self.isActive = !!clipped && clipped < 1;
                                wasActive = !!prevProgress && prevProgress < 1;
                                toggled = isActive !== wasActive;
                                stateChanged = toggled || !!clipped !== !!prevProgress;
                                self.direction = clipped > prevProgress ? 1 : -1;
                                self.progress = clipped;
                                if (stateChanged && !_refreshing) {
                                    toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3;
                                    if (isToggle) {
                                        action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState];
                                        isTakingAction = animation && (action === "complete" || action === "reset" || action in animation)
                                    }
                                }
                                preventOverlaps && (toggled || isTakingAction) && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function(t) {
                                    return t.endAnimation()
                                }));
                                if (!isToggle) {
                                    if (scrubTween && !_refreshing && !_startup) {
                                        scrubTween._dp._time - scrubTween._start !== scrubTween._time && scrubTween.render(scrubTween._dp._time - scrubTween._start);
                                        if (scrubTween.resetTo) {
                                            scrubTween.resetTo("totalProgress", clipped, animation._tTime / animation._tDur)
                                        } else {
                                            scrubTween.vars.totalProgress = clipped;
                                            scrubTween.invalidate().restart()
                                        }
                                    } else if (animation) {
                                        animation.totalProgress(clipped, !!(_refreshing && (lastRefresh || reset)))
                                    }
                                }
                                if (pin) {
                                    reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);
                                    if (!useFixedPosition) {
                                        pinSetter(_round(pinStart + pinChange * clipped))
                                    } else if (stateChanged) {
                                        isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction);
                                        if (pinReparent) {
                                            if (!reset && (isActive || isAtMax)) {
                                                var bounds = _getBounds(pin, !0),
                                                    _offset = scroll - start;
                                                _reparent(pin, _body, bounds.top + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? _offset : 0) + _px, bounds.left + (direction === _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical ? 0 : _offset) + _px)
                                            } else {
                                                _reparent(pin, spacer)
                                            }
                                        }
                                        _setState(isActive || isAtMax ? pinActiveState : pinState);
                                        pinMoves && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0))
                                    }
                                }
                                snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(!0);
                                toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function(el) {
                                    return el.classList[isActive || once ? "add" : "remove"](toggleClass.className)
                                });
                                onUpdate && !isToggle && !reset && onUpdate(self);
                                if (stateChanged && !_refreshing) {
                                    if (isToggle) {
                                        if (isTakingAction) {
                                            if (action === "complete") {
                                                animation.pause().totalProgress(1)
                                            } else if (action === "reset") {
                                                animation.restart(!0).pause()
                                            } else if (action === "restart") {
                                                animation.restart(!0)
                                            } else {
                                                animation[action]()
                                            }
                                        }
                                        onUpdate && onUpdate(self)
                                    }
                                    if (toggled || !_limitCallbacks) {
                                        onToggle && toggled && _callback(self, onToggle);
                                        callbacks[toggleState] && _callback(self, callbacks[toggleState]);
                                        once && (clipped === 1 ? self.kill(!1, 1) : callbacks[toggleState] = 0);
                                        if (!toggled) {
                                            toggleState = clipped === 1 ? 1 : 3;
                                            callbacks[toggleState] && _callback(self, callbacks[toggleState])
                                        }
                                    }
                                    if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
                                        _endAnimation(self.callbackAnimation);
                                        scrubTween ? scrubTween.progress(1) : _endAnimation(animation, action === "reverse" ? 1 : !clipped, 1)
                                    }
                                } else if (isToggle && onUpdate && !_refreshing) {
                                    onUpdate(self)
                                }
                            }
                            if (markerEndSetter) {
                                var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
                                markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
                                markerEndSetter(n)
                            }
                            caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0))
                        };
                        self.enable = function(reset, refresh) {
                            if (!self.enabled) {
                                self.enabled = !0;
                                _addListener(scroller, "resize", _onResize);
                                isViewport || _addListener(scroller, "scroll", _onScroll);
                                onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);
                                if (reset !== !1) {
                                    self.progress = prevProgress = 0;
                                    scroll1 = scroll2 = lastSnap = scrollFunc()
                                }
                                refresh !== !1 && self.refresh()
                            }
                        };
                        self.getTween = function(snap) {
                            return snap && tweenTo ? tweenTo.tween : scrubTween
                        };
                        self.setPositions = function(newStart, newEnd, keepClamp, pinOffset) {
                            if (containerAnimation) {
                                var st = containerAnimation.scrollTrigger,
                                    duration = containerAnimation.duration(),
                                    _change = st.end - st.start;
                                newStart = st.start + _change * newStart / duration;
                                newEnd = st.start + _change * newEnd / duration
                            }
                            self.refresh(!1, !1, {
                                start: _keepClamp(newStart, keepClamp && !!self._startClamp),
                                end: _keepClamp(newEnd, keepClamp && !!self._endClamp)
                            }, pinOffset);
                            self.update()
                        };
                        self.adjustPinSpacing = function(amount) {
                            if (spacerState && amount) {
                                var i = spacerState.indexOf(direction.d) + 1;
                                spacerState[i] = parseFloat(spacerState[i]) + amount + _px;
                                spacerState[1] = parseFloat(spacerState[1]) + amount + _px;
                                _setState(spacerState)
                            }
                        };
                        self.disable = function(reset, allowAnimation) {
                            if (self.enabled) {
                                reset !== !1 && self.revert(!0, !0);
                                self.enabled = self.isActive = !1;
                                allowAnimation || scrubTween && scrubTween.pause();
                                prevScroll = 0;
                                pinCache && (pinCache.uncache = 1);
                                onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);
                                if (snapDelayedCall) {
                                    snapDelayedCall.pause();
                                    tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0)
                                }
                                if (!isViewport) {
                                    var i = _triggers.length;
                                    while (i--) {
                                        if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
                                            return
                                        }
                                    }
                                    _removeListener(scroller, "resize", _onResize);
                                    isViewport || _removeListener(scroller, "scroll", _onScroll)
                                }
                            }
                        };
                        self.kill = function(revert, allowAnimation) {
                            self.disable(revert, allowAnimation);
                            scrubTween && !allowAnimation && scrubTween.kill();
                            id && delete _ids[id];
                            var i = _triggers.indexOf(self);
                            i >= 0 && _triggers.splice(i, 1);
                            i === _i && _direction > 0 && _i--;
                            i = 0;
                            _triggers.forEach(function(t) {
                                return t.scroller === self.scroller && (i = 1)
                            });
                            i || _refreshingAll || (self.scroll.rec = 0);
                            if (animation) {
                                animation.scrollTrigger = null;
                                revert && animation.revert({
                                    kill: !1
                                });
                                allowAnimation || animation.kill()
                            }
                            markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function(m) {
                                return m.parentNode && m.parentNode.removeChild(m)
                            });
                            _primary === self && (_primary = 0);
                            if (pin) {
                                pinCache && (pinCache.uncache = 1);
                                i = 0;
                                _triggers.forEach(function(t) {
                                    return t.pin === pin && i++
                                });
                                i || (pinCache.spacer = 0)
                            }
                            vars.onKill && vars.onKill(self)
                        };
                        _triggers.push(self);
                        self.enable(!1, !1);
                        customRevertReturn && customRevertReturn(self);
                        if (animation && animation.add && !change) {
                            var updateFunc = self.update;
                            self.update = function() {
                                self.update = updateFunc;
                                start || end || self.refresh()
                            };
                            gsap.delayedCall(0.01, self.update);
                            change = 0.01;
                            start = end = 0
                        } else {
                            self.refresh()
                        }
                        pin && _queueRefreshAll()
                    };
                    ScrollTrigger.register = function register(core) {
                        if (!_coreInitted) {
                            gsap = core || _getGSAP();
                            _windowExists() && window.document && ScrollTrigger.enable();
                            _coreInitted = _enabled
                        }
                        return _coreInitted
                    };
                    ScrollTrigger.defaults = function defaults(config) {
                        if (config) {
                            for (var p in config) {
                                _defaults[p] = config[p]
                            }
                        }
                        return _defaults
                    };
                    ScrollTrigger.disable = function disable(reset, kill) {
                        _enabled = 0;
                        _triggers.forEach(function(trigger) {
                            return trigger[kill ? "kill" : "disable"](reset)
                        });
                        _removeListener(_win, "wheel", _onScroll);
                        _removeListener(_doc, "scroll", _onScroll);
                        clearInterval(_syncInterval);
                        _removeListener(_doc, "touchcancel", _passThrough);
                        _removeListener(_body, "touchstart", _passThrough);
                        _multiListener(_removeListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                        _multiListener(_removeListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                        _resizeDelay.kill();
                        _iterateAutoRefresh(_removeListener);
                        for (var i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {
                            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);
                            _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2])
                        }
                    };
                    ScrollTrigger.enable = function enable() {
                        _win = window;
                        _doc = document;
                        _docEl = _doc.documentElement;
                        _body = _doc.body;
                        if (gsap) {
                            _toArray = gsap.utils.toArray;
                            _clamp = gsap.utils.clamp;
                            _context = gsap.core.context || _passThrough;
                            _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
                            _scrollRestoration = _win.history.scrollRestoration || "auto";
                            _lastScroll = _win.pageYOffset;
                            gsap.core.globals("ScrollTrigger", ScrollTrigger);
                            if (_body) {
                                _enabled = 1;
                                _div100vh = document.createElement("div");
                                _div100vh.style.height = "100vh";
                                _div100vh.style.position = "absolute";
                                _refresh100vh();
                                _rafBugFix();
                                _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.register(gsap);
                                ScrollTrigger.isTouch = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch;
                                _fixIOSBug = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent);
                                _ignoreMobileResize = _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch === 1;
                                _addListener(_win, "wheel", _onScroll);
                                _root = [_win, _doc, _docEl, _body];
                                if (gsap.matchMedia) {
                                    ScrollTrigger.matchMedia = function(vars) {
                                        var mm = gsap.matchMedia(),
                                            p;
                                        for (p in vars) {
                                            mm.add(p, vars[p])
                                        }
                                        return mm
                                    };
                                    gsap.addEventListener("matchMediaInit", function() {
                                        return _revertAll()
                                    });
                                    gsap.addEventListener("matchMediaRevert", function() {
                                        return _revertRecorded()
                                    });
                                    gsap.addEventListener("matchMedia", function() {
                                        _refreshAll(0, 1);
                                        _dispatch("matchMedia")
                                    });
                                    gsap.matchMedia("(orientation: portrait)", function() {
                                        _setBaseDimensions();
                                        return _setBaseDimensions
                                    })
                                } else {
                                    console.warn("Requires GSAP 3.11.0 or later")
                                }
                                _setBaseDimensions();
                                _addListener(_doc, "scroll", _onScroll);
                                var bodyStyle = _body.style,
                                    border = bodyStyle.borderTopStyle,
                                    AnimationProto = gsap.core.Animation.prototype,
                                    bounds, i;
                                AnimationProto.revert || Object.defineProperty(AnimationProto, "revert", {
                                    value: function value() {
                                        return this.time(-0.01, !0)
                                    }
                                });
                                bodyStyle.borderTopStyle = "solid";
                                bounds = _getBounds(_body);
                                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.m = Math.round(bounds.top + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical.sc()) || 0;
                                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.m = Math.round(bounds.left + _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal.sc()) || 0;
                                border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
                                _syncInterval = setInterval(_sync, 250);
                                gsap.delayedCall(0.5, function() {
                                    return _startup = 0
                                });
                                _addListener(_doc, "touchcancel", _passThrough);
                                _addListener(_body, "touchstart", _passThrough);
                                _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", _pointerDownHandler);
                                _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", _pointerUpHandler);
                                _transformProp = gsap.utils.checkPrefix("transform");
                                _stateProps.push(_transformProp);
                                _coreInitted = _getTime();
                                _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
                                _autoRefresh = [_doc, "visibilitychange", function() {
                                    var w = _win.innerWidth,
                                        h = _win.innerHeight;
                                    if (_doc.hidden) {
                                        _prevWidth = w;
                                        _prevHeight = h
                                    } else if (_prevWidth !== w || _prevHeight !== h) {
                                        _onResize()
                                    }
                                }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", _refreshAll, _win, "resize", _onResize];
                                _iterateAutoRefresh(_addListener);
                                _triggers.forEach(function(trigger) {
                                    return trigger.enable(0, 1)
                                });
                                for (i = 0; i < _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.length; i += 3) {
                                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 1]);
                                    _wheelListener(_removeListener, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i], _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers[i + 2])
                                }
                            }
                        }
                    };
                    ScrollTrigger.config = function config(vars) {
                        "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
                        var ms = vars.syncInterval;
                        ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);
                        "ignoreMobileResize" in vars && (_ignoreMobileResize = ScrollTrigger.isTouch === 1 && vars.ignoreMobileResize);
                        if ("autoRefreshEvents" in vars) {
                            _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
                            _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1
                        }
                    };
                    ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
                        var t = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(target),
                            i = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.indexOf(t),
                            isViewport = _isViewport(t);
                        if (~i) {
                            _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.splice(i, isViewport ? 6 : 2)
                        }
                        if (vars) {
                            isViewport ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies.unshift(t, vars)
                        }
                    };
                    ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
                        _triggers.forEach(function(t) {
                            return t._ctx && t._ctx.query === query && t._ctx.kill(!0, !0)
                        })
                    };
                    ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
                        var bounds = (_isString(element) ? (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element) : element).getBoundingClientRect(),
                            offset = bounds[horizontal ? _width : _height] * ratio || 0;
                        return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight
                    };
                    ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
                        _isString(element) && (element = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element));
                        var bounds = element.getBoundingClientRect(),
                            size = bounds[horizontal ? _width : _height],
                            offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
                        return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight
                    };
                    ScrollTrigger.killAll = function killAll(allowListeners) {
                        _triggers.slice(0).forEach(function(t) {
                            return t.vars.id !== "ScrollSmoother" && t.kill()
                        });
                        if (allowListeners !== !0) {
                            var listeners = _listeners.killAll || [];
                            _listeners = {};
                            listeners.forEach(function(f) {
                                return f()
                            })
                        }
                    };
                    return ScrollTrigger
                }();
                ScrollTrigger.version = "3.12.5";
                ScrollTrigger.saveStyles = function(targets) {
                    return targets ? _toArray(targets).forEach(function(target) {
                        if (target && target.style) {
                            var i = _savedStyles.indexOf(target);
                            i >= 0 && _savedStyles.splice(i, 5);
                            _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _context())
                        }
                    }) : _savedStyles
                };
                ScrollTrigger.revert = function(soft, media) {
                    return _revertAll(!soft, media)
                };
                ScrollTrigger.create = function(vars, animation) {
                    return new ScrollTrigger(vars, animation)
                };
                ScrollTrigger.refresh = function(safe) {
                    return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(!0)
                };
                ScrollTrigger.update = function(force) {
                    return ++_Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache && _updateAll(force === !0 ? 2 : 0)
                };
                ScrollTrigger.clearScrollMemory = _clearScrollMemory;
                ScrollTrigger.maxScroll = function(element, horizontal) {
                    return _maxScroll(element, horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)
                };
                ScrollTrigger.getScrollFunc = function(element, horizontal) {
                    return (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)((0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(element), horizontal ? _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal : _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical)
                };
                ScrollTrigger.getById = function(id) {
                    return _ids[id]
                };
                ScrollTrigger.getAll = function() {
                    return _triggers.filter(function(t) {
                        return t.vars.id !== "ScrollSmoother"
                    })
                };
                ScrollTrigger.isScrolling = function() {
                    return !!_lastScrollTime
                };
                ScrollTrigger.snapDirectional = _snapDirectional;
                ScrollTrigger.addEventListener = function(type, callback) {
                    var a = _listeners[type] || (_listeners[type] = []);
                    ~a.indexOf(callback) || a.push(callback)
                };
                ScrollTrigger.removeEventListener = function(type, callback) {
                    var a = _listeners[type],
                        i = a && a.indexOf(callback);
                    i >= 0 && a.splice(i, 1)
                };
                ScrollTrigger.batch = function(targets, vars) {
                    var result = [],
                        varsCopy = {},
                        interval = vars.interval || 0.016,
                        batchMax = vars.batchMax || 1e9,
                        proxyCallback = function proxyCallback(type, callback) {
                            var elements = [],
                                triggers = [],
                                delay = gsap.delayedCall(interval, function() {
                                    callback(elements, triggers);
                                    elements = [];
                                    triggers = []
                                }).pause();
                            return function(self) {
                                elements.length || delay.restart(!0);
                                elements.push(self.trigger);
                                triggers.push(self);
                                batchMax <= elements.length && delay.progress(1)
                            }
                        },
                        p;
                    for (p in vars) {
                        varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p]
                    }
                    if (_isFunction(batchMax)) {
                        batchMax = batchMax();
                        _addListener(ScrollTrigger, "refresh", function() {
                            return batchMax = vars.batchMax()
                        })
                    }
                    _toArray(targets).forEach(function(target) {
                        var config = {};
                        for (p in varsCopy) {
                            config[p] = varsCopy[p]
                        }
                        config.trigger = target;
                        result.push(ScrollTrigger.create(config))
                    });
                    return result
                };
                var _clampScrollAndGetDurationMultiplier = function _clampScrollAndGetDurationMultiplier(scrollFunc, current, end, max) {
                        current > max ? scrollFunc(max) : current < 0 && scrollFunc(0);
                        return end > max ? (max - current) / (end - current) : end < 0 ? current / (current - end) : 1
                    },
                    _allowNativePanning = function _allowNativePanning(target, direction) {
                        if (direction === !0) {
                            target.style.removeProperty("touch-action")
                        } else {
                            target.style.touchAction = direction === !0 ? "auto" : direction ? "pan-" + direction + (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch ? " pinch-zoom" : "") : "none"
                        }
                        target === _docEl && _allowNativePanning(_body, direction)
                    },
                    _overflow = {
                        auto: 1,
                        scroll: 1
                    },
                    _nestedScroll = function _nestedScroll(_ref5) {
                        var event = _ref5.event,
                            target = _ref5.target,
                            axis = _ref5.axis;
                        var node = (event.changedTouches ? event.changedTouches[0] : event).target,
                            cache = node._gsap || gsap.core.getCache(node),
                            time = _getTime(),
                            cs;
                        if (!cache._isScrollT || time - cache._isScrollT > 2000) {
                            while (node && node !== _body && (node.scrollHeight <= node.clientHeight && node.scrollWidth <= node.clientWidth || !(_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]))) {
                                node = node.parentNode
                            }
                            cache._isScroll = node && node !== target && !_isViewport(node) && (_overflow[(cs = _getComputedStyle(node)).overflowY] || _overflow[cs.overflowX]);
                            cache._isScrollT = time
                        }
                        if (cache._isScroll || axis === "x") {
                            event.stopPropagation();
                            event._gsapAllow = !0
                        }
                    },
                    _inputObserver = function _inputObserver(target, type, inputs, nested) {
                        return _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.create({
                            target: target,
                            capture: !0,
                            debounce: !1,
                            lockAxis: !0,
                            type: type,
                            onWheel: nested = nested && _nestedScroll,
                            onPress: nested,
                            onDrag: nested,
                            onScroll: nested,
                            onEnable: function onEnable() {
                                return inputs && _addListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, !1, !0)
                            },
                            onDisable: function onDisable() {
                                return _removeListener(_doc, _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.eventTypes[0], _captureInputs, !0)
                            }
                        })
                    },
                    _inputExp = /(input|label|select|textarea)/i,
                    _inputIsFocused, _captureInputs = function _captureInputs(e) {
                        var isInput = _inputExp.test(e.target.tagName);
                        if (isInput || _inputIsFocused) {
                            e._gsapAllow = !0;
                            _inputIsFocused = isInput
                        }
                    },
                    _getScrollNormalizer = function _getScrollNormalizer(vars) {
                        _isObject(vars) || (vars = {});
                        vars.preventDefault = vars.isNormalizer = vars.allowClicks = !0;
                        vars.type || (vars.type = "wheel,touch");
                        vars.debounce = !!vars.debounce;
                        vars.id = vars.id || "normalizer";
                        var _vars2 = vars,
                            normalizeScrollX = _vars2.normalizeScrollX,
                            momentum = _vars2.momentum,
                            allowNestedScroll = _vars2.allowNestedScroll,
                            onRelease = _vars2.onRelease,
                            self, maxY, target = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.target) || _docEl,
                            smoother = gsap.core.globals().ScrollSmoother,
                            smootherInstance = smoother && smoother.get(),
                            content = _fixIOSBug && (vars.content && (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getTarget)(vars.content) || smootherInstance && vars.content !== !1 && !smootherInstance.smooth() && smootherInstance.content()),
                            scrollFuncY = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical),
                            scrollFuncX = (0, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getScrollFunc)(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal),
                            scale = 1,
                            initialScale = (_Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer.isTouch && _win.visualViewport ? _win.visualViewport.scale * _win.visualViewport.width : _win.outerWidth) / _win.innerWidth,
                            wheelRefresh = 0,
                            resolveMomentumDuration = _isFunction(momentum) ? function() {
                                return momentum(self)
                            } : function() {
                                return momentum || 2.8
                            },
                            lastRefreshID, skipTouchMove, inputObserver = _inputObserver(target, vars.type, !0, allowNestedScroll),
                            resumeTouchMove = function resumeTouchMove() {
                                return skipTouchMove = !1
                            },
                            scrollClampX = _passThrough,
                            scrollClampY = _passThrough,
                            updateClamps = function updateClamps() {
                                maxY = _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical);
                                scrollClampY = _clamp(_fixIOSBug ? 1 : 0, maxY);
                                normalizeScrollX && (scrollClampX = _clamp(0, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal)));
                                lastRefreshID = _refreshID
                            },
                            removeContentOffset = function removeContentOffset() {
                                content._gsap.y = _round(parseFloat(content._gsap.y) + scrollFuncY.offset) + "px";
                                content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(content._gsap.y) + ", 0, 1)";
                                scrollFuncY.offset = scrollFuncY.cacheID = 0
                            },
                            ignoreDrag = function ignoreDrag() {
                                if (skipTouchMove) {
                                    requestAnimationFrame(resumeTouchMove);
                                    var offset = _round(self.deltaY / 2),
                                        scroll = scrollClampY(scrollFuncY.v - offset);
                                    if (content && scroll !== scrollFuncY.v + scrollFuncY.offset) {
                                        scrollFuncY.offset = scroll - scrollFuncY.v;
                                        var y = _round((parseFloat(content && content._gsap.y) || 0) - scrollFuncY.offset);
                                        content.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + y + ", 0, 1)";
                                        content._gsap.y = y + "px";
                                        scrollFuncY.cacheID = _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache;
                                        _updateAll()
                                    }
                                    return !0
                                }
                                scrollFuncY.offset && removeContentOffset();
                                skipTouchMove = !0
                            },
                            tween, startScrollX, startScrollY, onStopDelayedCall, onResize = function onResize() {
                                updateClamps();
                                if (tween.isActive() && tween.vars.scrollY > maxY) {
                                    scrollFuncY() > maxY ? tween.progress(1) && scrollFuncY(maxY) : tween.resetTo("scrollY", maxY)
                                }
                            };
                        content && gsap.set(content, {
                            y: "+=0"
                        });
                        vars.ignoreCheck = function(e) {
                            return _fixIOSBug && e.type === "touchmove" && ignoreDrag(e) || scale > 1.05 && e.type !== "touchstart" || self.isGesturing || e.touches && e.touches.length > 1
                        };
                        vars.onPress = function() {
                            skipTouchMove = !1;
                            var prevScale = scale;
                            scale = _round((_win.visualViewport && _win.visualViewport.scale || 1) / initialScale);
                            tween.pause();
                            prevScale !== scale && _allowNativePanning(target, scale > 1.01 ? !0 : normalizeScrollX ? !1 : "x");
                            startScrollX = scrollFuncX();
                            startScrollY = scrollFuncY();
                            updateClamps();
                            lastRefreshID = _refreshID
                        };
                        vars.onRelease = vars.onGestureStart = function(self, wasDragging) {
                            scrollFuncY.offset && removeContentOffset();
                            if (!wasDragging) {
                                onStopDelayedCall.restart(!0)
                            } else {
                                _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers.cache++;
                                var dur = resolveMomentumDuration(),
                                    currentScroll, endScroll;
                                if (normalizeScrollX) {
                                    currentScroll = scrollFuncX();
                                    endScroll = currentScroll + dur * 0.05 * -self.velocityX / 0.227;
                                    dur *= _clampScrollAndGetDurationMultiplier(scrollFuncX, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._horizontal));
                                    tween.vars.scrollX = scrollClampX(endScroll)
                                }
                                currentScroll = scrollFuncY();
                                endScroll = currentScroll + dur * 0.05 * -self.velocityY / 0.227;
                                dur *= _clampScrollAndGetDurationMultiplier(scrollFuncY, currentScroll, endScroll, _maxScroll(target, _Observer_js__WEBPACK_IMPORTED_MODULE_0__._vertical));
                                tween.vars.scrollY = scrollClampY(endScroll);
                                tween.invalidate().duration(dur).play(0.01);
                                if (_fixIOSBug && tween.vars.scrollY >= maxY || currentScroll >= maxY - 1) {
                                    gsap.to({}, {
                                        onUpdate: onResize,
                                        duration: dur
                                    })
                                }
                            }
                            onRelease && onRelease(self)
                        };
                        vars.onWheel = function() {
                            tween._ts && tween.pause();
                            if (_getTime() - wheelRefresh > 1000) {
                                lastRefreshID = 0;
                                wheelRefresh = _getTime()
                            }
                        };
                        vars.onChange = function(self, dx, dy, xArray, yArray) {
                            _refreshID !== lastRefreshID && updateClamps();
                            dx && normalizeScrollX && scrollFuncX(scrollClampX(xArray[2] === dx ? startScrollX + (self.startX - self.x) : scrollFuncX() + dx - xArray[1]));
                            if (dy) {
                                scrollFuncY.offset && removeContentOffset();
                                var isTouch = yArray[2] === dy,
                                    y = isTouch ? startScrollY + self.startY - self.y : scrollFuncY() + dy - yArray[1],
                                    yClamped = scrollClampY(y);
                                isTouch && y !== yClamped && (startScrollY += yClamped - y);
                                scrollFuncY(yClamped)
                            }(dy || dx) && _updateAll()
                        };
                        vars.onEnable = function() {
                            _allowNativePanning(target, normalizeScrollX ? !1 : "x");
                            ScrollTrigger.addEventListener("refresh", onResize);
                            _addListener(_win, "resize", onResize);
                            if (scrollFuncY.smooth) {
                                scrollFuncY.target.style.scrollBehavior = "auto";
                                scrollFuncY.smooth = scrollFuncX.smooth = !1
                            }
                            inputObserver.enable()
                        };
                        vars.onDisable = function() {
                            _allowNativePanning(target, !0);
                            _removeListener(_win, "resize", onResize);
                            ScrollTrigger.removeEventListener("refresh", onResize);
                            inputObserver.kill()
                        };
                        vars.lockAxis = vars.lockAxis !== !1;
                        self = new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars);
                        self.iOS = _fixIOSBug;
                        _fixIOSBug && !scrollFuncY() && scrollFuncY(1);
                        _fixIOSBug && gsap.ticker.add(_passThrough);
                        onStopDelayedCall = self._dc;
                        tween = gsap.to(self, {
                            ease: "power4",
                            paused: !0,
                            inherit: !1,
                            scrollX: normalizeScrollX ? "+=0.1" : "+=0",
                            scrollY: "+=0.1",
                            modifiers: {
                                scrollY: _interruptionTracker(scrollFuncY, scrollFuncY(), function() {
                                    return tween.pause()
                                })
                            },
                            onUpdate: _updateAll,
                            onComplete: onStopDelayedCall.vars.onComplete
                        });
                        return self
                    };
                ScrollTrigger.sort = function(func) {
                    return _triggers.sort(func || function(a, b) {
                        return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6)
                    })
                };
                ScrollTrigger.observe = function(vars) {
                    return new _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer(vars)
                };
                ScrollTrigger.normalizeScroll = function(vars) {
                    if (typeof vars === "undefined") {
                        return _normalizer
                    }
                    if (vars === !0 && _normalizer) {
                        return _normalizer.enable()
                    }
                    if (vars === !1) {
                        _normalizer && _normalizer.kill();
                        _normalizer = vars;
                        return
                    }
                    var normalizer = vars instanceof _Observer_js__WEBPACK_IMPORTED_MODULE_0__.Observer ? vars : _getScrollNormalizer(vars);
                    _normalizer && _normalizer.target === normalizer.target && _normalizer.kill();
                    _isViewport(normalizer.target) && (_normalizer = normalizer);
                    return normalizer
                };
                ScrollTrigger.core = {
                    _getVelocityProp: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._getVelocityProp,
                    _inputObserver: _inputObserver,
                    _scrollers: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._scrollers,
                    _proxies: _Observer_js__WEBPACK_IMPORTED_MODULE_0__._proxies,
                    bridge: {
                        ss: function ss() {
                            _lastScrollTime || _dispatch("scrollStart");
                            _lastScrollTime = _getTime()
                        },
                        ref: function ref() {
                            return _refreshing
                        }
                    }
                };
                _getGSAP() && gsap.registerPlugin(ScrollTrigger)
            }),
        "./node_modules/gsap/gsap-core.js":
            /*!****************************************!*\
              !*** ./node_modules/gsap/gsap-core.js ***!
              \****************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    GSCache: () => (GSCache),
                    PropTween: () => (PropTween),
                    _checkPlugin: () => (_checkPlugin),
                    _colorExp: () => (_colorExp),
                    _colorStringFilter: () => (_colorStringFilter),
                    _config: () => (_config),
                    _forEachName: () => (_forEachName),
                    _getCache: () => (_getCache),
                    _getProperty: () => (_getProperty),
                    _getSetter: () => (_getSetter),
                    _isString: () => (_isString),
                    _isUndefined: () => (_isUndefined),
                    _missingPlugin: () => (_missingPlugin),
                    _numExp: () => (_numExp),
                    _numWithUnitExp: () => (_numWithUnitExp),
                    _parseRelative: () => (_parseRelative),
                    _plugins: () => (_plugins),
                    _relExp: () => (_relExp),
                    _renderComplexString: () => (_renderComplexString),
                    _replaceRandom: () => (_replaceRandom),
                    _round: () => (_round),
                    _sortPropTweensByPriority: () => (_sortPropTweensByPriority),
                    _ticker: () => (_ticker),
                    getUnit: () => (getUnit),
                    gsap: () => (gsap)
                });

                function _assertThisInitialized(self) {
                    if (self === void 0) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called")
                    }
                    return self
                }

                function _inheritsLoose(subClass, superClass) {
                    subClass.prototype = Object.create(superClass.prototype);
                    subClass.prototype.constructor = subClass;
                    subClass.__proto__ = superClass
                }
                /*!
                 * GSAP 3.12.5
                 * https://gsap.com
                 *
                 * @license Copyright 2008-2024, GreenSock. All rights reserved.
                 * Subject to the terms at https://gsap.com/standard-license or for
                 * Club GSAP members, the agreement issued with that membership.
                 * @author: Jack Doyle, jack@greensock.com
                 */
                var _config = {
                        autoSleep: 120,
                        force3D: "auto",
                        nullTargetWarn: 1,
                        units: {
                            lineHeight: ""
                        }
                    },
                    _defaults = {
                        duration: .5,
                        overwrite: !1,
                        delay: 0
                    },
                    _suppressOverwrites, _reverting, _context, _bigNum = 1e8,
                    _tinyNum = 1 / _bigNum,
                    _2PI = Math.PI * 2,
                    _HALF_PI = _2PI / 4,
                    _gsID = 0,
                    _sqrt = Math.sqrt,
                    _cos = Math.cos,
                    _sin = Math.sin,
                    _isString = function _isString(value) {
                        return typeof value === "string"
                    },
                    _isFunction = function _isFunction(value) {
                        return typeof value === "function"
                    },
                    _isNumber = function _isNumber(value) {
                        return typeof value === "number"
                    },
                    _isUndefined = function _isUndefined(value) {
                        return typeof value === "undefined"
                    },
                    _isObject = function _isObject(value) {
                        return typeof value === "object"
                    },
                    _isNotFalse = function _isNotFalse(value) {
                        return value !== !1
                    },
                    _windowExists = function _windowExists() {
                        return typeof window !== "undefined"
                    },
                    _isFuncOrString = function _isFuncOrString(value) {
                        return _isFunction(value) || _isString(value)
                    },
                    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {},
                    _isArray = Array.isArray,
                    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
                    _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
                    _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
                    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
                    _relExp = /[+-]=-?[.\d]+/,
                    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
                    _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
                    _globalTimeline, _win, _coreInitted, _doc, _globals = {},
                    _installScope = {},
                    _coreReady, _install = function _install(scope) {
                        return (_installScope = _merge(scope, _globals)) && gsap
                    },
                    _missingPlugin = function _missingPlugin(property, value) {
                        return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()")
                    },
                    _warn = function _warn(message, suppress) {
                        return !suppress && console.warn(message)
                    },
                    _addGlobal = function _addGlobal(name, obj) {
                        return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals
                    },
                    _emptyFunc = function _emptyFunc() {
                        return 0
                    },
                    _startAtRevertConfig = {
                        suppressEvents: !0,
                        isStart: !0,
                        kill: !1
                    },
                    _revertConfigNoKill = {
                        suppressEvents: !0,
                        kill: !1
                    },
                    _revertConfig = {
                        suppressEvents: !0
                    },
                    _reservedProps = {},
                    _lazyTweens = [],
                    _lazyLookup = {},
                    _lastRenderedFrame, _plugins = {},
                    _effects = {},
                    _nextGCFrame = 30,
                    _harnessPlugins = [],
                    _callbackNames = "",
                    _harness = function _harness(targets) {
                        var target = targets[0],
                            harnessPlugin, i;
                        _isObject(target) || _isFunction(target) || (targets = [targets]);
                        if (!(harnessPlugin = (target._gsap || {}).harness)) {
                            i = _harnessPlugins.length;
                            while (i-- && !_harnessPlugins[i].targetTest(target)) {}
                            harnessPlugin = _harnessPlugins[i]
                        }
                        i = targets.length;
                        while (i--) {
                            targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1)
                        }
                        return targets
                    },
                    _getCache = function _getCache(target) {
                        return target._gsap || _harness(toArray(target))[0]._gsap
                    },
                    _getProperty = function _getProperty(target, property, v) {
                        return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v
                    },
                    _forEachName = function _forEachName(names, func) {
                        return (names = names.split(",")).forEach(func) || names
                    },
                    _round = function _round(value) {
                        return Math.round(value * 100000) / 100000 || 0
                    },
                    _roundPrecise = function _roundPrecise(value) {
                        return Math.round(value * 10000000) / 10000000 || 0
                    },
                    _parseRelative = function _parseRelative(start, value) {
                        var operator = value.charAt(0),
                            end = parseFloat(value.substr(2));
                        start = parseFloat(start);
                        return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end
                    },
                    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
                        var l = toFind.length,
                            i = 0;
                        for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}
                        return i < l
                    },
                    _lazyRender = function _lazyRender() {
                        var l = _lazyTweens.length,
                            a = _lazyTweens.slice(0),
                            i, tween;
                        _lazyLookup = {};
                        _lazyTweens.length = 0;
                        for (i = 0; i < l; i++) {
                            tween = a[i];
                            tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], !0)._lazy = 0)
                        }
                    },
                    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
                        _lazyTweens.length && !_reverting && _lazyRender();
                        animation.render(time, suppressEvents, force || _reverting && time < 0 && (animation._initted || animation._startAt));
                        _lazyTweens.length && !_reverting && _lazyRender()
                    },
                    _numericIfPossible = function _numericIfPossible(value) {
                        var n = parseFloat(value);
                        return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value
                    },
                    _passThrough = function _passThrough(p) {
                        return p
                    },
                    _setDefaults = function _setDefaults(obj, defaults) {
                        for (var p in defaults) {
                            p in obj || (obj[p] = defaults[p])
                        }
                        return obj
                    },
                    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
                        return function(obj, defaults) {
                            for (var p in defaults) {
                                p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p])
                            }
                        }
                    },
                    _merge = function _merge(base, toMerge) {
                        for (var p in toMerge) {
                            base[p] = toMerge[p]
                        }
                        return base
                    },
                    _mergeDeep = function _mergeDeep(base, toMerge) {
                        for (var p in toMerge) {
                            p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p])
                        }
                        return base
                    },
                    _copyExcluding = function _copyExcluding(obj, excluding) {
                        var copy = {},
                            p;
                        for (p in obj) {
                            p in excluding || (copy[p] = obj[p])
                        }
                        return copy
                    },
                    _inheritDefaults = function _inheritDefaults(vars) {
                        var parent = vars.parent || _globalTimeline,
                            func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
                        if (_isNotFalse(vars.inherit)) {
                            while (parent) {
                                func(vars, parent.vars.defaults);
                                parent = parent.parent || parent._dp
                            }
                        }
                        return vars
                    },
                    _arraysMatch = function _arraysMatch(a1, a2) {
                        var i = a1.length,
                            match = i === a2.length;
                        while (match && i-- && a1[i] === a2[i]) {}
                        return i < 0
                    },
                    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
                        if (firstProp === void 0) {
                            firstProp = "_first"
                        }
                        if (lastProp === void 0) {
                            lastProp = "_last"
                        }
                        var prev = parent[lastProp],
                            t;
                        if (sortBy) {
                            t = child[sortBy];
                            while (prev && prev[sortBy] > t) {
                                prev = prev._prev
                            }
                        }
                        if (prev) {
                            child._next = prev._next;
                            prev._next = child
                        } else {
                            child._next = parent[firstProp];
                            parent[firstProp] = child
                        }
                        if (child._next) {
                            child._next._prev = child
                        } else {
                            parent[lastProp] = child
                        }
                        child._prev = prev;
                        child.parent = child._dp = parent;
                        return child
                    },
                    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
                        if (firstProp === void 0) {
                            firstProp = "_first"
                        }
                        if (lastProp === void 0) {
                            lastProp = "_last"
                        }
                        var prev = child._prev,
                            next = child._next;
                        if (prev) {
                            prev._next = next
                        } else if (parent[firstProp] === child) {
                            parent[firstProp] = next
                        }
                        if (next) {
                            next._prev = prev
                        } else if (parent[lastProp] === child) {
                            parent[lastProp] = prev
                        }
                        child._next = child._prev = child.parent = null
                    },
                    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
                        child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
                        child._act = 0
                    },
                    _uncache = function _uncache(animation, child) {
                        if (animation && (!child || child._end > animation._dur || child._start < 0)) {
                            var a = animation;
                            while (a) {
                                a._dirty = 1;
                                a = a.parent
                            }
                        }
                        return animation
                    },
                    _recacheAncestors = function _recacheAncestors(animation) {
                        var parent = animation.parent;
                        while (parent && parent.parent) {
                            parent._dirty = 1;
                            parent.totalDuration();
                            parent = parent.parent
                        }
                        return animation
                    },
                    _rewindStartAt = function _rewindStartAt(tween, totalTime, suppressEvents, force) {
                        return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, !0, force))
                    },
                    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
                        return !animation || animation._ts && _hasNoPausedAncestors(animation.parent)
                    },
                    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
                        return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0
                    },
                    _animationCycle = function _animationCycle(tTime, cycleDuration) {
                        var whole = Math.floor(tTime /= cycleDuration);
                        return tTime && whole === tTime ? whole - 1 : whole
                    },
                    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
                        return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur)
                    },
                    _setEnd = function _setEnd(animation) {
                        return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0))
                    },
                    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
                        var parent = animation._dp;
                        if (parent && parent.smoothChildTiming && animation._ts) {
                            animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
                            _setEnd(animation);
                            parent._dirty || _uncache(parent, animation)
                        }
                        return animation
                    },
                    _postAddChecks = function _postAddChecks(timeline, child) {
                        var t;
                        if (child._time || !child._dur && child._initted || child._start < timeline._time && (child._dur || !child.add)) {
                            t = _parentToChildTotalTime(timeline.rawTime(), child);
                            if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
                                child.render(t, !0)
                            }
                        }
                        if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
                            if (timeline._dur < timeline.duration()) {
                                t = timeline;
                                while (t._dp) {
                                    t.rawTime() >= 0 && t.totalTime(t._tTime);
                                    t = t._dp
                                }
                            }
                            timeline._zTime = -_tinyNum
                        }
                    },
                    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
                        child.parent && _removeFromParent(child);
                        child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
                        child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
                        _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);
                        _isFromOrFromStart(child) || (timeline._recent = child);
                        skipChecks || _postAddChecks(timeline, child);
                        timeline._ts < 0 && _alignPlayhead(timeline, timeline._tTime);
                        return timeline
                    },
                    _scrollTrigger = function _scrollTrigger(animation, trigger) {
                        return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation)
                    },
                    _attemptInitTween = function _attemptInitTween(tween, time, force, suppressEvents, tTime) {
                        _initTween(tween, time, tTime);
                        if (!tween._initted) {
                            return 1
                        }
                        if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== !1 || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
                            _lazyTweens.push(tween);
                            tween._lazy = [tTime, suppressEvents];
                            return 1
                        }
                    },
                    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
                        var parent = _ref.parent;
                        return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent))
                    },
                    _isFromOrFromStart = function _isFromOrFromStart(_ref2) {
                        var data = _ref2.data;
                        return data === "isFromStart" || data === "isStart"
                    },
                    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
                        var prevRatio = tween.ratio,
                            ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
                            repeatDelay = tween._rDelay,
                            tTime = 0,
                            pt, iteration, prevIteration;
                        if (repeatDelay && tween._repeat) {
                            tTime = _clamp(0, tween._tDur, totalTime);
                            iteration = _animationCycle(tTime, repeatDelay);
                            tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
                            if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
                                prevRatio = 1 - ratio;
                                tween.vars.repeatRefresh && tween._initted && tween.invalidate()
                            }
                        }
                        if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
                            if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
                                return
                            }
                            prevIteration = tween._zTime;
                            tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
                            suppressEvents || (suppressEvents = totalTime && !prevIteration);
                            tween.ratio = ratio;
                            tween._from && (ratio = 1 - ratio);
                            tween._time = 0;
                            tween._tTime = tTime;
                            pt = tween._pt;
                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next
                            }
                            totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, !0);
                            tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
                            tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
                            if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
                                ratio && _removeFromParent(tween, 1);
                                if (!suppressEvents && !_reverting) {
                                    _callback(tween, ratio ? "onComplete" : "onReverseComplete", !0);
                                    tween._prom && tween._prom()
                                }
                            }
                        } else if (!tween._zTime) {
                            tween._zTime = totalTime
                        }
                    },
                    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
                        var child;
                        if (time > prevTime) {
                            child = animation._first;
                            while (child && child._start <= time) {
                                if (child.data === "isPause" && child._start > prevTime) {
                                    return child
                                }
                                child = child._next
                            }
                        } else {
                            child = animation._last;
                            while (child && child._start >= time) {
                                if (child.data === "isPause" && child._start < prevTime) {
                                    return child
                                }
                                child = child._prev
                            }
                        }
                    },
                    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
                        var repeat = animation._repeat,
                            dur = _roundPrecise(duration) || 0,
                            totalProgress = animation._tTime / animation._tDur;
                        totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
                        animation._dur = dur;
                        animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
                        totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
                        animation.parent && _setEnd(animation);
                        skipUncache || _uncache(animation.parent, animation);
                        return animation
                    },
                    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
                        return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur)
                    },
                    _zeroPosition = {
                        _start: 0,
                        endTime: _emptyFunc,
                        totalDuration: _emptyFunc
                    },
                    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
                        var labels = animation.labels,
                            recent = animation._recent || _zeroPosition,
                            clippedDuration = animation.duration() >= _bigNum ? recent.endTime(!1) : animation._dur,
                            i, offset, isPercent;
                        if (_isString(position) && (isNaN(position) || position in labels)) {
                            offset = position.charAt(0);
                            isPercent = position.substr(-1) === "%";
                            i = position.indexOf("=");
                            if (offset === "<" || offset === ">") {
                                i >= 0 && (position = position.replace(/=/, ""));
                                return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1)
                            }
                            if (i < 0) {
                                position in labels || (labels[position] = clippedDuration);
                                return labels[position]
                            }
                            offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
                            if (isPercent && percentAnimation) {
                                offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration()
                            }
                            return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset
                        }
                        return position == null ? clippedDuration : +position
                    },
                    _createTweenType = function _createTweenType(type, params, timeline) {
                        var isLegacy = _isNumber(params[1]),
                            varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
                            vars = params[varsIndex],
                            irVars, parent;
                        isLegacy && (vars.duration = params[1]);
                        vars.parent = timeline;
                        if (type) {
                            irVars = vars;
                            parent = timeline;
                            while (parent && !("immediateRender" in irVars)) {
                                irVars = parent.vars.defaults || {};
                                parent = _isNotFalse(parent.vars.inherit) && parent.parent
                            }
                            vars.immediateRender = _isNotFalse(irVars.immediateRender);
                            type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]
                        }
                        return new Tween(params[0], vars, params[varsIndex + 1])
                    },
                    _conditionalReturn = function _conditionalReturn(value, func) {
                        return value || value === 0 ? func(value) : func
                    },
                    _clamp = function _clamp(min, max, value) {
                        return value < min ? min : value > max ? max : value
                    },
                    getUnit = function getUnit(value, v) {
                        return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : v[1]
                    },
                    clamp = function clamp(min, max, value) {
                        return _conditionalReturn(value, function(v) {
                            return _clamp(min, max, v)
                        })
                    },
                    _slice = [].slice,
                    _isArrayLike = function _isArrayLike(value, nonEmpty) {
                        return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win
                    },
                    _flatten = function _flatten(ar, leaveStrings, accumulator) {
                        if (accumulator === void 0) {
                            accumulator = []
                        }
                        return ar.forEach(function(value) {
                            var _accumulator;
                            return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value)
                        }) || accumulator
                    },
                    toArray = function toArray(value, scope, leaveStrings) {
                        return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : []
                    },
                    selector = function selector(value) {
                        value = toArray(value)[0] || _warn("Invalid scope") || {};
                        return function(v) {
                            var el = value.current || value.nativeElement || value;
                            return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value)
                        }
                    },
                    shuffle = function shuffle(a) {
                        return a.sort(function() {
                            return .5 - Math.random()
                        })
                    },
                    distribute = function distribute(v) {
                        if (_isFunction(v)) {
                            return v
                        }
                        var vars = _isObject(v) ? v : {
                                each: v
                            },
                            ease = _parseEase(vars.ease),
                            from = vars.from || 0,
                            base = parseFloat(vars.base) || 0,
                            cache = {},
                            isDecimal = from > 0 && from < 1,
                            ratios = isNaN(from) || isDecimal,
                            axis = vars.axis,
                            ratioX = from,
                            ratioY = from;
                        if (_isString(from)) {
                            ratioX = ratioY = {
                                center: .5,
                                edges: .5,
                                end: 1
                            }[from] || 0
                        } else if (!isDecimal && ratios) {
                            ratioX = from[0];
                            ratioY = from[1]
                        }
                        return function(i, target, a) {
                            var l = (a || vars).length,
                                distances = cache[l],
                                originX, originY, x, y, d, j, max, min, wrapAt;
                            if (!distances) {
                                wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
                                if (!wrapAt) {
                                    max = -_bigNum;
                                    while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}
                                    wrapAt < l && wrapAt--
                                }
                                distances = cache[l] = [];
                                originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
                                originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
                                max = 0;
                                min = _bigNum;
                                for (j = 0; j < l; j++) {
                                    x = j % wrapAt - originX;
                                    y = originY - (j / wrapAt | 0);
                                    distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
                                    d > max && (max = d);
                                    d < min && (min = d)
                                }
                                from === "random" && shuffle(distances);
                                distances.max = max - min;
                                distances.min = min;
                                distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
                                distances.b = l < 0 ? base - l : base;
                                distances.u = getUnit(vars.amount || vars.each) || 0;
                                ease = ease && l < 0 ? _invertEase(ease) : ease
                            }
                            l = (distances[i] - distances.min) / distances.max || 0;
                            return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u
                        }
                    },
                    _roundModifier = function _roundModifier(v) {
                        var p = Math.pow(10, ((v + "").split(".")[1] || "").length);
                        return function(raw) {
                            var n = _roundPrecise(Math.round(parseFloat(raw) / v) * v * p);
                            return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw))
                        }
                    },
                    snap = function snap(snapTo, value) {
                        var isArray = _isArray(snapTo),
                            radius, is2D;
                        if (!isArray && _isObject(snapTo)) {
                            radius = isArray = snapTo.radius || _bigNum;
                            if (snapTo.values) {
                                snapTo = toArray(snapTo.values);
                                if (is2D = !_isNumber(snapTo[0])) {
                                    radius *= radius
                                }
                            } else {
                                snapTo = _roundModifier(snapTo.increment)
                            }
                        }
                        return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
                            is2D = snapTo(raw);
                            return Math.abs(is2D - raw) <= radius ? is2D : raw
                        } : function(raw) {
                            var x = parseFloat(is2D ? raw.x : raw),
                                y = parseFloat(is2D ? raw.y : 0),
                                min = _bigNum,
                                closest = 0,
                                i = snapTo.length,
                                dx, dy;
                            while (i--) {
                                if (is2D) {
                                    dx = snapTo[i].x - x;
                                    dy = snapTo[i].y - y;
                                    dx = dx * dx + dy * dy
                                } else {
                                    dx = Math.abs(snapTo[i] - x)
                                }
                                if (dx < min) {
                                    min = dx;
                                    closest = i
                                }
                            }
                            closest = !radius || min <= radius ? snapTo[closest] : raw;
                            return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw)
                        })
                    },
                    random = function random(min, max, roundingIncrement, returnFunction) {
                        return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === !0 ? !!(roundingIncrement = 0) : !returnFunction, function() {
                            return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction
                        })
                    },
                    pipe = function pipe() {
                        for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
                            functions[_key] = arguments[_key]
                        }
                        return function(value) {
                            return functions.reduce(function(v, f) {
                                return f(v)
                            }, value)
                        }
                    },
                    unitize = function unitize(func, unit) {
                        return function(value) {
                            return func(parseFloat(value)) + (unit || getUnit(value))
                        }
                    },
                    normalize = function normalize(min, max, value) {
                        return mapRange(min, max, 0, 1, value)
                    },
                    _wrapArray = function _wrapArray(a, wrapper, value) {
                        return _conditionalReturn(value, function(index) {
                            return a[~~wrapper(index)]
                        })
                    },
                    wrap = function wrap(min, max, value) {
                        var range = max - min;
                        return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function(value) {
                            return (range + (value - min) % range) % range + min
                        })
                    },
                    wrapYoyo = function wrapYoyo(min, max, value) {
                        var range = max - min,
                            total = range * 2;
                        return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function(value) {
                            value = (total + (value - min) % total) % total || 0;
                            return min + (value > range ? total - value : value)
                        })
                    },
                    _replaceRandom = function _replaceRandom(value) {
                        var prev = 0,
                            s = "",
                            i, nums, end, isArray;
                        while (~(i = value.indexOf("random(", prev))) {
                            end = value.indexOf(")", i);
                            isArray = value.charAt(i + 7) === "[";
                            nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
                            s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
                            prev = end + 1
                        }
                        return s + value.substr(prev, value.length - prev)
                    },
                    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
                        var inRange = inMax - inMin,
                            outRange = outMax - outMin;
                        return _conditionalReturn(value, function(value) {
                            return outMin + ((value - inMin) / inRange * outRange || 0)
                        })
                    },
                    interpolate = function interpolate(start, end, progress, mutate) {
                        var func = isNaN(start + end) ? 0 : function(p) {
                            return (1 - p) * start + p * end
                        };
                        if (!func) {
                            var isString = _isString(start),
                                master = {},
                                p, i, interpolators, l, il;
                            progress === !0 && (mutate = 1) && (progress = null);
                            if (isString) {
                                start = {
                                    p: start
                                };
                                end = {
                                    p: end
                                }
                            } else if (_isArray(start) && !_isArray(end)) {
                                interpolators = [];
                                l = start.length;
                                il = l - 2;
                                for (i = 1; i < l; i++) {
                                    interpolators.push(interpolate(start[i - 1], start[i]))
                                }
                                l--;
                                func = function func(p) {
                                    p *= l;
                                    var i = Math.min(il, ~~p);
                                    return interpolators[i](p - i)
                                };
                                progress = end
                            } else if (!mutate) {
                                start = _merge(_isArray(start) ? [] : {}, start)
                            }
                            if (!interpolators) {
                                for (p in end) {
                                    _addPropTween.call(master, start, p, "get", end[p])
                                }
                                func = function func(p) {
                                    return _renderPropTweens(p, master) || (isString ? start.p : start)
                                }
                            }
                        }
                        return _conditionalReturn(progress, func)
                    },
                    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
                        var labels = timeline.labels,
                            min = _bigNum,
                            p, distance, label;
                        for (p in labels) {
                            distance = labels[p] - fromTime;
                            if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
                                label = p;
                                min = distance
                            }
                        }
                        return label
                    },
                    _callback = function _callback(animation, type, executeLazyFirst) {
                        var v = animation.vars,
                            callback = v[type],
                            prevContext = _context,
                            context = animation._ctx,
                            params, scope, result;
                        if (!callback) {
                            return
                        }
                        params = v[type + "Params"];
                        scope = v.callbackScope || animation;
                        executeLazyFirst && _lazyTweens.length && _lazyRender();
                        context && (_context = context);
                        result = params ? callback.apply(scope, params) : callback.call(scope);
                        _context = prevContext;
                        return result
                    },
                    _interrupt = function _interrupt(animation) {
                        _removeFromParent(animation);
                        animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
                        animation.progress() < 1 && _callback(animation, "onInterrupt");
                        return animation
                    },
                    _quickTween, _registerPluginQueue = [],
                    _createPlugin = function _createPlugin(config) {
                        if (!config) return;
                        config = !config.name && config["default"] || config;
                        if (_windowExists() || config.headless) {
                            var name = config.name,
                                isFunc = _isFunction(config),
                                Plugin = name && !isFunc && config.init ? function() {
                                    this._props = []
                                } : config,
                                instanceDefaults = {
                                    init: _emptyFunc,
                                    render: _renderPropTweens,
                                    add: _addPropTween,
                                    kill: _killPropTweensOf,
                                    modifier: _addPluginModifier,
                                    rawVars: 0
                                },
                                statics = {
                                    targetTest: 0,
                                    get: 0,
                                    getSetter: _getSetter,
                                    aliases: {},
                                    register: 0
                                };
                            _wake();
                            if (config !== Plugin) {
                                if (_plugins[name]) {
                                    return
                                }
                                _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics));
                                _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics)));
                                _plugins[Plugin.prop = name] = Plugin;
                                if (config.targetTest) {
                                    _harnessPlugins.push(Plugin);
                                    _reservedProps[name] = 1
                                }
                                name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"
                            }
                            _addGlobal(name, Plugin);
                            config.register && config.register(gsap, Plugin, PropTween)
                        } else {
                            _registerPluginQueue.push(config)
                        }
                    },
                    _255 = 255,
                    _colorLookup = {
                        aqua: [0, _255, _255],
                        lime: [0, _255, 0],
                        silver: [192, 192, 192],
                        black: [0, 0, 0],
                        maroon: [128, 0, 0],
                        teal: [0, 128, 128],
                        blue: [0, 0, _255],
                        navy: [0, 0, 128],
                        white: [_255, _255, _255],
                        olive: [128, 128, 0],
                        yellow: [_255, _255, 0],
                        orange: [_255, 165, 0],
                        gray: [128, 128, 128],
                        purple: [128, 0, 128],
                        green: [0, 128, 0],
                        red: [_255, 0, 0],
                        pink: [_255, 192, 203],
                        cyan: [0, _255, _255],
                        transparent: [_255, _255, _255, 0]
                    },
                    _hue = function _hue(h, m1, m2) {
                        h += h < 0 ? 1 : h > 1 ? -1 : 0;
                        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0
                    },
                    splitColor = function splitColor(v, toHSL, forceAlpha) {
                        var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
                            r, g, b, h, s, l, max, min, d, wasHSL;
                        if (!a) {
                            if (v.substr(-1) === ",") {
                                v = v.substr(0, v.length - 1)
                            }
                            if (_colorLookup[v]) {
                                a = _colorLookup[v]
                            } else if (v.charAt(0) === "#") {
                                if (v.length < 6) {
                                    r = v.charAt(1);
                                    g = v.charAt(2);
                                    b = v.charAt(3);
                                    v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "")
                                }
                                if (v.length === 9) {
                                    a = parseInt(v.substr(1, 6), 16);
                                    return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255]
                                }
                                v = parseInt(v.substr(1), 16);
                                a = [v >> 16, v >> 8 & _255, v & _255]
                            } else if (v.substr(0, 3) === "hsl") {
                                a = wasHSL = v.match(_strictNumExp);
                                if (!toHSL) {
                                    h = +a[0] % 360 / 360;
                                    s = +a[1] / 100;
                                    l = +a[2] / 100;
                                    g = l <= .5 ? l * (s + 1) : l + s - l * s;
                                    r = l * 2 - g;
                                    a.length > 3 && (a[3] *= 1);
                                    a[0] = _hue(h + 1 / 3, r, g);
                                    a[1] = _hue(h, r, g);
                                    a[2] = _hue(h - 1 / 3, r, g)
                                } else if (~v.indexOf("=")) {
                                    a = v.match(_numExp);
                                    forceAlpha && a.length < 4 && (a[3] = 1);
                                    return a
                                }
                            } else {
                                a = v.match(_strictNumExp) || _colorLookup.transparent
                            }
                            a = a.map(Number)
                        }
                        if (toHSL && !wasHSL) {
                            r = a[0] / _255;
                            g = a[1] / _255;
                            b = a[2] / _255;
                            max = Math.max(r, g, b);
                            min = Math.min(r, g, b);
                            l = (max + min) / 2;
                            if (max === min) {
                                h = s = 0
                            } else {
                                d = max - min;
                                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                                h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
                                h *= 60
                            }
                            a[0] = ~~(h + .5);
                            a[1] = ~~(s * 100 + .5);
                            a[2] = ~~(l * 100 + .5)
                        }
                        forceAlpha && a.length < 4 && (a[3] = 1);
                        return a
                    },
                    _colorOrderData = function _colorOrderData(v) {
                        var values = [],
                            c = [],
                            i = -1;
                        v.split(_colorExp).forEach(function(v) {
                            var a = v.match(_numWithUnitExp) || [];
                            values.push.apply(values, a);
                            c.push(i += a.length + 1)
                        });
                        values.c = c;
                        return values
                    },
                    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
                        var result = "",
                            colors = (s + result).match(_colorExp),
                            type = toHSL ? "hsla(" : "rgba(",
                            i = 0,
                            c, shell, d, l;
                        if (!colors) {
                            return s
                        }
                        colors = colors.map(function(color) {
                            return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")"
                        });
                        if (orderMatchData) {
                            d = _colorOrderData(s);
                            c = orderMatchData.c;
                            if (c.join(result) !== d.c.join(result)) {
                                shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
                                l = shell.length - 1;
                                for (; i < l; i++) {
                                    result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift())
                                }
                            }
                        }
                        if (!shell) {
                            shell = s.split(_colorExp);
                            l = shell.length - 1;
                            for (; i < l; i++) {
                                result += shell[i] + colors[i]
                            }
                        }
                        return result + shell[l]
                    },
                    _colorExp = function() {
                        var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
                            p;
                        for (p in _colorLookup) {
                            s += "|" + p + "\\b"
                        }
                        return new RegExp(s + ")", "gi")
                    }(),
                    _hslExp = /hsl[a]?\(/,
                    _colorStringFilter = function _colorStringFilter(a) {
                        var combined = a.join(" "),
                            toHSL;
                        _colorExp.lastIndex = 0;
                        if (_colorExp.test(combined)) {
                            toHSL = _hslExp.test(combined);
                            a[1] = _formatColors(a[1], toHSL);
                            a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
                            return !0
                        }
                    },
                    _tickerActive, _ticker = function() {
                        var _getTime = Date.now,
                            _lagThreshold = 500,
                            _adjustedLag = 33,
                            _startTime = _getTime(),
                            _lastUpdate = _startTime,
                            _gap = 1000 / 240,
                            _nextTime = _gap,
                            _listeners = [],
                            _id, _req, _raf, _self, _delta, _i, _tick = function _tick(v) {
                                var elapsed = _getTime() - _lastUpdate,
                                    manual = v === !0,
                                    overlap, dispatch, time, frame;
                                (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
                                _lastUpdate += elapsed;
                                time = _lastUpdate - _startTime;
                                overlap = time - _nextTime;
                                if (overlap > 0 || manual) {
                                    frame = ++_self.frame;
                                    _delta = time - _self.time * 1000;
                                    _self.time = time = time / 1000;
                                    _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
                                    dispatch = 1
                                }
                                manual || (_id = _req(_tick));
                                if (dispatch) {
                                    for (_i = 0; _i < _listeners.length; _i++) {
                                        _listeners[_i](time, _delta, frame, v)
                                    }
                                }
                            };
                        _self = {
                            time: 0,
                            frame: 0,
                            tick: function tick() {
                                _tick(!0)
                            },
                            deltaRatio: function deltaRatio(fps) {
                                return _delta / (1000 / (fps || 60))
                            },
                            wake: function wake() {
                                if (_coreReady) {
                                    if (!_coreInitted && _windowExists()) {
                                        _win = _coreInitted = window;
                                        _doc = _win.document || {};
                                        _globals.gsap = gsap;
                                        (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
                                        _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
                                        _registerPluginQueue.forEach(_createPlugin)
                                    }
                                    _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
                                    _id && _self.sleep();
                                    _req = _raf || function(f) {
                                        return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0)
                                    };
                                    _tickerActive = 1;
                                    _tick(2)
                                }
                            },
                            sleep: function sleep() {
                                (_raf ? cancelAnimationFrame : clearTimeout)(_id);
                                _tickerActive = 0;
                                _req = _emptyFunc
                            },
                            lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
                                _lagThreshold = threshold || Infinity;
                                _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold)
                            },
                            fps: function fps(_fps) {
                                _gap = 1000 / (_fps || 240);
                                _nextTime = _self.time * 1000 + _gap
                            },
                            add: function add(callback, once, prioritize) {
                                var func = once ? function(t, d, f, v) {
                                    callback(t, d, f, v);
                                    _self.remove(func)
                                } : callback;
                                _self.remove(callback);
                                _listeners[prioritize ? "unshift" : "push"](func);
                                _wake();
                                return func
                            },
                            remove: function remove(callback, i) {
                                ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--
                            },
                            _listeners: _listeners
                        };
                        return _self
                    }(),
                    _wake = function _wake() {
                        return !_tickerActive && _ticker.wake()
                    },
                    _easeMap = {},
                    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
                    _quotesExp = /["']/g,
                    _parseObjectInString = function _parseObjectInString(value) {
                        var obj = {},
                            split = value.substr(1, value.length - 3).split(":"),
                            key = split[0],
                            i = 1,
                            l = split.length,
                            index, val, parsedVal;
                        for (; i < l; i++) {
                            val = split[i];
                            index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
                            parsedVal = val.substr(0, index);
                            obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
                            key = val.substr(index + 1).trim()
                        }
                        return obj
                    },
                    _valueInParentheses = function _valueInParentheses(value) {
                        var open = value.indexOf("(") + 1,
                            close = value.indexOf(")"),
                            nested = value.indexOf("(", open);
                        return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close)
                    },
                    _configEaseFromString = function _configEaseFromString(name) {
                        var split = (name + "").split("("),
                            ease = _easeMap[split[0]];
                        return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease
                    },
                    _invertEase = function _invertEase(ease) {
                        return function(p) {
                            return 1 - ease(1 - p)
                        }
                    },
                    _propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
                        var child = timeline._first,
                            ease;
                        while (child) {
                            if (child instanceof Timeline) {
                                _propagateYoyoEase(child, isYoyo)
                            } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
                                if (child.timeline) {
                                    _propagateYoyoEase(child.timeline, isYoyo)
                                } else {
                                    ease = child._ease;
                                    child._ease = child._yEase;
                                    child._yEase = ease;
                                    child._yoyo = isYoyo
                                }
                            }
                            child = child._next
                        }
                    },
                    _parseEase = function _parseEase(ease, defaultEase) {
                        return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase
                    },
                    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
                        if (easeOut === void 0) {
                            easeOut = function easeOut(p) {
                                return 1 - easeIn(1 - p)
                            }
                        }
                        if (easeInOut === void 0) {
                            easeInOut = function easeInOut(p) {
                                return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2
                            }
                        }
                        var ease = {
                                easeIn: easeIn,
                                easeOut: easeOut,
                                easeInOut: easeInOut
                            },
                            lowercaseName;
                        _forEachName(names, function(name) {
                            _easeMap[name] = _globals[name] = ease;
                            _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
                            for (var p in ease) {
                                _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p]
                            }
                        });
                        return ease
                    },
                    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
                        return function(p) {
                            return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2
                        }
                    },
                    _configElastic = function _configElastic(type, amplitude, period) {
                        var p1 = amplitude >= 1 ? amplitude : 1,
                            p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
                            p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
                            easeOut = function easeOut(p) {
                                return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1
                            },
                            ease = type === "out" ? easeOut : type === "in" ? function(p) {
                                return 1 - easeOut(1 - p)
                            } : _easeInOutFromOut(easeOut);
                        p2 = _2PI / p2;
                        ease.config = function(amplitude, period) {
                            return _configElastic(type, amplitude, period)
                        };
                        return ease
                    },
                    _configBack = function _configBack(type, overshoot) {
                        if (overshoot === void 0) {
                            overshoot = 1.70158
                        }
                        var easeOut = function easeOut(p) {
                                return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0
                            },
                            ease = type === "out" ? easeOut : type === "in" ? function(p) {
                                return 1 - easeOut(1 - p)
                            } : _easeInOutFromOut(easeOut);
                        ease.config = function(overshoot) {
                            return _configBack(type, overshoot)
                        };
                        return ease
                    };
                _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
                    var power = i < 5 ? i + 1 : i;
                    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
                        return Math.pow(p, power)
                    } : function(p) {
                        return p
                    }, function(p) {
                        return 1 - Math.pow(1 - p, power)
                    }, function(p) {
                        return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2
                    })
                });
                _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
                _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
                (function(n, c) {
                    var n1 = 1 / c,
                        n2 = 2 * n1,
                        n3 = 2.5 * n1,
                        easeOut = function easeOut(p) {
                            return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375
                        };
                    _insertEase("Bounce", function(p) {
                        return 1 - easeOut(1 - p)
                    }, easeOut)
                })(7.5625, 2.75);
                _insertEase("Expo", function(p) {
                    return p ? Math.pow(2, 10 * (p - 1)) : 0
                });
                _insertEase("Circ", function(p) {
                    return -(_sqrt(1 - p * p) - 1)
                });
                _insertEase("Sine", function(p) {
                    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1
                });
                _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
                _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
                    config: function config(steps, immediateStart) {
                        if (steps === void 0) {
                            steps = 1
                        }
                        var p1 = 1 / steps,
                            p2 = steps + (immediateStart ? 0 : 1),
                            p3 = immediateStart ? 1 : 0,
                            max = 1 - _tinyNum;
                        return function(p) {
                            return ((p2 * _clamp(0, max, p) | 0) + p3) * p1
                        }
                    }
                };
                _defaults.ease = _easeMap["quad.out"];
                _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
                    return _callbackNames += name + "," + name + "Params,"
                });
                var GSCache = function GSCache(target, harness) {
                    this.id = _gsID++;
                    target._gsap = this;
                    this.target = target;
                    this.harness = harness;
                    this.get = harness ? harness.get : _getProperty;
                    this.set = harness ? harness.getSetter : _getSetter
                };
                var Animation = function() {
                    function Animation(vars) {
                        this.vars = vars;
                        this._delay = +vars.delay || 0;
                        if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
                            this._rDelay = vars.repeatDelay || 0;
                            this._yoyo = !!vars.yoyo || !!vars.yoyoEase
                        }
                        this._ts = 1;
                        _setDuration(this, +vars.duration, 1, 1);
                        this.data = vars.data;
                        if (_context) {
                            this._ctx = _context;
                            _context.data.push(this)
                        }
                        _tickerActive || _ticker.wake()
                    }
                    var _proto = Animation.prototype;
                    _proto.delay = function delay(value) {
                        if (value || value === 0) {
                            this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
                            this._delay = value;
                            return this
                        }
                        return this._delay
                    };
                    _proto.duration = function duration(value) {
                        return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur
                    };
                    _proto.totalDuration = function totalDuration(value) {
                        if (!arguments.length) {
                            return this._tDur
                        }
                        this._dirty = 0;
                        return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1))
                    };
                    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
                        _wake();
                        if (!arguments.length) {
                            return this._tTime
                        }
                        var parent = this._dp;
                        if (parent && parent.smoothChildTiming && this._ts) {
                            _alignPlayhead(this, _totalTime);
                            !parent._dp || parent.parent || _postAddChecks(parent, this);
                            while (parent && parent.parent) {
                                if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
                                    parent.totalTime(parent._tTime, !0)
                                }
                                parent = parent.parent
                            }
                            if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
                                _addToTimeline(this._dp, this, this._start - this._delay)
                            }
                        }
                        if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
                            this._ts || (this._pTime = _totalTime);
                            _lazySafeRender(this, _totalTime, suppressEvents)
                        }
                        return this
                    };
                    _proto.time = function time(value, suppressEvents) {
                        return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time
                    };
                    _proto.totalProgress = function totalProgress(value, suppressEvents) {
                        return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
                    };
                    _proto.progress = function progress(value, suppressEvents) {
                        return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
                    };
                    _proto.iteration = function iteration(value, suppressEvents) {
                        var cycleDuration = this.duration() + this._rDelay;
                        return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1
                    };
                    _proto.timeScale = function timeScale(value, suppressEvents) {
                        if (!arguments.length) {
                            return this._rts === -_tinyNum ? 0 : this._rts
                        }
                        if (this._rts === value) {
                            return this
                        }
                        var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
                        this._rts = +value || 0;
                        this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
                        this.totalTime(_clamp(-Math.abs(this._delay), this._tDur, tTime), suppressEvents !== !1);
                        _setEnd(this);
                        return _recacheAncestors(this)
                    };
                    _proto.paused = function paused(value) {
                        if (!arguments.length) {
                            return this._ps
                        }
                        if (this._ps !== value) {
                            this._ps = value;
                            if (value) {
                                this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
                                this._ts = this._act = 0
                            } else {
                                _wake();
                                this._ts = this._rts;
                                this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum))
                            }
                        }
                        return this
                    };
                    _proto.startTime = function startTime(value) {
                        if (arguments.length) {
                            this._start = value;
                            var parent = this.parent || this._dp;
                            parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
                            return this
                        }
                        return this._start
                    };
                    _proto.endTime = function endTime(includeRepeats) {
                        return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
                    };
                    _proto.rawTime = function rawTime(wrapRepeats) {
                        var parent = this.parent || this._dp;
                        return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this)
                    };
                    _proto.revert = function revert(config) {
                        if (config === void 0) {
                            config = _revertConfig
                        }
                        var prevIsReverting = _reverting;
                        _reverting = config;
                        if (this._initted || this._startAt) {
                            this.timeline && this.timeline.revert(config);
                            this.totalTime(-0.01, config.suppressEvents)
                        }
                        this.data !== "nested" && config.kill !== !1 && this.kill();
                        _reverting = prevIsReverting;
                        return this
                    };
                    _proto.globalTime = function globalTime(rawTime) {
                        var animation = this,
                            time = arguments.length ? rawTime : animation.rawTime();
                        while (animation) {
                            time = animation._start + time / (Math.abs(animation._ts) || 1);
                            animation = animation._dp
                        }
                        return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time
                    };
                    _proto.repeat = function repeat(value) {
                        if (arguments.length) {
                            this._repeat = value === Infinity ? -2 : value;
                            return _onUpdateTotalDuration(this)
                        }
                        return this._repeat === -2 ? Infinity : this._repeat
                    };
                    _proto.repeatDelay = function repeatDelay(value) {
                        if (arguments.length) {
                            var time = this._time;
                            this._rDelay = value;
                            _onUpdateTotalDuration(this);
                            return time ? this.time(time) : this
                        }
                        return this._rDelay
                    };
                    _proto.yoyo = function yoyo(value) {
                        if (arguments.length) {
                            this._yoyo = value;
                            return this
                        }
                        return this._yoyo
                    };
                    _proto.seek = function seek(position, suppressEvents) {
                        return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents))
                    };
                    _proto.restart = function restart(includeDelay, suppressEvents) {
                        return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents))
                    };
                    _proto.play = function play(from, suppressEvents) {
                        from != null && this.seek(from, suppressEvents);
                        return this.reversed(!1).paused(!1)
                    };
                    _proto.reverse = function reverse(from, suppressEvents) {
                        from != null && this.seek(from || this.totalDuration(), suppressEvents);
                        return this.reversed(!0).paused(!1)
                    };
                    _proto.pause = function pause(atTime, suppressEvents) {
                        atTime != null && this.seek(atTime, suppressEvents);
                        return this.paused(!0)
                    };
                    _proto.resume = function resume() {
                        return this.paused(!1)
                    };
                    _proto.reversed = function reversed(value) {
                        if (arguments.length) {
                            !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
                            return this
                        }
                        return this._rts < 0
                    };
                    _proto.invalidate = function invalidate() {
                        this._initted = this._act = 0;
                        this._zTime = -_tinyNum;
                        return this
                    };
                    _proto.isActive = function isActive() {
                        var parent = this.parent || this._dp,
                            start = this._start,
                            rawTime;
                        return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(!0)) >= start && rawTime < this.endTime(!0) - _tinyNum)
                    };
                    _proto.eventCallback = function eventCallback(type, callback, params) {
                        var vars = this.vars;
                        if (arguments.length > 1) {
                            if (!callback) {
                                delete vars[type]
                            } else {
                                vars[type] = callback;
                                params && (vars[type + "Params"] = params);
                                type === "onUpdate" && (this._onUpdate = callback)
                            }
                            return this
                        }
                        return vars[type]
                    };
                    _proto.then = function then(onFulfilled) {
                        var self = this;
                        return new Promise(function(resolve) {
                            var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
                                _resolve = function _resolve() {
                                    var _then = self.then;
                                    self.then = null;
                                    _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
                                    resolve(f);
                                    self.then = _then
                                };
                            if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
                                _resolve()
                            } else {
                                self._prom = _resolve
                            }
                        })
                    };
                    _proto.kill = function kill() {
                        _interrupt(this)
                    };
                    return Animation
                }();
                _setDefaults(Animation.prototype, {
                    _time: 0,
                    _start: 0,
                    _end: 0,
                    _tTime: 0,
                    _tDur: 0,
                    _dirty: 0,
                    _repeat: 0,
                    _yoyo: !1,
                    parent: null,
                    _initted: !1,
                    _rDelay: 0,
                    _ts: 1,
                    _dp: 0,
                    ratio: 0,
                    _zTime: -_tinyNum,
                    _prom: 0,
                    _ps: !1,
                    _rts: 1
                });
                var Timeline = function(_Animation) {
                    _inheritsLoose(Timeline, _Animation);

                    function Timeline(vars, position) {
                        var _this;
                        if (vars === void 0) {
                            vars = {}
                        }
                        _this = _Animation.call(this, vars) || this;
                        _this.labels = {};
                        _this.smoothChildTiming = !!vars.smoothChildTiming;
                        _this.autoRemoveChildren = !!vars.autoRemoveChildren;
                        _this._sort = _isNotFalse(vars.sortChildren);
                        _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
                        vars.reversed && _this.reverse();
                        vars.paused && _this.paused(!0);
                        vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
                        return _this
                    }
                    var _proto2 = Timeline.prototype;
                    _proto2.to = function to(targets, vars, position) {
                        _createTweenType(0, arguments, this);
                        return this
                    };
                    _proto2.from = function from(targets, vars, position) {
                        _createTweenType(1, arguments, this);
                        return this
                    };
                    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
                        _createTweenType(2, arguments, this);
                        return this
                    };
                    _proto2.set = function set(targets, vars, position) {
                        vars.duration = 0;
                        vars.parent = this;
                        _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
                        vars.immediateRender = !!vars.immediateRender;
                        new Tween(targets, vars, _parsePosition(this, position), 1);
                        return this
                    };
                    _proto2.call = function call(callback, params, position) {
                        return _addToTimeline(this, Tween.delayedCall(0, callback, params), position)
                    };
                    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        vars.duration = duration;
                        vars.stagger = vars.stagger || stagger;
                        vars.onComplete = onCompleteAll;
                        vars.onCompleteParams = onCompleteAllParams;
                        vars.parent = this;
                        new Tween(targets, vars, _parsePosition(this, position));
                        return this
                    };
                    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        vars.runBackwards = 1;
                        _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
                        return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams)
                    };
                    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
                        toVars.startAt = fromVars;
                        _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
                        return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams)
                    };
                    _proto2.render = function render(totalTime, suppressEvents, force) {
                        var prevTime = this._time,
                            tDur = this._dirty ? this.totalDuration() : this._tDur,
                            dur = this._dur,
                            tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
                            crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
                            time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
                        this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
                        if (tTime !== this._tTime || force || crossingStart) {
                            if (prevTime !== this._time && dur) {
                                tTime += this._time - prevTime;
                                totalTime += this._time - prevTime
                            }
                            time = tTime;
                            prevStart = this._start;
                            timeScale = this._ts;
                            prevPaused = !timeScale;
                            if (crossingStart) {
                                dur || (prevTime = this._zTime);
                                (totalTime || !suppressEvents) && (this._zTime = totalTime)
                            }
                            if (this._repeat) {
                                yoyo = this._yoyo;
                                cycleDuration = dur + this._rDelay;
                                if (this._repeat < -1 && totalTime < 0) {
                                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force)
                                }
                                time = _roundPrecise(tTime % cycleDuration);
                                if (tTime === tDur) {
                                    iteration = this._repeat;
                                    time = dur
                                } else {
                                    iteration = ~~(tTime / cycleDuration);
                                    if (iteration && iteration === tTime / cycleDuration) {
                                        time = dur;
                                        iteration--
                                    }
                                    time > dur && (time = dur)
                                }
                                prevIteration = _animationCycle(this._tTime, cycleDuration);
                                !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
                                if (yoyo && iteration & 1) {
                                    time = dur - time;
                                    isYoyo = 1
                                }
                                if (iteration !== prevIteration && !this._lock) {
                                    var rewinding = yoyo && prevIteration & 1,
                                        doesWrap = rewinding === (yoyo && iteration & 1);
                                    iteration < prevIteration && (rewinding = !rewinding);
                                    prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
                                    this._lock = 1;
                                    this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
                                    this._tTime = tTime;
                                    !suppressEvents && this.parent && _callback(this, "onRepeat");
                                    this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
                                    if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
                                        return this
                                    }
                                    dur = this._dur;
                                    tDur = this._tDur;
                                    if (doesWrap) {
                                        this._lock = 2;
                                        prevTime = rewinding ? dur : -0.0001;
                                        this.render(prevTime, !0);
                                        this.vars.repeatRefresh && !isYoyo && this.invalidate()
                                    }
                                    this._lock = 0;
                                    if (!this._ts && !prevPaused) {
                                        return this
                                    }
                                    _propagateYoyoEase(this, isYoyo)
                                }
                            }
                            if (this._hasPause && !this._forcing && this._lock < 2) {
                                pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
                                if (pauseTween) {
                                    tTime -= time - (time = pauseTween._start)
                                }
                            }
                            this._tTime = tTime;
                            this._time = time;
                            this._act = !timeScale;
                            if (!this._initted) {
                                this._onUpdate = this.vars.onUpdate;
                                this._initted = 1;
                                this._zTime = totalTime;
                                prevTime = 0
                            }
                            if (!prevTime && time && !suppressEvents && !iteration) {
                                _callback(this, "onStart");
                                if (this._tTime !== tTime) {
                                    return this
                                }
                            }
                            if (time >= prevTime && totalTime >= 0) {
                                child = this._first;
                                while (child) {
                                    next = child._next;
                                    if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
                                        if (child.parent !== this) {
                                            return this.render(totalTime, suppressEvents, force)
                                        }
                                        child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
                                        if (time !== this._time || !this._ts && !prevPaused) {
                                            pauseTween = 0;
                                            next && (tTime += this._zTime = -_tinyNum);
                                            break
                                        }
                                    }
                                    child = next
                                }
                            } else {
                                child = this._last;
                                var adjustedTime = totalTime < 0 ? totalTime : time;
                                while (child) {
                                    next = child._prev;
                                    if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
                                        if (child.parent !== this) {
                                            return this.render(totalTime, suppressEvents, force)
                                        }
                                        child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && (child._initted || child._startAt));
                                        if (time !== this._time || !this._ts && !prevPaused) {
                                            pauseTween = 0;
                                            next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                                            break
                                        }
                                    }
                                    child = next
                                }
                            }
                            if (pauseTween && !suppressEvents) {
                                this.pause();
                                pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
                                if (this._ts) {
                                    this._start = prevStart;
                                    _setEnd(this);
                                    return this.render(totalTime, suppressEvents, force)
                                }
                            }
                            this._onUpdate && !suppressEvents && _callback(this, "onUpdate", !0);
                            if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime)
                                if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts))
                                    if (!this._lock) {
                                        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                                        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                                            _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", !0);
                                            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom()
                                        }
                                    }
                        }
                        return this
                    };
                    _proto2.add = function add(child, position) {
                        var _this2 = this;
                        _isNumber(position) || (position = _parsePosition(this, position, child));
                        if (!(child instanceof Animation)) {
                            if (_isArray(child)) {
                                child.forEach(function(obj) {
                                    return _this2.add(obj, position)
                                });
                                return this
                            }
                            if (_isString(child)) {
                                return this.addLabel(child, position)
                            }
                            if (_isFunction(child)) {
                                child = Tween.delayedCall(0, child)
                            } else {
                                return this
                            }
                        }
                        return this !== child ? _addToTimeline(this, child, position) : this
                    };
                    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
                        if (nested === void 0) {
                            nested = !0
                        }
                        if (tweens === void 0) {
                            tweens = !0
                        }
                        if (timelines === void 0) {
                            timelines = !0
                        }
                        if (ignoreBeforeTime === void 0) {
                            ignoreBeforeTime = -_bigNum
                        }
                        var a = [],
                            child = this._first;
                        while (child) {
                            if (child._start >= ignoreBeforeTime) {
                                if (child instanceof Tween) {
                                    tweens && a.push(child)
                                } else {
                                    timelines && a.push(child);
                                    nested && a.push.apply(a, child.getChildren(!0, tweens, timelines))
                                }
                            }
                            child = child._next
                        }
                        return a
                    };
                    _proto2.getById = function getById(id) {
                        var animations = this.getChildren(1, 1, 1),
                            i = animations.length;
                        while (i--) {
                            if (animations[i].vars.id === id) {
                                return animations[i]
                            }
                        }
                    };
                    _proto2.remove = function remove(child) {
                        if (_isString(child)) {
                            return this.removeLabel(child)
                        }
                        if (_isFunction(child)) {
                            return this.killTweensOf(child)
                        }
                        _removeLinkedListItem(this, child);
                        if (child === this._recent) {
                            this._recent = this._last
                        }
                        return _uncache(this)
                    };
                    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
                        if (!arguments.length) {
                            return this._tTime
                        }
                        this._forcing = 1;
                        if (!this._dp && this._ts) {
                            this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts))
                        }
                        _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
                        this._forcing = 0;
                        return this
                    };
                    _proto2.addLabel = function addLabel(label, position) {
                        this.labels[label] = _parsePosition(this, position);
                        return this
                    };
                    _proto2.removeLabel = function removeLabel(label) {
                        delete this.labels[label];
                        return this
                    };
                    _proto2.addPause = function addPause(position, callback, params) {
                        var t = Tween.delayedCall(0, callback || _emptyFunc, params);
                        t.data = "isPause";
                        this._hasPause = 1;
                        return _addToTimeline(this, t, _parsePosition(this, position))
                    };
                    _proto2.removePause = function removePause(position) {
                        var child = this._first;
                        position = _parsePosition(this, position);
                        while (child) {
                            if (child._start === position && child.data === "isPause") {
                                _removeFromParent(child)
                            }
                            child = child._next
                        }
                    };
                    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        var tweens = this.getTweensOf(targets, onlyActive),
                            i = tweens.length;
                        while (i--) {
                            _overwritingTween !== tweens[i] && tweens[i].kill(targets, props)
                        }
                        return this
                    };
                    _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
                        var a = [],
                            parsedTargets = toArray(targets),
                            child = this._first,
                            isGlobalTime = _isNumber(onlyActive),
                            children;
                        while (child) {
                            if (child instanceof Tween) {
                                if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
                                    a.push(child)
                                }
                            } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
                                a.push.apply(a, children)
                            }
                            child = child._next
                        }
                        return a
                    };
                    _proto2.tweenTo = function tweenTo(position, vars) {
                        vars = vars || {};
                        var tl = this,
                            endTime = _parsePosition(tl, position),
                            _vars = vars,
                            startAt = _vars.startAt,
                            _onStart = _vars.onStart,
                            onStartParams = _vars.onStartParams,
                            immediateRender = _vars.immediateRender,
                            initted, tween = Tween.to(tl, _setDefaults({
                                ease: vars.ease || "none",
                                lazy: !1,
                                immediateRender: !1,
                                time: endTime,
                                overwrite: "auto",
                                duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
                                onStart: function onStart() {
                                    tl.pause();
                                    if (!initted) {
                                        var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
                                        tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, !0, !0);
                                        initted = 1
                                    }
                                    _onStart && _onStart.apply(tween, onStartParams || [])
                                }
                            }, vars));
                        return immediateRender ? tween.render(0) : tween
                    };
                    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
                        return this.tweenTo(toPosition, _setDefaults({
                            startAt: {
                                time: _parsePosition(this, fromPosition)
                            }
                        }, vars))
                    };
                    _proto2.recent = function recent() {
                        return this._recent
                    };
                    _proto2.nextLabel = function nextLabel(afterTime) {
                        if (afterTime === void 0) {
                            afterTime = this._time
                        }
                        return _getLabelInDirection(this, _parsePosition(this, afterTime))
                    };
                    _proto2.previousLabel = function previousLabel(beforeTime) {
                        if (beforeTime === void 0) {
                            beforeTime = this._time
                        }
                        return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1)
                    };
                    _proto2.currentLabel = function currentLabel(value) {
                        return arguments.length ? this.seek(value, !0) : this.previousLabel(this._time + _tinyNum)
                    };
                    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
                        if (ignoreBeforeTime === void 0) {
                            ignoreBeforeTime = 0
                        }
                        var child = this._first,
                            labels = this.labels,
                            p;
                        while (child) {
                            if (child._start >= ignoreBeforeTime) {
                                child._start += amount;
                                child._end += amount
                            }
                            child = child._next
                        }
                        if (adjustLabels) {
                            for (p in labels) {
                                if (labels[p] >= ignoreBeforeTime) {
                                    labels[p] += amount
                                }
                            }
                        }
                        return _uncache(this)
                    };
                    _proto2.invalidate = function invalidate(soft) {
                        var child = this._first;
                        this._lock = 0;
                        while (child) {
                            child.invalidate(soft);
                            child = child._next
                        }
                        return _Animation.prototype.invalidate.call(this, soft)
                    };
                    _proto2.clear = function clear(includeLabels) {
                        if (includeLabels === void 0) {
                            includeLabels = !0
                        }
                        var child = this._first,
                            next;
                        while (child) {
                            next = child._next;
                            this.remove(child);
                            child = next
                        }
                        this._dp && (this._time = this._tTime = this._pTime = 0);
                        includeLabels && (this.labels = {});
                        return _uncache(this)
                    };
                    _proto2.totalDuration = function totalDuration(value) {
                        var max = 0,
                            self = this,
                            child = self._last,
                            prevStart = _bigNum,
                            prev, start, parent;
                        if (arguments.length) {
                            return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value))
                        }
                        if (self._dirty) {
                            parent = self.parent;
                            while (child) {
                                prev = child._prev;
                                child._dirty && child.totalDuration();
                                start = child._start;
                                if (start > prevStart && self._sort && child._ts && !self._lock) {
                                    self._lock = 1;
                                    _addToTimeline(self, child, start - child._delay, 1)._lock = 0
                                } else {
                                    prevStart = start
                                }
                                if (start < 0 && child._ts) {
                                    max -= start;
                                    if (!parent && !self._dp || parent && parent.smoothChildTiming) {
                                        self._start += start / self._ts;
                                        self._time -= start;
                                        self._tTime -= start
                                    }
                                    self.shiftChildren(-start, !1, -1e999);
                                    prevStart = 0
                                }
                                child._end > max && child._ts && (max = child._end);
                                child = prev
                            }
                            _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);
                            self._dirty = 0
                        }
                        return self._tDur
                    };
                    Timeline.updateRoot = function updateRoot(time) {
                        if (_globalTimeline._ts) {
                            _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
                            _lastRenderedFrame = _ticker.frame
                        }
                        if (_ticker.frame >= _nextGCFrame) {
                            _nextGCFrame += _config.autoSleep || 120;
                            var child = _globalTimeline._first;
                            if (!child || !child._ts)
                                if (_config.autoSleep && _ticker._listeners.length < 2) {
                                    while (child && !child._ts) {
                                        child = child._next
                                    }
                                    child || _ticker.sleep()
                                }
                        }
                    };
                    return Timeline
                }(Animation);
                _setDefaults(Timeline.prototype, {
                    _lock: 0,
                    _hasPause: 0,
                    _forcing: 0
                });
                var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
                        var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
                            index = 0,
                            matchIndex = 0,
                            result, startNums, color, endNum, chunk, startNum, hasRandom, a;
                        pt.b = start;
                        pt.e = end;
                        start += "";
                        end += "";
                        if (hasRandom = ~end.indexOf("random(")) {
                            end = _replaceRandom(end)
                        }
                        if (stringFilter) {
                            a = [start, end];
                            stringFilter(a, target, prop);
                            start = a[0];
                            end = a[1]
                        }
                        startNums = start.match(_complexStringNumExp) || [];
                        while (result = _complexStringNumExp.exec(end)) {
                            endNum = result[0];
                            chunk = end.substring(index, result.index);
                            if (color) {
                                color = (color + 1) % 5
                            } else if (chunk.substr(-5) === "rgba(") {
                                color = 1
                            }
                            if (endNum !== startNums[matchIndex++]) {
                                startNum = parseFloat(startNums[matchIndex - 1]) || 0;
                                pt._pt = {
                                    _next: pt._pt,
                                    p: chunk || matchIndex === 1 ? chunk : ",",
                                    s: startNum,
                                    c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
                                    m: color && color < 4 ? Math.round : 0
                                };
                                index = _complexStringNumExp.lastIndex
                            }
                        }
                        pt.c = index < end.length ? end.substring(index, end.length) : "";
                        pt.fp = funcParam;
                        if (_relExp.test(end) || hasRandom) {
                            pt.e = 0
                        }
                        this._pt = pt;
                        return pt
                    },
                    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
                        _isFunction(end) && (end = end(index || 0, target, targets));
                        var currentValue = target[prop],
                            parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
                            setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
                            pt;
                        if (_isString(end)) {
                            if (~end.indexOf("random(")) {
                                end = _replaceRandom(end)
                            }
                            if (end.charAt(1) === "=") {
                                pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
                                if (pt || pt === 0) {
                                    end = pt
                                }
                            }
                        }
                        if (!optional || parsedStart !== end || _forceAllPropTweens) {
                            if (!isNaN(parsedStart * end) && end !== "") {
                                pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
                                funcParam && (pt.fp = funcParam);
                                modifier && pt.modifier(modifier, this, target);
                                return this._pt = pt
                            }!currentValue && !(prop in target) && _missingPlugin(prop, end);
                            return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam)
                        }
                    },
                    _processVars = function _processVars(vars, index, target, targets, tween) {
                        _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
                        if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
                            return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars
                        }
                        var copy = {},
                            p;
                        for (p in vars) {
                            copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets)
                        }
                        return copy
                    },
                    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
                        var plugin, pt, ptLookup, i;
                        if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== !1) {
                            tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
                            if (tween !== _quickTween) {
                                ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
                                i = plugin._props.length;
                                while (i--) {
                                    ptLookup[plugin._props[i]] = pt
                                }
                            }
                        }
                        return plugin
                    },
                    _overwritingTween, _forceAllPropTweens, _initTween = function _initTween(tween, time, tTime) {
                        var vars = tween.vars,
                            ease = vars.ease,
                            startAt = vars.startAt,
                            immediateRender = vars.immediateRender,
                            lazy = vars.lazy,
                            onUpdate = vars.onUpdate,
                            runBackwards = vars.runBackwards,
                            yoyoEase = vars.yoyoEase,
                            keyframes = vars.keyframes,
                            autoRevert = vars.autoRevert,
                            dur = tween._dur,
                            prevStartAt = tween._startAt,
                            targets = tween._targets,
                            parent = tween.parent,
                            fullTargets = parent && parent.data === "nested" ? parent.vars.targets : targets,
                            autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
                            tl = tween.timeline,
                            cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
                        tl && (!keyframes || !ease) && (ease = "none");
                        tween._ease = _parseEase(ease, _defaults.ease);
                        tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === !0 ? ease : yoyoEase, _defaults.ease)) : 0;
                        if (yoyoEase && tween._yoyo && !tween._repeat) {
                            yoyoEase = tween._yEase;
                            tween._yEase = tween._ease;
                            tween._ease = yoyoEase
                        }
                        tween._from = !tl && !!vars.runBackwards;
                        if (!tl || keyframes && !vars.stagger) {
                            harness = targets[0] ? _getCache(targets[0]).harness : 0;
                            harnessVars = harness && vars[harness.prop];
                            cleanVars = _copyExcluding(vars, _reservedProps);
                            if (prevStartAt) {
                                prevStartAt._zTime < 0 && prevStartAt.progress(1);
                                time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, !0) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
                                prevStartAt._lazy = 0
                            }
                            if (startAt) {
                                _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
                                    data: "isStart",
                                    overwrite: !1,
                                    parent: parent,
                                    immediateRender: !0,
                                    lazy: !prevStartAt && _isNotFalse(lazy),
                                    startAt: null,
                                    delay: 0,
                                    onUpdate: onUpdate && function() {
                                        return _callback(tween, "onUpdate")
                                    },
                                    stagger: 0
                                }, startAt)));
                                tween._startAt._dp = 0;
                                tween._startAt._sat = tween;
                                time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
                                if (immediateRender) {
                                    if (dur && time <= 0 && tTime <= 0) {
                                        time && (tween._zTime = time);
                                        return
                                    }
                                }
                            } else if (runBackwards && dur) {
                                if (!prevStartAt) {
                                    time && (immediateRender = !1);
                                    p = _setDefaults({
                                        overwrite: !1,
                                        data: "isFromStart",
                                        lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
                                        immediateRender: immediateRender,
                                        stagger: 0,
                                        parent: parent
                                    }, cleanVars);
                                    harnessVars && (p[harness.prop] = harnessVars);
                                    _removeFromParent(tween._startAt = Tween.set(targets, p));
                                    tween._startAt._dp = 0;
                                    tween._startAt._sat = tween;
                                    time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, !0));
                                    tween._zTime = time;
                                    if (!immediateRender) {
                                        _initTween(tween._startAt, _tinyNum, _tinyNum)
                                    } else if (!time) {
                                        return
                                    }
                                }
                            }
                            tween._pt = tween._ptCache = 0;
                            lazy = dur && _isNotFalse(lazy) || lazy && !dur;
                            for (i = 0; i < targets.length; i++) {
                                target = targets[i];
                                gsData = target._gsap || _harness(targets)[i]._gsap;
                                tween._ptLookup[i] = ptLookup = {};
                                _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
                                index = fullTargets === targets ? i : fullTargets.indexOf(target);
                                if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== !1) {
                                    tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
                                    plugin._props.forEach(function(name) {
                                        ptLookup[name] = pt
                                    });
                                    plugin.priority && (hasPriority = 1)
                                }
                                if (!harness || harnessVars) {
                                    for (p in cleanVars) {
                                        if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
                                            plugin.priority && (hasPriority = 1)
                                        } else {
                                            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter)
                                        }
                                    }
                                }
                                tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
                                if (autoOverwrite && tween._pt) {
                                    _overwritingTween = tween;
                                    _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
                                    overwritten = !tween.parent;
                                    _overwritingTween = 0
                                }
                                tween._pt && lazy && (_lazyLookup[gsData.id] = 1)
                            }
                            hasPriority && _sortPropTweensByPriority(tween);
                            tween._onInit && tween._onInit(tween)
                        }
                        tween._onUpdate = onUpdate;
                        tween._initted = (!tween._op || tween._pt) && !overwritten;
                        keyframes && time <= 0 && tl.render(_bigNum, !0, !0)
                    },
                    _updatePropTweens = function _updatePropTweens(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
                        var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property],
                            pt, rootPT, lookup, i;
                        if (!ptCache) {
                            ptCache = tween._ptCache[property] = [];
                            lookup = tween._ptLookup;
                            i = tween._targets.length;
                            while (i--) {
                                pt = lookup[i][property];
                                if (pt && pt.d && pt.d._pt) {
                                    pt = pt.d._pt;
                                    while (pt && pt.p !== property && pt.fp !== property) {
                                        pt = pt._next
                                    }
                                }
                                if (!pt) {
                                    _forceAllPropTweens = 1;
                                    tween.vars[property] = "+=0";
                                    _initTween(tween, time);
                                    _forceAllPropTweens = 0;
                                    return skipRecursion ? _warn(property + " not eligible for reset") : 1
                                }
                                ptCache.push(pt)
                            }
                        }
                        i = ptCache.length;
                        while (i--) {
                            rootPT = ptCache[i];
                            pt = rootPT._pt || rootPT;
                            pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
                            pt.c = value - pt.s;
                            rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
                            rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b))
                        }
                    },
                    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
                        var harness = targets[0] ? _getCache(targets[0]).harness : 0,
                            propertyAliases = harness && harness.aliases,
                            copy, p, i, aliases;
                        if (!propertyAliases) {
                            return vars
                        }
                        copy = _merge({}, vars);
                        for (p in propertyAliases) {
                            if (p in copy) {
                                aliases = propertyAliases[p].split(",");
                                i = aliases.length;
                                while (i--) {
                                    copy[aliases[i]] = copy[p]
                                }
                            }
                        }
                        return copy
                    },
                    _parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
                        var ease = obj.ease || easeEach || "power1.inOut",
                            p, a;
                        if (_isArray(obj)) {
                            a = allProps[prop] || (allProps[prop] = []);
                            obj.forEach(function(value, i) {
                                return a.push({
                                    t: i / (obj.length - 1) * 100,
                                    v: value,
                                    e: ease
                                })
                            })
                        } else {
                            for (p in obj) {
                                a = allProps[p] || (allProps[p] = []);
                                p === "ease" || a.push({
                                    t: parseFloat(prop),
                                    v: obj[p],
                                    e: ease
                                })
                            }
                        }
                    },
                    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
                        return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value
                    },
                    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
                    _staggerPropsToSkip = {};
                _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
                    return _staggerPropsToSkip[name] = 1
                });
                var Tween = function(_Animation2) {
                    _inheritsLoose(Tween, _Animation2);

                    function Tween(targets, vars, position, skipInherit) {
                        var _this3;
                        if (typeof vars === "number") {
                            position.duration = vars;
                            vars = position;
                            position = null
                        }
                        _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
                        var _this3$vars = _this3.vars,
                            duration = _this3$vars.duration,
                            delay = _this3$vars.delay,
                            immediateRender = _this3$vars.immediateRender,
                            stagger = _this3$vars.stagger,
                            overwrite = _this3$vars.overwrite,
                            keyframes = _this3$vars.keyframes,
                            defaults = _this3$vars.defaults,
                            scrollTrigger = _this3$vars.scrollTrigger,
                            yoyoEase = _this3$vars.yoyoEase,
                            parent = vars.parent || _globalTimeline,
                            parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
                            tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
                        _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
                        _this3._ptLookup = [];
                        _this3._overwrite = overwrite;
                        if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                            vars = _this3.vars;
                            tl = _this3.timeline = new Timeline({
                                data: "nested",
                                defaults: defaults || {},
                                targets: parent && parent.data === "nested" ? parent.vars.targets : parsedTargets
                            });
                            tl.kill();
                            tl.parent = tl._dp = _assertThisInitialized(_this3);
                            tl._start = 0;
                            if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
                                l = parsedTargets.length;
                                staggerFunc = stagger && distribute(stagger);
                                if (_isObject(stagger)) {
                                    for (p in stagger) {
                                        if (~_staggerTweenProps.indexOf(p)) {
                                            staggerVarsToMerge || (staggerVarsToMerge = {});
                                            staggerVarsToMerge[p] = stagger[p]
                                        }
                                    }
                                }
                                for (i = 0; i < l; i++) {
                                    copy = _copyExcluding(vars, _staggerPropsToSkip);
                                    copy.stagger = 0;
                                    yoyoEase && (copy.yoyoEase = yoyoEase);
                                    staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
                                    curTarget = parsedTargets[i];
                                    copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
                                    copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
                                    if (!stagger && l === 1 && copy.delay) {
                                        _this3._delay = delay = copy.delay;
                                        _this3._start += delay;
                                        copy.delay = 0
                                    }
                                    tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
                                    tl._ease = _easeMap.none
                                }
                                tl.duration() ? duration = delay = 0 : _this3.timeline = 0
                            } else if (keyframes) {
                                _inheritDefaults(_setDefaults(tl.vars.defaults, {
                                    ease: "none"
                                }));
                                tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
                                var time = 0,
                                    a, kf, v;
                                if (_isArray(keyframes)) {
                                    keyframes.forEach(function(frame) {
                                        return tl.to(parsedTargets, frame, ">")
                                    });
                                    tl.duration()
                                } else {
                                    copy = {};
                                    for (p in keyframes) {
                                        p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach)
                                    }
                                    for (p in copy) {
                                        a = copy[p].sort(function(a, b) {
                                            return a.t - b.t
                                        });
                                        time = 0;
                                        for (i = 0; i < a.length; i++) {
                                            kf = a[i];
                                            v = {
                                                ease: kf.e,
                                                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                                            };
                                            v[p] = kf.v;
                                            tl.to(parsedTargets, v, time);
                                            time += v.duration
                                        }
                                    }
                                    tl.duration() < duration && tl.to({}, {
                                        duration: duration - tl.duration()
                                    })
                                }
                            }
                            duration || _this3.duration(duration = tl.duration())
                        } else {
                            _this3.timeline = 0
                        }
                        if (overwrite === !0 && !_suppressOverwrites) {
                            _overwritingTween = _assertThisInitialized(_this3);
                            _globalTimeline.killTweensOf(parsedTargets);
                            _overwritingTween = 0
                        }
                        _addToTimeline(parent, _assertThisInitialized(_this3), position);
                        vars.reversed && _this3.reverse();
                        vars.paused && _this3.paused(!0);
                        if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
                            _this3._tTime = -_tinyNum;
                            _this3.render(Math.max(0, -delay) || 0)
                        }
                        scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
                        return _this3
                    }
                    var _proto3 = Tween.prototype;
                    _proto3.render = function render(totalTime, suppressEvents, force) {
                        var prevTime = this._time,
                            tDur = this._tDur,
                            dur = this._dur,
                            isNegative = totalTime < 0,
                            tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime,
                            time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline, yoyoEase;
                        if (!dur) {
                            _renderZeroDurationTween(this, totalTime, suppressEvents, force)
                        } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative) {
                            time = tTime;
                            timeline = this.timeline;
                            if (this._repeat) {
                                cycleDuration = dur + this._rDelay;
                                if (this._repeat < -1 && isNegative) {
                                    return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force)
                                }
                                time = _roundPrecise(tTime % cycleDuration);
                                if (tTime === tDur) {
                                    iteration = this._repeat;
                                    time = dur
                                } else {
                                    iteration = ~~(tTime / cycleDuration);
                                    if (iteration && iteration === _roundPrecise(tTime / cycleDuration)) {
                                        time = dur;
                                        iteration--
                                    }
                                    time > dur && (time = dur)
                                }
                                isYoyo = this._yoyo && iteration & 1;
                                if (isYoyo) {
                                    yoyoEase = this._yEase;
                                    time = dur - time
                                }
                                prevIteration = _animationCycle(this._tTime, cycleDuration);
                                if (time === prevTime && !force && this._initted && iteration === prevIteration) {
                                    this._tTime = tTime;
                                    return this
                                }
                                if (iteration !== prevIteration) {
                                    timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
                                    if (this.vars.repeatRefresh && !isYoyo && !this._lock && this._time !== cycleDuration && this._initted) {
                                        this._lock = force = 1;
                                        this.render(_roundPrecise(cycleDuration * iteration), !0).invalidate()._lock = 0
                                    }
                                }
                            }
                            if (!this._initted) {
                                if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
                                    this._tTime = 0;
                                    return this
                                }
                                if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
                                    return this
                                }
                                if (dur !== this._dur) {
                                    return this.render(totalTime, suppressEvents, force)
                                }
                            }
                            this._tTime = tTime;
                            this._time = time;
                            if (!this._act && this._ts) {
                                this._act = 1;
                                this._lazy = 0
                            }
                            this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
                            if (this._from) {
                                this.ratio = ratio = 1 - ratio
                            }
                            if (time && !prevTime && !suppressEvents && !iteration) {
                                _callback(this, "onStart");
                                if (this._tTime !== tTime) {
                                    return this
                                }
                            }
                            pt = this._pt;
                            while (pt) {
                                pt.r(ratio, pt.d);
                                pt = pt._next
                            }
                            timeline && timeline.render(totalTime < 0 ? totalTime : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
                            if (this._onUpdate && !suppressEvents) {
                                isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
                                _callback(this, "onUpdate")
                            }
                            this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
                            if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
                                isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, !0, !0);
                                (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
                                if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
                                    _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", !0);
                                    this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom()
                                }
                            }
                        }
                        return this
                    };
                    _proto3.targets = function targets() {
                        return this._targets
                    };
                    _proto3.invalidate = function invalidate(soft) {
                        (!soft || !this.vars.runBackwards) && (this._startAt = 0);
                        this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
                        this._ptLookup = [];
                        this.timeline && this.timeline.invalidate(soft);
                        return _Animation2.prototype.invalidate.call(this, soft)
                    };
                    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
                        _tickerActive || _ticker.wake();
                        this._ts || this.play();
                        var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
                            ratio;
                        this._initted || _initTween(this, time);
                        ratio = this._ease(time / this._dur);
                        if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
                            return this.resetTo(property, value, start, startIsRelative, 1)
                        }
                        _alignPlayhead(this, 0);
                        this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
                        return this.render(0)
                    };
                    _proto3.kill = function kill(targets, vars) {
                        if (vars === void 0) {
                            vars = "all"
                        }
                        if (!targets && (!vars || vars === "all")) {
                            this._lazy = this._pt = 0;
                            return this.parent ? _interrupt(this) : this
                        }
                        if (this.timeline) {
                            var tDur = this.timeline.totalDuration();
                            this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== !0)._first || _interrupt(this);
                            this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
                            return this
                        }
                        var parsedTargets = this._targets,
                            killingTargets = targets ? toArray(targets) : parsedTargets,
                            propTweenLookup = this._ptLookup,
                            firstPT = this._pt,
                            overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
                        if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
                            vars === "all" && (this._pt = 0);
                            return _interrupt(this)
                        }
                        overwrittenProps = this._op = this._op || [];
                        if (vars !== "all") {
                            if (_isString(vars)) {
                                p = {};
                                _forEachName(vars, function(name) {
                                    return p[name] = 1
                                });
                                vars = p
                            }
                            vars = _addAliasesToVars(parsedTargets, vars)
                        }
                        i = parsedTargets.length;
                        while (i--) {
                            if (~killingTargets.indexOf(parsedTargets[i])) {
                                curLookup = propTweenLookup[i];
                                if (vars === "all") {
                                    overwrittenProps[i] = vars;
                                    props = curLookup;
                                    curOverwriteProps = {}
                                } else {
                                    curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
                                    props = vars
                                }
                                for (p in props) {
                                    pt = curLookup && curLookup[p];
                                    if (pt) {
                                        if (!("kill" in pt.d) || pt.d.kill(p) === !0) {
                                            _removeLinkedListItem(this, pt, "_pt")
                                        }
                                        delete curLookup[p]
                                    }
                                    if (curOverwriteProps !== "all") {
                                        curOverwriteProps[p] = 1
                                    }
                                }
                            }
                        }
                        this._initted && !this._pt && firstPT && _interrupt(this);
                        return this
                    };
                    Tween.to = function to(targets, vars) {
                        return new Tween(targets, vars, arguments[2])
                    };
                    Tween.from = function from(targets, vars) {
                        return _createTweenType(1, arguments)
                    };
                    Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
                        return new Tween(callback, 0, {
                            immediateRender: !1,
                            lazy: !1,
                            overwrite: !1,
                            delay: delay,
                            onComplete: callback,
                            onReverseComplete: callback,
                            onCompleteParams: params,
                            onReverseCompleteParams: params,
                            callbackScope: scope
                        })
                    };
                    Tween.fromTo = function fromTo(targets, fromVars, toVars) {
                        return _createTweenType(2, arguments)
                    };
                    Tween.set = function set(targets, vars) {
                        vars.duration = 0;
                        vars.repeatDelay || (vars.repeat = 0);
                        return new Tween(targets, vars)
                    };
                    Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
                        return _globalTimeline.killTweensOf(targets, props, onlyActive)
                    };
                    return Tween
                }(Animation);
                _setDefaults(Tween.prototype, {
                    _targets: [],
                    _lazy: 0,
                    _startAt: 0,
                    _op: 0,
                    _onInit: 0
                });
                _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
                    Tween[name] = function() {
                        var tl = new Timeline(),
                            params = _slice.call(arguments, 0);
                        params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
                        return tl[name].apply(tl, params)
                    }
                });
                var _setterPlain = function _setterPlain(target, property, value) {
                        return target[property] = value
                    },
                    _setterFunc = function _setterFunc(target, property, value) {
                        return target[property](value)
                    },
                    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
                        return target[property](data.fp, value)
                    },
                    _setterAttribute = function _setterAttribute(target, property, value) {
                        return target.setAttribute(property, value)
                    },
                    _getSetter = function _getSetter(target, property) {
                        return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain
                    },
                    _renderPlain = function _renderPlain(ratio, data) {
                        return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data)
                    },
                    _renderBoolean = function _renderBoolean(ratio, data) {
                        return data.set(data.t, data.p, !!(data.s + data.c * ratio), data)
                    },
                    _renderComplexString = function _renderComplexString(ratio, data) {
                        var pt = data._pt,
                            s = "";
                        if (!ratio && data.b) {
                            s = data.b
                        } else if (ratio === 1 && data.e) {
                            s = data.e
                        } else {
                            while (pt) {
                                s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s;
                                pt = pt._next
                            }
                            s += data.c
                        }
                        data.set(data.t, data.p, s, data)
                    },
                    _renderPropTweens = function _renderPropTweens(ratio, data) {
                        var pt = data._pt;
                        while (pt) {
                            pt.r(ratio, pt.d);
                            pt = pt._next
                        }
                    },
                    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
                        var pt = this._pt,
                            next;
                        while (pt) {
                            next = pt._next;
                            pt.p === property && pt.modifier(modifier, tween, target);
                            pt = next
                        }
                    },
                    _killPropTweensOf = function _killPropTweensOf(property) {
                        var pt = this._pt,
                            hasNonDependentRemaining, next;
                        while (pt) {
                            next = pt._next;
                            if (pt.p === property && !pt.op || pt.op === property) {
                                _removeLinkedListItem(this, pt, "_pt")
                            } else if (!pt.dep) {
                                hasNonDependentRemaining = 1
                            }
                            pt = next
                        }
                        return !hasNonDependentRemaining
                    },
                    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
                        data.mSet(target, property, data.m.call(data.tween, value, data.mt), data)
                    },
                    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
                        var pt = parent._pt,
                            next, pt2, first, last;
                        while (pt) {
                            next = pt._next;
                            pt2 = first;
                            while (pt2 && pt2.pr > pt.pr) {
                                pt2 = pt2._next
                            }
                            if (pt._prev = pt2 ? pt2._prev : last) {
                                pt._prev._next = pt
                            } else {
                                first = pt
                            }
                            if (pt._next = pt2) {
                                pt2._prev = pt
                            } else {
                                last = pt
                            }
                            pt = next
                        }
                        parent._pt = first
                    };
                var PropTween = function() {
                    function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
                        this.t = target;
                        this.s = start;
                        this.c = change;
                        this.p = prop;
                        this.r = renderer || _renderPlain;
                        this.d = data || this;
                        this.set = setter || _setterPlain;
                        this.pr = priority || 0;
                        this._next = next;
                        if (next) {
                            next._prev = this
                        }
                    }
                    var _proto4 = PropTween.prototype;
                    _proto4.modifier = function modifier(func, tween, target) {
                        this.mSet = this.mSet || this.set;
                        this.set = _setterWithModifier;
                        this.m = func;
                        this.mt = target;
                        this.tween = tween
                    };
                    return PropTween
                }();
                _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
                    return _reservedProps[name] = 1
                });
                _globals.TweenMax = _globals.TweenLite = Tween;
                _globals.TimelineLite = _globals.TimelineMax = Timeline;
                _globalTimeline = new Timeline({
                    sortChildren: !1,
                    defaults: _defaults,
                    autoRemoveChildren: !0,
                    id: "root",
                    smoothChildTiming: !0
                });
                _config.stringFilter = _colorStringFilter;
                var _media = [],
                    _listeners = {},
                    _emptyArray = [],
                    _lastMediaTime = 0,
                    _contextID = 0,
                    _dispatch = function _dispatch(type) {
                        return (_listeners[type] || _emptyArray).map(function(f) {
                            return f()
                        })
                    },
                    _onMediaChange = function _onMediaChange() {
                        var time = Date.now(),
                            matches = [];
                        if (time - _lastMediaTime > 2) {
                            _dispatch("matchMediaInit");
                            _media.forEach(function(c) {
                                var queries = c.queries,
                                    conditions = c.conditions,
                                    match, p, anyMatch, toggled;
                                for (p in queries) {
                                    match = _win.matchMedia(queries[p]).matches;
                                    match && (anyMatch = 1);
                                    if (match !== conditions[p]) {
                                        conditions[p] = match;
                                        toggled = 1
                                    }
                                }
                                if (toggled) {
                                    c.revert();
                                    anyMatch && matches.push(c)
                                }
                            });
                            _dispatch("matchMediaRevert");
                            matches.forEach(function(c) {
                                return c.onMatch(c, function(func) {
                                    return c.add(null, func)
                                })
                            });
                            _lastMediaTime = time;
                            _dispatch("matchMedia")
                        }
                    };
                var Context = function() {
                    function Context(func, scope) {
                        this.selector = scope && selector(scope);
                        this.data = [];
                        this._r = [];
                        this.isReverted = !1;
                        this.id = _contextID++;
                        func && this.add(func)
                    }
                    var _proto5 = Context.prototype;
                    _proto5.add = function add(name, func, scope) {
                        if (_isFunction(name)) {
                            scope = func;
                            func = name;
                            name = _isFunction
                        }
                        var self = this,
                            f = function f() {
                                var prev = _context,
                                    prevSelector = self.selector,
                                    result;
                                prev && prev !== self && prev.data.push(self);
                                scope && (self.selector = selector(scope));
                                _context = self;
                                result = func.apply(self, arguments);
                                _isFunction(result) && self._r.push(result);
                                _context = prev;
                                self.selector = prevSelector;
                                self.isReverted = !1;
                                return result
                            };
                        self.last = f;
                        return name === _isFunction ? f(self, function(func) {
                            return self.add(null, func)
                        }) : name ? self[name] = f : f
                    };
                    _proto5.ignore = function ignore(func) {
                        var prev = _context;
                        _context = null;
                        func(this);
                        _context = prev
                    };
                    _proto5.getTweens = function getTweens() {
                        var a = [];
                        this.data.forEach(function(e) {
                            return e instanceof Context ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e)
                        });
                        return a
                    };
                    _proto5.clear = function clear() {
                        this._r.length = this.data.length = 0
                    };
                    _proto5.kill = function kill(revert, matchMedia) {
                        var _this4 = this;
                        if (revert) {
                            (function() {
                                var tweens = _this4.getTweens(),
                                    i = _this4.data.length,
                                    t;
                                while (i--) {
                                    t = _this4.data[i];
                                    if (t.data === "isFlip") {
                                        t.revert();
                                        t.getChildren(!0, !0, !1).forEach(function(tween) {
                                            return tweens.splice(tweens.indexOf(tween), 1)
                                        })
                                    }
                                }
                                tweens.map(function(t) {
                                    return {
                                        g: t._dur || t._delay || t._sat && !t._sat.vars.immediateRender ? t.globalTime(0) : -Infinity,
                                        t: t
                                    }
                                }).sort(function(a, b) {
                                    return b.g - a.g || -Infinity
                                }).forEach(function(o) {
                                    return o.t.revert(revert)
                                });
                                i = _this4.data.length;
                                while (i--) {
                                    t = _this4.data[i];
                                    if (t instanceof Timeline) {
                                        if (t.data !== "nested") {
                                            t.scrollTrigger && t.scrollTrigger.revert();
                                            t.kill()
                                        }
                                    } else {
                                        !(t instanceof Tween) && t.revert && t.revert(revert)
                                    }
                                }
                                _this4._r.forEach(function(f) {
                                    return f(revert, _this4)
                                });
                                _this4.isReverted = !0
                            })()
                        } else {
                            this.data.forEach(function(e) {
                                return e.kill && e.kill()
                            })
                        }
                        this.clear();
                        if (matchMedia) {
                            var i = _media.length;
                            while (i--) {
                                _media[i].id === this.id && _media.splice(i, 1)
                            }
                        }
                    };
                    _proto5.revert = function revert(config) {
                        this.kill(config || {})
                    };
                    return Context
                }();
                var MatchMedia = function() {
                    function MatchMedia(scope) {
                        this.contexts = [];
                        this.scope = scope;
                        _context && _context.data.push(this)
                    }
                    var _proto6 = MatchMedia.prototype;
                    _proto6.add = function add(conditions, func, scope) {
                        _isObject(conditions) || (conditions = {
                            matches: conditions
                        });
                        var context = new Context(0, scope || this.scope),
                            cond = context.conditions = {},
                            mq, p, active;
                        _context && !context.selector && (context.selector = _context.selector);
                        this.contexts.push(context);
                        func = context.add("onMatch", func);
                        context.queries = conditions;
                        for (p in conditions) {
                            if (p === "all") {
                                active = 1
                            } else {
                                mq = _win.matchMedia(conditions[p]);
                                if (mq) {
                                    _media.indexOf(context) < 0 && _media.push(context);
                                    (cond[p] = mq.matches) && (active = 1);
                                    mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange)
                                }
                            }
                        }
                        active && func(context, function(f) {
                            return context.add(null, f)
                        });
                        return this
                    };
                    _proto6.revert = function revert(config) {
                        this.kill(config || {})
                    };
                    _proto6.kill = function kill(revert) {
                        this.contexts.forEach(function(c) {
                            return c.kill(revert, !0)
                        })
                    };
                    return MatchMedia
                }();
                var _gsap = {
                    registerPlugin: function registerPlugin() {
                        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                            args[_key2] = arguments[_key2]
                        }
                        args.forEach(function(config) {
                            return _createPlugin(config)
                        })
                    },
                    timeline: function timeline(vars) {
                        return new Timeline(vars)
                    },
                    getTweensOf: function getTweensOf(targets, onlyActive) {
                        return _globalTimeline.getTweensOf(targets, onlyActive)
                    },
                    getProperty: function getProperty(target, property, unit, uncache) {
                        _isString(target) && (target = toArray(target)[0]);
                        var getter = _getCache(target || {}).get,
                            format = unit ? _passThrough : _numericIfPossible;
                        unit === "native" && (unit = "");
                        return !target ? target : !property ? function(property, unit, uncache) {
                            return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache))
                        } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache))
                    },
                    quickSetter: function quickSetter(target, property, unit) {
                        target = toArray(target);
                        if (target.length > 1) {
                            var setters = target.map(function(t) {
                                    return gsap.quickSetter(t, property, unit)
                                }),
                                l = setters.length;
                            return function(value) {
                                var i = l;
                                while (i--) {
                                    setters[i](value)
                                }
                            }
                        }
                        target = target[0] || {};
                        var Plugin = _plugins[property],
                            cache = _getCache(target),
                            p = cache.harness && (cache.harness.aliases || {})[property] || property,
                            setter = Plugin ? function(value) {
                                var p = new Plugin();
                                _quickTween._pt = 0;
                                p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
                                p.render(1, p);
                                _quickTween._pt && _renderPropTweens(1, _quickTween)
                            } : cache.set(target, p);
                        return Plugin ? setter : function(value) {
                            return setter(target, p, unit ? value + unit : value, cache, 1)
                        }
                    },
                    quickTo: function quickTo(target, property, vars) {
                        var _merge2;
                        var tween = gsap.to(target, _merge((_merge2 = {}, _merge2[property] = "+=0.1", _merge2.paused = !0, _merge2), vars || {})),
                            func = function func(value, start, startIsRelative) {
                                return tween.resetTo(property, value, start, startIsRelative)
                            };
                        func.tween = tween;
                        return func
                    },
                    isTweening: function isTweening(targets) {
                        return _globalTimeline.getTweensOf(targets, !0).length > 0
                    },
                    defaults: function defaults(value) {
                        value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
                        return _mergeDeep(_defaults, value || {})
                    },
                    config: function config(value) {
                        return _mergeDeep(_config, value || {})
                    },
                    registerEffect: function registerEffect(_ref3) {
                        var name = _ref3.name,
                            effect = _ref3.effect,
                            plugins = _ref3.plugins,
                            defaults = _ref3.defaults,
                            extendTimeline = _ref3.extendTimeline;
                        (plugins || "").split(",").forEach(function(pluginName) {
                            return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.")
                        });
                        _effects[name] = function(targets, vars, tl) {
                            return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl)
                        };
                        if (extendTimeline) {
                            Timeline.prototype[name] = function(targets, vars, position) {
                                return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position)
                            }
                        }
                    },
                    registerEase: function registerEase(name, ease) {
                        _easeMap[name] = _parseEase(ease)
                    },
                    parseEase: function parseEase(ease, defaultEase) {
                        return arguments.length ? _parseEase(ease, defaultEase) : _easeMap
                    },
                    getById: function getById(id) {
                        return _globalTimeline.getById(id)
                    },
                    exportRoot: function exportRoot(vars, includeDelayedCalls) {
                        if (vars === void 0) {
                            vars = {}
                        }
                        var tl = new Timeline(vars),
                            child, next;
                        tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
                        _globalTimeline.remove(tl);
                        tl._dp = 0;
                        tl._time = tl._tTime = _globalTimeline._time;
                        child = _globalTimeline._first;
                        while (child) {
                            next = child._next;
                            if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
                                _addToTimeline(tl, child, child._start - child._delay)
                            }
                            child = next
                        }
                        _addToTimeline(_globalTimeline, tl, 0);
                        return tl
                    },
                    context: function context(func, scope) {
                        return func ? new Context(func, scope) : _context
                    },
                    matchMedia: function matchMedia(scope) {
                        return new MatchMedia(scope)
                    },
                    matchMediaRefresh: function matchMediaRefresh() {
                        return _media.forEach(function(c) {
                            var cond = c.conditions,
                                found, p;
                            for (p in cond) {
                                if (cond[p]) {
                                    cond[p] = !1;
                                    found = 1
                                }
                            }
                            found && c.revert()
                        }) || _onMediaChange()
                    },
                    addEventListener: function addEventListener(type, callback) {
                        var a = _listeners[type] || (_listeners[type] = []);
                        ~a.indexOf(callback) || a.push(callback)
                    },
                    removeEventListener: function removeEventListener(type, callback) {
                        var a = _listeners[type],
                            i = a && a.indexOf(callback);
                        i >= 0 && a.splice(i, 1)
                    },
                    utils: {
                        wrap: wrap,
                        wrapYoyo: wrapYoyo,
                        distribute: distribute,
                        random: random,
                        snap: snap,
                        normalize: normalize,
                        getUnit: getUnit,
                        clamp: clamp,
                        splitColor: splitColor,
                        toArray: toArray,
                        selector: selector,
                        mapRange: mapRange,
                        pipe: pipe,
                        unitize: unitize,
                        interpolate: interpolate,
                        shuffle: shuffle
                    },
                    install: _install,
                    effects: _effects,
                    ticker: _ticker,
                    updateRoot: Timeline.updateRoot,
                    plugins: _plugins,
                    globalTimeline: _globalTimeline,
                    core: {
                        PropTween: PropTween,
                        globals: _addGlobal,
                        Tween: Tween,
                        Timeline: Timeline,
                        Animation: Animation,
                        getCache: _getCache,
                        _removeLinkedListItem: _removeLinkedListItem,
                        reverting: function reverting() {
                            return _reverting
                        },
                        context: function context(toAdd) {
                            if (toAdd && _context) {
                                _context.data.push(toAdd);
                                toAdd._ctx = _context
                            }
                            return _context
                        },
                        suppressOverwrites: function suppressOverwrites(value) {
                            return _suppressOverwrites = value
                        }
                    }
                };
                _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
                    return _gsap[name] = Tween[name]
                });
                _ticker.add(Timeline.updateRoot);
                _quickTween = _gsap.to({}, {
                    duration: 0
                });
                var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
                        var pt = plugin._pt;
                        while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
                            pt = pt._next
                        }
                        return pt
                    },
                    _addModifiers = function _addModifiers(tween, modifiers) {
                        var targets = tween._targets,
                            p, i, pt;
                        for (p in modifiers) {
                            i = targets.length;
                            while (i--) {
                                pt = tween._ptLookup[i][p];
                                if (pt && (pt = pt.d)) {
                                    if (pt._pt) {
                                        pt = _getPluginPropTween(pt, p)
                                    }
                                    pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p)
                                }
                            }
                        }
                    },
                    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
                        return {
                            name: name,
                            rawVars: 1,
                            init: function init(target, vars, tween) {
                                tween._onInit = function(tween) {
                                    var temp, p;
                                    if (_isString(vars)) {
                                        temp = {};
                                        _forEachName(vars, function(name) {
                                            return temp[name] = 1
                                        });
                                        vars = temp
                                    }
                                    if (modifier) {
                                        temp = {};
                                        for (p in vars) {
                                            temp[p] = modifier(vars[p])
                                        }
                                        vars = temp
                                    }
                                    _addModifiers(tween, vars)
                                }
                            }
                        }
                    };
                var gsap = _gsap.registerPlugin({
                    name: "attr",
                    init: function init(target, vars, tween, index, targets) {
                        var p, pt, v;
                        this.tween = tween;
                        for (p in vars) {
                            v = target.getAttribute(p) || "";
                            pt = this.add(target, "setAttribute", (v || 0) + "", vars[p], index, targets, 0, 0, p);
                            pt.op = p;
                            pt.b = v;
                            this._props.push(p)
                        }
                    },
                    render: function render(ratio, data) {
                        var pt = data._pt;
                        while (pt) {
                            _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
                            pt = pt._next
                        }
                    }
                }, {
                    name: "endArray",
                    init: function init(target, value) {
                        var i = value.length;
                        while (i--) {
                            this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1)
                        }
                    }
                }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
                Tween.version = Timeline.version = gsap.version = "3.12.5";
                _coreReady = 1;
                _windowExists() && _wake();
                var Power0 = _easeMap.Power0,
                    Power1 = _easeMap.Power1,
                    Power2 = _easeMap.Power2,
                    Power3 = _easeMap.Power3,
                    Power4 = _easeMap.Power4,
                    Linear = _easeMap.Linear,
                    Quad = _easeMap.Quad,
                    Cubic = _easeMap.Cubic,
                    Quart = _easeMap.Quart,
                    Quint = _easeMap.Quint,
                    Strong = _easeMap.Strong,
                    Elastic = _easeMap.Elastic,
                    Back = _easeMap.Back,
                    SteppedEase = _easeMap.SteppedEase,
                    Bounce = _easeMap.Bounce,
                    Sine = _easeMap.Sine,
                    Expo = _easeMap.Expo,
                    Circ = _easeMap.Circ
            }),
        "./node_modules/gsap/index.js":
            /*!************************************!*\
              !*** ./node_modules/gsap/index.js ***!
              \************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    gsap: () => (gsapWithCSS)
                });
                var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
                var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");
                var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__.CSSPlugin) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap,
                    TweenMaxWithCSS = gsapWithCSS.core.Tween
            }),
        "./node_modules/@splidejs/splide/dist/css/splide-core.min.css":
            /*!********************************************************************!*\
              !*** ./node_modules/@splidejs/splide/dist/css/splide-core.min.css ***!
              \********************************************************************/
            (() => {
                "use strict"
            }),
        "./src/styles/main.scss":
            /*!******************************!*\
              !*** ./src/styles/main.scss ***!
              \******************************/
            (() => {
                "use strict"
            }),
        "./node_modules/path-to-regexp/dist.es2015/index.js":
            /*!**********************************************************!*\
              !*** ./node_modules/path-to-regexp/dist.es2015/index.js ***!
              \**********************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    match: () => (match)
                });

                function lexer(str) {
                    var tokens = [];
                    var i = 0;
                    while (i < str.length) {
                        var char = str[i];
                        if (char === "*" || char === "+" || char === "?") {
                            tokens.push({
                                type: "MODIFIER",
                                index: i,
                                value: str[i++]
                            });
                            continue
                        }
                        if (char === "\\") {
                            tokens.push({
                                type: "ESCAPED_CHAR",
                                index: i++,
                                value: str[i++]
                            });
                            continue
                        }
                        if (char === "{") {
                            tokens.push({
                                type: "OPEN",
                                index: i,
                                value: str[i++]
                            });
                            continue
                        }
                        if (char === "}") {
                            tokens.push({
                                type: "CLOSE",
                                index: i,
                                value: str[i++]
                            });
                            continue
                        }
                        if (char === ":") {
                            var name = "";
                            var j = i + 1;
                            while (j < str.length) {
                                var code = str.charCodeAt(j);
                                if ((code >= 48 && code <= 57) || (code >= 65 && code <= 90) || (code >= 97 && code <= 122) || code === 95) {
                                    name += str[j++];
                                    continue
                                }
                                break
                            }
                            if (!name)
                                throw new TypeError("Missing parameter name at ".concat(i));
                            tokens.push({
                                type: "NAME",
                                index: i,
                                value: name
                            });
                            i = j;
                            continue
                        }
                        if (char === "(") {
                            var count = 1;
                            var pattern = "";
                            var j = i + 1;
                            if (str[j] === "?") {
                                throw new TypeError("Pattern cannot start with \"?\" at ".concat(j))
                            }
                            while (j < str.length) {
                                if (str[j] === "\\") {
                                    pattern += str[j++] + str[j++];
                                    continue
                                }
                                if (str[j] === ")") {
                                    count--;
                                    if (count === 0) {
                                        j++;
                                        break
                                    }
                                } else if (str[j] === "(") {
                                    count++;
                                    if (str[j + 1] !== "?") {
                                        throw new TypeError("Capturing groups are not allowed at ".concat(j))
                                    }
                                }
                                pattern += str[j++]
                            }
                            if (count)
                                throw new TypeError("Unbalanced pattern at ".concat(i));
                            if (!pattern)
                                throw new TypeError("Missing pattern at ".concat(i));
                            tokens.push({
                                type: "PATTERN",
                                index: i,
                                value: pattern
                            });
                            i = j;
                            continue
                        }
                        tokens.push({
                            type: "CHAR",
                            index: i,
                            value: str[i++]
                        })
                    }
                    tokens.push({
                        type: "END",
                        index: i,
                        value: ""
                    });
                    return tokens
                }

                function parse(str, options) {
                    if (options === void 0) {
                        options = {}
                    }
                    var tokens = lexer(str);
                    var _a = options.prefixes,
                        prefixes = _a === void 0 ? "./" : _a;
                    var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
                    var result = [];
                    var key = 0;
                    var i = 0;
                    var path = "";
                    var tryConsume = function(type) {
                        if (i < tokens.length && tokens[i].type === type)
                            return tokens[i++].value
                    };
                    var mustConsume = function(type) {
                        var value = tryConsume(type);
                        if (value !== undefined)
                            return value;
                        var _a = tokens[i],
                            nextType = _a.type,
                            index = _a.index;
                        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type))
                    };
                    var consumeText = function() {
                        var result = "";
                        var value;
                        while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
                            result += value
                        }
                        return result
                    };
                    while (i < tokens.length) {
                        var char = tryConsume("CHAR");
                        var name = tryConsume("NAME");
                        var pattern = tryConsume("PATTERN");
                        if (name || pattern) {
                            var prefix = char || "";
                            if (prefixes.indexOf(prefix) === -1) {
                                path += prefix;
                                prefix = ""
                            }
                            if (path) {
                                result.push(path);
                                path = ""
                            }
                            result.push({
                                name: name || key++,
                                prefix: prefix,
                                suffix: "",
                                pattern: pattern || defaultPattern,
                                modifier: tryConsume("MODIFIER") || "",
                            });
                            continue
                        }
                        var value = char || tryConsume("ESCAPED_CHAR");
                        if (value) {
                            path += value;
                            continue
                        }
                        if (path) {
                            result.push(path);
                            path = ""
                        }
                        var open = tryConsume("OPEN");
                        if (open) {
                            var prefix = consumeText();
                            var name_1 = tryConsume("NAME") || "";
                            var pattern_1 = tryConsume("PATTERN") || "";
                            var suffix = consumeText();
                            mustConsume("CLOSE");
                            result.push({
                                name: name_1 || (pattern_1 ? key++ : ""),
                                pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                                prefix: prefix,
                                suffix: suffix,
                                modifier: tryConsume("MODIFIER") || "",
                            });
                            continue
                        }
                        mustConsume("END")
                    }
                    return result
                }

                function compile(str, options) {
                    return tokensToFunction(parse(str, options), options)
                }

                function tokensToFunction(tokens, options) {
                    if (options === void 0) {
                        options = {}
                    }
                    var reFlags = flags(options);
                    var _a = options.encode,
                        encode = _a === void 0 ? function(x) {
                            return x
                        } : _a,
                        _b = options.validate,
                        validate = _b === void 0 ? !0 : _b;
                    var matches = tokens.map(function(token) {
                        if (typeof token === "object") {
                            return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags)
                        }
                    });
                    return function(data) {
                        var path = "";
                        for (var i = 0; i < tokens.length; i++) {
                            var token = tokens[i];
                            if (typeof token === "string") {
                                path += token;
                                continue
                            }
                            var value = data ? data[token.name] : undefined;
                            var optional = token.modifier === "?" || token.modifier === "*";
                            var repeat = token.modifier === "*" || token.modifier === "+";
                            if (Array.isArray(value)) {
                                if (!repeat) {
                                    throw new TypeError("Expected \"".concat(token.name, "\" to not repeat, but got an array"))
                                }
                                if (value.length === 0) {
                                    if (optional)
                                        continue;
                                    throw new TypeError("Expected \"".concat(token.name, "\" to not be empty"))
                                }
                                for (var j = 0; j < value.length; j++) {
                                    var segment = encode(value[j], token);
                                    if (validate && !matches[i].test(segment)) {
                                        throw new TypeError("Expected all \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""))
                                    }
                                    path += token.prefix + segment + token.suffix
                                }
                                continue
                            }
                            if (typeof value === "string" || typeof value === "number") {
                                var segment = encode(String(value), token);
                                if (validate && !matches[i].test(segment)) {
                                    throw new TypeError("Expected \"".concat(token.name, "\" to match \"").concat(token.pattern, "\", but got \"").concat(segment, "\""))
                                }
                                path += token.prefix + segment + token.suffix;
                                continue
                            }
                            if (optional)
                                continue;
                            var typeOfMessage = repeat ? "an array" : "a string";
                            throw new TypeError("Expected \"".concat(token.name, "\" to be ").concat(typeOfMessage))
                        }
                        return path
                    }
                }

                function match(str, options) {
                    var keys = [];
                    var re = pathToRegexp(str, keys, options);
                    return regexpToFunction(re, keys, options)
                }

                function regexpToFunction(re, keys, options) {
                    if (options === void 0) {
                        options = {}
                    }
                    var _a = options.decode,
                        decode = _a === void 0 ? function(x) {
                            return x
                        } : _a;
                    return function(pathname) {
                        var m = re.exec(pathname);
                        if (!m)
                            return !1;
                        var path = m[0],
                            index = m.index;
                        var params = Object.create(null);
                        var _loop_1 = function(i) {
                            if (m[i] === undefined)
                                return "continue";
                            var key = keys[i - 1];
                            if (key.modifier === "*" || key.modifier === "+") {
                                params[key.name] = m[i].split(key.prefix + key.suffix).map(function(value) {
                                    return decode(value, key)
                                })
                            } else {
                                params[key.name] = decode(m[i], key)
                            }
                        };
                        for (var i = 1; i < m.length; i++) {
                            _loop_1(i)
                        }
                        return {
                            path: path,
                            index: index,
                            params: params
                        }
                    }
                }

                function escapeString(str) {
                    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1")
                }

                function flags(options) {
                    return options && options.sensitive ? "" : "i"
                }

                function regexpToRegexp(path, keys) {
                    if (!keys)
                        return path;
                    var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
                    var index = 0;
                    var execResult = groupsRegex.exec(path.source);
                    while (execResult) {
                        keys.push({
                            name: execResult[1] || index++,
                            prefix: "",
                            suffix: "",
                            modifier: "",
                            pattern: "",
                        });
                        execResult = groupsRegex.exec(path.source)
                    }
                    return path
                }

                function arrayToRegexp(paths, keys, options) {
                    var parts = paths.map(function(path) {
                        return pathToRegexp(path, keys, options).source
                    });
                    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options))
                }

                function stringToRegexp(path, keys, options) {
                    return tokensToRegexp(parse(path, options), keys, options)
                }

                function tokensToRegexp(tokens, keys, options) {
                    if (options === void 0) {
                        options = {}
                    }
                    var _a = options.strict,
                        strict = _a === void 0 ? !1 : _a,
                        _b = options.start,
                        start = _b === void 0 ? !0 : _b,
                        _c = options.end,
                        end = _c === void 0 ? !0 : _c,
                        _d = options.encode,
                        encode = _d === void 0 ? function(x) {
                            return x
                        } : _d,
                        _e = options.delimiter,
                        delimiter = _e === void 0 ? "/#?" : _e,
                        _f = options.endsWith,
                        endsWith = _f === void 0 ? "" : _f;
                    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
                    var delimiterRe = "[".concat(escapeString(delimiter), "]");
                    var route = start ? "^" : "";
                    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
                        var token = tokens_1[_i];
                        if (typeof token === "string") {
                            route += escapeString(encode(token))
                        } else {
                            var prefix = escapeString(encode(token.prefix));
                            var suffix = escapeString(encode(token.suffix));
                            if (token.pattern) {
                                if (keys)
                                    keys.push(token);
                                if (prefix || suffix) {
                                    if (token.modifier === "+" || token.modifier === "*") {
                                        var mod = token.modifier === "*" ? "?" : "";
                                        route += "(?:".concat(prefix, "((?:").concat(token.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token.pattern, "))*)").concat(suffix, ")").concat(mod)
                                    } else {
                                        route += "(?:".concat(prefix, "(").concat(token.pattern, ")").concat(suffix, ")").concat(token.modifier)
                                    }
                                } else {
                                    if (token.modifier === "+" || token.modifier === "*") {
                                        route += "((?:".concat(token.pattern, ")").concat(token.modifier, ")")
                                    } else {
                                        route += "(".concat(token.pattern, ")").concat(token.modifier)
                                    }
                                }
                            } else {
                                route += "(?:".concat(prefix).concat(suffix, ")").concat(token.modifier)
                            }
                        }
                    }
                    if (end) {
                        if (!strict)
                            route += "".concat(delimiterRe, "?");
                        route += !options.endsWith ? "$" : "(?=".concat(endsWithRe, ")")
                    } else {
                        var endToken = tokens[tokens.length - 1];
                        var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === undefined;
                        if (!strict) {
                            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?")
                        }
                        if (!isEndDelimited) {
                            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")")
                        }
                    }
                    return new RegExp(route, flags(options))
                }

                function pathToRegexp(path, keys, options) {
                    if (path instanceof RegExp)
                        return regexpToRegexp(path, keys);
                    if (Array.isArray(path))
                        return arrayToRegexp(path, keys, options);
                    return stringToRegexp(path, keys, options)
                }
            }),
        "./node_modules/siema/dist/siema.min.js":
            /*!**********************************************!*\
              !*** ./node_modules/siema/dist/siema.min.js ***!
              \**********************************************/
            (function(module) {
                ! function(e, t) {
                    !0 ? module.exports = t() : 0
                }("undefined" != typeof self ? self : this, function() {
                    return function(e) {
                        function t(r) {
                            if (i[r]) return i[r].exports;
                            var n = i[r] = {
                                i: r,
                                l: !1,
                                exports: {}
                            };
                            return e[r].call(n.exports, n, n.exports, t), n.l = !0, n.exports
                        }
                        var i = {};
                        return t.m = e, t.c = i, t.d = function(e, i, r) {
                            t.o(e, i) || Object.defineProperty(e, i, {
                                configurable: !1,
                                enumerable: !0,
                                get: r
                            })
                        }, t.n = function(e) {
                            var i = e && e.__esModule ? function() {
                                return e.default
                            } : function() {
                                return e
                            };
                            return t.d(i, "a", i), i
                        }, t.o = function(e, t) {
                            return Object.prototype.hasOwnProperty.call(e, t)
                        }, t.p = "", t(t.s = 0)
                    }([function(e, t, i) {
                        "use strict";

                        function r(e, t) {
                            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                        }
                        Object.defineProperty(t, "__esModule", {
                            value: !0
                        });
                        var n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
                                return typeof e
                            } : function(e) {
                                return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
                            },
                            s = function() {
                                function e(e, t) {
                                    for (var i = 0; i < t.length; i++) {
                                        var r = t[i];
                                        r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                                    }
                                }
                                return function(t, i, r) {
                                    return i && e(t.prototype, i), r && e(t, r), t
                                }
                            }(),
                            l = function() {
                                function e(t) {
                                    var i = this;
                                    if (r(this, e), this.config = e.mergeSettings(t), this.selector = "string" == typeof this.config.selector ? document.querySelector(this.config.selector) : this.config.selector, null === this.selector) throw new Error("Something wrong with your selector 😭");
                                    this.resolveSlidesNumber(), this.selectorWidth = this.selector.offsetWidth, this.innerElements = [].slice.call(this.selector.children), this.currentSlide = this.config.loop ? this.config.startIndex % this.innerElements.length : Math.max(0, Math.min(this.config.startIndex, this.innerElements.length - this.perPage)), this.transformProperty = e.webkitOrNot(), ["resizeHandler", "touchstartHandler", "touchendHandler", "touchmoveHandler", "mousedownHandler", "mouseupHandler", "mouseleaveHandler", "mousemoveHandler", "clickHandler"].forEach(function(e) {
                                        i[e] = i[e].bind(i)
                                    }), this.init()
                                }
                                return s(e, [{
                                    key: "attachEvents",
                                    value: function() {
                                        window.addEventListener("resize", this.resizeHandler), this.config.draggable && (this.pointerDown = !1, this.drag = {
                                            startX: 0,
                                            endX: 0,
                                            startY: 0,
                                            letItGo: null,
                                            preventClick: !1
                                        }, this.selector.addEventListener("touchstart", this.touchstartHandler), this.selector.addEventListener("touchend", this.touchendHandler), this.selector.addEventListener("touchmove", this.touchmoveHandler), this.selector.addEventListener("mousedown", this.mousedownHandler), this.selector.addEventListener("mouseup", this.mouseupHandler), this.selector.addEventListener("mouseleave", this.mouseleaveHandler), this.selector.addEventListener("mousemove", this.mousemoveHandler), this.selector.addEventListener("click", this.clickHandler))
                                    }
                                }, {
                                    key: "detachEvents",
                                    value: function() {
                                        window.removeEventListener("resize", this.resizeHandler), this.selector.removeEventListener("touchstart", this.touchstartHandler), this.selector.removeEventListener("touchend", this.touchendHandler), this.selector.removeEventListener("touchmove", this.touchmoveHandler), this.selector.removeEventListener("mousedown", this.mousedownHandler), this.selector.removeEventListener("mouseup", this.mouseupHandler), this.selector.removeEventListener("mouseleave", this.mouseleaveHandler), this.selector.removeEventListener("mousemove", this.mousemoveHandler), this.selector.removeEventListener("click", this.clickHandler)
                                    }
                                }, {
                                    key: "init",
                                    value: function() {
                                        this.attachEvents(), this.selector.style.overflow = "hidden", this.selector.style.direction = this.config.rtl ? "rtl" : "ltr", this.buildSliderFrame(), this.config.onInit.call(this)
                                    }
                                }, {
                                    key: "buildSliderFrame",
                                    value: function() {
                                        var e = this.selectorWidth / this.perPage,
                                            t = this.config.loop ? this.innerElements.length + 2 * this.perPage : this.innerElements.length;
                                        this.sliderFrame = document.createElement("div"), this.sliderFrame.style.width = e * t + "px", this.enableTransition(), this.config.draggable && (this.selector.style.cursor = "-webkit-grab");
                                        var i = document.createDocumentFragment();
                                        if (this.config.loop)
                                            for (var r = this.innerElements.length - this.perPage; r < this.innerElements.length; r++) {
                                                var n = this.buildSliderFrameItem(this.innerElements[r].cloneNode(!0));
                                                i.appendChild(n)
                                            }
                                        for (var s = 0; s < this.innerElements.length; s++) {
                                            var l = this.buildSliderFrameItem(this.innerElements[s]);
                                            i.appendChild(l)
                                        }
                                        if (this.config.loop)
                                            for (var o = 0; o < this.perPage; o++) {
                                                var a = this.buildSliderFrameItem(this.innerElements[o].cloneNode(!0));
                                                i.appendChild(a)
                                            }
                                        this.sliderFrame.appendChild(i), this.selector.innerHTML = "", this.selector.appendChild(this.sliderFrame), this.slideToCurrent()
                                    }
                                }, {
                                    key: "buildSliderFrameItem",
                                    value: function(e) {
                                        var t = document.createElement("div");
                                        return t.style.cssFloat = this.config.rtl ? "right" : "left", t.style.float = this.config.rtl ? "right" : "left", t.style.width = (this.config.loop ? 100 / (this.innerElements.length + 2 * this.perPage) : 100 / this.innerElements.length) + "%", t.appendChild(e), t
                                    }
                                }, {
                                    key: "resolveSlidesNumber",
                                    value: function() {
                                        if ("number" == typeof this.config.perPage) this.perPage = this.config.perPage;
                                        else if ("object" === n(this.config.perPage)) {
                                            this.perPage = 1;
                                            for (var e in this.config.perPage) window.innerWidth >= e && (this.perPage = this.config.perPage[e])
                                        }
                                    }
                                }, {
                                    key: "prev",
                                    value: function() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                            t = arguments[1];
                                        if (!(this.innerElements.length <= this.perPage)) {
                                            var i = this.currentSlide;
                                            if (this.config.loop) {
                                                if (this.currentSlide - e < 0) {
                                                    this.disableTransition();
                                                    var r = this.currentSlide + this.innerElements.length,
                                                        n = this.perPage,
                                                        s = r + n,
                                                        l = (this.config.rtl ? 1 : -1) * s * (this.selectorWidth / this.perPage),
                                                        o = this.config.draggable ? this.drag.endX - this.drag.startX : 0;
                                                    this.sliderFrame.style[this.transformProperty] = "translate3d(" + (l + o) + "px, 0, 0)", this.currentSlide = r - e
                                                } else this.currentSlide = this.currentSlide - e
                                            } else this.currentSlide = Math.max(this.currentSlide - e, 0);
                                            i !== this.currentSlide && (this.slideToCurrent(this.config.loop), this.config.onChange.call(this), t && t.call(this))
                                        }
                                    }
                                }, {
                                    key: "next",
                                    value: function() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1,
                                            t = arguments[1];
                                        if (!(this.innerElements.length <= this.perPage)) {
                                            var i = this.currentSlide;
                                            if (this.config.loop) {
                                                if (this.currentSlide + e > this.innerElements.length - this.perPage) {
                                                    this.disableTransition();
                                                    var r = this.currentSlide - this.innerElements.length,
                                                        n = this.perPage,
                                                        s = r + n,
                                                        l = (this.config.rtl ? 1 : -1) * s * (this.selectorWidth / this.perPage),
                                                        o = this.config.draggable ? this.drag.endX - this.drag.startX : 0;
                                                    this.sliderFrame.style[this.transformProperty] = "translate3d(" + (l + o) + "px, 0, 0)", this.currentSlide = r + e
                                                } else this.currentSlide = this.currentSlide + e
                                            } else this.currentSlide = Math.min(this.currentSlide + e, this.innerElements.length - this.perPage);
                                            i !== this.currentSlide && (this.slideToCurrent(this.config.loop), this.config.onChange.call(this), t && t.call(this))
                                        }
                                    }
                                }, {
                                    key: "disableTransition",
                                    value: function() {
                                        this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing
                                    }
                                }, {
                                    key: "enableTransition",
                                    value: function() {
                                        this.sliderFrame.style.webkitTransition = "all " + this.config.duration + "ms " + this.config.easing, this.sliderFrame.style.transition = "all " + this.config.duration + "ms " + this.config.easing
                                    }
                                }, {
                                    key: "goTo",
                                    value: function(e, t) {
                                        if (!(this.innerElements.length <= this.perPage)) {
                                            var i = this.currentSlide;
                                            this.currentSlide = this.config.loop ? e % this.innerElements.length : Math.min(Math.max(e, 0), this.innerElements.length - this.perPage), i !== this.currentSlide && (this.slideToCurrent(), this.config.onChange.call(this), t && t.call(this))
                                        }
                                    }
                                }, {
                                    key: "slideToCurrent",
                                    value: function(e) {
                                        var t = this,
                                            i = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
                                            r = (this.config.rtl ? 1 : -1) * i * (this.selectorWidth / this.perPage);
                                        e ? requestAnimationFrame(function() {
                                            requestAnimationFrame(function() {
                                                t.enableTransition(), t.sliderFrame.style[t.transformProperty] = "translate3d(" + r + "px, 0, 0)"
                                            })
                                        }) : this.sliderFrame.style[this.transformProperty] = "translate3d(" + r + "px, 0, 0)"
                                    }
                                }, {
                                    key: "updateAfterDrag",
                                    value: function() {
                                        var e = (this.config.rtl ? -1 : 1) * (this.drag.endX - this.drag.startX),
                                            t = Math.abs(e),
                                            i = this.config.multipleDrag ? Math.ceil(t / (this.selectorWidth / this.perPage)) : 1,
                                            r = e > 0 && this.currentSlide - i < 0,
                                            n = e < 0 && this.currentSlide + i > this.innerElements.length - this.perPage;
                                        e > 0 && t > this.config.threshold && this.innerElements.length > this.perPage ? this.prev(i) : e < 0 && t > this.config.threshold && this.innerElements.length > this.perPage && this.next(i), this.slideToCurrent(r || n)
                                    }
                                }, {
                                    key: "resizeHandler",
                                    value: function() {
                                        this.resolveSlidesNumber(), this.currentSlide + this.perPage > this.innerElements.length && (this.currentSlide = this.innerElements.length <= this.perPage ? 0 : this.innerElements.length - this.perPage), this.selectorWidth = this.selector.offsetWidth, this.buildSliderFrame()
                                    }
                                }, {
                                    key: "clearDrag",
                                    value: function() {
                                        this.drag = {
                                            startX: 0,
                                            endX: 0,
                                            startY: 0,
                                            letItGo: null,
                                            preventClick: this.drag.preventClick
                                        }
                                    }
                                }, {
                                    key: "touchstartHandler",
                                    value: function(e) {
                                        -1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT"].indexOf(e.target.nodeName) || (e.stopPropagation(), this.pointerDown = !0, this.drag.startX = e.touches[0].pageX, this.drag.startY = e.touches[0].pageY)
                                    }
                                }, {
                                    key: "touchendHandler",
                                    value: function(e) {
                                        e.stopPropagation(), this.pointerDown = !1, this.enableTransition(), this.drag.endX && this.updateAfterDrag(), this.clearDrag()
                                    }
                                }, {
                                    key: "touchmoveHandler",
                                    value: function(e) {
                                        if (e.stopPropagation(), null === this.drag.letItGo && (this.drag.letItGo = Math.abs(this.drag.startY - e.touches[0].pageY) < Math.abs(this.drag.startX - e.touches[0].pageX)), this.pointerDown && this.drag.letItGo) {
                                            e.preventDefault(), this.drag.endX = e.touches[0].pageX, this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing;
                                            var t = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
                                                i = t * (this.selectorWidth / this.perPage),
                                                r = this.drag.endX - this.drag.startX,
                                                n = this.config.rtl ? i + r : i - r;
                                            this.sliderFrame.style[this.transformProperty] = "translate3d(" + (this.config.rtl ? 1 : -1) * n + "px, 0, 0)"
                                        }
                                    }
                                }, {
                                    key: "mousedownHandler",
                                    value: function(e) {
                                        -1 !== ["TEXTAREA", "OPTION", "INPUT", "SELECT"].indexOf(e.target.nodeName) || (e.preventDefault(), e.stopPropagation(), this.pointerDown = !0, this.drag.startX = e.pageX)
                                    }
                                }, {
                                    key: "mouseupHandler",
                                    value: function(e) {
                                        e.stopPropagation(), this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.enableTransition(), this.drag.endX && this.updateAfterDrag(), this.clearDrag()
                                    }
                                }, {
                                    key: "mousemoveHandler",
                                    value: function(e) {
                                        if (e.preventDefault(), this.pointerDown) {
                                            "A" === e.target.nodeName && (this.drag.preventClick = !0), this.drag.endX = e.pageX, this.selector.style.cursor = "-webkit-grabbing", this.sliderFrame.style.webkitTransition = "all 0ms " + this.config.easing, this.sliderFrame.style.transition = "all 0ms " + this.config.easing;
                                            var t = this.config.loop ? this.currentSlide + this.perPage : this.currentSlide,
                                                i = t * (this.selectorWidth / this.perPage),
                                                r = this.drag.endX - this.drag.startX,
                                                n = this.config.rtl ? i + r : i - r;
                                            this.sliderFrame.style[this.transformProperty] = "translate3d(" + (this.config.rtl ? 1 : -1) * n + "px, 0, 0)"
                                        }
                                    }
                                }, {
                                    key: "mouseleaveHandler",
                                    value: function(e) {
                                        this.pointerDown && (this.pointerDown = !1, this.selector.style.cursor = "-webkit-grab", this.drag.endX = e.pageX, this.drag.preventClick = !1, this.enableTransition(), this.updateAfterDrag(), this.clearDrag())
                                    }
                                }, {
                                    key: "clickHandler",
                                    value: function(e) {
                                        this.drag.preventClick && e.preventDefault(), this.drag.preventClick = !1
                                    }
                                }, {
                                    key: "remove",
                                    value: function(e, t) {
                                        if (e < 0 || e >= this.innerElements.length) throw new Error("Item to remove doesn't exist 😭");
                                        var i = e < this.currentSlide,
                                            r = this.currentSlide + this.perPage - 1 === e;
                                        (i || r) && this.currentSlide--, this.innerElements.splice(e, 1), this.buildSliderFrame(), t && t.call(this)
                                    }
                                }, {
                                    key: "insert",
                                    value: function(e, t, i) {
                                        if (t < 0 || t > this.innerElements.length + 1) throw new Error("Unable to inset it at this index 😭");
                                        if (-1 !== this.innerElements.indexOf(e)) throw new Error("The same item in a carousel? Really? Nope 😭");
                                        var r = t <= this.currentSlide > 0 && this.innerElements.length;
                                        this.currentSlide = r ? this.currentSlide + 1 : this.currentSlide, this.innerElements.splice(t, 0, e), this.buildSliderFrame(), i && i.call(this)
                                    }
                                }, {
                                    key: "prepend",
                                    value: function(e, t) {
                                        this.insert(e, 0), t && t.call(this)
                                    }
                                }, {
                                    key: "append",
                                    value: function(e, t) {
                                        this.insert(e, this.innerElements.length + 1), t && t.call(this)
                                    }
                                }, {
                                    key: "destroy",
                                    value: function() {
                                        var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                            t = arguments[1];
                                        if (this.detachEvents(), this.selector.style.cursor = "auto", e) {
                                            for (var i = document.createDocumentFragment(), r = 0; r < this.innerElements.length; r++) i.appendChild(this.innerElements[r]);
                                            this.selector.innerHTML = "", this.selector.appendChild(i), this.selector.removeAttribute("style")
                                        }
                                        t && t.call(this)
                                    }
                                }], [{
                                    key: "mergeSettings",
                                    value: function(e) {
                                        var t = {
                                                selector: ".siema",
                                                duration: 200,
                                                easing: "ease-out",
                                                perPage: 1,
                                                startIndex: 0,
                                                draggable: !0,
                                                multipleDrag: !0,
                                                threshold: 20,
                                                loop: !1,
                                                rtl: !1,
                                                onInit: function() {},
                                                onChange: function() {}
                                            },
                                            i = e;
                                        for (var r in i) t[r] = i[r];
                                        return t
                                    }
                                }, {
                                    key: "webkitOrNot",
                                    value: function() {
                                        return "string" == typeof document.documentElement.style.transform ? "transform" : "WebkitTransform"
                                    }
                                }]), e
                            }();
                        t.default = l, e.exports = t.default
                    }])
                })
            }),
        "./src/scripts/helpers/Animations.js":
            /*!*******************************************!*\
              !*** ./src/scripts/helpers/Animations.js ***!
              \*******************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (Animations)
                });
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                var _SplitText_min__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./SplitText.min */ "./src/scripts/helpers/SplitText.min.js");
                var _SplitText_min__WEBPACK_IMPORTED_MODULE_0___default = __webpack_require__.n(_SplitText_min__WEBPACK_IMPORTED_MODULE_0__);
                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(_SplitText_min__WEBPACK_IMPORTED_MODULE_0__.SplitText, gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger);

                function Animations(el) {
                    let rootEl = el || document;

                    function bottomMaskReveal() {
                        const elems = rootEl.querySelectorAll("[anim-bottom-mask-reveal]");
                        elems.forEach((elem) => {
                            const splitted = new _SplitText_min__WEBPACK_IMPORTED_MODULE_0__.SplitText(elem, {
                                type: "lines, words",
                                linesClass: "overflow-hidden splitted-lines"
                            });
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(splitted.words, {
                                y: "150%",
                            }, {
                                y: "0%",
                                ease: "expo.out",
                                stagger: elem.dataset.stagger || 0.05,
                                duration: elem.dataset.duration || 1.4,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: elem.dataset.start || "top 85%",
                                    end: "bottom top",
                                },
                            });
                            elem.classList.add("inited")
                        })
                    }

                    function textLetterFadeReveal() {
                        const elems = rootEl.querySelectorAll("[anim-text-letter-fade-reveal]");
                        elems.forEach((elem) => {
                            const splitted = new _SplitText_min__WEBPACK_IMPORTED_MODULE_0__.SplitText(elem, {
                                type: "lines, words, chars",
                                charsClass: "split_chars"
                            });
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(splitted.chars, {
                                color: elem.dataset.fromColor || "#969696",
                            }, {
                                color: elem.dataset.toColor || "#181818",
                                ease: "power1.out",
                                stagger: 0.015,
                                duration: 1.2,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: "top bottom",
                                    end: elem.dataset.end ? elem.dataset.end : "bottom 10%",
                                    scrub: !0,
                                    markers: !1
                                },
                            })
                        })
                    }

                    function countNumberReveal() {
                        const elems = rootEl.querySelectorAll("[count-number-reveal]");
                        elems.forEach((elem) => {
                            const i = elem.querySelector("i");
                            const endNum = elem.dataset.endVal;
                            const dummy = {
                                val: 0
                            };
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(dummy, {
                                val: 0
                            }, {
                                val: endNum,
                                ease: "power1.inOut",
                                duration: 2,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: "top bottom",
                                    end: "bottom top",
                                },
                                onUpdate: function() {
                                    i.textContent = Math.floor(dummy.val)
                                }
                            })
                        })
                    }

                    function staggerLeftReveal() {
                        const elems = rootEl.querySelectorAll("[anim-stagger-left-reveal]");
                        elems.forEach((elem) => {
                            const staggers = elem.querySelectorAll(".stagger-piece");
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(staggers, {
                                opacity: 0,
                                x: elem.dataset.direction == "inverse" ? -75 : 75,
                            }, {
                                opacity: 1,
                                x: "0%",
                                ease: "power2.inOut",
                                stagger: elem.dataset.stagger || 0.1,
                                duration: elem.dataset.duration || 1.3,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: "top bottom",
                                    end: "bottom 50%",
                                    scrub: elem.dataset.scrub == "true" ? !0 : !1,
                                },
                            });
                            elem.classList.add("inited")
                        })
                    }

                    function staggerClassReveal() {
                        const elems = rootEl.querySelectorAll("[anim-stagger-class-reveal]");
                        elems.forEach((elem) => {
                            const staggers = elem.querySelectorAll(".stagger_piece");
                            let delayIncrement = parseFloat(elem.dataset.stagger) || 0.1;
                            let delay = parseFloat(elem.dataset.delay) || 0;
                            let duration = parseFloat(elem.dataset.duration) || 1.3;
                            staggers.forEach((staggerElem, i) => {
                                staggerElem.dummy = 0;
                                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(staggerElem, {
                                    dummy: 0
                                }, {
                                    dummy: 1,
                                    ease: "power2.inOut",
                                    duration: duration,
                                    delay: delay + i * delayIncrement,
                                    onStart: function() {
                                        staggerElem.classList.add("anim-started")
                                    },
                                    onComplete: function() {
                                        staggerElem.classList.add("animated")
                                    },
                                    scrollTrigger: {
                                        trigger: elem,
                                        start: "top bottom",
                                        end: "bottom 50%",
                                        scrub: elem.dataset.scrub === "false" ? !1 : !0,
                                    },
                                })
                            })
                        })
                    }

                    function fadeUpReveal() {
                        const elems = rootEl.querySelectorAll("[anim-fade-up-reveal]");
                        elems.forEach((elem) => {
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(elem, {
                                opacity: 0,
                                y: elem.dataset.small == "true" ? "50%" : "100%",
                            }, {
                                opacity: 1,
                                y: "0%",
                                ease: "expo.out",
                                duration: 1,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: elem.dataset.start || "top 85%",
                                    end: "bottom top"
                                },
                            });
                            elem.classList.add("inited")
                        })
                    }

                    function fadeUp() {
                        const elems = rootEl.querySelectorAll("[anim-fade-up]");
                        elems.forEach((elem) => {
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(elem, {
                                opacity: 0,
                            }, {
                                opacity: 1,
                                ease: "expo.out",
                                duration: 3,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: elem.dataset.start || "top 85%",
                                    end: "bottom top"
                                },
                            })
                        })
                    }

                    function fadeScaleReveal() {
                        const elems = rootEl.querySelectorAll("[anim-fade-scale-reveal]");
                        elems.forEach((elem) => {
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(elem, {
                                opacity: 0,
                                scale: 0.8,
                            }, {
                                opacity: 1,
                                scale: 1,
                                ease: elem.dataset.ease || "expo.inOut",
                                duration: elem.dataset.duration || 1.4,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: elem.dataset.start || "top 85%",
                                    end: "bottom top"
                                },
                            })
                        })
                    }

                    function introMediaReveal() {
                        const elems = rootEl.querySelectorAll("[anim-intro-media-reveal]");
                        elems.forEach((elem) => {
                            elem.anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                                paused: !0,
                                delay: elem.dataset.delay || 0,
                                scrollTrigger: {
                                    trigger: elem,
                                    start: elem.dataset.start || "-50% 85%",
                                    end: "bottom top",
                                },
                            });
                            elem.anim.add("start");
                            elem.anim.fromTo(elem, {
                                y: window.innerWidth > 768 ? "50%" : "0%",
                                opacity: 0
                            }, {
                                opacity: 1,
                                y: "0%",
                                ease: "expo.inOut",
                                duration: elem.dataset.duration || 2,
                            }, "start");
                            elem.anim.fromTo(elem.children[0], {
                                scale: window.innerWidth > 768 ? 3 : 1,
                            }, {
                                scale: 1,
                                ease: "expo.inOut",
                                duration: elem.dataset.duration || 2,
                            }, "start")
                        })
                    }
                    bottomMaskReveal();
                    textLetterFadeReveal();
                    countNumberReveal();
                    staggerLeftReveal();
                    staggerClassReveal();
                    fadeUpReveal();
                    fadeUp();
                    fadeScaleReveal();
                    introMediaReveal()
                }
            }),
        "./src/scripts/helpers/R2Dom.js":
            /*!**************************************!*\
              !*** ./src/scripts/helpers/R2Dom.js ***!
              \**************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                });
                let R2Dom = {
                    Methods: {},
                    Init: function() {
                        document.querySelectorAll("[r2-method]").forEach((function(elem) {
                            const attrMethods = elem.getAttribute("r2-method");
                            attrMethods.split(" ").forEach((function(method) {
                                try {
                                    new R2Dom.Methods[method](elem)
                                } catch (err) {}
                            }))
                        }))
                    }
                };
                const __WEBPACK_DEFAULT_EXPORT__ = (R2Dom)
            }),
        "./src/scripts/helpers/SplitText.min.js":
            /*!**********************************************!*\
              !*** ./src/scripts/helpers/SplitText.min.js ***!
              \**********************************************/
            (function(__unused_webpack_module, exports) {
                /*!
                 * SplitText 3.12.5
                 * https://gsap.com
                 * 
                 * @license Copyright 2024, GreenSock. All rights reserved.
                 * This plugin is a membership benefit of Club GSAP and is only authorized for use in sites/apps/products developed by individuals/companies with an active Club GSAP membership. See https://gsap.com/pricing
                 * @author: Jack Doyle, jack@greensock.com
                 */
                ! function(D, u) {
                    !0 ? u(exports) : 0
                }(this, function(D) {
                    "use strict";
                    var b = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;

                    function n(D) {
                        X = document, e = window, (C = C || D || e.gsap || console.warn("Please gsap.registerPlugin(SplitText)")) && (E = C.utils.toArray, i = C.core.context || function() {}, F = 1)
                    }

                    function o(D) {
                        return e.getComputedStyle(D)
                    }

                    function p(D) {
                        return "absolute" === D.position || !0 === D.absolute
                    }

                    function q(D, u) {
                        for (var e, t = u.length; - 1 < --t;)
                            if (e = u[t], D.substr(0, e.length) === e) return e.length
                    }

                    function s(D, u) {
                        void 0 === D && (D = "");
                        var e = ~D.indexOf("++"),
                            t = 1;
                        return e && (D = D.split("++").join("")),
                            function() {
                                return "<" + u + " style='position:relative;display:inline-block;'" + (D ? " class='" + D + (e ? t++ : "") + "'>" : ">")
                            }
                    }

                    function t(D, u, e) {
                        var F = D.nodeType;
                        if (1 === F || 9 === F || 11 === F)
                            for (D = D.firstChild; D; D = D.nextSibling) t(D, u, e);
                        else 3 !== F && 4 !== F || (D.nodeValue = D.nodeValue.split(u).join(e))
                    }

                    function u(D, u) {
                        for (var e = u.length; - 1 < --e;) D.push(u[e])
                    }

                    function v(D, u, e) {
                        for (var t; D && D !== u;) {
                            if (t = D._next || D.nextSibling) return t.textContent.charAt(0) === e;
                            D = D.parentNode || D._parent
                        }
                    }

                    function w(D) {
                        var u, e, t = E(D.childNodes),
                            F = t.length;
                        for (u = 0; u < F; u++)(e = t[u])._isSplit ? w(e) : u && e.previousSibling && 3 === e.previousSibling.nodeType ? (e.previousSibling.nodeValue += 3 === e.nodeType ? e.nodeValue : e.firstChild.nodeValue, D.removeChild(e)) : 3 !== e.nodeType && (D.insertBefore(e.firstChild, e), D.removeChild(e))
                    }

                    function x(D, u) {
                        return parseFloat(u[D]) || 0
                    }

                    function y(D, e, F, C, i, n, s) {
                        var E, r, l, d, a, h, B, f, A, c, g, y, b = o(D),
                            _ = x("paddingLeft", b),
                            S = -999,
                            T = x("borderBottomWidth", b) + x("borderTopWidth", b),
                            m = x("borderLeftWidth", b) + x("borderRightWidth", b),
                            N = x("paddingTop", b) + x("paddingBottom", b),
                            L = x("paddingLeft", b) + x("paddingRight", b),
                            W = x("fontSize", b) * (e.lineThreshold || .2),
                            H = b.textAlign,
                            O = [],
                            V = [],
                            M = [],
                            R = e.wordDelimiter || " ",
                            j = e.tag ? e.tag : e.span ? "span" : "div",
                            k = e.type || e.split || "chars,words,lines",
                            P = i && ~k.indexOf("lines") ? [] : null,
                            z = ~k.indexOf("words"),
                            q = ~k.indexOf("chars"),
                            G = p(e),
                            I = e.linesClass,
                            J = ~(I || "").indexOf("++"),
                            K = [],
                            Q = "flex" === b.display,
                            U = D.style.display;
                        for (J && (I = I.split("++").join("")), Q && (D.style.display = "block"), l = (r = D.getElementsByTagName("*")).length, a = [], E = 0; E < l; E++) a[E] = r[E];
                        if (P || G)
                            for (E = 0; E < l; E++)((h = (d = a[E]).parentNode === D) || G || q && !z) && (y = d.offsetTop, P && h && Math.abs(y - S) > W && ("BR" !== d.nodeName || 0 === E) && (B = [], P.push(B), S = y), G && (d._x = d.offsetLeft, d._y = y, d._w = d.offsetWidth, d._h = d.offsetHeight), P && ((d._isSplit && h || !q && h || z && h || !z && d.parentNode.parentNode === D && !d.parentNode._isSplit) && (B.push(d), d._x -= _, v(d, D, R) && (d._wordEnd = !0)), "BR" === d.nodeName && (d.nextSibling && "BR" === d.nextSibling.nodeName || 0 === E) && P.push([])));
                        for (E = 0; E < l; E++)
                            if (h = (d = a[E]).parentNode === D, "BR" !== d.nodeName)
                                if (G && (A = d.style, z || h || (d._x += d.parentNode._x, d._y += d.parentNode._y), A.left = d._x + "px", A.top = d._y + "px", A.position = "absolute", A.display = "block", A.width = d._w + 1 + "px", A.height = d._h + "px"), !z && q)
                                    if (d._isSplit)
                                        for (d._next = r = d.nextSibling, d.parentNode.appendChild(d); r && 3 === r.nodeType && " " === r.textContent;) d._next = r.nextSibling, d.parentNode.appendChild(r), r = r.nextSibling;
                                    else d.parentNode._isSplit ? (d._parent = d.parentNode, !d.previousSibling && d.firstChild && (d.firstChild._isFirst = !0), d.nextSibling && " " === d.nextSibling.textContent && !d.nextSibling.nextSibling && K.push(d.nextSibling), d._next = d.nextSibling && d.nextSibling._isFirst ? null : d.nextSibling, d.parentNode.removeChild(d), a.splice(E--, 1), l--) : h || (y = !d.nextSibling && v(d.parentNode, D, R), d.parentNode._parent && d.parentNode._parent.appendChild(d), y && d.parentNode.appendChild(X.createTextNode(" ")), "span" === j && (d.style.display = "inline"), O.push(d));
                        else d.parentNode._isSplit && !d._isSplit && "" !== d.innerHTML ? V.push(d) : q && !d._isSplit && ("span" === j && (d.style.display = "inline"), O.push(d));
                        else P || G ? (d.parentNode && d.parentNode.removeChild(d), a.splice(E--, 1), l--) : z || D.appendChild(d);
                        for (E = K.length; - 1 < --E;) K[E].parentNode.removeChild(K[E]);
                        if (P) {
                            for (G && (c = X.createElement(j), D.appendChild(c), g = c.offsetWidth + "px", y = c.offsetParent === D ? 0 : D.offsetLeft, D.removeChild(c)), A = D.style.cssText, D.style.cssText = "display:none;"; D.firstChild;) D.removeChild(D.firstChild);
                            for (f = " " === R && (!G || !z && !q), E = 0; E < P.length; E++) {
                                for (B = P[E], (c = X.createElement(j)).style.cssText = "display:block;text-align:" + H + ";position:" + (G ? "absolute;" : "relative;"), I && (c.className = I + (J ? E + 1 : "")), M.push(c), l = B.length, r = 0; r < l; r++) "BR" !== B[r].nodeName && (d = B[r], c.appendChild(d), f && d._wordEnd && c.appendChild(X.createTextNode(" ")), G && (0 === r && (c.style.top = d._y + "px", c.style.left = _ + y + "px"), d.style.top = "0px", y && (d.style.left = d._x - y + "px")));
                                0 === l ? c.innerHTML = "&nbsp;" : z || q || (w(c), t(c, String.fromCharCode(160), " ")), G && (c.style.width = g, c.style.height = d._h + "px"), D.appendChild(c)
                            }
                            D.style.cssText = A
                        }
                        G && (s > D.clientHeight && (D.style.height = s - N + "px", D.clientHeight < s && (D.style.height = s + T + "px")), n > D.clientWidth && (D.style.width = n - L + "px", D.clientWidth < n && (D.style.width = n + m + "px"))), Q && (U ? D.style.display = U : D.style.removeProperty("display")), u(F, O), z && u(C, V), u(i, M)
                    }

                    function z(D, u, e, F) {
                        function eb(D) {
                            return D === B || D === T && " " === B
                        }
                        var C, i, n, s, E, r, l, o, d = u.tag ? u.tag : u.span ? "span" : "div",
                            a = ~(u.type || u.split || "chars,words,lines").indexOf("chars"),
                            h = p(u),
                            B = u.wordDelimiter || " ",
                            f = " " !== B ? "" : h ? "&#173; " : " ",
                            A = "</" + d + ">",
                            c = 1,
                            x = u.specialChars ? "function" == typeof u.specialChars ? u.specialChars : q : null,
                            g = X.createElement("div"),
                            y = D.parentNode;
                        for (y.insertBefore(g, D), g.textContent = D.nodeValue, y.removeChild(D), l = -1 !== (C = function getText(D) {
                                var u = D.nodeType,
                                    e = "";
                                if (1 === u || 9 === u || 11 === u) {
                                    if ("string" == typeof D.textContent) return D.textContent;
                                    for (D = D.firstChild; D; D = D.nextSibling) e += getText(D)
                                } else if (3 === u || 4 === u) return D.nodeValue;
                                return e
                            }(D = g)).indexOf("<"), !1 !== u.reduceWhiteSpace && (C = C.replace(S, " ").replace(_, "")), l && (C = C.split("<").join("{{LT}}")), E = C.length, i = (" " === C.charAt(0) ? f : "") + e(), n = 0; n < E; n++)
                            if (r = C.charAt(n), x && (o = x(C.substr(n), u.specialChars))) r = C.substr(n, o || 1), i += a && " " !== r ? F() + r + "</" + d + ">" : r, n += o - 1;
                            else if (eb(r) && !eb(C.charAt(n - 1)) && n) {
                            for (i += c ? A : "", c = 0; eb(C.charAt(n + 1));) i += f, n++;
                            n === E - 1 ? i += f : ")" !== C.charAt(n + 1) && (i += f + e(), c = 1)
                        } else "{" === r && "{{LT}}" === C.substr(n, 6) ? (i += a ? F() + "{{LT}}</" + d + ">" : "{{LT}}", n += 5) : 55296 <= r.charCodeAt(0) && r.charCodeAt(0) <= 56319 || 65024 <= C.charCodeAt(n + 1) && C.charCodeAt(n + 1) <= 65039 ? (s = ((C.substr(n, 12).split(b) || [])[1] || "").length || 2, i += a && " " !== r ? F() + C.substr(n, s) + "</" + d + ">" : C.substr(n, s), n += s - 1) : i += a && " " !== r ? F() + r + "</" + d + ">" : r;
                        D.outerHTML = i + (c ? A : ""), l && t(y, "{{LT}}", "<")
                    }

                    function A(D, u, e, t) {
                        var F, C, i = E(D.childNodes),
                            n = i.length,
                            s = p(u);
                        if (3 !== D.nodeType || 1 < n) {
                            for (u.absolute = !1, F = 0; F < n; F++)(C = i[F])._next = C._isFirst = C._parent = C._wordEnd = null, 3 === C.nodeType && !/\S+/.test(C.nodeValue) || (s && 3 !== C.nodeType && "inline" === o(C).display && (C.style.display = "inline-block", C.style.position = "relative"), C._isSplit = !0, A(C, u, e, t));
                            return u.absolute = s, void(D._isSplit = !0)
                        }
                        z(D, u, e, t)
                    }
                    var X, e, F, C, i, E, r, _ = /(?:\r|\n|\t\t)/g,
                        S = /(?:\s\s+)/g,
                        T = String.fromCharCode(160),
                        l = ((r = SplitText.prototype).split = function split(D) {
                            this.isSplit && this.revert(), this.vars = D = D || this.vars, this._originals.length = this.chars.length = this.words.length = this.lines.length = 0;
                            for (var u, e, t, F = this.elements.length, C = D.tag ? D.tag : D.span ? "span" : "div", i = s(D.wordsClass, C), n = s(D.charsClass, C); - 1 < --F;) t = this.elements[F], this._originals[F] = {
                                html: t.innerHTML,
                                style: t.getAttribute("style")
                            }, u = t.clientHeight, e = t.clientWidth, A(t, D, i, n), y(t, D, this.chars, this.words, this.lines, e, u);
                            return this.chars.reverse(), this.words.reverse(), this.lines.reverse(), this.isSplit = !0, this
                        }, r.revert = function revert() {
                            var e = this._originals;
                            if (!e) throw "revert() call wasn't scoped properly.";
                            return this.elements.forEach(function(D, u) {
                                D.innerHTML = e[u].html, D.setAttribute("style", e[u].style)
                            }), this.chars = [], this.words = [], this.lines = [], this.isSplit = !1, this
                        }, SplitText.create = function create(D, u) {
                            return new SplitText(D, u)
                        }, SplitText);

                    function SplitText(D, u) {
                        F || n(), this.elements = E(D), this.chars = [], this.words = [], this.lines = [], this._originals = [], this.vars = u || {}, i(this), this.split(u)
                    }
                    l.version = "3.12.5", l.register = n, D.SplitText = l, D.default = l;
                    if (typeof(window) === "undefined" || window !== D) {
                        Object.defineProperty(D, "__esModule", {
                            value: !0
                        })
                    } else {
                        delete D.default
                    }
                })
            }),
        "./src/scripts/helpers/globals.js":
            /*!****************************************!*\
              !*** ./src/scripts/helpers/globals.js ***!
              \****************************************/
            ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {
                "use strict";
                var _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! @studio-freight/lenis */ "./node_modules/@studio-freight/lenis/dist/lenis.mjs");
                var swup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! swup */ "./node_modules/swup/dist/Swup.modern.js");
                var _swup_parallel_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @swup/parallel-plugin */ "./node_modules/@swup/parallel-plugin/dist/index.modern.js");
                var _swup_body_class_plugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @swup/body-class-plugin */ "./node_modules/@swup/body-class-plugin/dist/index.modern.js");
                var _swup_preload_plugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @swup/preload-plugin */ "./node_modules/@swup/preload-plugin/dist/index.modern.js");
                var _swup_debug_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! @swup/debug-plugin */ "./node_modules/@swup/debug-plugin/dist/index.modern.js");
                var _swup_gtm_plugin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! @swup/gtm-plugin */ "./node_modules/@swup/gtm-plugin/dist/index.modern.js");
                var gsap__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                var _R2Dom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! ./R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var _Animations_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! ./Animations.js */ "./src/scripts/helpers/Animations.js");
                gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger);
                const isSafari = /^((?!chrome|chromium|android).)*safari/i.test(navigator.userAgent);
                if (window.location.search && window.location.search == "?noscale") {
                    document.documentElement.classList.add("noscale")
                }

                function isAppleOS() {
                    const platform = navigator.platform.toLowerCase();
                    return platform.indexOf("mac") !== -1 || platform.indexOf("macintosh") !== -1 || platform.indexOf("intel mac") !== -1
                }
                let isChrome;
                const userAgent = navigator.userAgent.toLowerCase();
                if (userAgent.indexOf("chrome") > -1) {
                    isChrome = !0
                } else {
                    isChrome = !1
                }
                const isMobile = window.innerWidth <= 768;
                const isIOS = isAppleOS();
                document.body.classList.add(isIOS ? "apple_os" : "regular_os");
                window.addEventListener("pageshow", function(event) {
                    if (event.persisted) {
                        document.body.classList.add("loaded")
                    } else {
                        console.log("Page was loaded normally.")
                    }
                });

                function initVideoModal() {
                    const el = document.querySelector("#videoModal");
                    const mediaFrame = el.querySelector(".media-frame");
                    const media = el.querySelector(".media");
                    const closeBtn = el.querySelector(".close");
                    const controls = el.querySelector(".controls");
                    const playBtn = controls.querySelector(".play-pause");
                    const muteBtn = controls.querySelector(".mute");
                    let isPlaying = !1;
                    el.open = (elem) => {
                        const mediaSrc = media.src.replace(/^(https?:)?\/\/localhost:3000/, "");
                        const elemSrc = elem.dataset.modalSrc.replace(/^(https?:)?\/\/localhost:3000/, "");
                        if (media.src.length == 0) {
                            media.src = elem.dataset.modalSrc;
                            console.log("Empty src")
                        } else if (elemSrc != mediaSrc) {
                            media.src = elem.dataset.modalSrc;
                            console.log("Different src")
                        }
                        const smallVideo = document.querySelector(elem.dataset.smallVideo);
                        el.classList.add("open");
                        anim.play();
                        if (window.lenis) {
                            window.lenis.stop()
                        } else {
                            document.body.classList.add("overflow-hidden")
                        }
                        const rect = smallVideo.getBoundingClientRect();
                        mediaFrame.removeAttribute("style");
                        gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.from(mediaFrame, {
                            width: rect.width,
                            height: rect.height,
                            left: rect.left,
                            top: rect.top,
                            duration: 0.6,
                            ease: "power3.inOut",
                            delay: 0.2,
                            onStart: () => {
                                let promise = media.play();
                                if (promise !== undefined) {
                                    promise.then(_ => {}).catch(error => {})
                                }
                            }
                        })
                    }
                    el.close = () => {
                        el.classList.remove("open");
                        anim.reverse();
                        media.pause();
                        if (window.lenis) {
                            window.lenis.start()
                        } else {
                            document.body.classList.remove("overflow-hidden")
                        }
                    }
                    let anim = gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.timeline({
                        paused: !0
                    });
                    anim.from(el, {
                        display: "none",
                        opacity: 0,
                        duration: 0.3,
                        ease: "power2.inOut"
                    });
                    media.addEventListener("play", () => {
                        isPlaying = !0;
                        playBtn.classList.remove("paused");
                        playBtn.classList.add("playing")
                    });
                    media.addEventListener("pause", () => {
                        isPlaying = !1;
                        playBtn.classList.remove("playing");
                        playBtn.classList.add("paused")
                    });
                    media.addEventListener("volumechange", () => {
                        if (media.muted) {
                            muteBtn.classList.add("muted")
                        } else {
                            muteBtn.classList.remove("muted")
                        }
                    });
                    document.addEventListener("keydown", (e) => {
                        if (e.key == "Escape") {
                            el.close()
                        }
                    });
                    closeBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        el.close()
                    });
                    playBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (isPlaying) {
                            media.pause()
                        } else {
                            let promise = media.play();
                            if (promise !== undefined) {
                                promise.then(_ => {}).catch(error => {})
                            }
                        }
                    });
                    muteBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (media.muted) {
                            media.muted = !1
                        } else {
                            media.muted = !0
                        }
                    })
                }

                function initModalOpeners() {
                    const openers = document.querySelectorAll(".video-modal-opener");
                    openers.forEach((opener) => {
                        opener.addEventListener("click", (e) => {
                            e.preventDefault();
                            document.querySelector("#videoModal").open(opener)
                        })
                    })
                }

                function playAutoVideos() {
                    const videos = document.querySelectorAll("video[autoplay]");
                    videos.forEach((video) => {
                        let promise = video.play();
                        if (promise !== undefined) {
                            promise.then(_ => {}).catch(error => {})
                        }
                    })
                }

                function checkMediaLoaded(elem) {
                    let rootEl = elem || document;
                    const medias = document.querySelectorAll(".check-media-loaded .media");
                    medias.forEach((media) => {
                        if (media.tagName === "IMG") {
                            if (media.complete) {
                                media.closest(".check-media-loaded").classList.add("media-loaded")
                            } else {
                                media.addEventListener("load", function() {
                                    media.closest(".check-media-loaded").classList.add("media-loaded")
                                })
                            }
                        } else if (media.tagName === "VIDEO") {
                            if (media.readyState >= 2) {
                                media.closest(".check-media-loaded").classList.add("media-loaded")
                            } else {
                                media.addEventListener("loadedmetadata", function() {
                                    media.closest(".check-media-loaded").classList.add("media-loaded")
                                })
                            }
                        }
                    })
                }

                function loadHandle(el) {
                    _R2Dom__WEBPACK_IMPORTED_MODULE_8__["default"].Init();
                    initModalOpeners();
                    playAutoVideos();
                    handleMediaLoad();
                    videoViewportControl();
                    setTimeout(() => {
                        (0, _Animations_js__WEBPACK_IMPORTED_MODULE_9__["default"])(el);
                        initGravityFormsBarba()
                    }, 350)
                }
                initGravityFormsBarba();
                initVideoModal();
                checkMediaLoaded();
                handleMediaLoad();
                initModalOpeners();
                videoViewportControl();
                let lenis;
                if (!isMobile) {
                    lenis = new _studio_freight_lenis__WEBPACK_IMPORTED_MODULE_10__["default"]({
                        duration: 0.75,
                        easing: (x) => 1 - Math.pow(1 - x, 5),
                    });
                    let raf = function(time) {
                        lenis.raf(time);
                        requestAnimationFrame(raf)
                    }
                    requestAnimationFrame(raf);
                    window.lenis = lenis
                }
                let lastScrollY = 0;
                window.addEventListener("scroll", () => {
                    let scrollY = window.scrollY;
                    if (scrollY > lastScrollY) {
                        document.body.classList.remove("scroll-up");
                        document.body.classList.add("scroll-down")
                    } else {
                        document.body.classList.remove("scroll-down");
                        document.body.classList.add("scroll-up")
                    }
                    if (scrollY > 100) {
                        document.body.classList.add("scroll-past-top")
                    } else {
                        document.body.classList.remove("scroll-past-top")
                    }
                    lastScrollY = scrollY <= 0 ? 0 : scrollY
                });
                if (!window.ADMIN_BAR_VISIBLE && window.innerWidth > 768) {
                    const swup = new swup__WEBPACK_IMPORTED_MODULE_0__["default"]({
                        containers: ["main"],
                        animateHistoryBrowsing: !0,
                        cache: !0,
                        linkToSelf: 'scroll',
                        plugins: [new _swup_parallel_plugin__WEBPACK_IMPORTED_MODULE_1__["default"](), new _swup_preload_plugin__WEBPACK_IMPORTED_MODULE_3__["default"](), new _swup_body_class_plugin__WEBPACK_IMPORTED_MODULE_2__["default"](), new _swup_gtm_plugin__WEBPACK_IMPORTED_MODULE_5__["default"]()],
                    });
                    swup.hooks.on('visit:start', (visit) => {
                        if (visit.trigger.el && visit.trigger.el.closest(".page-header") != null) {
                            const lnk = visit.trigger.el;
                            const current = localStorage.getItem("page-order") || 0;
                            if (parseInt(lnk.dataset.order) > current) {
                                document.documentElement.classList.remove("swup-direction-left")
                            } else {
                                document.documentElement.classList.add("swup-direction-left")
                            }
                            localStorage.setItem("page-order", parseInt(lnk.dataset.order))
                        } else {
                            document.documentElement.classList.remove("swup-direction-left")
                        }
                        if (visit.history.popstate) {
                            window.location.href = visit.to.url
                        }
                        if ("scrollRestoration" in history) {
                            history.scrollRestoration = "manual"
                        }
                    });
                    swup.hooks.on('animation:out:start', (visit) => {
                        if ("scrollRestoration" in history) {
                            history.scrollRestoration = "manual"
                        }
                        const prev = document.querySelector(".swup-wrap .transform-wrap");
                        gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.set(prev, {
                            y: -window.scrollY,
                            transition: "none"
                        });
                        if (window.lenis) {
                            window.lenis ? .scrollTo(0, {
                                immediate: !0,
                                lock: !0,
                            })
                        } else {
                            window.scrollTo(0, 0)
                        }
                        if (window.lenis) {
                            window.lenis.stop()
                        }
                        gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.killAll()
                    });
                    swup.hooks.on('animation:in:start', (visit) => {
                        const next = document.querySelector(".pages .page:not([aria-hidden])");
                        loadHandle(next)
                    });
                    swup.hooks.on('animation:in:end', (visit) => {
                        checkMediaLoaded();
                        gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.refresh();
                        if (window.lenis) {
                            window.lenis.start()
                        }
                    })
                }

                function initGravityFormsBarba() {
                    var contactForm = $('.form-wrap');
                    contactForm.each(function() {
                        var currentForm = $(this),
                            gfItem = currentForm.find('.gfid'),
                            gfNum = gfItem.attr('data-id'),
                            gfId = parseInt(gfNum),
                            gfTitle = gfItem.attr('data-title'),
                            gfDesc = gfItem.attr('data-descr'),
                            gfAjax = gfItem.attr('data-ajax');
                        currentForm.animate({
                            'opacity': '0.0'
                        }, 0);
                        if (currentForm.length) {
                            $.ajax({
                                type: "GET",
                                url: admin_url,
                                data: {
                                    action: 'load_gravity_form',
                                    formid: gfId,
                                    formtitle: gfTitle,
                                    formdescr: gfDesc,
                                    formajax: gfAjax,
                                }
                            }).done(function(data) {
                                currentForm.html(data);
                                currentForm.animate({
                                    'opacity': '1.0'
                                }, 400);
                                if (currentForm[0].closest(".form")) {
                                    gsap__WEBPACK_IMPORTED_MODULE_6__.gsap.fromTo(currentForm[0].closest(".form"), {
                                        height: 0,
                                    }, {
                                        height: currentForm[0].clientHeight,
                                        clearProps: "all",
                                        onComplete: () => {
                                            gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.refresh()
                                        }
                                    })
                                }
                                gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.refresh();
                                console.log("Forms apended!");
                                jQuery(document).on('gform_confirmation_loaded', function(event, formId) {
                                    var gravityFormSection = currentForm.closest('.gravity-form-section');
                                    if (gravityFormSection.length) {
                                        var sectionFormId = gravityFormSection.attr('data-formID');
                                        console.log('Section Form ID: ' + sectionFormId);
                                        console.log('EVENT ID: ' + formId);
                                        if (parseInt(sectionFormId) === formId) {
                                            console.log('Form IDs match: ' + formId);
                                            console.log(gravityFormSection.find('.hide-on-submit-gravity'));
                                            gravityFormSection.find('.hide-on-submit-gravity').css('display', 'none')
                                        } else {
                                            console.log('Form IDs do not match')
                                        }
                                    }
                                    gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.refresh()
                                })
                            })
                        }
                    })
                }

                function handleMediaLoad() {
                    const mediaElements = document.querySelectorAll('*:not(.check-media-loaded) img:not(.no-placeholder), *:not(.check-media-loaded) video:not(.no-placeholder)');
                    mediaElements.forEach(media => {
                        if (media.tagName.toLowerCase() === 'img') {
                            media.addEventListener('load', () => {
                                media.classList.add('media-loaded')
                            });
                            if (media.complete) {
                                media.classList.add('media-loaded')
                            }
                        }
                        if (media.tagName.toLowerCase() === 'video') {
                            media.addEventListener('loadeddata', () => {
                                media.classList.add('media-loaded')
                            });
                            if (media.readyState >= 2) {
                                media.classList.add('media-loaded')
                            }
                        }
                    })
                }

                function videoViewportControl() {
                    const videos = document.querySelectorAll("video.play-on-scroll");
                    if (videos) {
                        videos.forEach(function(video) {
                            gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_7__.ScrollTrigger.create({
                                trigger: video,
                                start: "top bottom",
                                end: "bottom top",
                                onEnter: function() {
                                    video.play();
                                    console.log('play')
                                },
                                onEnterBack: function() {
                                    video.play();
                                    console.log('play')
                                },
                                onLeave: function() {
                                    video.pause();
                                    console.log('pause')
                                },
                                onLeaveBack: function() {
                                    video.pause();
                                    console.log('pause')
                                }
                            })
                        })
                    }
                }
            }),
        "./src/scripts/methods-global/archLayout.js":
            /*!**************************************************!*\
              !*** ./src/scripts/methods-global/archLayout.js ***!
              \**************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.archLayout = function(_this) {
                    const el = _this;
                    const imagesFrame = el.querySelector(".images");
                    const frontFaceImg = el.querySelector(".face.front .media");
                    let isInvert = el.classList.contains("invert");
                    const a = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                        repeat: -1,
                        repeatDelay: 2,
                        onStart: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        },
                        onRepeat: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        }
                    });
                    let xr = {
                        rotation: 0
                    };
                    let yr = {
                        rotation: 0
                    };
                    let zr = {
                        rotation: 0
                    };
                    a.to(yr, {
                        rotation: isInvert ? 90 : -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--yr", yr.rotation + "deg")
                        }
                    });
                    a.to(xr, {
                        rotation: isInvert ? 90 : -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--xr", xr.rotation + "deg")
                        },
                        onComplete: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: isInvert ? -90 : -90
                            })
                        }
                    });
                    a.to(zr, {
                        rotation: isInvert ? 90 : 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--zr", zr.rotation + "deg")
                        }
                    })
                }
            }),
        "./src/scripts/methods-global/archTeam.js":
            /*!************************************************!*\
              !*** ./src/scripts/methods-global/archTeam.js ***!
              \************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var siema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! siema */ "./node_modules/siema/dist/siema.min.js");
                var siema__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(siema__WEBPACK_IMPORTED_MODULE_1__);
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.archTeam = function(_this) {
                    const el = _this;
                    const imageFrames = el.querySelectorAll(".image-frame");
                    let activeMediaFrame;

                    function removeClass() {
                        imageFrames.forEach((frame) => {
                            frame.classList.remove("active")
                        })
                    }

                    function dimOthers() {
                        imageFrames.forEach((frame) => {
                            frame.classList.add("dimmed")
                        })
                    }

                    function resetDim() {
                        imageFrames.forEach((frame) => {
                            frame.classList.remove("dimmed")
                        })
                    }
                    imageFrames.forEach((frame) => {
                        frame.addEventListener("mouseenter", () => {
                            removeClass();
                            dimOthers();
                            frame.classList.add("active");
                            frame.classList.remove("dimmed");
                            activeMediaFrame = frame.querySelector(".media");
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(hoverYdist, {
                                val: 7,
                                duration: 0.2
                            })
                        });
                        frame.addEventListener("mouseleave", () => {
                            resetDim();
                            activeMediaFrame = null;
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(hoverYdist, {
                                val: 0,
                                duration: 0.2
                            });
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(frame.querySelector(".media"), {
                                y: 0,
                                duration: 0.2
                            })
                        })
                    });
                    const sliderEl = el.querySelector(".slider");
                    const slides = sliderEl.querySelectorAll(".slide");
                    const prev = el.querySelector(".btn.prev");
                    const next = el.querySelector(".btn.next");

                    function setClass(index) {
                        slides.forEach((slide, i) => {
                            if (i == index) {
                                slide.classList.add("active")
                            } else {
                                slide.classList.remove("active")
                            }
                        })
                    }
                    let slider;

                    function initSlider() {
                        slider = new(siema__WEBPACK_IMPORTED_MODULE_1___default())({
                            selector: sliderEl,
                            easing: "linear",
                            draggable: !1,
                            duration: 0,
                            onInit: function() {
                                setClass(this.currentSlide)
                            },
                            onChange: function() {
                                setClass(this.currentSlide)
                            },
                        });
                        prev.addEventListener("click", (e) => {
                            e.preventDefault();
                            slider.prev()
                        });
                        next.addEventListener("click", (e) => {
                            e.preventDefault();
                            slider.next()
                        })
                    }
                    if (!el.classList.contains("no-slider")) {}
                    initSlider();
                    let hoverYdist = {
                        val: 0
                    };

                    function animate() {
                        if (activeMediaFrame) {
                            const t = Date.now() * 0.0017;
                            const posY = 0 + (Math.sin(t) * hoverYdist.val);
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.set(activeMediaFrame, {
                                y: posY
                            })
                        }
                        requestAnimationFrame(animate)
                    }
                    animate()
                }
            }),
        "./src/scripts/methods-global/blogList.js":
            /*!************************************************!*\
              !*** ./src/scripts/methods-global/blogList.js ***!
              \************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.blogList = function(_this) {
                    const cards = _this.querySelectorAll(".card");

                    function removeClass() {
                        cards.forEach((card) => {
                            card.classList.remove("active")
                        })
                    }
                    cards.forEach((card) => {
                        card.addEventListener("mouseenter", () => {
                            removeClass();
                            card.classList.add("active")
                        })
                    })
                }
            }),
        "./src/scripts/methods-global/blogPaginationAjax.js":
            /*!**********************************************************!*\
              !*** ./src/scripts/methods-global/blogPaginationAjax.js ***!
              \**********************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var _helpers_Animations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../helpers/Animations */ "./src/scripts/helpers/Animations.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.blogPaginationAjax = function(_this) {
                    const el = _this;
                    let blogNextPage = el.querySelectorAll('.num-not-dots');
                    if (blogNextPage && el) {
                        blogNextPage.forEach((number) => {
                            number.addEventListener("click", function(event) {
                                event.preventDefault();
                                let nextPageNumber = number.dataset.page;
                                el.style.pointerEvents = "none";
                                if (typeof lenis !== 'undefined' && lenis !== null) {
                                    lenis.scrollTo(el, {
                                        offset: -300,
                                    })
                                } else {
                                    el.scrollIntoView({
                                        behavior: 'smooth',
                                        block: 'start'
                                    })
                                }
                                setTimeout(function() {
                                    gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(el, {
                                        alpha: 0,
                                        duration: 0.5,
                                        ease: 'none'
                                    })
                                }, 300);
                                $.ajax({
                                    type: 'POST',
                                    url: admin_url,
                                    dataType: 'html',
                                    data: {
                                        action: 'blog_pagination_ajax',
                                        paged: nextPageNumber,
                                    },
                                    success: function(data) {
                                        el.innerHTML = '';
                                        el.insertAdjacentHTML('beforeend', data);
                                        _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Init();
                                        (0, _helpers_Animations__WEBPACK_IMPORTED_MODULE_1__["default"])(el);
                                        el.style.pointerEvents = "auto";
                                        setTimeout(function() {
                                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.to(el, {
                                                alpha: 1,
                                                duration: 0.5,
                                                ease: 'none'
                                            })
                                        }, 300)
                                    }
                                })
                            })
                        })
                    }
                }
            }),
        "./src/scripts/methods-global/caseStudyCards.js":
            /*!******************************************************!*\
              !*** ./src/scripts/methods-global/caseStudyCards.js ***!
              \******************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var siema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! siema */ "./node_modules/siema/dist/siema.min.js");
                var siema__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(siema__WEBPACK_IMPORTED_MODULE_1__);
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.caseStudyCards = function(_this) {
                    const cards = _this.querySelectorAll(".card");
                    if (window.innerWidth > 768) {
                        cards.forEach((card) => {
                            const media = card.querySelector(".media");
                            card.addEventListener("mouseenter", (e) => {
                                let promise = media.play();
                                if (promise !== undefined) {
                                    promise.then(_ => {}).catch(error => {})
                                }
                            });
                            card.addEventListener("mouseleave", () => {
                                media.pause()
                            });
                            card.addEventListener("mousemove", (e) => {
                                const x = e.offsetX;
                                const y = e.offsetY;
                                card.style.setProperty("--x", x + "px");
                                card.style.setProperty("--y", y + "px")
                            })
                        })
                    }
                    const sliderEl = _this.querySelector(".slider");
                    const slides = sliderEl.querySelectorAll(".slide");

                    function setClass(i) {
                        slides.forEach((slide, index) => {
                            if (i == index) {
                                slide.classList.add("active")
                            } else {
                                slide.classList.remove("active")
                            }
                        })
                    }
                    if (window.innerWidth <= 768) {
                        const slider = new(siema__WEBPACK_IMPORTED_MODULE_1___default())({
                            selector: sliderEl,
                            perPage: 1.17,
                            onInit: function() {
                                const inx = parseInt(Math.ceil(this.currentSlide));
                                setClass(inx);
                                cards.forEach((card, index) => {
                                    const media = card.querySelector(".media");
                                    if (index == inx) {
                                        let promise = media.play();
                                        if (promise !== undefined) {
                                            promise.then(_ => {}).catch(error => {})
                                        }
                                    } else {
                                        media.pause()
                                    }
                                })
                            },
                            onChange: function() {
                                const inx = parseInt(Math.ceil(this.currentSlide));
                                setClass(inx);
                                cards.forEach((card, index) => {
                                    const media = card.querySelector(".media");
                                    if (index == inx) {
                                        let promise = media.play();
                                        if (promise !== undefined) {
                                            promise.then(_ => {}).catch(error => {})
                                        }
                                    } else {
                                        media.pause()
                                    }
                                })
                            }
                        })
                    }
                }
            }),
        "./src/scripts/methods-global/contentBlocks.js":
            /*!*****************************************************!*\
              !*** ./src/scripts/methods-global/contentBlocks.js ***!
              \*****************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger);
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.contentBlocks = function(_this) {
                    const el = _this;
                    const track = el.querySelector(".track");
                    const sticky = el.querySelector(".sticky");

                    function vw(v) {
                        return v * window.innerWidth
                    }
                    let st;

                    function init() {
                        st ? .kill();
                        st = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.create({
                            trigger: track,
                            pin: sticky,
                            pinSpacer: !1,
                            pinSpacing: !1,
                            start: `top+=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            end: `bottom-=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            onEnter: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onEnterBack: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onLeave: () => {
                                document.body.classList.remove("sticky-active")
                            },
                            onLeaveBack: () => {
                                document.body.classList.remove("sticky-active")
                            },
                        })
                    }
                    if (window.innerWidth > 768) {
                        init();
                        window.addEventListener("resize", init)
                    }
                }
            }),
        "./src/scripts/methods-global/dotsSliderSection.js":
            /*!*********************************************************!*\
              !*** ./src/scripts/methods-global/dotsSliderSection.js ***!
              \*********************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var _splidejs_splide__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @splidejs/splide */ "./node_modules/@splidejs/splide/dist/js/splide.esm.js");
                var _splidejs_splide_css_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @splidejs/splide/css/core */ "./node_modules/@splidejs/splide/dist/css/splide-core.min.css");
                var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ../helpers/SplitText.min */ "./src/scripts/helpers/SplitText.min.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_3___default = __webpack_require__.n(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_3__);
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.dotsSliderSection = function(_this) {
                    const sliderEl = _this.querySelector(".splide");
                    const sliderNav = _this.querySelector(".slider-nav");
                    const progressLine = sliderNav.querySelector(".line");
                    const dots = sliderNav.querySelectorAll(".dot");
                    const titles = _this.querySelectorAll(".title");
                    const texts = _this.querySelectorAll(".text");
                    let prev, next;
                    if (window.innerWidth > 768) {
                        prev = sliderNav.querySelector(".prev");
                        next = sliderNav.querySelector(".next")
                    } else {
                        prev = _this.querySelector(".buttons.mobile .prev");
                        next = _this.querySelector(".buttons.mobile .next")
                    }
                    titles.forEach((title) => {
                        title.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_3___default())(title, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });
                    const slider = new _splidejs_splide__WEBPACK_IMPORTED_MODULE_1__["default"](sliderEl, {
                        arrows: !1,
                        pagination: !1,
                        type: "fade",
                    });
                    let ta, tb;

                    function animateTitleText(title, text) {
                        ta ? .kill();
                        tb ? .kill();
                        ta = gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(title.splitted.words, {
                            y: "150%",
                        }, {
                            y: "0%",
                            duration: 1,
                            stagger: 0.1,
                            ease: "power3.inOut"
                        });
                        tb = gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(text, {
                            y: "5%",
                            opacity: 0,
                        }, {
                            y: "0%",
                            opacity: 1,
                            duration: 0.6,
                            ease: "power3.inOut"
                        })
                    }
                    slider.on("move", () => {
                        progressLine.style.setProperty("--progress", (100 / (slider.length - 1) * slider.index) / 100);
                        dots.forEach((dot, index) => {
                            if (index == slider.index) {
                                dot.classList.add("active")
                            } else {
                                dot.classList.remove("active")
                            }
                        });
                        animateTitleText(titles[slider.index], texts[slider.index])
                    });
                    slider.mount();
                    prev.addEventListener("click", (e) => {
                        e.preventDefault();
                        slider.go("<")
                    });
                    next.addEventListener("click", (e) => {
                        e.preventDefault();
                        slider.go(">")
                    });
                    dots.forEach((dot, index) => {
                        dot.addEventListener("click", (e) => {
                            slider.go(index)
                        })
                    })
                }
            }),
        "./src/scripts/methods-global/faqList.js":
            /*!***********************************************!*\
              !*** ./src/scripts/methods-global/faqList.js ***!
              \***********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger);

                function vw(v) {
                    return v * window.innerWidth
                }
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.faqList = function(_this) {
                    const el = _this;
                    const track = el.querySelector(".track");
                    const sticky = el.querySelector(".sticky");
                    const rows = el.querySelectorAll(".row");

                    function closeAll() {
                        rows.forEach((row) => {
                            row.close ? .call()
                        })
                    }
                    rows.forEach((row, i) => {
                        const accordion = row.querySelector(".accordion");
                        const expander = row.querySelector(".expander");
                        let isOpen = !1;
                        const a = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.from([expander], {
                            height: 0,
                            duration: 0.5,
                            ease: "power2.inOut",
                            paused: !0,
                            onComplete: () => {
                                if (window.lenis) {
                                    window.lenis.scrollTo(row, {
                                        duration: 1,
                                        offset: -vw(0.0071)
                                    })
                                } else {
                                    const topPosition = row.getBoundingClientRect().top + window.pageYOffset - vw(0.0071);
                                    window.scrollTo({
                                        top: topPosition,
                                        left: 0,
                                        behavior: "smooth",
                                    });
                                    console.log(topPosition)
                                }
                                gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                            },
                            onReverseComplete: () => {
                                gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                            }
                        });

                        function open() {
                            isOpen = !0;
                            row.classList.add("is-open");
                            a.play()
                        }

                        function close() {
                            isOpen = !1;
                            row.classList.remove("is-open");
                            a.reverse();
                            gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                        }
                        accordion.addEventListener("click", (e) => {
                            e.preventDefault();
                            if (isOpen) {
                                close()
                            } else {
                                closeAll();
                                open()
                            }
                        });
                        row.close = close
                    });
                    let st;

                    function init() {
                        st ? .kill();
                        st = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.create({
                            trigger: track,
                            pin: sticky,
                            pinSpacer: !1,
                            pinSpacing: !1,
                            start: `top+=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            end: `bottom-=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            onEnter: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onEnterBack: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onLeave: () => {
                                document.body.classList.remove("sticky-active")
                            },
                            onLeaveBack: () => {
                                document.body.classList.remove("sticky-active")
                            },
                        })
                    }
                    if (window.innerWidth > 768) {
                        init();
                        window.addEventListener("resize", init)
                    }
                }
            }),
        "./src/scripts/methods-global/globalExample.js":
            /*!*****************************************************!*\
              !*** ./src/scripts/methods-global/globalExample.js ***!
              \*****************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.globalExample = function(_this) {
                    console.warn("src/scripts/global-methods/globalExample.js Method!", _this)
                }
            }),
        "./src/scripts/methods-global/goDown.js":
            /*!**********************************************!*\
              !*** ./src/scripts/methods-global/goDown.js ***!
              \**********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap/ScrollToPlugin */ "./node_modules/gsap/ScrollToPlugin.js");
                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_2__.ScrollToPlugin);

                function vw(v) {
                    return v * window.innerWidth
                }
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.goDown = function(_this) {
                    const el = _this;
                    const nextSection = el.closest(".transform-wrap").querySelector(".circle-button-card-section + section");
                    el.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (window.lenis) {
                            window.lenis.scrollTo(nextSection, {
                                duration: 1,
                                offset: -vw(0.0071)
                            })
                        } else {
                            const topPosition = nextSection.getBoundingClientRect().top + window.pageYOffset - vw(0.0071);
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(window, {
                                scrollTo: topPosition,
                                duration: 0.5
                            })
                        }
                    })
                }
            }),
        "./src/scripts/methods-global/influencersSection.js":
            /*!**********************************************************!*\
              !*** ./src/scripts/methods-global/influencersSection.js ***!
              \**********************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../helpers/SplitText.min */ "./src/scripts/helpers/SplitText.min.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1__);
                gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.registerPlugin((_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default()));
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.influencersSection = function(_this) {
                    const el = _this;
                    const titleFrame = el.querySelector(".title-frame");
                    const titles = titleFrame.querySelectorAll(".title");
                    titles.forEach((title) => {
                        title.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default())(title, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });
                    const dur = 1;
                    const eas = "power3.inOut";
                    let isReady = !0;
                    let current = 0;

                    function titleOut(title) {
                        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(title.splitted.words, {
                            y: "0%",
                        }, {
                            y: "-150%",
                            duration: dur,
                            ease: eas,
                            stagger: 0.2,
                            onStart: () => {
                                isReady = !1
                            }
                        })
                    }

                    function titleIn(title) {
                        gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.fromTo(title.splitted.words, {
                            y: "250%"
                        }, {
                            y: "0%",
                            duration: dur,
                            ease: eas,
                            stagger: 0.2,
                            onStart: () => {
                                title.style.opacity = "1"
                            },
                            onComplete: () => {
                                isReady = !0
                            }
                        })
                    }

                    function count() {
                        if (current + 1 <= titles.length - 1) {
                            current++
                        } else {
                            current = 0
                        }
                    }

                    function go() {
                        if (isReady) {
                            titleOut(titles[current]);
                            if (current < titles.length - 1) {
                                titleIn(titles[current + 1])
                            } else {
                                titleIn(titles[0])
                            }
                            setImage();
                            rotateCube();
                            count()
                        }
                    }

                    function changeAlt(i, img) {
                        img.alt = JSON.parse(el.dataset.alts)[i]
                    }
                    const imagesFrame = el.querySelector(".images");
                    const frontFaceImg = el.querySelector(".face.front .media");
                    const rightFaceImg = el.querySelector(".face.right .media");
                    const topFaceImg = el.querySelector(".face.top .media");
                    const imgArr = JSON.parse(el.dataset.images);
                    const cachedImages = [];
                    imgArr.forEach((url, index) => {
                        const img = new Image();
                        img.src = url;
                        cachedImages[index] = img
                    });
                    let cc = 1;

                    function setImage() {
                        let imageEl;
                        if (cc == 1) {
                            imageEl = rightFaceImg
                        }
                        if (cc == 2) {
                            imageEl = topFaceImg
                        }
                        if (cc == 3) {
                            imageEl = frontFaceImg
                        }
                        let curImg = current + 1;
                        if (curImg > imgArr.length - 1) {
                            curImg = 0
                        }
                        changeAlt(curImg, imageEl);
                        imageEl.src = cachedImages[curImg].src
                    }

                    function rotateCube() {
                        if (cc == 1) {
                            a.seek("b0");
                            a.tweenTo("b1")
                        } else {
                            a.tweenTo(`b${cc}`)
                        }
                        if (cc + 1 <= 3) {
                            cc++
                        } else {
                            cc = 1
                        }
                    }
                    const a = gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.timeline({
                        repeat: -1,
                        repeatDelay: 2,
                        paused: !0,
                        onStart: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        },
                        onRepeat: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        }
                    });
                    let xr = {
                        rotation: 0
                    };
                    let yr = {
                        rotation: 0
                    };
                    let zr = {
                        rotation: 0
                    };
                    a.add("b0");
                    a.to(yr, {
                        rotation: -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--yr", yr.rotation + "deg")
                        }
                    });
                    a.add("b1");
                    a.to(xr, {
                        rotation: -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--xr", xr.rotation + "deg")
                        },
                        onComplete: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_2__.gsap.set(frontFaceImg, {
                                rotation: -90
                            })
                        }
                    });
                    a.add("b2");
                    a.to(zr, {
                        rotation: 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--zr", zr.rotation + "deg")
                        }
                    });
                    a.add("b3");
                    setInterval(() => {
                        go()
                    }, 3000)
                }
            }),
        "./src/scripts/methods-global/meetTeam.js":
            /*!************************************************!*\
              !*** ./src/scripts/methods-global/meetTeam.js ***!
              \************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.meetTeam = function(_this) {
                    const el = _this;
                    let isReady = !0;
                    let current = 0;

                    function count() {
                        if (current + 1 <= cachedImages.length - 1) {
                            current++
                        } else {
                            current = 0
                        }
                    }

                    function go() {
                        if (isReady) {
                            setImage();
                            rotateCube();
                            count()
                        }
                    }

                    function changeAlt(i, img) {
                        img.alt = JSON.parse(el.dataset.alts)[i]
                    }
                    const imagesFrame = el.querySelector(".images");
                    const frontFaceImg = el.querySelector(".face.front .media");
                    const rightFaceImg = el.querySelector(".face.right .media");
                    const topFaceImg = el.querySelector(".face.top .media");
                    const imgArr = JSON.parse(el.dataset.images);
                    console.log("dsdad");
                    const cachedImages = [];
                    imgArr.forEach((url, index) => {
                        const img = new Image();
                        img.src = url;
                        cachedImages[index] = img
                    });
                    let cc = 1;

                    function setImage() {
                        let imageEl;
                        if (cc == 1) {
                            imageEl = rightFaceImg
                        }
                        if (cc == 2) {
                            imageEl = topFaceImg
                        }
                        if (cc == 3) {
                            imageEl = frontFaceImg
                        }
                        let curImg = current + 1;
                        if (curImg > imgArr.length - 1) {
                            curImg = 0
                        }
                        changeAlt(curImg, imageEl);
                        imageEl.src = cachedImages[curImg].src
                    }

                    function rotateCube() {
                        if (cc == 1) {
                            a.seek("b0");
                            a.tweenTo("b1")
                        } else {
                            a.tweenTo(`b${cc}`)
                        }
                        if (cc + 1 <= 3) {
                            cc++
                        } else {
                            cc = 1
                        }
                    }
                    const a = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                        repeat: -1,
                        repeatDelay: 2,
                        paused: !0,
                        onStart: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        },
                        onRepeat: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        }
                    });
                    let xr = {
                        rotation: 0
                    };
                    let yr = {
                        rotation: 0
                    };
                    let zr = {
                        rotation: 0
                    };
                    a.add("b0");
                    a.to(yr, {
                        rotation: 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--yr", yr.rotation + "deg")
                        }
                    });
                    a.add("b1");
                    a.to(xr, {
                        rotation: 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--xr", xr.rotation + "deg")
                        },
                        onComplete: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(frontFaceImg, {
                                rotation: -90
                            })
                        }
                    });
                    a.add("b2");
                    a.to(zr, {
                        rotation: 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--zr", zr.rotation + "deg")
                        }
                    });
                    a.add("b3");
                    setInterval(() => {
                        go()
                    }, 3000)
                }
            }),
        "./src/scripts/methods-global/model3d.js":
            /*!***********************************************!*\
              !*** ./src/scripts/methods-global/model3d.js ***!
              \***********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                var three_addons_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! three/addons/loaders/GLTFLoader.js */ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js");
                var three_addons_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! three/addons/loaders/DRACOLoader.js */ "./node_modules/three/examples/jsm/loaders/DRACOLoader.js");

                function throttle(func, limit) {
                    let inThrottle;
                    return function() {
                        const args = arguments;
                        const context = this;
                        if (!inThrottle) {
                            func.apply(context, args);
                            inThrottle = !0;
                            setTimeout(() => inThrottle = !1, limit)
                        }
                    }
                }
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.model3d = function(_this) {
                    const el = _this;
                    let width = el.clientWidth;
                    let height = el.clientHeight;
                    let camera, scene, renderer, loader;
                    let model, hoverWrap, transformWrap;
                    const modifier = 0.15;
                    const url = el.dataset.path;
                    console.log("Production Log!");

                    function init() {
                        scene = new three__WEBPACK_IMPORTED_MODULE_1__.Scene();
                        camera = new three__WEBPACK_IMPORTED_MODULE_1__.PerspectiveCamera(75, width / height, 0.1, 1000);
                        renderer = new three__WEBPACK_IMPORTED_MODULE_1__.WebGLRenderer({
                            alpha: !0,
                            antialias: !0,
                            powerPreference: "low-power"
                        });
                        renderer.setSize(width, height);
                        renderer.setPixelRatio(window.devicePixelRatio);
                        renderer.setAnimationLoop(animate);
                        el.appendChild(renderer.domElement);
                        hoverWrap = new three__WEBPACK_IMPORTED_MODULE_1__.Object3D();
                        transformWrap = new three__WEBPACK_IMPORTED_MODULE_1__.Object3D();
                        transformWrap.add(hoverWrap);
                        scene.add(transformWrap);
                        const dracoLoader = new three_addons_loaders_DRACOLoader_js__WEBPACK_IMPORTED_MODULE_2__.DRACOLoader();
                        dracoLoader.setDecoderPath(theme_url + "/assets/draco/");
                        loader = new three_addons_loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_3__.GLTFLoader();
                        loader.setDRACOLoader(dracoLoader);
                        loader.load(url, (gltf) => {
                            model = gltf.scene;
                            hoverWrap.add(model)
                        }, () => {}, (error) => {
                            console.log(error)
                        });
                        const ambient = new three__WEBPACK_IMPORTED_MODULE_1__.AmbientLight(0xffffff, 1.5);
                        scene.add(ambient);
                        const directional = new three__WEBPACK_IMPORTED_MODULE_1__.DirectionalLight(0xffffff, 2);
                        directional.position.set(-0.2, -1, 1);
                        scene.add(directional);
                        camera.position.z = 3;
                        camera.lookAt(0, 0, 0);
                        window.addEventListener("mousemove", throttled);
                        window.addEventListener("resize", resize)
                    }
                    let a;

                    function moveHandle(e) {
                        const x = (e.clientX / window.innerWidth) * 2 - 1;
                        const y = (e.clientY / window.innerHeight) * 2 - 1;
                        if (transformWrap) {
                            a ? .kill();
                            a = gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(transformWrap.rotation, {
                                x: y * modifier,
                                y: x * modifier,
                                ease: "power1.out"
                            })
                        }
                    }
                    const throttled = throttle(moveHandle, 1000 / 60);

                    function resize() {
                        width = el.clientWidth;
                        height = el.clientHeight;
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                        renderer.render(scene, camera)
                    }

                    function animate() {
                        if (hoverWrap) {
                            const t = Date.now() * 0.0015;
                            hoverWrap.position.y = 0 + (Math.sin(t) * 0.075)
                        }
                        renderer.render(scene, camera)
                    }
                    init()
                }
            }),
        "./src/scripts/methods-global/pageHeader.js":
            /*!**************************************************!*\
              !*** ./src/scripts/methods-global/pageHeader.js ***!
              \**************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.pageHeader = function(_this) {
                    const header = _this;
                    const button = header.querySelector(".mobile-menu-btn");
                    const mobileMenu = header.querySelector(".mobile-menu");
                    const menuLinks = header.querySelectorAll(".menu-link");
                    const expander = mobileMenu.querySelector(".expander");
                    let isOpen = !1;

                    function open() {
                        isOpen = !0;
                        header.classList.add("menu-open");
                        document.body.classList.add("menu-open");
                        document.body.classList.add("overflow-hidden");
                        anim.timeScale(1).play()
                    }

                    function close() {
                        isOpen = !1;
                        header.classList.remove("menu-open");
                        document.body.classList.remove("menu-open");
                        document.body.classList.remove("overflow-hidden");
                        anim.timeScale(1.5).reverse()
                    }
                    let anim;

                    function initExpander() {
                        anim ? .kill();
                        anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                            paused: !0
                        });
                        anim.add("s");
                        anim.from(expander, {
                            height: 0,
                            ease: "power2.inOut",
                            duration: 0.6,
                        }, "s");
                        anim.from(menuLinks, {
                            y: "-100%",
                            stagger: 0.05,
                            ease: "power2.out",
                            duration: 0.6,
                        }, "s")
                    }
                    if (window.innerWidth <= 768) {
                        initExpander();
                        button.addEventListener("click", (e) => {
                            e.preventDefault();
                            if (isOpen) {
                                close()
                            } else {
                                open()
                            }
                        })
                    }
                }
            }),
        "./src/scripts/methods-global/playPauseVideo.js":
            /*!******************************************************!*\
              !*** ./src/scripts/methods-global/playPauseVideo.js ***!
              \******************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.playPauseVideo = function(_this) {
                    const el = _this;
                    const video = el.querySelector('video');
                    el.addEventListener('click', function() {
                        if (video.paused) {
                            video.play();
                            el.classList.add('playing')
                        } else {
                            video.pause();
                            el.classList.remove('playing')
                        }
                    })
                }
            }),
        "./src/scripts/methods-global/projectList.js":
            /*!***************************************************!*\
              !*** ./src/scripts/methods-global/projectList.js ***!
              \***************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                var gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! gsap/ScrollToPlugin */ "./node_modules/gsap/ScrollToPlugin.js");
                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger, gsap_ScrollToPlugin__WEBPACK_IMPORTED_MODULE_3__.ScrollToPlugin);

                function vw(v) {
                    return v * window.innerWidth
                }
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.projectList = function(_this) {
                    const el = _this;
                    const track = el.querySelector(".track");
                    const sticky = el.querySelector(".sticky");
                    const rows = el.querySelectorAll(".row");
                    const flyMedia = el.querySelector(".fly-media");

                    function closeAll() {
                        rows.forEach((row) => {
                            row.close ? .call()
                        })
                    }
                    let anm;

                    function showMedia(i) {
                        Array.from(flyMedia.children).forEach((img, index) => {
                            if (i == index) {
                                anm ? .kill();
                                anm = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.fromTo(img, {
                                    opacity: 0,
                                    scale: 1.1
                                }, {
                                    opacity: 1,
                                    scale: 1,
                                    ease: "expo.out",
                                    duration: 0.9
                                })
                            } else {
                                gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.set(img, {
                                    opacity: 0,
                                })
                            }
                        })
                    }
                    rows.forEach((row, i) => {
                        const accordion = row.querySelector(".accordion");
                        const expander = row.querySelector(".expander");
                        const mediaOuter = row.querySelector(".media-outer");
                        const media = row.querySelector(".media");
                        let isOpen = !1;
                        const a = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.from([expander, mediaOuter], {
                            height: 0,
                            duration: 0.5,
                            ease: "power2.inOut",
                            paused: !0,
                            onComplete: () => {
                                if (window.lenis) {
                                    window.lenis.scrollTo(row, {
                                        duration: 1,
                                        offset: -vw(0.0071)
                                    })
                                } else {
                                    const topPosition = row.getBoundingClientRect().top + window.pageYOffset - vw(0.0071);
                                    gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.to(window, {
                                        scrollTo: topPosition,
                                        duration: 0.5
                                    })
                                }
                                gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                            },
                            onReverseComplete: () => {
                                gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                            }
                        });

                        function open() {
                            isOpen = !0;
                            row.classList.add("is-open");
                            a.play();
                            if (media && media.play) {
                                let promise = media.play();
                                if (promise !== undefined) {
                                    promise.then(_ => {}).catch(error => {})
                                }
                            }
                        }

                        function close() {
                            isOpen = !1;
                            row.classList.remove("is-open");
                            a.reverse();
                            if (media && media.pause) {
                                media.pause()
                            }
                            gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.refresh()
                        }
                        accordion.addEventListener("click", (e) => {
                            e.preventDefault();
                            if (isOpen) {
                                close()
                            } else {
                                closeAll();
                                open()
                            }
                        });
                        if (window.innerWidth > 768) {
                            row.addEventListener("mouseenter", () => {
                                showMedia(i);
                                flyMedia.classList.add("active")
                            });
                            row.addEventListener("mouseleave", () => {
                                flyMedia.classList.remove("active")
                            })
                        }
                        row.close = close
                    });
                    let st;

                    function init() {
                        st ? .kill();
                        st = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_2__.ScrollTrigger.create({
                            trigger: track,
                            pin: sticky,
                            pinSpacer: !1,
                            pinSpacing: !1,
                            start: `top+=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            end: `bottom-=${sticky.clientHeight * 0.5} ${vw(0.0071)}+=${sticky.clientHeight * 0.5}`,
                            onEnter: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onEnterBack: () => {
                                document.body.classList.add("sticky-active")
                            },
                            onLeave: () => {
                                document.body.classList.remove("sticky-active")
                            },
                            onLeaveBack: () => {
                                document.body.classList.remove("sticky-active")
                            },
                        })
                    }
                    if (window.innerWidth > 768) {
                        init();
                        window.addEventListener("resize", init)
                    }
                }
            }),
        "./src/scripts/methods-global/studyListSlider.js":
            /*!*******************************************************!*\
              !*** ./src/scripts/methods-global/studyListSlider.js ***!
              \*******************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                var gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! gsap/ScrollTrigger */ "./node_modules/gsap/ScrollTrigger.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../helpers/SplitText.min */ "./src/scripts/helpers/SplitText.min.js");
                var _helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default = __webpack_require__.n(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1__);
                var _splidejs_splide__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! @splidejs/splide */ "./node_modules/@splidejs/splide/dist/js/splide.esm.js");
                var _splidejs_splide_css_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! @splidejs/splide/css/core */ "./node_modules/@splidejs/splide/dist/css/splide-core.min.css");
                gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.registerPlugin(gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_5__.ScrollTrigger);
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.studyListSlider = function(_this) {
                    const el = _this;
                    const mainLinks = el.querySelectorAll(".layout.content-layout, .layout.media-layout");
                    const titleFrame = el.querySelector(".title-frame");
                    const titles = titleFrame.querySelectorAll(".title");
                    const textFrame = el.querySelector(".text-frame");
                    const texts = textFrame.querySelectorAll(".text");
                    const numFrame1 = el.querySelector(".num-frame.first");
                    const nums1 = numFrame1.querySelectorAll(".num");
                    const numFrame2 = el.querySelector(".num-frame.second");
                    const nums2 = numFrame2.querySelectorAll(".num");
                    const numFrame3 = el.querySelector(".num-frame.third");
                    const nums3 = numFrame3.querySelectorAll(".num");
                    const subtexts1 = el.querySelectorAll(".subtext-frame.first .subtext");
                    const subtexts2 = el.querySelectorAll(".subtext-frame.second .subtext");
                    const subtexts3 = el.querySelectorAll(".subtext-frame.third .subtext");
                    const prev = el.querySelector(".prev");
                    const next = el.querySelector(".next");
                    titles.forEach((title) => {
                        title.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default())(title, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });
                    nums1.forEach((num) => {
                        num.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default())(num, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });
                    nums2.forEach((num) => {
                        num.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default())(num, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });
                    nums3.forEach((num) => {
                        num.splitted = new(_helpers_SplitText_min__WEBPACK_IMPORTED_MODULE_1___default())(num, {
                            type: "lines, words",
                            linesClass: "overflow-hidden"
                        })
                    });

                    function changeHref(i) {
                        mainLinks.forEach((link) => {
                            link.href = JSON.parse(el.dataset.hrefs)[i]
                        })
                    }
                    const dur = 1;
                    const eas = "power3.inOut";
                    let isReady = !0;
                    let current = titles.length - 1;

                    function titleOut(title) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(title.splitted.words, {
                            y: "-150%",
                            duration: dur * 0.55,
                            ease: eas,
                            stagger: 0.105,
                            onStart: () => {
                                isReady = !1
                            }
                        })
                    }

                    function titleIn(title) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(titleFrame, {
                            height: title.clientHeight,
                            duration: 0.6,
                            ease: "power3.inOut"
                        });
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(title.splitted.words, {
                            y: "250%"
                        }, {
                            y: "0%",
                            duration: dur,
                            ease: eas,
                            stagger: 0.2,
                            onStart: () => {
                                title.style.opacity = "1"
                            },
                        })
                    }

                    function textOut(text) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(text, {
                            opacity: 0,
                            duration: dur,
                            ease: eas,
                        })
                    }

                    function textIn(text) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.to(textFrame, {
                            height: text.clientHeight,
                            duration: 0.6,
                            ease: "power3.inOut"
                        });
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(text, {
                            opacity: 0,
                        }, {
                            opacity: 1,
                            duration: dur,
                            ease: eas,
                            onStart: () => {
                                text.closest(".aligner").classList.add("loaded")
                            },
                        })
                    }

                    function subtextOut(text) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(text, {
                            opacity: 1,
                        }, {
                            opacity: 0,
                            duration: dur,
                            ease: eas,
                        })
                    }

                    function subtextIn(text) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(text, {
                            opacity: 0,
                        }, {
                            opacity: 1,
                            duration: dur,
                            ease: eas,
                            onStart: () => {
                                text.closest(".aligner").classList.add("loaded")
                            },
                        })
                    }

                    function numOut(num) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(num.splitted.words, {
                            y: "0%",
                        }, {
                            y: "-150%",
                            duration: dur,
                            ease: eas,
                            stagger: 0.2,
                        })
                    }

                    function numIn(num) {
                        gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.fromTo(num.splitted.words, {
                            y: "250%"
                        }, {
                            y: "0%",
                            duration: dur,
                            ease: eas,
                            stagger: 0.2,
                            onStart: () => {
                                num.style.opacity = "1"
                            },
                        })
                    }

                    function count() {
                        if (current + 1 <= titles.length - 1) {
                            current++
                        } else {
                            current = 0
                        }
                        changeHref(current)
                    }

                    function countDown() {
                        if (current - 1 >= 0) {
                            current--
                        } else {
                            current = titles.length - 1
                        }
                        changeHref(current)
                    }

                    function go() {
                        if (isReady) {
                            titleOut(titles[current]);
                            numOut(nums1[current]);
                            numOut(nums2[current]);
                            numOut(nums3[current]);
                            textOut(texts[current]);
                            subtextOut(subtexts1[current]);
                            subtextOut(subtexts2[current]);
                            subtextOut(subtexts3[current]);
                            if (current < titles.length - 1) {
                                titleIn(titles[current + 1]);
                                numIn(nums1[current + 1]);
                                numIn(nums2[current + 1]);
                                numIn(nums3[current + 1]);
                                textIn(texts[current + 1]);
                                subtextIn(subtexts1[current + 1]);
                                subtextIn(subtexts2[current + 1]);
                                subtextIn(subtexts3[current + 1])
                            } else {
                                titleIn(titles[0]);
                                numIn(nums1[0]);
                                numIn(nums2[0]);
                                numIn(nums3[0]);
                                textIn(texts[0]);
                                subtextIn(subtexts1[0]);
                                subtextIn(subtexts2[0]);
                                subtextIn(subtexts3[0])
                            }
                            setMedia("next");
                            rotateCube();
                            count();
                            slider.go(">");
                            updateSlideClass(current)
                        }
                    }

                    function goPrev() {
                        if (isReady) {
                            titleOut(titles[current]);
                            numOut(nums1[current]);
                            numOut(nums2[current]);
                            numOut(nums3[current]);
                            textOut(texts[current]);
                            subtextOut(subtexts1[current]);
                            subtextOut(subtexts2[current]);
                            subtextOut(subtexts3[current]);
                            if (current > 0) {
                                titleIn(titles[current - 1]);
                                numIn(nums1[current - 1]);
                                numIn(nums2[current - 1]);
                                numIn(nums3[current - 1]);
                                textIn(texts[current - 1]);
                                subtextIn(subtexts1[current - 1]);
                                subtextIn(subtexts2[current - 1]);
                                subtextIn(subtexts3[current - 1])
                            } else {
                                titleIn(titles[titles.length - 1]);
                                numIn(nums1[titles.length - 1]);
                                numIn(nums2[titles.length - 1]);
                                numIn(nums3[titles.length - 1]);
                                textIn(texts[titles.length - 1]);
                                subtextIn(subtexts1[titles.length - 1]);
                                subtextIn(subtexts2[titles.length - 1]);
                                subtextIn(subtexts3[titles.length - 1])
                            }
                            setMedia("prev");
                            rotateCube();
                            countDown();
                            slider.go("<");
                            updateSlideClass(current)
                        }
                    }

                    function goSpecific(next, prev, difference) {
                        if (isReady) {
                            titleOut(titles[prev]);
                            numOut(nums1[prev]);
                            numOut(nums2[prev]);
                            numOut(nums3[prev]);
                            textOut(texts[prev]);
                            subtextOut(subtexts1[prev]);
                            subtextOut(subtexts2[prev]);
                            subtextOut(subtexts3[prev]);
                            titleIn(titles[next]);
                            numIn(nums1[next]);
                            numIn(nums2[next]);
                            numIn(nums3[next]);
                            textIn(texts[next]);
                            subtextIn(subtexts1[next]);
                            subtextIn(subtexts2[next]);
                            subtextIn(subtexts3[next]);
                            setMediaSpecific(next);
                            rotateCube();
                            current = next;
                            changeHref(current);
                            slider.go(`+${difference}`);
                            updateSlideClass(current)
                        }
                    }
                    const imagesFrame = el.querySelector(".images");
                    const frontFaceMedia = el.querySelector(".face.front .media");
                    const rightFaceMedia = el.querySelector(".face.right .media");
                    const topFaceMedia = el.querySelector(".face.top .media");
                    const videos = el.querySelectorAll(".media");
                    const mediaArr = JSON.parse(el.dataset.medias);
                    const cachedMedia = [];
                    mediaArr.forEach((url, index) => {
                        if (url.includes("webp") || url.includes("jpg") || url.includes("png") || url.includes("jpeg")) {
                            const media = new Image();
                            media.src = url;
                            cachedMedia[index] = media
                        } else if (url.includes("mp4") || url.includes("avi") || url.includes("mov")) {
                            const media = document.createElement("video");
                            media.src = url;
                            cachedMedia[index] = media
                        }
                    });
                    let cc = 1;
                    let mediaEl, lastMedia;

                    function setMedia(direction) {
                        if (cc == 1) {
                            mediaEl = rightFaceMedia;
                            lastMedia = frontFaceMedia
                        }
                        if (cc == 2) {
                            mediaEl = topFaceMedia;
                            lastMedia = rightFaceMedia
                        }
                        if (cc == 3) {
                            mediaEl = frontFaceMedia;
                            lastMedia = topFaceMedia
                        }
                        let curMedia;
                        if (direction == "next") {
                            curMedia = current + 1;
                            if (curMedia > mediaArr.length - 1) {
                                curMedia = 0
                            }
                        } else if (direction == "prev") {
                            curMedia = current - 1;
                            if (curMedia < 0) {
                                curMedia = mediaArr.length - 1
                            }
                        }
                        if (cachedMedia[curMedia].nodeName == "VIDEO") {
                            mediaEl.src = cachedMedia[curMedia].src;
                            let promise = mediaEl.play();
                            if (promise !== undefined) {
                                promise.then(_ => {}).catch(error => {})
                            }
                        } else if (cachedMedia[curMedia].nodeName == "IMG") {
                            mediaEl.src = "";
                            mediaEl.poster = cachedMedia[curMedia].src
                        }
                        el.classList.add("media-loaded")
                    }

                    function setMediaSpecific(next) {
                        if (cc == 1) {
                            mediaEl = rightFaceMedia;
                            lastMedia = frontFaceMedia
                        }
                        if (cc == 2) {
                            mediaEl = topFaceMedia;
                            lastMedia = rightFaceMedia
                        }
                        if (cc == 3) {
                            mediaEl = frontFaceMedia;
                            lastMedia = topFaceMedia
                        }
                        let curMedia = next;
                        if (cachedMedia[curMedia].nodeName == "VIDEO") {
                            mediaEl.src = cachedMedia[curMedia].src;
                            let promise = mediaEl.play();
                            if (promise !== undefined) {
                                promise.then(_ => {}).catch(error => {})
                            }
                        } else if (cachedMedia[curMedia].nodeName == "IMG") {
                            mediaEl.src = "";
                            mediaEl.poster = cachedMedia[curMedia].src
                        }
                    }

                    function rotateCube(direction) {
                        if (cc == 1) {
                            a.seek("b0");
                            a.tweenTo("b1")
                        } else {
                            a.tweenTo(`b${cc}`)
                        }
                        if (cc + 1 <= 3) {
                            cc++
                        } else {
                            cc = 1
                        }
                    }
                    const a = gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.timeline({
                        repeat: -1,
                        repeatDelay: 2,
                        paused: !0,
                        onStart: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.set(frontFaceMedia, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        },
                        onRepeat: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.set(frontFaceMedia, {
                                rotation: 0
                            });
                            imagesFrame.style.setProperty("--yr", "0deg");
                            imagesFrame.style.setProperty("--zr", "0deg");
                            imagesFrame.style.setProperty("--xr", "0deg")
                        }
                    });
                    let xr = {
                        rotation: 0
                    };
                    let yr = {
                        rotation: 0
                    };
                    let zr = {
                        rotation: 0
                    };
                    a.add("b0");
                    a.to(yr, {
                        rotation: -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--yr", yr.rotation + "deg")
                        },
                        onComplete: () => {
                            isReady = !0
                        }
                    });
                    a.add("b1");
                    a.to(xr, {
                        rotation: -90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--xr", xr.rotation + "deg")
                        },
                        onComplete: () => {
                            gsap__WEBPACK_IMPORTED_MODULE_4__.gsap.set(frontFaceMedia, {
                                rotation: -90
                            });
                            isReady = !0
                        }
                    });
                    a.add("b2");
                    a.to(zr, {
                        rotation: 90,
                        ease: "power3.inOut",
                        duration: 1,
                        onUpdate: () => {
                            imagesFrame.style.setProperty("--zr", zr.rotation + "deg")
                        },
                        onComplete: () => {
                            isReady = !0
                        }
                    });
                    a.add("b3");
                    next.addEventListener("click", (e) => {
                        e.preventDefault();
                        go()
                    });
                    prev.addEventListener("click", (e) => {
                        e.preventDefault();
                        goPrev()
                    });
                    el.classList.add("media-loaded");
                    let hasEntered = !1;
                    let st = gsap_ScrollTrigger__WEBPACK_IMPORTED_MODULE_5__.ScrollTrigger.create({
                        trigger: el,
                        pin: !1,
                        start: "top bottom",
                        onEnter: () => {
                            if (!hasEntered) {
                                hasEntered = !0;
                                go();
                                st.kill()
                            }
                        }
                    });
                    const sliderEl = el.querySelector(".splide");
                    let slides = el.querySelectorAll(".splide__slide");
                    let logos = el.querySelectorAll(".logo");

                    function updateSlideClass(i) {
                        slides.forEach((slide, index) => {
                            if (i == index) {
                                slide.classList.add("slide-active")
                            } else {
                                slide.classList.remove("slide-active")
                            }
                        })
                    }
                    const slider = new _splidejs_splide__WEBPACK_IMPORTED_MODULE_2__["default"](sliderEl, {
                        perPage: 4,
                        gap: "0.1rem",
                        arrows: !1,
                        pagination: !1,
                        perMove: 1,
                        type: "loop",
                        updateOnMove: !0,
                        drag: !1,
                        start: current,
                        breakpoints: {
                            768: {
                                gap: "0.05rem"
                            }
                        }
                    });
                    slider.on("mounted", function() {
                        logos = el.querySelectorAll(".logo");
                        logos.forEach((logo, ind) => {
                            logo.realIndex = ind;
                            logo.addEventListener("click", (e) => {
                                e.preventDefault();
                                const index = parseInt(logo.dataset.index);
                                const activeLogo = el.querySelector(".splide__slide:not(.splide__slide--clone).is-active .logo").realIndex;
                                const difference = ind - activeLogo;
                                if (isReady && current != index) {
                                    const prev = current;
                                    const next = index;
                                    goSpecific(next, prev, difference)
                                }
                            })
                        })
                    });
                    slider.mount()
                }
            }),
        "./src/scripts/methods-global/tooltip.js":
            /*!***********************************************!*\
              !*** ./src/scripts/methods-global/tooltip.js ***!
              \***********************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.tooltip = function(_this) {
                    _this.addEventListener("mousemove", (e) => {
                        const x = e.offsetX;
                        const y = e.offsetY;
                        _this.style.setProperty("--x", x + "px");
                        _this.style.setProperty("--y", y + "px")
                    })
                }
            }),
        "./src/scripts/methods-global/videoModal.js":
            /*!**************************************************!*\
              !*** ./src/scripts/methods-global/videoModal.js ***!
              \**************************************************/
            ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.r(__webpack_exports__);
                var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
                var gsap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! gsap */ "./node_modules/gsap/index.js");
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_0__["default"].Methods.videoModal = function(_this) {
                    const el = _this;
                    const mediaFrame = el.querySelector(".media-frame");
                    const media = el.querySelector(".media");
                    const opener = document.querySelector(".video-modal-opener");
                    const sectionPlayButton = document.querySelector(".two-cards-button-section .button-circle");
                    const closeBtn = el.querySelector(".close");
                    const controls = el.querySelector(".controls");
                    const playBtn = controls.querySelector(".play-pause");
                    const muteBtn = controls.querySelector(".mute");
                    let isOpen = !1;
                    let isPlaying = !1;

                    function open() {
                        isOpen = !0;
                        el.classList.add("open");
                        anim.play();
                        if (window.lenis) {
                            window.lenis.stop()
                        } else {
                            document.body.classList.add("overflow-hidden")
                        }
                        const rect = opener.getBoundingClientRect();
                        mediaFrame.removeAttribute("style");
                        gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.from(mediaFrame, {
                            width: rect.width,
                            height: rect.height,
                            left: rect.left,
                            top: rect.top,
                            borderRadius: "0.35rem",
                            duration: 0.6,
                            ease: "power3.inOut",
                            delay: 0.2,
                            onStart: () => {
                                let promise = media.play();
                                if (promise !== undefined) {
                                    promise.then(_ => {}).catch(error => {})
                                }
                            }
                        })
                    }

                    function close() {
                        isOpen = !1;
                        el.classList.remove("open");
                        anim.reverse();
                        media.pause();
                        if (window.lenis) {
                            window.lenis.start()
                        } else {
                            document.body.classList.remove("overflow-hidden")
                        }
                    }
                    let anim = gsap__WEBPACK_IMPORTED_MODULE_1__.gsap.timeline({
                        paused: !0
                    });
                    anim.from(el, {
                        display: "none",
                        opacity: 0,
                        duration: 0.3,
                        ease: "power2.inOut"
                    });
                    media.addEventListener("play", () => {
                        isPlaying = !0;
                        playBtn.classList.remove("paused");
                        playBtn.classList.add("playing")
                    });
                    media.addEventListener("pause", () => {
                        isPlaying = !1;
                        playBtn.classList.remove("playing");
                        playBtn.classList.add("paused")
                    });
                    media.addEventListener("volumechange", () => {
                        if (media.muted) {
                            muteBtn.classList.add("muted")
                        } else {
                            muteBtn.classList.remove("muted")
                        }
                    });
                    opener.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (isOpen) {
                            close()
                        } else {
                            open()
                        }
                    });
                    sectionPlayButton.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (isOpen) {
                            close()
                        } else {
                            open()
                        }
                    });
                    document.addEventListener("keydown", (e) => {
                        if (e.key == "Escape") {
                            close()
                        }
                    });
                    closeBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        close()
                    });
                    playBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (isPlaying) {
                            media.pause()
                        } else {
                            let promise = media.play();
                            if (promise !== undefined) {
                                promise.then(_ => {}).catch(error => {})
                            }
                        }
                    });
                    muteBtn.addEventListener("click", (e) => {
                        e.preventDefault();
                        if (media.muted) {
                            media.muted = !1
                        } else {
                            media.muted = !0
                        }
                    })
                }
            }),
        "./src/scripts/methods-global sync recursive \\.js$":
            /*!************************************************!*\
              !*** ./src/scripts/methods-global/ sync \.js$ ***!
              \************************************************/
            ((module, __unused_webpack_exports, __webpack_require__) => {
                var map = {
                    "./archLayout.js": "./src/scripts/methods-global/archLayout.js",
                    "./archTeam.js": "./src/scripts/methods-global/archTeam.js",
                    "./blogList.js": "./src/scripts/methods-global/blogList.js",
                    "./blogPaginationAjax.js": "./src/scripts/methods-global/blogPaginationAjax.js",
                    "./caseStudyCards.js": "./src/scripts/methods-global/caseStudyCards.js",
                    "./contentBlocks.js": "./src/scripts/methods-global/contentBlocks.js",
                    "./dotsSliderSection.js": "./src/scripts/methods-global/dotsSliderSection.js",
                    "./faqList.js": "./src/scripts/methods-global/faqList.js",
                    "./globalExample.js": "./src/scripts/methods-global/globalExample.js",
                    "./goDown.js": "./src/scripts/methods-global/goDown.js",
                    "./influencersSection.js": "./src/scripts/methods-global/influencersSection.js",
                    "./meetTeam.js": "./src/scripts/methods-global/meetTeam.js",
                    "./model3d.js": "./src/scripts/methods-global/model3d.js",
                    "./pageHeader.js": "./src/scripts/methods-global/pageHeader.js",
                    "./playPauseVideo.js": "./src/scripts/methods-global/playPauseVideo.js",
                    "./projectList.js": "./src/scripts/methods-global/projectList.js",
                    "./studyListSlider.js": "./src/scripts/methods-global/studyListSlider.js",
                    "./tooltip.js": "./src/scripts/methods-global/tooltip.js",
                    "./videoModal.js": "./src/scripts/methods-global/videoModal.js"
                };

                function webpackContext(req) {
                    var id = webpackContextResolve(req);
                    return __webpack_require__(id)
                }

                function webpackContextResolve(req) {
                    if (!__webpack_require__.o(map, req)) {
                        var e = new Error("Cannot find module '" + req + "'");
                        e.code = 'MODULE_NOT_FOUND';
                        throw e
                    }
                    return map[req]
                }
                webpackContext.keys = function webpackContextKeys() {
                    return Object.keys(map)
                };
                webpackContext.resolve = webpackContextResolve;
                module.exports = webpackContext;
                webpackContext.id = "./src/scripts/methods-global sync recursive \\.js$"
            }),
        "./node_modules/@studio-freight/lenis/dist/lenis.mjs":
            /*!***********************************************************!*\
              !*** ./node_modules/@studio-freight/lenis/dist/lenis.mjs ***!
              \***********************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (Lenis)
                });

                function t(t, e, i) {
                    return Math.max(t, Math.min(e, i))
                }
                class Animate {
                    advance(e) {
                        if (!this.isRunning) return;
                        let i = !1;
                        if (this.lerp) this.value = (s = this.value, o = this.to, n = 60 * this.lerp, r = e, function(t, e, i) {
                            return (1 - i) * t + i * e
                        }(s, o, 1 - Math.exp(-n * r))), Math.round(this.value) === this.to && (this.value = this.to, i = !0);
                        else {
                            this.currentTime += e;
                            const s = t(0, this.currentTime / this.duration, 1);
                            i = s >= 1;
                            const o = i ? 1 : this.easing(s);
                            this.value = this.from + (this.to - this.from) * o
                        }
                        var s, o, n, r;
                        this.onUpdate ? .(this.value, i), i && this.stop()
                    }
                    stop() {
                        this.isRunning = !1
                    }
                    fromTo(t, e, {
                        lerp: i = .1,
                        duration: s = 1,
                        easing: o = (t => t),
                        onStart: n,
                        onUpdate: r
                    }) {
                        this.from = this.value = t, this.to = e, this.lerp = i, this.duration = s, this.easing = o, this.currentTime = 0, this.isRunning = !0, n ? .(), this.onUpdate = r
                    }
                }
                class Dimensions {
                    constructor({
                        wrapper: t,
                        content: e,
                        autoResize: i = !0,
                        debounce: s = 250
                    } = {}) {
                        this.wrapper = t, this.content = e, i && (this.debouncedResize = function(t, e) {
                            let i;
                            return function() {
                                let s = arguments,
                                    o = this;
                                clearTimeout(i), i = setTimeout((function() {
                                    t.apply(o, s)
                                }), e)
                            }
                        }(this.resize, s), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
                    }
                    destroy() {
                        this.wrapperResizeObserver ? .disconnect(), this.contentResizeObserver ? .disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
                    }
                    resize = () => {
                        this.onWrapperResize(), this.onContentResize()
                    };
                    onWrapperResize = () => {
                        this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
                    };
                    onContentResize = () => {
                        this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
                    };
                    get limit() {
                        return {
                            x: this.scrollWidth - this.width,
                            y: this.scrollHeight - this.height
                        }
                    }
                }
                class Emitter {
                    constructor() {
                        this.events = {}
                    }
                    emit(t, ...e) {
                        let i = this.events[t] || [];
                        for (let t = 0, s = i.length; t < s; t++) i[t](...e)
                    }
                    on(t, e) {
                        return this.events[t] ? .push(e) || (this.events[t] = [e]), () => {
                            this.events[t] = this.events[t] ? .filter((t => e !== t))
                        }
                    }
                    off(t, e) {
                        this.events[t] = this.events[t] ? .filter((t => e !== t))
                    }
                    destroy() {
                        this.events = {}
                    }
                }
                const e = 100 / 6;
                class VirtualScroll {
                    constructor(t, {
                        wheelMultiplier: e = 1,
                        touchMultiplier: i = 1
                    }) {
                        this.element = t, this.wheelMultiplier = e, this.touchMultiplier = i, this.touchStart = {
                            x: null,
                            y: null
                        }, this.emitter = new Emitter, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
                            passive: !1
                        }), this.element.addEventListener("touchstart", this.onTouchStart, {
                            passive: !1
                        }), this.element.addEventListener("touchmove", this.onTouchMove, {
                            passive: !1
                        }), this.element.addEventListener("touchend", this.onTouchEnd, {
                            passive: !1
                        })
                    }
                    on(t, e) {
                        return this.emitter.on(t, e)
                    }
                    destroy() {
                        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
                            passive: !1
                        }), this.element.removeEventListener("touchstart", this.onTouchStart, {
                            passive: !1
                        }), this.element.removeEventListener("touchmove", this.onTouchMove, {
                            passive: !1
                        }), this.element.removeEventListener("touchend", this.onTouchEnd, {
                            passive: !1
                        })
                    }
                    onTouchStart = t => {
                        const {
                            clientX: e,
                            clientY: i
                        } = t.targetTouches ? t.targetTouches[0] : t;
                        this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {
                            x: 0,
                            y: 0
                        }, this.emitter.emit("scroll", {
                            deltaX: 0,
                            deltaY: 0,
                            event: t
                        })
                    };
                    onTouchMove = t => {
                        const {
                            clientX: e,
                            clientY: i
                        } = t.targetTouches ? t.targetTouches[0] : t, s = -(e - this.touchStart.x) * this.touchMultiplier, o = -(i - this.touchStart.y) * this.touchMultiplier;
                        this.touchStart.x = e, this.touchStart.y = i, this.lastDelta = {
                            x: s,
                            y: o
                        }, this.emitter.emit("scroll", {
                            deltaX: s,
                            deltaY: o,
                            event: t
                        })
                    };
                    onTouchEnd = t => {
                        this.emitter.emit("scroll", {
                            deltaX: this.lastDelta.x,
                            deltaY: this.lastDelta.y,
                            event: t
                        })
                    };
                    onWheel = t => {
                        let {
                            deltaX: i,
                            deltaY: s,
                            deltaMode: o
                        } = t;
                        i *= 1 === o ? e : 2 === o ? this.windowWidth : 1, s *= 1 === o ? e : 2 === o ? this.windowHeight : 1, i *= this.wheelMultiplier, s *= this.wheelMultiplier, this.emitter.emit("scroll", {
                            deltaX: i,
                            deltaY: s,
                            event: t
                        })
                    };
                    onWindowResize = () => {
                        this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
                    }
                }
                class Lenis {
                    constructor({
                        wrapper: t = window,
                        content: e = document.documentElement,
                        wheelEventsTarget: i = t,
                        eventsTarget: s = i,
                        smoothWheel: o = !0,
                        syncTouch: n = !1,
                        syncTouchLerp: r = .075,
                        touchInertiaMultiplier: l = 35,
                        duration: h,
                        easing: a = (t => Math.min(1, 1.001 - Math.pow(2, -10 * t))),
                        lerp: c = !h && .1,
                        infinite: d = !1,
                        orientation: p = "vertical",
                        gestureOrientation: u = "vertical",
                        touchMultiplier: m = 1,
                        wheelMultiplier: v = 1,
                        autoResize: g = !0,
                        __experimental__naiveDimensions: S = !1
                    } = {}) {
                        this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
                            deltaX: t,
                            deltaY: e,
                            event: i
                        }) => {
                            if (i.ctrlKey) return;
                            const s = i.type.includes("touch"),
                                o = i.type.includes("wheel");
                            if (this.options.syncTouch && s && "touchstart" === i.type && !this.isStopped && !this.isLocked) return void this.reset();
                            const n = 0 === t && 0 === e,
                                r = "vertical" === this.options.gestureOrientation && 0 === e || "horizontal" === this.options.gestureOrientation && 0 === t;
                            if (n || r) return;
                            let l = i.composedPath();
                            if (l = l.slice(0, l.indexOf(this.rootElement)), l.find((t => {
                                    var e, i, n, r, l;
                                    return (null === (e = t.hasAttribute) || void 0 === e ? void 0 : e.call(t, "data-lenis-prevent")) || s && (null === (i = t.hasAttribute) || void 0 === i ? void 0 : i.call(t, "data-lenis-prevent-touch")) || o && (null === (n = t.hasAttribute) || void 0 === n ? void 0 : n.call(t, "data-lenis-prevent-wheel")) || (null === (r = t.classList) || void 0 === r ? void 0 : r.contains("lenis")) && !(null === (l = t.classList) || void 0 === l ? void 0 : l.contains("lenis-stopped"))
                                }))) return;
                            if (this.isStopped || this.isLocked) return void i.preventDefault();
                            if (this.isSmooth = this.options.syncTouch && s || this.options.smoothWheel && o, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
                            i.preventDefault();
                            let h = e;
                            "both" === this.options.gestureOrientation ? h = Math.abs(e) > Math.abs(t) ? e : t : "horizontal" === this.options.gestureOrientation && (h = t);
                            const a = s && this.options.syncTouch,
                                c = s && "touchend" === i.type && Math.abs(h) > 5;
                            c && (h = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + h, Object.assign({
                                programmatic: !1
                            }, a ? {
                                lerp: c ? this.options.syncTouchLerp : 1
                            } : {
                                lerp: this.options.lerp,
                                duration: this.options.duration,
                                easing: this.options.easing
                            }))
                        }, this.onNativeScroll = () => {
                            if (!this.__preventNextScrollEvent && !this.isScrolling) {
                                const t = this.animatedScroll;
                                this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - t), this.emit()
                            }
                        }, window.lenisVersion = "1.0.42", t !== document.documentElement && t !== document.body || (t = window), this.options = {
                            wrapper: t,
                            content: e,
                            wheelEventsTarget: i,
                            eventsTarget: s,
                            smoothWheel: o,
                            syncTouch: n,
                            syncTouchLerp: r,
                            touchInertiaMultiplier: l,
                            duration: h,
                            easing: a,
                            lerp: c,
                            infinite: d,
                            gestureOrientation: u,
                            orientation: p,
                            touchMultiplier: m,
                            wheelMultiplier: v,
                            autoResize: g,
                            __experimental__naiveDimensions: S
                        }, this.animate = new Animate, this.emitter = new Emitter, this.dimensions = new Dimensions({
                            wrapper: t,
                            content: e,
                            autoResize: g
                        }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = n || o, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new VirtualScroll(s, {
                            touchMultiplier: m,
                            wheelMultiplier: v
                        }), this.virtualScroll.on("scroll", this.onVirtualScroll)
                    }
                    destroy() {
                        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
                    }
                    on(t, e) {
                        return this.emitter.on(t, e)
                    }
                    off(t, e) {
                        return this.emitter.off(t, e)
                    }
                    setScroll(t) {
                        this.isHorizontal ? this.rootElement.scrollLeft = t : this.rootElement.scrollTop = t
                    }
                    resize() {
                        this.dimensions.resize()
                    }
                    emit() {
                        this.emitter.emit("scroll", this)
                    }
                    reset() {
                        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
                    }
                    start() {
                        this.isStopped && (this.isStopped = !1, this.reset())
                    }
                    stop() {
                        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
                    }
                    raf(t) {
                        const e = t - (this.time || t);
                        this.time = t, this.animate.advance(.001 * e)
                    }
                    scrollTo(e, {
                        offset: i = 0,
                        immediate: s = !1,
                        lock: o = !1,
                        duration: n = this.options.duration,
                        easing: r = this.options.easing,
                        lerp: l = !n && this.options.lerp,
                        onComplete: h,
                        force: a = !1,
                        programmatic: c = !0
                    } = {}) {
                        if (!this.isStopped && !this.isLocked || a) {
                            if (["top", "left", "start"].includes(e)) e = 0;
                            else if (["bottom", "right", "end"].includes(e)) e = this.limit;
                            else {
                                let t;
                                if ("string" == typeof e ? t = document.querySelector(e) : (null == e ? void 0 : e.nodeType) && (t = e), t) {
                                    if (this.options.wrapper !== window) {
                                        const t = this.options.wrapper.getBoundingClientRect();
                                        i -= this.isHorizontal ? t.left : t.top
                                    }
                                    const s = t.getBoundingClientRect();
                                    e = (this.isHorizontal ? s.left : s.top) + this.animatedScroll
                                }
                            }
                            if ("number" == typeof e) {
                                if (e += i, e = Math.round(e), this.options.infinite ? c && (this.targetScroll = this.animatedScroll = this.scroll) : e = t(0, e, this.limit), s) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void(null == h || h(this));
                                if (!c) {
                                    if (e === this.targetScroll) return;
                                    this.targetScroll = e
                                }
                                this.animate.fromTo(this.animatedScroll, e, {
                                    duration: n,
                                    easing: r,
                                    lerp: l,
                                    onStart: () => {
                                        o && (this.isLocked = !0), this.isScrolling = !0
                                    },
                                    onUpdate: (t, e) => {
                                        this.isScrolling = !0, this.velocity = t - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = t, this.setScroll(this.scroll), c && (this.targetScroll = t), e || this.emit(), e && (this.reset(), this.emit(), null == h || h(this), this.__preventNextScrollEvent = !0, requestAnimationFrame((() => {
                                            delete this.__preventNextScrollEvent
                                        })))
                                    }
                                })
                            }
                        }
                    }
                    get rootElement() {
                        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
                    }
                    get limit() {
                        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
                    }
                    get isHorizontal() {
                        return "horizontal" === this.options.orientation
                    }
                    get actualScroll() {
                        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
                    }
                    get scroll() {
                        return this.options.infinite ? (t = this.animatedScroll, e = this.limit, (t % e + e) % e) : this.animatedScroll;
                        var t, e
                    }
                    get progress() {
                        return 0 === this.limit ? 1 : this.scroll / this.limit
                    }
                    get isSmooth() {
                        return this.__isSmooth
                    }
                    set isSmooth(t) {
                        this.__isSmooth !== t && (this.__isSmooth = t, this.toggleClassName("lenis-smooth", t))
                    }
                    get isScrolling() {
                        return this.__isScrolling
                    }
                    set isScrolling(t) {
                        this.__isScrolling !== t && (this.__isScrolling = t, this.toggleClassName("lenis-scrolling", t))
                    }
                    get isStopped() {
                        return this.__isStopped
                    }
                    set isStopped(t) {
                        this.__isStopped !== t && (this.__isStopped = t, this.toggleClassName("lenis-stopped", t))
                    }
                    get isLocked() {
                        return this.__isLocked
                    }
                    set isLocked(t) {
                        this.__isLocked !== t && (this.__isLocked = t, this.toggleClassName("lenis-locked", t))
                    }
                    get className() {
                        let t = "lenis";
                        return this.isStopped && (t += " lenis-stopped"), this.isLocked && (t += " lenis-locked"), this.isScrolling && (t += " lenis-scrolling"), this.isSmooth && (t += " lenis-smooth"), t
                    }
                    toggleClassName(t, e) {
                        this.rootElement.classList.toggle(t, e), this.emitter.emit("className change", this)
                    }
                }
            }),
        "./node_modules/@swup/body-class-plugin/dist/index.modern.js":
            /*!*******************************************************************!*\
              !*** ./node_modules/@swup/body-class-plugin/dist/index.modern.js ***!
              \*******************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (i)
                });
                var _swup_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @swup/plugin */ "./node_modules/@swup/body-class-plugin/node_modules/@swup/plugin/dist/index.modern.js");

                function t() {
                    return t = Object.assign ? Object.assign.bind() : function(s) {
                        for (var t = 1; t < arguments.length; t++) {
                            var i = arguments[t];
                            for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (s[a] = i[a])
                        }
                        return s
                    }, t.apply(this, arguments)
                }
                class i extends _swup_plugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
                    constructor(s = {}) {
                        super(), this.name = "SwupBodyClassPlugin", this.requires = {
                            swup: ">=4.6"
                        }, this.defaults = {
                            prefix: ""
                        }, this.options = void 0, this.updateBodyClass = s => {
                            this.updateClassNames(document.body, s.to.document.body)
                        }, this.options = t({}, this.defaults, s)
                    }
                    mount() {
                        this.on("content:replace", this.updateBodyClass)
                    }
                    updateClassNames(s, t) {
                        const i = [...s.classList].filter(s => this.isValidClassName(s)),
                            a = [...t.classList].filter(s => this.isValidClassName(s));
                        s.classList.remove(...i), s.classList.add(...a)
                    }
                    isValidClassName(s) {
                        return s && s.startsWith(this.options.prefix)
                    }
                }
            }),
        "./node_modules/@swup/body-class-plugin/node_modules/@swup/plugin/dist/index.modern.js":
            /*!*********************************************************************************************!*\
              !*** ./node_modules/@swup/body-class-plugin/node_modules/@swup/plugin/dist/index.modern.js ***!
              \*********************************************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (e)
                });

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(r) {
                        for (var n = 1; n < arguments.length; n++) {
                            var e = arguments[n];
                            for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t])
                        }
                        return r
                    }, r.apply(this, arguments)
                }
                const n = r => String(r).split(".").map(r => String(parseInt(r || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
                class e {
                    constructor() {
                        this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = []
                    }
                    mount() {}
                    unmount() {
                        this.handlersToUnregister.forEach(r => r()), this.handlersToUnregister = []
                    }
                    _beforeMount() {
                        if (!this.name) throw new Error("You must define a name of plugin when creating a class.")
                    }
                    _afterUnmount() {}
                    _checkRequirements() {
                        return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r, e]) => {
                            if (! function(r, e, t) {
                                    const s = function(r, n) {
                                        var e;
                                        if ("swup" === r) return null != (e = n.version) ? e : ""; {
                                            var t;
                                            const e = n.findPlugin(r);
                                            return null != (t = null == e ? void 0 : e.version) ? t : ""
                                        }
                                    }(r, t);
                                    return !!s && ((r, e) => e.every(e => {
                                        const [, t, s] = e.match(/^([\D]+)?(.*)$/) || [];
                                        var o, i;
                                        return ((r, n) => {
                                            const e = {
                                                "": r => 0 === r,
                                                ">": r => r > 0,
                                                ">=": r => r >= 0,
                                                "<": r => r < 0,
                                                "<=": r => r <= 0
                                            };
                                            return (e[n] || e[""])(r)
                                        })((i = s, o = n(o = r), i = n(i), o.localeCompare(i, void 0, {
                                            numeric: !0
                                        })), t || ">=")
                                    }))(s, e)
                                }(r, e = Array.isArray(e) ? e : [e], this.swup)) {
                                const n = `${r} ${e.join(", ")}`;
                                throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)
                            }
                        }), !0
                    }
                    on(r, n, e = {}) {
                        var t;
                        n = !(t = n).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n.bind(this) : n;
                        const s = this.swup.hooks.on(r, n, e);
                        return this.handlersToUnregister.push(s), s
                    }
                    once(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            once: !0
                        }))
                    }
                    before(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            before: !0
                        }))
                    }
                    replace(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            replace: !0
                        }))
                    }
                    off(r, n) {
                        return this.swup.hooks.off(r, n)
                    }
                }
            }),
        "./node_modules/@swup/debug-plugin/dist/index.modern.js":
            /*!**************************************************************!*\
              !*** ./node_modules/@swup/debug-plugin/dist/index.modern.js ***!
              \**************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                var _swup_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @swup/plugin */ "./node_modules/@swup/debug-plugin/node_modules/@swup/plugin/dist/index.modern.js");
                var swup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! swup */ "./node_modules/swup/dist/Swup.modern.js");

                function i() {
                    return i = Object.assign ? Object.assign.bind() : function(o) {
                        for (var s = 1; s < arguments.length; s++) {
                            var t = arguments[s];
                            for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (o[i] = t[i])
                        }
                        return o
                    }, i.apply(this, arguments)
                }
                class n extends _swup_plugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
                    constructor(o = {}) {
                        super(), this.name = "SwupDebugPlugin", this.requires = {
                            swup: ">=4"
                        }, this.defaults = {
                            globalInstance: !1
                        }, this.options = void 0, this.originalSwupLog = void 0, this.originalSwupHookCall = void 0, this.originalSwupHookCallSync = void 0, this.callHook = (o, s, ...t) => (this.logHook(o, s), this.originalSwupHookCall(o, s, ...t)), this.callHookSync = (o, s, ...t) => (this.logHook(o, s), this.originalSwupHookCallSync(o, s, ...t)), this.options = i({}, this.defaults, o)
                    }
                    mount() {
                        this.setLogImplementation(), this.setGlobalInstance(), this.proxyHooksThroughConsole(), this.checkDocumentTitle(), this.checkContainers(), this.checkAnimationSelector()
                    }
                    unmount() {
                        super.unmount(), this.restoreLogImplementation(), this.restoreHooksImplementation(), this.unsetGlobalInstance()
                    }
                    setLogImplementation() {
                        this.originalSwupLog = this.swup.log, this.swup.log = this.log
                    }
                    restoreLogImplementation() {
                        this.swup.log = this.originalSwupLog
                    }
                    proxyHooksThroughConsole() {
                        this.originalSwupHookCall = this.swup.hooks.call.bind(this.swup.hooks), this.originalSwupHookCallSync = this.swup.hooks.callSync.bind(this.swup.hooks), this.swup.hooks.call = this.callHook.bind(this), this.swup.hooks.callSync = this.callHookSync.bind(this)
                    }
                    restoreHooksImplementation() {
                        this.swup.hooks.call = this.originalSwupHookCall, this.swup.hooks.callSync = this.originalSwupHookCallSync
                    }
                    setGlobalInstance() {
                        this.options.globalInstance && (window.swup = this.swup)
                    }
                    unsetGlobalInstance() {
                        this.options.globalInstance && (window.swup = void 0)
                    }
                    checkDocumentTitle() {
                        (0, swup__WEBPACK_IMPORTED_MODULE_1__.query)("title") || this.error("Document is missing a title tag. It is required on every page.")
                    }
                    checkContainers() {
                        for (const o of this.swup.options.containers) {
                            const s = (0, swup__WEBPACK_IMPORTED_MODULE_1__.queryAll)(o);
                            s.length || this.error(`Container \`${o}\` is missing on the page.`), s.length > 1 && this.error(`Container \`${o}\` matches multiple elements.`), s.some(o => !o.matches("body *")) && this.error(`Container \`${o}\` is not supported. It must be a child of the body tag.`)
                        }
                    }
                    checkAnimationSelector() {
                        const {
                            animationSelector: o
                        } = this.swup.options;
                        o && (this.swup.options.containers.map(o => (0, swup__WEBPACK_IMPORTED_MODULE_1__.query)(o)).filter(s => null == s ? void 0 : s.matches(o)).length || this.warn(`No container matches the animation selector \`${o}\`.`))
                    }
                    logHook(o, s) {
                        console.groupCollapsed("%cswup:%c" + o, "color: #343434", "color: #009ACD"), console.log(s), console.groupEnd()
                    }
                    log(o, s) {
                        if (s) {
                            console.groupCollapsed(o);
                            for (let o in s) console.log(s[o]);
                            console.groupEnd()
                        } else console.log(o + "%c", "color: #009ACD")
                    }
                    warn(o) {
                        console.warn(`[swup debug plugin] ${o}`)
                    }
                    error(o) {
                        console.error(`[swup debug plugin] ${o}`)
                    }
                }
            }),
        "./node_modules/@swup/debug-plugin/node_modules/@swup/plugin/dist/index.modern.js":
            /*!****************************************************************************************!*\
              !*** ./node_modules/@swup/debug-plugin/node_modules/@swup/plugin/dist/index.modern.js ***!
              \****************************************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (e)
                });

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(r) {
                        for (var n = 1; n < arguments.length; n++) {
                            var e = arguments[n];
                            for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t])
                        }
                        return r
                    }, r.apply(this, arguments)
                }
                const n = r => String(r).split(".").map(r => String(parseInt(r || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
                class e {
                    constructor() {
                        this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = []
                    }
                    mount() {}
                    unmount() {
                        this.handlersToUnregister.forEach(r => r()), this.handlersToUnregister = []
                    }
                    _beforeMount() {
                        if (!this.name) throw new Error("You must define a name of plugin when creating a class.")
                    }
                    _afterUnmount() {}
                    _checkRequirements() {
                        return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r, e]) => {
                            if (! function(r, e, t) {
                                    const s = function(r, n) {
                                        var e;
                                        if ("swup" === r) return null != (e = n.version) ? e : ""; {
                                            var t;
                                            const e = n.findPlugin(r);
                                            return null != (t = null == e ? void 0 : e.version) ? t : ""
                                        }
                                    }(r, t);
                                    return !!s && ((r, e) => e.every(e => {
                                        const [, t, s] = e.match(/^([\D]+)?(.*)$/) || [];
                                        var o, i;
                                        return ((r, n) => {
                                            const e = {
                                                "": r => 0 === r,
                                                ">": r => r > 0,
                                                ">=": r => r >= 0,
                                                "<": r => r < 0,
                                                "<=": r => r <= 0
                                            };
                                            return (e[n] || e[""])(r)
                                        })((i = s, o = n(o = r), i = n(i), o.localeCompare(i, void 0, {
                                            numeric: !0
                                        })), t || ">=")
                                    }))(s, e)
                                }(r, e = Array.isArray(e) ? e : [e], this.swup)) {
                                const n = `${r} ${e.join(", ")}`;
                                throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)
                            }
                        }), !0
                    }
                    on(r, n, e = {}) {
                        var t;
                        n = !(t = n).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n.bind(this) : n;
                        const s = this.swup.hooks.on(r, n, e);
                        return this.handlersToUnregister.push(s), s
                    }
                    once(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            once: !0
                        }))
                    }
                    before(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            before: !0
                        }))
                    }
                    replace(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            replace: !0
                        }))
                    }
                    off(r, n) {
                        return this.swup.hooks.off(r, n)
                    }
                }
            }),
        "./node_modules/@swup/gtm-plugin/dist/index.modern.js":
            /*!************************************************************!*\
              !*** ./node_modules/@swup/gtm-plugin/dist/index.modern.js ***!
              \************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (t)
                });
                var _swup_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @swup/plugin */ "./node_modules/@swup/plugin/dist/index.modern.js");
                class t extends _swup_plugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
                    constructor(...e) {
                        super(...e), this.name = "SwupGtmPlugin"
                    }
                    mount() {
                        this.on("page:view", this.trackPageview)
                    }
                    trackPageview() {
                        if ("object" != typeof window.dataLayer) return void console.warn("GTM is not loaded on the page");
                        const e = window.location.pathname + window.location.search,
                            t = document.title;
                        window.dataLayer.push({
                            event: "VirtualPageview",
                            virtualPageURL: e,
                            virtualPageTitle: t
                        }), this.swup.log(`GTM page view: ${e}`)
                    }
                }
            }),
        "./node_modules/@swup/parallel-plugin/dist/index.modern.js":
            /*!*****************************************************************!*\
              !*** ./node_modules/@swup/parallel-plugin/dist/index.modern.js ***!
              \*****************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (e)
                });
                var swup__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! swup */ "./node_modules/swup/dist/Swup.modern.js");
                var _swup_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! @swup/plugin */ "./node_modules/@swup/plugin/dist/index.modern.js");

                function n() {
                    return n = Object.assign ? Object.assign.bind() : function(t) {
                        for (var i = 1; i < arguments.length; i++) {
                            var n = arguments[i];
                            for (var e in n) Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e])
                        }
                        return t
                    }, n.apply(this, arguments)
                }
                class e extends _swup_plugin__WEBPACK_IMPORTED_MODULE_1__["default"] {
                    constructor(i = {}) {
                        super(), this.name = "SwupParallelPlugin", this.requires = {
                            swup: ">=4.6"
                        }, this.defaults = {
                            containers: [],
                            keep: 0
                        }, this.options = void 0, this.originalContainers = null, this.parallelContainers = [], this.startVisit = t => {
                            this.originalContainers = null, this.visitHasPotentialParallelAnimation(t) && (t.animation.wait = !0, t.animation.parallel = !0)
                        }, this.skipOutAnimation = (t, i) => {
                            this.isParallelVisit(t) && (i.skip = !0)
                        }, this.insertContainers = i => {
                            if (!this.isParallelVisit(i)) return;
                            const n = this.getParallelContainersForVisit(i);
                            this.parallelContainers = n, this.swup.hooks.call("content:insert", {
                                containers: n
                            }, () => {
                                for (const {
                                        all: e,
                                        next: s,
                                        previous: a,
                                        keep: o,
                                        remove: r
                                    } of n) e.forEach((t, i) => t.style.setProperty("--swup-parallel-container", `${i}`)), a.setAttribute("aria-hidden", "true"), a.before(s), i.animation.animate && (s.classList.add("is-next-container"), (0, swup__WEBPACK_IMPORTED_MODULE_0__.forceReflow)(s), s.classList.remove("is-next-container")), a.classList.add("is-previous-container"), o.forEach(t => t.classList.add("is-kept-container")), r.forEach(t => t.classList.add("is-removing-container"))
                            }), this.originalContainers = i.containers;
                            const e = this.parallelContainers.map(({
                                selector: t
                            }) => t);
                            i.containers = i.containers.filter(t => !e.includes(t))
                        }, this.resetContainers = t => {
                            this.originalContainers && (t.containers = this.originalContainers)
                        }, this.cleanupContainers = () => {
                            const t = this.parallelContainers;
                            this.swup.hooks.call("content:remove", {
                                containers: t
                            }, () => {
                                for (const {
                                        remove: i,
                                        next: n
                                    } of t) i.forEach(t => t.remove()), n.classList.remove("is-next-container")
                            }), this.parallelContainers = []
                        }, this.options = n({}, this.defaults, i)
                    }
                    mount() {
                        this.options.containers.length || (this.options.containers = this.swup.options.containers), this.swup.hooks.create("content:insert"), this.swup.hooks.create("content:remove"), this.on("visit:start", this.startVisit, {
                            priority: 1
                        }), this.before("animation:out:await", this.skipOutAnimation, {
                            priority: 1
                        }), this.before("content:replace", this.insertContainers, {
                            priority: 1
                        }), this.on("content:replace", this.resetContainers), this.on("visit:end", this.cleanupContainers)
                    }
                    getParallelContainersForVisit(t) {
                        const {
                            containers: i
                        } = this.options, n = i.filter(i => t.containers.includes(i));
                        return n.length ? n.reduce((i, n) => {
                            let {
                                keep: e
                            } = this.options;
                            e = "object" == typeof e ? e[n] : e, e = Math.max(0, Number(e));
                            const s = t.to.document.querySelector(n),
                                a = Array.from(document.querySelectorAll(n)),
                                o = a[0],
                                r = a.slice(0, e),
                                l = a.slice(e),
                                c = [...new Set([s, o, ...r, ...l])];
                            return s && o ? [...i, {
                                selector: n,
                                next: s,
                                previous: o,
                                keep: r,
                                remove: l,
                                all: c
                            }] : (console.warn(`Parallel container ${n} not found`), i)
                        }, []) : (console.warn("No parallel containers found in list of replaced containers"), [])
                    }
                    isParallelVisit(t) {
                        return t.animation.parallel
                    }
                    markVisitAsParallelAnimation(t) {
                        t.animation.wait = !0, t.animation.parallel = !0
                    }
                    visitHasPotentialParallelAnimation(t) {
                        return !1 !== t.animation.parallel && this.visitHasParallelContainers(t)
                    }
                    visitHasParallelContainers(t) {
                        return this.options.containers.some(i => {
                            const n = document.querySelector(i);
                            return null == n ? void 0 : n.matches(t.containers.join(","))
                        })
                    }
                }
            }),
        "./node_modules/@swup/plugin/dist/index.modern.js":
            /*!********************************************************!*\
              !*** ./node_modules/@swup/plugin/dist/index.modern.js ***!
              \********************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (e)
                });

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(r) {
                        for (var n = 1; n < arguments.length; n++) {
                            var e = arguments[n];
                            for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t])
                        }
                        return r
                    }, r.apply(this, arguments)
                }
                const n = r => String(r).split(".").map(r => String(parseInt(r || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
                class e {
                    constructor() {
                        this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = []
                    }
                    mount() {}
                    unmount() {
                        this.handlersToUnregister.forEach(r => r()), this.handlersToUnregister = []
                    }
                    _beforeMount() {
                        if (!this.name) throw new Error("You must define a name of plugin when creating a class.")
                    }
                    _afterUnmount() {}
                    _checkRequirements() {
                        return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r, e]) => {
                            if (! function(r, e, t) {
                                    const s = function(r, n) {
                                        var e;
                                        if ("swup" === r) return null != (e = n.version) ? e : ""; {
                                            var t;
                                            const e = n.findPlugin(r);
                                            return null != (t = null == e ? void 0 : e.version) ? t : ""
                                        }
                                    }(r, t);
                                    return !!s && ((r, e) => e.every(e => {
                                        const [, t, s] = e.match(/^([\D]+)?(.*)$/) || [];
                                        var o, i;
                                        return ((r, n) => {
                                            const e = {
                                                "": r => 0 === r,
                                                ">": r => r > 0,
                                                ">=": r => r >= 0,
                                                "<": r => r < 0,
                                                "<=": r => r <= 0
                                            };
                                            return (e[n] || e[""])(r)
                                        })((i = s, o = n(o = r), i = n(i), o.localeCompare(i, void 0, {
                                            numeric: !0
                                        })), t || ">=")
                                    }))(s, e)
                                }(r, e = Array.isArray(e) ? e : [e], this.swup)) {
                                const n = `${r} ${e.join(", ")}`;
                                throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)
                            }
                        }), !0
                    }
                    on(r, n, e = {}) {
                        var t;
                        n = !(t = n).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n.bind(this) : n;
                        const s = this.swup.hooks.on(r, n, e);
                        return this.handlersToUnregister.push(s), s
                    }
                    once(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            once: !0
                        }))
                    }
                    before(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            before: !0
                        }))
                    }
                    replace(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            replace: !0
                        }))
                    }
                    off(r, n) {
                        return this.swup.hooks.off(r, n)
                    }
                }
            }),
        "./node_modules/@swup/preload-plugin/dist/index.modern.js":
            /*!****************************************************************!*\
              !*** ./node_modules/@swup/preload-plugin/dist/index.modern.js ***!
              \****************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (l)
                });
                var _swup_plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! @swup/plugin */ "./node_modules/@swup/preload-plugin/node_modules/@swup/plugin/dist/index.modern.js");
                var swup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! swup */ "./node_modules/swup/dist/Swup.modern.js");

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var s = arguments[t];
                            for (var r in s) Object.prototype.hasOwnProperty.call(s, r) && (e[r] = s[r])
                        }
                        return e
                    }, r.apply(this, arguments)
                }

                function o() {
                    return window.matchMedia("(hover: hover)").matches
                }

                function i(e) {
                    return !!e && (e instanceof HTMLAnchorElement || e instanceof SVGAElement)
                }
                const n = window.requestIdleCallback || (e => setTimeout(e, 1)),
                    a = ["preloadVisibleLinks"];
                class l extends _swup_plugin__WEBPACK_IMPORTED_MODULE_0__["default"] {
                    constructor(e = {}) {
                        var s;
                        super(), s = this, this.name = "SwupPreloadPlugin", this.requires = {
                            swup: ">=4.5"
                        }, this.defaults = {
                            throttle: 5,
                            preloadInitialPage: !0,
                            preloadHoveredLinks: !0,
                            preloadVisibleLinks: {
                                enabled: !1,
                                threshold: .2,
                                delay: 500,
                                containers: ["body"],
                                ignore: () => !1
                            }
                        }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = new Map, this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e, t, s) => {
                            const {
                                url: r
                            } = e.to;
                            return r && this.preloadPromises.has(r) ? this.preloadPromises.get(r) : s(e, t)
                        }, this.onMouseEnter = async function(e) {
                            if (e.target !== e.delegateTarget) return;
                            if (!o()) return;
                            const r = e.delegateTarget;
                            if (!i(r)) return;
                            const {
                                url: n,
                                hash: a
                            } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromElement(r), l = s.swup.createVisit({
                                to: n,
                                hash: a,
                                el: r,
                                event: e
                            });
                            s.swup.hooks.callSync("link:hover", l, {
                                el: r,
                                event: e
                            }), s.preload(r, {
                                priority: !0
                            })
                        }, this.onTouchStart = e => {
                            if (o()) return;
                            const t = e.delegateTarget;
                            i(t) && this.preload(t, {
                                priority: !0
                            })
                        }, this.onFocus = e => {
                            const t = e.delegateTarget;
                            i(t) && this.preload(t, {
                                priority: !0
                            })
                        };
                        const {
                            preloadVisibleLinks: n
                        } = e, l = function(e, t) {
                            if (null == e) return {};
                            var s, r, o = {},
                                i = Object.keys(e);
                            for (r = 0; r < i.length; r++) t.indexOf(s = i[r]) >= 0 || (o[s] = e[s]);
                            return o
                        }(e, a);
                        this.options = r({}, this.defaults, l), "object" == typeof n ? this.options.preloadVisibleLinks = r({}, this.options.preloadVisibleLinks, {
                            enabled: !0
                        }, n) : this.options.preloadVisibleLinks.enabled = Boolean(n), this.preload = this.preload.bind(this), this.queue = function(e = 1) {
                            const t = [],
                                s = [];
                            let r = 0,
                                o = 0;

                            function i() {
                                o < e && r > 0 && ((s.shift() || t.shift() || (() => {}))(), r--, o++)
                            }
                            return {
                                add: function(e, o = !1) {
                                    if (e.__queued) {
                                        if (!o) return; {
                                            const s = t.indexOf(e);
                                            if (s >= 0) {
                                                const e = t.splice(s, 1);
                                                r -= e.length
                                            }
                                        }
                                    }
                                    e.__queued = !0, (o ? s : t).push(e), r++, r <= 1 && i()
                                },
                                next: function() {
                                    o--, i()
                                }
                            }
                        }(this.options.throttle)
                    }
                    mount() {
                        const e = this.swup;
                        e.options.cache ? (e.hooks.create("page:preload"), e.hooks.create("link:hover"), e.preload = this.preload, e.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload((0, swup__WEBPACK_IMPORTED_MODULE_1__.getCurrentUrl)())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading")
                    }
                    unmount() {
                        var e, t, s;
                        this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), null == (e = this.mouseEnterDelegate) || e.destroy(), null == (t = this.touchStartDelegate) || t.destroy(), null == (s = this.focusDelegate) || s.destroy(), this.stopPreloadingVisibleLinks()
                    }
                    async preload(e, s = {}) {
                        var r;
                        let o, n;
                        const a = null != (r = s.priority) && r;
                        if (Array.isArray(e)) return Promise.all(e.map(e => this.preload(e)));
                        if (i(e)) n = e, ({
                            href: o
                        } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromElement(e));
                        else {
                            if ("string" != typeof e) return;
                            o = e
                        }
                        if (!o) return;
                        if (this.preloadPromises.has(o)) return this.preloadPromises.get(o);
                        if (!this.shouldPreload(o, {
                                el: n
                            })) return;
                        const l = new Promise(e => {
                            this.queue.add(() => {
                                this.performPreload(o).catch(() => {}).then(t => e(t)).finally(() => {
                                    this.queue.next(), this.preloadPromises.delete(o)
                                })
                            }, a)
                        });
                        return this.preloadPromises.set(o, l), l
                    }
                    preloadLinks() {
                        n(() => {
                            Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach(e => this.preload(e))
                        })
                    }
                    preloadLinksOnAttention() {
                        const {
                            swup: e
                        } = this, {
                            linkSelector: t
                        } = e.options, s = {
                            passive: !0,
                            capture: !0
                        };
                        this.mouseEnterDelegate = e.delegateEvent(t, "mouseenter", this.onMouseEnter, s), this.touchStartDelegate = e.delegateEvent(t, "touchstart", this.onTouchStart, s), this.focusDelegate = e.delegateEvent(t, "focus", this.onFocus, s)
                    }
                    preloadVisibleLinks() {
                        if (this.preloadObserver) return void this.preloadObserver.update();
                        const {
                            threshold: e,
                            delay: s,
                            containers: r
                        } = this.options.preloadVisibleLinks;
                        this.preloadObserver = function({
                            threshold: e,
                            delay: s,
                            containers: r,
                            callback: o,
                            filter: i
                        }) {
                            const a = new Map,
                                l = new IntersectionObserver(e => {
                                    e.forEach(e => {
                                        e.isIntersecting ? h(e.target) : d(e.target)
                                    })
                                }, {
                                    threshold: e
                                }),
                                h = e => {
                                    var r;
                                    const {
                                        href: i
                                    } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromElement(e), n = null != (r = a.get(i)) ? r : new Set;
                                    a.set(i, n), n.add(e), setTimeout(() => {
                                        const t = a.get(i);
                                        null != t && t.size && (o(e), l.unobserve(e), t.delete(e))
                                    }, s)
                                },
                                d = e => {
                                    var s;
                                    const {
                                        href: r
                                    } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromElement(e);
                                    null == (s = a.get(r)) || s.delete(e)
                                },
                                u = () => {
                                    n(() => {
                                        const e = r.map(e => `${e} a[*|href]`).join(", ");
                                        Array.from(document.querySelectorAll(e)).filter(e => i(e)).forEach(e => l.observe(e))
                                    })
                                };
                            return {
                                start: () => u(),
                                stop: () => l.disconnect(),
                                update: () => (a.clear(), u())
                            }
                        }({
                            threshold: e,
                            delay: s,
                            containers: r,
                            callback: e => this.preload(e),
                            filter: e => {
                                if (this.options.preloadVisibleLinks.ignore(e)) return !1;
                                if (!e.matches(this.swup.options.linkSelector)) return !1;
                                const {
                                    href: s
                                } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromElement(e);
                                return this.shouldPreload(s, {
                                    el: e
                                })
                            }
                        }), this.preloadObserver.start()
                    }
                    stopPreloadingVisibleLinks() {
                        this.preloadObserver && this.preloadObserver.stop()
                    }
                    shouldPreload(e, {
                        el: r
                    } = {}) {
                        const {
                            url: o,
                            href: i
                        } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromUrl(e);
                        return !(! function() {
                            if (navigator.connection) {
                                var e;
                                if (navigator.connection.saveData) return !1;
                                if (null != (e = navigator.connection.effectiveType) && e.endsWith("2g")) return !1
                            }
                            return !0
                        }() || this.swup.cache.has(o) || this.preloadPromises.has(o) || this.swup.shouldIgnoreVisit(i, {
                            el: r
                        }) || r && this.swup.resolveUrl(o) === this.swup.resolveUrl((0, swup__WEBPACK_IMPORTED_MODULE_1__.getCurrentUrl)()))
                    }
                    async performPreload(e) {
                        var s = this;
                        const {
                            url: r
                        } = swup__WEBPACK_IMPORTED_MODULE_1__.Location.fromUrl(e), o = this.swup.createVisit({
                            to: r
                        }), i = await this.swup.hooks.call("page:preload", o, {
                            url: r
                        }, async function(t, r) {
                            return r.page = await s.swup.fetchPage(e, {
                                visit: t
                            }), r.page
                        });
                        return i
                    }
                }
            }),
        "./node_modules/@swup/preload-plugin/node_modules/@swup/plugin/dist/index.modern.js":
            /*!******************************************************************************************!*\
              !*** ./node_modules/@swup/preload-plugin/node_modules/@swup/plugin/dist/index.modern.js ***!
              \******************************************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (e)
                });

                function r() {
                    return r = Object.assign ? Object.assign.bind() : function(r) {
                        for (var n = 1; n < arguments.length; n++) {
                            var e = arguments[n];
                            for (var t in e) Object.prototype.hasOwnProperty.call(e, t) && (r[t] = e[t])
                        }
                        return r
                    }, r.apply(this, arguments)
                }
                const n = r => String(r).split(".").map(r => String(parseInt(r || "0", 10))).concat(["0", "0"]).slice(0, 3).join(".");
                class e {
                    constructor() {
                        this.isSwupPlugin = !0, this.swup = void 0, this.version = void 0, this.requires = {}, this.handlersToUnregister = []
                    }
                    mount() {}
                    unmount() {
                        this.handlersToUnregister.forEach(r => r()), this.handlersToUnregister = []
                    }
                    _beforeMount() {
                        if (!this.name) throw new Error("You must define a name of plugin when creating a class.")
                    }
                    _afterUnmount() {}
                    _checkRequirements() {
                        return "object" != typeof this.requires || Object.entries(this.requires).forEach(([r, e]) => {
                            if (! function(r, e, t) {
                                    const s = function(r, n) {
                                        var e;
                                        if ("swup" === r) return null != (e = n.version) ? e : ""; {
                                            var t;
                                            const e = n.findPlugin(r);
                                            return null != (t = null == e ? void 0 : e.version) ? t : ""
                                        }
                                    }(r, t);
                                    return !!s && ((r, e) => e.every(e => {
                                        const [, t, s] = e.match(/^([\D]+)?(.*)$/) || [];
                                        var o, i;
                                        return ((r, n) => {
                                            const e = {
                                                "": r => 0 === r,
                                                ">": r => r > 0,
                                                ">=": r => r >= 0,
                                                "<": r => r < 0,
                                                "<=": r => r <= 0
                                            };
                                            return (e[n] || e[""])(r)
                                        })((i = s, o = n(o = r), i = n(i), o.localeCompare(i, void 0, {
                                            numeric: !0
                                        })), t || ">=")
                                    }))(s, e)
                                }(r, e = Array.isArray(e) ? e : [e], this.swup)) {
                                const n = `${r} ${e.join(", ")}`;
                                throw new Error(`Plugin version mismatch: ${this.name} requires ${n}`)
                            }
                        }), !0
                    }
                    on(r, n, e = {}) {
                        var t;
                        n = !(t = n).name.startsWith("bound ") || t.hasOwnProperty("prototype") ? n.bind(this) : n;
                        const s = this.swup.hooks.on(r, n, e);
                        return this.handlersToUnregister.push(s), s
                    }
                    once(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            once: !0
                        }))
                    }
                    before(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            before: !0
                        }))
                    }
                    replace(n, e, t = {}) {
                        return this.on(n, e, r({}, t, {
                            replace: !0
                        }))
                    }
                    off(r, n) {
                        return this.swup.hooks.off(r, n)
                    }
                }
            }),
        "./node_modules/delegate-it/delegate.js":
            /*!**********************************************!*\
              !*** ./node_modules/delegate-it/delegate.js ***!
              \**********************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (__WEBPACK_DEFAULT_EXPORT__)
                });
                const ledger = new WeakMap();

                function editLedger(wanted, baseElement, callback, setup) {
                    if (!wanted && !ledger.has(baseElement)) {
                        return !1
                    }
                    const elementMap = ledger.get(baseElement) ? ? new WeakMap();
                    ledger.set(baseElement, elementMap);
                    const setups = elementMap.get(callback) ? ? new Set();
                    elementMap.set(callback, setups);
                    const existed = setups.has(setup);
                    if (wanted) {
                        setups.add(setup)
                    } else {
                        setups.delete(setup)
                    }
                    return existed && wanted
                }

                function safeClosest(event, selector) {
                    let target = event.target;
                    if (target instanceof Text) {
                        target = target.parentElement
                    }
                    if (target instanceof Element && event.currentTarget instanceof Element) {
                        const closest = target.closest(selector);
                        if (closest && event.currentTarget.contains(closest)) {
                            return closest
                        }
                    }
                }

                function delegate(selector, type, callback, options = {}) {
                    const {
                        signal,
                        base = document
                    } = options;
                    if (signal ? .aborted) {
                        return
                    }
                    const {
                        once,
                        ...nativeListenerOptions
                    } = options;
                    const baseElement = base instanceof Document ? base.documentElement : base;
                    const capture = Boolean(typeof options === 'object' ? options.capture : options);
                    const listenerFunction = (event) => {
                        const delegateTarget = safeClosest(event, String(selector));
                        if (delegateTarget) {
                            const delegateEvent = Object.assign(event, {
                                delegateTarget
                            });
                            callback.call(baseElement, delegateEvent);
                            if (once) {
                                baseElement.removeEventListener(type, listenerFunction, nativeListenerOptions);
                                editLedger(!1, baseElement, callback, setup)
                            }
                        }
                    };
                    const setup = JSON.stringify({
                        selector,
                        type,
                        capture
                    });
                    const isAlreadyListening = editLedger(!0, baseElement, callback, setup);
                    if (!isAlreadyListening) {
                        baseElement.addEventListener(type, listenerFunction, nativeListenerOptions)
                    }
                    signal ? .addEventListener('abort', () => {
                        editLedger(!1, baseElement, callback, setup)
                    })
                }
                const __WEBPACK_DEFAULT_EXPORT__ = (delegate)
            }),
        "./node_modules/delegate-it/index.js":
            /*!*******************************************!*\
              !*** ./node_modules/delegate-it/index.js ***!
              \*******************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    "default": () => (_delegate_js__WEBPACK_IMPORTED_MODULE_0__["default"])
                });
                var _delegate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./delegate.js */ "./node_modules/delegate-it/delegate.js");
                var _one_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./one-event.js */ "./node_modules/delegate-it/one-event.js")
            }),
        "./node_modules/delegate-it/one-event.js":
            /*!***********************************************!*\
              !*** ./node_modules/delegate-it/one-event.js ***!
              \***********************************************/
            ((__unused_webpack___webpack_module__, __unused_webpack___webpack_exports__, __webpack_require__) => {
                "use strict";
                var _delegate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./delegate.js */ "./node_modules/delegate-it/delegate.js");
                async function oneEvent(selector, type, options = {}) {
                    return new Promise(resolve => {
                        options.once = !0;
                        if (options.signal ? .aborted) {
                            resolve(undefined)
                        }
                        options.signal ? .addEventListener('abort', () => {
                            resolve(undefined)
                        });
                        (0, _delegate_js__WEBPACK_IMPORTED_MODULE_0__["default"])(selector, type, resolve, options)
                    })
                }
                var __WEBPACK_DEFAULT_EXPORT__ = (oneEvent)
            }),
        "./node_modules/swup/dist/Swup.modern.js":
            /*!***********************************************!*\
              !*** ./node_modules/swup/dist/Swup.modern.js ***!
              \***********************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    Location: () => (l),
                    "default": () => (j),
                    forceReflow: () => (v),
                    getCurrentUrl: () => (n),
                    query: () => (p),
                    queryAll: () => (m)
                });
                var delegate_it__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! delegate-it */ "./node_modules/delegate-it/index.js");
                var path_to_regexp__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! path-to-regexp */ "./node_modules/path-to-regexp/dist.es2015/index.js");

                function i() {
                    return i = Object.assign ? Object.assign.bind() : function(t) {
                        for (var e = 1; e < arguments.length; e++) {
                            var i = arguments[e];
                            for (var s in i)({}).hasOwnProperty.call(i, s) && (t[s] = i[s])
                        }
                        return t
                    }, i.apply(null, arguments)
                }
                const s = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "",
                    n = ({
                        hash: t
                    } = {}) => window.location.pathname + window.location.search + (t ? window.location.hash : ""),
                    o = (t, e = {}) => {
                        const s = i({
                            url: t = t || n({
                                hash: !0
                            }),
                            random: Math.random(),
                            source: "swup"
                        }, e);
                        window.history.pushState(s, "", t)
                    },
                    r = (t = null, e = {}) => {
                        t = t || n({
                            hash: !0
                        });
                        const s = i({}, window.history.state || {}, {
                            url: t,
                            random: Math.random(),
                            source: "swup"
                        }, e);
                        window.history.replaceState(s, "", t)
                    },
                    a = (e, s, n, o) => {
                        const r = new AbortController;
                        return o = i({}, o, {
                            signal: r.signal
                        }), (0, delegate_it__WEBPACK_IMPORTED_MODULE_0__["default"])(e, s, n, o), {
                            destroy: () => r.abort()
                        }
                    };
                class l extends URL {
                    constructor(t, e = document.baseURI) {
                        super(t.toString(), e), Object.setPrototypeOf(this, l.prototype)
                    }
                    get url() {
                        return this.pathname + this.search
                    }
                    static fromElement(t) {
                        const e = t.getAttribute("href") || t.getAttribute("xlink:href") || "";
                        return new l(e)
                    }
                    static fromUrl(t) {
                        return new l(t)
                    }
                }
                const h = (t, i) => {
                    try {
                        return (0, path_to_regexp__WEBPACK_IMPORTED_MODULE_1__.match)(t, i)
                    } catch (e) {
                        throw new Error(`[swup] Error parsing path "${String(t)}":\n${String(e)}`)
                    }
                };
                class c extends Error {
                    constructor(t, e) {
                        super(t), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status, this.aborted = e.aborted || !1, this.timedOut = e.timedOut || !1
                    }
                }
                async function u(t, e = {}) {
                    var s;
                    t = l.fromUrl(t).url;
                    const {
                        visit: n = this.visit
                    } = e, o = i({}, this.options.requestHeaders, e.headers), r = null != (s = e.timeout) ? s : this.options.timeout, a = new AbortController, {
                        signal: h
                    } = a;
                    e = i({}, e, {
                        headers: o,
                        signal: h
                    });
                    let u, d = !1,
                        p = null;
                    r && r > 0 && (p = setTimeout(() => {
                        d = !0, a.abort("timeout")
                    }, r));
                    try {
                        u = await this.hooks.call("fetch:request", n, {
                            url: t,
                            options: e
                        }, (t, {
                            url: e,
                            options: i
                        }) => fetch(e, i)), p && clearTimeout(p)
                    } catch (e) {
                        if (d) throw this.hooks.call("fetch:timeout", n, {
                            url: t
                        }), new c(`Request timed out: ${t}`, {
                            url: t,
                            timedOut: d
                        });
                        if ("AbortError" === (null == e ? void 0 : e.name) || h.aborted) throw new c(`Request aborted: ${t}`, {
                            url: t,
                            aborted: !0
                        });
                        throw e
                    }
                    const {
                        status: m,
                        url: w
                    } = u, g = await u.text();
                    if (500 === m) throw this.hooks.call("fetch:error", n, {
                        status: m,
                        response: u,
                        url: w
                    }), new c(`Server error: ${w}`, {
                        status: m,
                        url: w
                    });
                    if (!g) throw new c(`Empty response: ${w}`, {
                        status: m,
                        url: w
                    });
                    const {
                        url: f
                    } = l.fromUrl(w), v = {
                        url: f,
                        html: g
                    };
                    return !n.cache.write || e.method && "GET" !== e.method || t !== f || this.cache.set(v.url, v), v
                }
                class d {
                    constructor(t) {
                        this.swup = void 0, this.pages = new Map, this.swup = t
                    }
                    get size() {
                        return this.pages.size
                    }
                    get all() {
                        const t = new Map;
                        return this.pages.forEach((e, s) => {
                            t.set(s, i({}, e))
                        }), t
                    }
                    has(t) {
                        return this.pages.has(this.resolve(t))
                    }
                    get(t) {
                        const e = this.pages.get(this.resolve(t));
                        return e ? i({}, e) : e
                    }
                    set(t, e) {
                        e = i({}, e, {
                            url: t = this.resolve(t)
                        }), this.pages.set(t, e), this.swup.hooks.callSync("cache:set", void 0, {
                            page: e
                        })
                    }
                    update(t, e) {
                        t = this.resolve(t);
                        const s = i({}, this.get(t), e, {
                            url: t
                        });
                        this.pages.set(t, s)
                    }
                    delete(t) {
                        this.pages.delete(this.resolve(t))
                    }
                    clear() {
                        this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0)
                    }
                    prune(t) {
                        this.pages.forEach((e, i) => {
                            t(i, e) && this.delete(i)
                        })
                    }
                    resolve(t) {
                        const {
                            url: e
                        } = l.fromUrl(t);
                        return this.swup.resolveUrl(e)
                    }
                }
                const p = (t, e = document) => e.querySelector(t),
                    m = (t, e = document) => Array.from(e.querySelectorAll(t)),
                    w = () => new Promise(t => {
                        requestAnimationFrame(() => {
                            requestAnimationFrame(() => {
                                t()
                            })
                        })
                    });

                function g(t) {
                    return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then
                }

                function f(t, e = []) {
                    return new Promise((i, s) => {
                        const n = t(...e);
                        g(n) ? n.then(i, s) : i(n)
                    })
                }

                function v(t) {
                    var e;
                    null == (e = t = t || document.body) || e.getBoundingClientRect()
                }

                function y(t, e) {
                    const i = null == t ? void 0 : t.closest(`[${e}]`);
                    return null != i && i.hasAttribute(e) ? (null == i ? void 0 : i.getAttribute(e)) || !0 : void 0
                }
                class k {
                    constructor(t) {
                        this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = t
                    }
                    get selectors() {
                        const {
                            scope: t
                        } = this.swup.visit.animation;
                        return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : []
                    }
                    get selector() {
                        return this.selectors.join(",")
                    }
                    get targets() {
                        return this.selector.trim() ? m(this.selector) : []
                    }
                    add(...t) {
                        this.targets.forEach(e => e.classList.add(...t))
                    }
                    remove(...t) {
                        this.targets.forEach(e => e.classList.remove(...t))
                    }
                    clear() {
                        this.targets.forEach(t => {
                            const e = t.className.split(" ").filter(t => this.isSwupClass(t));
                            t.classList.remove(...e)
                        })
                    }
                    isSwupClass(t) {
                        return this.swupClasses.some(e => t.startsWith(e))
                    }
                }
                class b {
                    constructor(t, e) {
                        this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0;
                        const {
                            to: i,
                            from: s,
                            hash: n,
                            el: o,
                            event: r
                        } = e;
                        this.id = Math.random(), this.state = 1, this.from = {
                            url: null != s ? s : t.location.url,
                            hash: t.location.hash
                        }, this.to = {
                            url: i,
                            hash: n
                        }, this.containers = t.options.containers, this.animation = {
                            animate: !0,
                            wait: !1,
                            name: void 0,
                            native: t.options.native,
                            scope: t.options.animationScope,
                            selector: t.options.animationSelector
                        }, this.trigger = {
                            el: o,
                            event: r
                        }, this.cache = {
                            read: t.options.cache,
                            write: t.options.cache
                        }, this.history = {
                            action: "push",
                            popstate: !1,
                            direction: void 0
                        }, this.scroll = {
                            reset: !0,
                            target: void 0
                        }
                    }
                    advance(t) {
                        this.state < t && (this.state = t)
                    }
                    abort() {
                        this.state = 8
                    }
                    get done() {
                        return this.state >= 7
                    }
                }

                function S(t) {
                    return new b(this, t)
                }
                class E {
                    constructor(t) {
                        this.swup = void 0, this.registry = new Map, this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = t, this.init()
                    }
                    init() {
                        this.hooks.forEach(t => this.create(t))
                    }
                    create(t) {
                        this.registry.has(t) || this.registry.set(t, new Map)
                    }
                    exists(t) {
                        return this.registry.has(t)
                    }
                    get(t) {
                        const e = this.registry.get(t);
                        if (e) return e;
                        console.error(`Unknown hook '${t}'`)
                    }
                    clear() {
                        this.registry.forEach(t => t.clear())
                    }
                    on(t, e, s = {}) {
                        const n = this.get(t);
                        if (!n) return console.warn(`Hook '${t}' not found.`), () => {};
                        const o = i({}, s, {
                            id: n.size + 1,
                            hook: t,
                            handler: e
                        });
                        return n.set(e, o), () => this.off(t, e)
                    }
                    before(t, e, s = {}) {
                        return this.on(t, e, i({}, s, {
                            before: !0
                        }))
                    }
                    replace(t, e, s = {}) {
                        return this.on(t, e, i({}, s, {
                            replace: !0
                        }))
                    }
                    once(t, e, s = {}) {
                        return this.on(t, e, i({}, s, {
                            once: !0
                        }))
                    }
                    off(t, e) {
                        const i = this.get(t);
                        i && e ? i.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : i && i.clear()
                    }
                    async call(t, e, i, s) {
                        const [n, o, r] = this.parseCallArgs(t, e, i, s), {
                            before: a,
                            handler: l,
                            after: h
                        } = this.getHandlers(t, r);
                        await this.run(a, n, o);
                        const [c] = await this.run(l, n, o, !0);
                        return await this.run(h, n, o), this.dispatchDomEvent(t, n, o), c
                    }
                    callSync(t, e, i, s) {
                        const [n, o, r] = this.parseCallArgs(t, e, i, s), {
                            before: a,
                            handler: l,
                            after: h
                        } = this.getHandlers(t, r);
                        this.runSync(a, n, o);
                        const [c] = this.runSync(l, n, o, !0);
                        return this.runSync(h, n, o), this.dispatchDomEvent(t, n, o), c
                    }
                    parseCallArgs(t, e, i, s) {
                        return e instanceof b || "object" != typeof e && "function" != typeof i ? [e, i, s] : [void 0, e, i]
                    }
                    async run(t, e = this.swup.visit, i, s = !1) {
                        const n = [];
                        for (const {
                                hook: o,
                                handler: r,
                                defaultHandler: a,
                                once: l
                            } of t)
                            if (null == e || !e.done) {
                                l && this.off(o, r);
                                try {
                                    const t = await f(r, [e, i, a]);
                                    n.push(t)
                                } catch (t) {
                                    if (s) throw t;
                                    console.error(`Error in hook '${o}':`, t)
                                }
                            }
                        return n
                    }
                    runSync(t, e = this.swup.visit, i, s = !1) {
                        const n = [];
                        for (const {
                                hook: o,
                                handler: r,
                                defaultHandler: a,
                                once: l
                            } of t)
                            if (null == e || !e.done) {
                                l && this.off(o, r);
                                try {
                                    const t = r(e, i, a);
                                    n.push(t), g(t) && console.warn(`Swup will not await Promises in handler for synchronous hook '${o}'.`)
                                } catch (t) {
                                    if (s) throw t;
                                    console.error(`Error in hook '${o}':`, t)
                                }
                            }
                        return n
                    }
                    getHandlers(t, e) {
                        const i = this.get(t);
                        if (!i) return {
                            found: !1,
                            before: [],
                            handler: [],
                            after: [],
                            replaced: !1
                        };
                        const s = Array.from(i.values()),
                            n = this.sortRegistrations,
                            o = s.filter(({
                                before: t,
                                replace: e
                            }) => t && !e).sort(n),
                            r = s.filter(({
                                replace: t
                            }) => t).filter(t => !0).sort(n),
                            a = s.filter(({
                                before: t,
                                replace: e
                            }) => !t && !e).sort(n),
                            l = r.length > 0;
                        let h = [];
                        if (e && (h = [{
                                id: 0,
                                hook: t,
                                handler: e
                            }], l)) {
                            const i = r.length - 1,
                                s = t => {
                                    const i = r[t - 1];
                                    return i ? (e, n) => i.handler(e, n, s(t - 1)) : e
                                };
                            h = [{
                                id: 0,
                                hook: t,
                                handler: r[i].handler,
                                defaultHandler: s(i)
                            }]
                        }
                        return {
                            found: !0,
                            before: o,
                            handler: h,
                            after: a,
                            replaced: l
                        }
                    }
                    sortRegistrations(t, e) {
                        var i, s;
                        return (null != (i = t.priority) ? i : 0) - (null != (s = e.priority) ? s : 0) || t.id - e.id || 0
                    }
                    dispatchDomEvent(t, e, i) {
                        if (null != e && e.done) return;
                        const s = {
                            hook: t,
                            args: i,
                            visit: e || this.swup.visit
                        };
                        document.dispatchEvent(new CustomEvent("swup:any", {
                            detail: s,
                            bubbles: !0
                        })), document.dispatchEvent(new CustomEvent(`swup:${t}`, {
                            detail: s,
                            bubbles: !0
                        }))
                    }
                }
                const C = t => {
                        if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t) return null;
                        const e = decodeURIComponent(t);
                        let i = document.getElementById(t) || document.getElementById(e) || p(`a[name='${CSS.escape(t)}']`) || p(`a[name='${CSS.escape(e)}']`);
                        return i || "top" !== t || (i = document.body), i
                    },
                    U = "transition",
                    P = "animation";
                async function $({
                    selector: t,
                    elements: e
                }) {
                    if (!1 === t && !e) return;
                    let i = [];
                    if (e) i = Array.from(e);
                    else if (t && (i = m(t, document.body), !i.length)) return void console.warn(`[swup] No elements found matching animationSelector \`${t}\``);
                    const s = i.map(t => function(t) {
                        const {
                            type: e,
                            timeout: i,
                            propCount: s
                        } = function(t) {
                            const e = window.getComputedStyle(t),
                                i = x(e, `${U}Delay`),
                                s = x(e, `${U}Duration`),
                                n = A(i, s),
                                o = x(e, `${P}Delay`),
                                r = x(e, `${P}Duration`),
                                a = A(o, r),
                                l = Math.max(n, a),
                                h = l > 0 ? n > a ? U : P : null;
                            return {
                                type: h,
                                timeout: l,
                                propCount: h ? h === U ? s.length : r.length : 0
                            }
                        }(t);
                        return !(!e || !i) && new Promise(n => {
                            const o = `${e}end`,
                                r = performance.now();
                            let a = 0;
                            const l = () => {
                                    t.removeEventListener(o, h), n()
                                },
                                h = e => {
                                    e.target === t && ((performance.now() - r) / 1e3 < e.elapsedTime || ++a >= s && l())
                                };
                            setTimeout(() => {
                                a < s && l()
                            }, i + 1), t.addEventListener(o, h)
                        })
                    }(t));
                    s.filter(Boolean).length > 0 ? await Promise.all(s) : t && console.warn(`[swup] No CSS animation duration defined on elements matching \`${t}\``)
                }

                function x(t, e) {
                    return (t[e] || "").split(", ")
                }

                function A(t, e) {
                    for (; t.length < e.length;) t = t.concat(t);
                    return Math.max(...e.map((e, i) => H(e) + H(t[i])))
                }

                function H(t) {
                    return 1e3 * parseFloat(t)
                }

                function V(t, e = {}, s = {}) {
                    if ("string" != typeof t) throw new Error("swup.navigate() requires a URL parameter");
                    if (this.shouldIgnoreVisit(t, {
                            el: s.el,
                            event: s.event
                        })) return void window.location.assign(t);
                    const {
                        url: n,
                        hash: o
                    } = l.fromUrl(t), r = this.createVisit(i({}, s, {
                        to: n,
                        hash: o
                    }));
                    this.performNavigation(r, e)
                }
                async function I(t, e = {}) {
                    if (this.navigating) {
                        if (this.visit.state >= 6) return t.state = 2, void(this.onVisitEnd = () => this.performNavigation(t, e));
                        await this.hooks.call("visit:abort", this.visit, void 0), delete this.visit.to.document, this.visit.state = 8
                    }
                    this.navigating = !0, this.visit = t;
                    const {
                        el: i
                    } = t.trigger;
                    e.referrer = e.referrer || this.location.url, !1 === e.animate && (t.animation.animate = !1), t.animation.animate || this.classes.clear();
                    const n = e.history || y(i, "data-swup-history");
                    "string" == typeof n && ["push", "replace"].includes(n) && (t.history.action = n);
                    const a = e.animation || y(i, "data-swup-animation");
                    var h, c;
                    "string" == typeof a && (t.animation.name = a), "object" == typeof e.cache ? (t.cache.read = null != (h = e.cache.read) ? h : t.cache.read, t.cache.write = null != (c = e.cache.write) ? c : t.cache.write) : void 0 !== e.cache && (t.cache = {
                        read: !!e.cache,
                        write: !!e.cache
                    }), delete e.cache;
                    try {
                        await this.hooks.call("visit:start", t, void 0), t.state = 3;
                        const i = this.hooks.call("page:load", t, {
                            options: e
                        }, async (t, e) => {
                            let i;
                            return t.cache.read && (i = this.cache.get(t.to.url)), e.page = i || await this.fetchPage(t.to.url, e.options), e.cache = !!i, e.page
                        });
                        i.then(({
                            html: e
                        }) => {
                            t.advance(5), t.to.html = e, t.to.document = (new DOMParser).parseFromString(e, "text/html")
                        });
                        const n = t.to.url + t.to.hash;
                        if (t.history.popstate || ("replace" === t.history.action || t.to.url === this.location.url ? r(n) : (this.currentHistoryIndex++, o(n, {
                                index: this.currentHistoryIndex
                            }))), this.location = l.fromUrl(n), t.history.popstate && this.classes.add("is-popstate"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`), t.animation.wait && await i, t.done) return;
                        if (await this.hooks.call("visit:transition", t, void 0, async () => {
                                if (!t.animation.animate) return await this.hooks.call("animation:skip", void 0), void await this.renderPage(t, await i);
                                t.advance(4), await this.animatePageOut(t), t.animation.native && document.startViewTransition ? await document.startViewTransition(async () => await this.renderPage(t, await i)).finished : await this.renderPage(t, await i), await this.animatePageIn(t)
                            }), t.done) return;
                        await this.hooks.call("visit:end", t, void 0, () => this.classes.clear()), t.state = 7, this.navigating = !1, this.onVisitEnd && (this.onVisitEnd(), this.onVisitEnd = void 0)
                    } catch (e) {
                        if (!e || null != e && e.aborted) return void(t.state = 8);
                        t.state = 9, console.error(e), this.options.skipPopStateHandling = () => (window.location.assign(t.to.url + t.to.hash), !0), window.history.back()
                    } finally {
                        delete t.to.document
                    }
                }
                const L = async function(t) {
                        await this.hooks.call("animation:out:start", t, void 0, () => {
                            this.classes.add("is-changing", "is-animating", "is-leaving")
                        }), await this.hooks.call("animation:out:await", t, {
                            skip: !1
                        }, (t, {
                            skip: e
                        }) => {
                            if (!e) return this.awaitAnimations({
                                selector: t.animation.selector
                            })
                        }), await this.hooks.call("animation:out:end", t, void 0)
                    },
                    q = function(t) {
                        var e;
                        const i = t.to.document;
                        if (!i) return !1;
                        const s = (null == (e = i.querySelector("title")) ? void 0 : e.innerText) || "";
                        document.title = s;
                        const n = m('[data-swup-persist]:not([data-swup-persist=""])'),
                            o = t.containers.map(t => {
                                const e = document.querySelector(t),
                                    s = i.querySelector(t);
                                return e && s ? (e.replaceWith(s.cloneNode(!0)), !0) : (e || console.warn(`[swup] Container missing in current document: ${t}`), s || console.warn(`[swup] Container missing in incoming document: ${t}`), !1)
                            }).filter(Boolean);
                        return n.forEach(t => {
                            const e = t.getAttribute("data-swup-persist"),
                                i = p(`[data-swup-persist="${e}"]`);
                            i && i !== t && i.replaceWith(t)
                        }), o.length === t.containers.length
                    },
                    R = function(t) {
                        const e = {
                                behavior: "auto"
                            },
                            {
                                target: s,
                                reset: n
                            } = t.scroll,
                            o = null != s ? s : t.to.hash;
                        let r = !1;
                        return o && (r = this.hooks.callSync("scroll:anchor", t, {
                            hash: o,
                            options: e
                        }, (t, {
                            hash: e,
                            options: i
                        }) => {
                            const s = this.getAnchorElement(e);
                            return s && s.scrollIntoView(i), !!s
                        })), n && !r && (r = this.hooks.callSync("scroll:top", t, {
                            options: e
                        }, (t, {
                            options: e
                        }) => (window.scrollTo(i({
                            top: 0,
                            left: 0
                        }, e)), !0))), r
                    },
                    T = async function(t) {
                        if (t.done) return;
                        const e = this.hooks.call("animation:in:await", t, {
                            skip: !1
                        }, (t, {
                            skip: e
                        }) => {
                            if (!e) return this.awaitAnimations({
                                selector: t.animation.selector
                            })
                        });
                        await w(), await this.hooks.call("animation:in:start", t, void 0, () => {
                            this.classes.remove("is-animating")
                        }), await e, await this.hooks.call("animation:in:end", t, void 0)
                    },
                    N = async function(t, e) {
                        if (t.done) return;
                        t.advance(6);
                        const {
                            url: i
                        } = e;
                        this.isSameResolvedUrl(n(), i) || (r(i), this.location = l.fromUrl(i), t.to.url = this.location.url, t.to.hash = this.location.hash), await this.hooks.call("content:replace", t, {
                            page: e
                        }, (t, {}) => {
                            if (this.classes.remove("is-leaving"), t.animation.animate && this.classes.add("is-rendering"), !this.replaceContent(t)) throw new Error("[swup] Container mismatch, aborting");
                            t.animation.animate && (this.classes.add("is-changing", "is-animating", "is-rendering"), t.animation.name && this.classes.add(`to-${s(t.animation.name)}`))
                        }), await this.hooks.call("content:scroll", t, void 0, () => this.scrollToContent(t)), await this.hooks.call("page:view", t, {
                            url: this.location.url,
                            title: document.title
                        })
                    },
                    O = function(t) {
                        var e;
                        if (e = t, Boolean(null == e ? void 0 : e.isSwupPlugin)) {
                            if (t.swup = this, !t._checkRequirements || t._checkRequirements()) return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins
                        } else console.error("Not a swup plugin instance", t)
                    };

                function D(t) {
                    const e = this.findPlugin(t);
                    if (e) return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter(t => t !== e), this.plugins;
                    console.error("No such plugin", e)
                }

                function M(t) {
                    return this.plugins.find(e => e === t || e.name === t || e.name === `Swup${String(t)}`)
                }

                function W(t) {
                    if ("function" != typeof this.options.resolveUrl) return console.warn("[swup] options.resolveUrl expects a callback function."), t;
                    const e = this.options.resolveUrl(t);
                    return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t)
                }

                function B(t, e) {
                    return this.resolveUrl(t) === this.resolveUrl(e)
                }
                const _ = {
                    animateHistoryBrowsing: !1,
                    animationSelector: '[class*="transition-"]',
                    animationScope: "html",
                    cache: !0,
                    containers: ["#swup"],
                    ignoreVisit: (t, {
                        el: e
                    } = {}) => !(null == e || !e.closest("[data-no-swup]")),
                    linkSelector: "a[href]",
                    linkToSelf: "scroll",
                    native: !1,
                    plugins: [],
                    resolveUrl: t => t,
                    requestHeaders: {
                        "X-Requested-With": "swup",
                        Accept: "text/html, application/xhtml+xml"
                    },
                    skipPopStateHandling: t => {
                        var e;
                        return "swup" !== (null == (e = t.state) ? void 0 : e.source)
                    },
                    timeout: 0
                };
                class j {
                    get currentPageUrl() {
                        return this.location.url
                    }
                    constructor(t = {}) {
                        var e, s;
                        this.version = "4.7.0", this.options = void 0, this.defaults = _, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.location = l.fromUrl(window.location.href), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = !1, this.onVisitEnd = void 0, this.use = O, this.unuse = D, this.findPlugin = M, this.log = () => {}, this.navigate = V, this.performNavigation = I, this.createVisit = S, this.delegateEvent = a, this.fetchPage = u, this.awaitAnimations = $, this.renderPage = N, this.replaceContent = q, this.animatePageIn = T, this.animatePageOut = L, this.scrollToContent = R, this.getAnchorElement = C, this.getCurrentUrl = n, this.resolveUrl = W, this.isSameResolvedUrl = B, this.options = i({}, this.defaults, t), this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new d(this), this.classes = new k(this), this.hooks = new E(this), this.visit = this.createVisit({
                            to: ""
                        }), this.currentHistoryIndex = null != (e = null == (s = window.history.state) ? void 0 : s.index) ? e : 1, this.enable()
                    }
                    async enable() {
                        var t;
                        const {
                            linkSelector: e
                        } = this.options;
                        this.clickDelegate = this.delegateEvent(e, "click", this.handleLinkClick), window.addEventListener("popstate", this.handlePopState), this.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.options.native = this.options.native && !!document.startViewTransition, this.options.plugins.forEach(t => this.use(t)), "swup" !== (null == (t = window.history.state) ? void 0 : t.source) && r(null, {
                            index: this.currentHistoryIndex
                        }), await w(), await this.hooks.call("enable", void 0, void 0, () => {
                            const t = document.documentElement;
                            t.classList.add("swup-enabled"), t.classList.toggle("swup-native", this.options.native)
                        })
                    }
                    async destroy() {
                        this.clickDelegate.destroy(), window.removeEventListener("popstate", this.handlePopState), this.cache.clear(), this.options.plugins.forEach(t => this.unuse(t)), await this.hooks.call("disable", void 0, void 0, () => {
                            const t = document.documentElement;
                            t.classList.remove("swup-enabled"), t.classList.remove("swup-native")
                        }), this.hooks.clear()
                    }
                    shouldIgnoreVisit(t, {
                        el: e,
                        event: i
                    } = {}) {
                        const {
                            origin: s,
                            url: n,
                            hash: o
                        } = l.fromUrl(t);
                        return s !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(n + o, {
                            el: e,
                            event: i
                        })
                    }
                    handleLinkClick(t) {
                        const e = t.delegateTarget,
                            {
                                href: i,
                                url: s,
                                hash: n
                            } = l.fromElement(e);
                        if (this.shouldIgnoreVisit(i, {
                                el: e,
                                event: t
                            })) return;
                        if (this.navigating && s === this.visit.to.url) return void t.preventDefault();
                        const o = this.createVisit({
                            to: s,
                            hash: n,
                            el: e,
                            event: t
                        });
                        t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.callSync("link:newtab", o, {
                            href: i
                        }) : 0 === t.button && this.hooks.callSync("link:click", o, {
                            el: e,
                            event: t
                        }, () => {
                            var e;
                            const i = null != (e = o.from.url) ? e : "";
                            t.preventDefault(), s && s !== i ? this.isSameResolvedUrl(s, i) || this.performNavigation(o) : n ? this.hooks.callSync("link:anchor", o, {
                                hash: n
                            }, () => {
                                r(s + n), this.scrollToContent(o)
                            }) : this.hooks.callSync("link:self", o, void 0, () => {
                                "navigate" === this.options.linkToSelf ? this.performNavigation(o) : (r(s), this.scrollToContent(o))
                            })
                        })
                    }
                    handlePopState(t) {
                        var e, i, s, o;
                        const r = null != (e = null == (i = t.state) ? void 0 : i.url) ? e : window.location.href;
                        if (this.options.skipPopStateHandling(t)) return;
                        if (this.isSameResolvedUrl(n(), this.location.url)) return;
                        const {
                            url: a,
                            hash: h
                        } = l.fromUrl(r), c = this.createVisit({
                            to: a,
                            hash: h,
                            event: t
                        });
                        c.history.popstate = !0;
                        const u = null != (s = null == (o = t.state) ? void 0 : o.index) ? s : 0;
                        u && u !== this.currentHistoryIndex && (c.history.direction = u - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = u), c.animation.animate = !1, c.scroll.reset = !1, c.scroll.target = !1, this.options.animateHistoryBrowsing && (c.animation.animate = !0, c.scroll.reset = !0), this.hooks.callSync("history:popstate", c, {
                            event: t
                        }, () => {
                            this.performNavigation(c)
                        })
                    }
                    triggerWillOpenNewWindow(t) {
                        return !!t.matches('[download], [target="_blank"]')
                    }
                }
            }),
        "./node_modules/three/build/three.module.js":
            /*!**************************************************!*\
              !*** ./node_modules/three/build/three.module.js ***!
              \**************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    AmbientLight: () => (AmbientLight),
                    AnimationClip: () => (AnimationClip),
                    Bone: () => (Bone),
                    Box3: () => (Box3),
                    BufferAttribute: () => (BufferAttribute),
                    BufferGeometry: () => (BufferGeometry),
                    ClampToEdgeWrapping: () => (ClampToEdgeWrapping),
                    Color: () => (Color),
                    ColorManagement: () => (ColorManagement),
                    DirectionalLight: () => (DirectionalLight),
                    DoubleSide: () => (DoubleSide),
                    FileLoader: () => (FileLoader),
                    Float32BufferAttribute: () => (Float32BufferAttribute),
                    FrontSide: () => (FrontSide),
                    Group: () => (Group),
                    ImageBitmapLoader: () => (ImageBitmapLoader),
                    InstancedBufferAttribute: () => (InstancedBufferAttribute),
                    InstancedMesh: () => (InstancedMesh),
                    InterleavedBuffer: () => (InterleavedBuffer),
                    InterleavedBufferAttribute: () => (InterleavedBufferAttribute),
                    Interpolant: () => (Interpolant),
                    InterpolateDiscrete: () => (InterpolateDiscrete),
                    InterpolateLinear: () => (InterpolateLinear),
                    Line: () => (Line),
                    LineBasicMaterial: () => (LineBasicMaterial),
                    LineLoop: () => (LineLoop),
                    LineSegments: () => (LineSegments),
                    LinearFilter: () => (LinearFilter),
                    LinearMipmapLinearFilter: () => (LinearMipmapLinearFilter),
                    LinearMipmapNearestFilter: () => (LinearMipmapNearestFilter),
                    LinearSRGBColorSpace: () => (LinearSRGBColorSpace),
                    Loader: () => (Loader),
                    LoaderUtils: () => (LoaderUtils),
                    Material: () => (Material),
                    MathUtils: () => (MathUtils),
                    Matrix4: () => (Matrix4),
                    Mesh: () => (Mesh),
                    MeshBasicMaterial: () => (MeshBasicMaterial),
                    MeshPhysicalMaterial: () => (MeshPhysicalMaterial),
                    MeshStandardMaterial: () => (MeshStandardMaterial),
                    MirroredRepeatWrapping: () => (MirroredRepeatWrapping),
                    NearestFilter: () => (NearestFilter),
                    NearestMipmapLinearFilter: () => (NearestMipmapLinearFilter),
                    NearestMipmapNearestFilter: () => (NearestMipmapNearestFilter),
                    NumberKeyframeTrack: () => (NumberKeyframeTrack),
                    Object3D: () => (Object3D),
                    OrthographicCamera: () => (OrthographicCamera),
                    PerspectiveCamera: () => (PerspectiveCamera),
                    PointLight: () => (PointLight),
                    Points: () => (Points),
                    PointsMaterial: () => (PointsMaterial),
                    PropertyBinding: () => (PropertyBinding),
                    Quaternion: () => (Quaternion),
                    QuaternionKeyframeTrack: () => (QuaternionKeyframeTrack),
                    RepeatWrapping: () => (RepeatWrapping),
                    SRGBColorSpace: () => (SRGBColorSpace),
                    Scene: () => (Scene),
                    Skeleton: () => (Skeleton),
                    SkinnedMesh: () => (SkinnedMesh),
                    Sphere: () => (Sphere),
                    SpotLight: () => (SpotLight),
                    Texture: () => (Texture),
                    TextureLoader: () => (TextureLoader),
                    TriangleFanDrawMode: () => (TriangleFanDrawMode),
                    TriangleStripDrawMode: () => (TriangleStripDrawMode),
                    TrianglesDrawMode: () => (TrianglesDrawMode),
                    Vector2: () => (Vector2),
                    Vector3: () => (Vector3),
                    VectorKeyframeTrack: () => (VectorKeyframeTrack),
                    WebGLRenderer: () => (WebGLRenderer)
                });
                /**
                 * @license
                 * Copyright 2010-2024 Three.js Authors
                 * SPDX-License-Identifier: MIT
                 */
                const REVISION = '167';
                const MOUSE = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2,
                    ROTATE: 0,
                    DOLLY: 1,
                    PAN: 2
                };
                const TOUCH = {
                    ROTATE: 0,
                    PAN: 1,
                    DOLLY_PAN: 2,
                    DOLLY_ROTATE: 3
                };
                const CullFaceNone = 0;
                const CullFaceBack = 1;
                const CullFaceFront = 2;
                const CullFaceFrontBack = 3;
                const BasicShadowMap = 0;
                const PCFShadowMap = 1;
                const PCFSoftShadowMap = 2;
                const VSMShadowMap = 3;
                const FrontSide = 0;
                const BackSide = 1;
                const DoubleSide = 2;
                const NoBlending = 0;
                const NormalBlending = 1;
                const AdditiveBlending = 2;
                const SubtractiveBlending = 3;
                const MultiplyBlending = 4;
                const CustomBlending = 5;
                const AddEquation = 100;
                const SubtractEquation = 101;
                const ReverseSubtractEquation = 102;
                const MinEquation = 103;
                const MaxEquation = 104;
                const ZeroFactor = 200;
                const OneFactor = 201;
                const SrcColorFactor = 202;
                const OneMinusSrcColorFactor = 203;
                const SrcAlphaFactor = 204;
                const OneMinusSrcAlphaFactor = 205;
                const DstAlphaFactor = 206;
                const OneMinusDstAlphaFactor = 207;
                const DstColorFactor = 208;
                const OneMinusDstColorFactor = 209;
                const SrcAlphaSaturateFactor = 210;
                const ConstantColorFactor = 211;
                const OneMinusConstantColorFactor = 212;
                const ConstantAlphaFactor = 213;
                const OneMinusConstantAlphaFactor = 214;
                const NeverDepth = 0;
                const AlwaysDepth = 1;
                const LessDepth = 2;
                const LessEqualDepth = 3;
                const EqualDepth = 4;
                const GreaterEqualDepth = 5;
                const GreaterDepth = 6;
                const NotEqualDepth = 7;
                const MultiplyOperation = 0;
                const MixOperation = 1;
                const AddOperation = 2;
                const NoToneMapping = 0;
                const LinearToneMapping = 1;
                const ReinhardToneMapping = 2;
                const CineonToneMapping = 3;
                const ACESFilmicToneMapping = 4;
                const CustomToneMapping = 5;
                const AgXToneMapping = 6;
                const NeutralToneMapping = 7;
                const AttachedBindMode = 'attached';
                const DetachedBindMode = 'detached';
                const UVMapping = 300;
                const CubeReflectionMapping = 301;
                const CubeRefractionMapping = 302;
                const EquirectangularReflectionMapping = 303;
                const EquirectangularRefractionMapping = 304;
                const CubeUVReflectionMapping = 306;
                const RepeatWrapping = 1000;
                const ClampToEdgeWrapping = 1001;
                const MirroredRepeatWrapping = 1002;
                const NearestFilter = 1003;
                const NearestMipmapNearestFilter = 1004;
                const NearestMipMapNearestFilter = 1004;
                const NearestMipmapLinearFilter = 1005;
                const NearestMipMapLinearFilter = 1005;
                const LinearFilter = 1006;
                const LinearMipmapNearestFilter = 1007;
                const LinearMipMapNearestFilter = 1007;
                const LinearMipmapLinearFilter = 1008;
                const LinearMipMapLinearFilter = 1008;
                const UnsignedByteType = 1009;
                const ByteType = 1010;
                const ShortType = 1011;
                const UnsignedShortType = 1012;
                const IntType = 1013;
                const UnsignedIntType = 1014;
                const FloatType = 1015;
                const HalfFloatType = 1016;
                const UnsignedShort4444Type = 1017;
                const UnsignedShort5551Type = 1018;
                const UnsignedInt248Type = 1020;
                const UnsignedInt5999Type = 35902;
                const AlphaFormat = 1021;
                const RGBFormat = 1022;
                const RGBAFormat = 1023;
                const LuminanceFormat = 1024;
                const LuminanceAlphaFormat = 1025;
                const DepthFormat = 1026;
                const DepthStencilFormat = 1027;
                const RedFormat = 1028;
                const RedIntegerFormat = 1029;
                const RGFormat = 1030;
                const RGIntegerFormat = 1031;
                const RGBIntegerFormat = 1032;
                const RGBAIntegerFormat = 1033;
                const RGB_S3TC_DXT1_Format = 33776;
                const RGBA_S3TC_DXT1_Format = 33777;
                const RGBA_S3TC_DXT3_Format = 33778;
                const RGBA_S3TC_DXT5_Format = 33779;
                const RGB_PVRTC_4BPPV1_Format = 35840;
                const RGB_PVRTC_2BPPV1_Format = 35841;
                const RGBA_PVRTC_4BPPV1_Format = 35842;
                const RGBA_PVRTC_2BPPV1_Format = 35843;
                const RGB_ETC1_Format = 36196;
                const RGB_ETC2_Format = 37492;
                const RGBA_ETC2_EAC_Format = 37496;
                const RGBA_ASTC_4x4_Format = 37808;
                const RGBA_ASTC_5x4_Format = 37809;
                const RGBA_ASTC_5x5_Format = 37810;
                const RGBA_ASTC_6x5_Format = 37811;
                const RGBA_ASTC_6x6_Format = 37812;
                const RGBA_ASTC_8x5_Format = 37813;
                const RGBA_ASTC_8x6_Format = 37814;
                const RGBA_ASTC_8x8_Format = 37815;
                const RGBA_ASTC_10x5_Format = 37816;
                const RGBA_ASTC_10x6_Format = 37817;
                const RGBA_ASTC_10x8_Format = 37818;
                const RGBA_ASTC_10x10_Format = 37819;
                const RGBA_ASTC_12x10_Format = 37820;
                const RGBA_ASTC_12x12_Format = 37821;
                const RGBA_BPTC_Format = 36492;
                const RGB_BPTC_SIGNED_Format = 36494;
                const RGB_BPTC_UNSIGNED_Format = 36495;
                const RED_RGTC1_Format = 36283;
                const SIGNED_RED_RGTC1_Format = 36284;
                const RED_GREEN_RGTC2_Format = 36285;
                const SIGNED_RED_GREEN_RGTC2_Format = 36286;
                const LoopOnce = 2200;
                const LoopRepeat = 2201;
                const LoopPingPong = 2202;
                const InterpolateDiscrete = 2300;
                const InterpolateLinear = 2301;
                const InterpolateSmooth = 2302;
                const ZeroCurvatureEnding = 2400;
                const ZeroSlopeEnding = 2401;
                const WrapAroundEnding = 2402;
                const NormalAnimationBlendMode = 2500;
                const AdditiveAnimationBlendMode = 2501;
                const TrianglesDrawMode = 0;
                const TriangleStripDrawMode = 1;
                const TriangleFanDrawMode = 2;
                const BasicDepthPacking = 3200;
                const RGBADepthPacking = 3201;
                const RGBDepthPacking = 3202;
                const RGDepthPacking = 3203;
                const TangentSpaceNormalMap = 0;
                const ObjectSpaceNormalMap = 1;
                const NoColorSpace = '';
                const SRGBColorSpace = 'srgb';
                const LinearSRGBColorSpace = 'srgb-linear';
                const DisplayP3ColorSpace = 'display-p3';
                const LinearDisplayP3ColorSpace = 'display-p3-linear';
                const LinearTransfer = 'linear';
                const SRGBTransfer = 'srgb';
                const Rec709Primaries = 'rec709';
                const P3Primaries = 'p3';
                const ZeroStencilOp = 0;
                const KeepStencilOp = 7680;
                const ReplaceStencilOp = 7681;
                const IncrementStencilOp = 7682;
                const DecrementStencilOp = 7683;
                const IncrementWrapStencilOp = 34055;
                const DecrementWrapStencilOp = 34056;
                const InvertStencilOp = 5386;
                const NeverStencilFunc = 512;
                const LessStencilFunc = 513;
                const EqualStencilFunc = 514;
                const LessEqualStencilFunc = 515;
                const GreaterStencilFunc = 516;
                const NotEqualStencilFunc = 517;
                const GreaterEqualStencilFunc = 518;
                const AlwaysStencilFunc = 519;
                const NeverCompare = 512;
                const LessCompare = 513;
                const EqualCompare = 514;
                const LessEqualCompare = 515;
                const GreaterCompare = 516;
                const NotEqualCompare = 517;
                const GreaterEqualCompare = 518;
                const AlwaysCompare = 519;
                const StaticDrawUsage = 35044;
                const DynamicDrawUsage = 35048;
                const StreamDrawUsage = 35040;
                const StaticReadUsage = 35045;
                const DynamicReadUsage = 35049;
                const StreamReadUsage = 35041;
                const StaticCopyUsage = 35046;
                const DynamicCopyUsage = 35050;
                const StreamCopyUsage = 35042;
                const GLSL1 = '100';
                const GLSL3 = '300 es';
                const WebGLCoordinateSystem = 2000;
                const WebGPUCoordinateSystem = 2001;
                class EventDispatcher {
                    addEventListener(type, listener) {
                        if (this._listeners === undefined) this._listeners = {};
                        const listeners = this._listeners;
                        if (listeners[type] === undefined) {
                            listeners[type] = []
                        }
                        if (listeners[type].indexOf(listener) === -1) {
                            listeners[type].push(listener)
                        }
                    }
                    hasEventListener(type, listener) {
                        if (this._listeners === undefined) return !1;
                        const listeners = this._listeners;
                        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1
                    }
                    removeEventListener(type, listener) {
                        if (this._listeners === undefined) return;
                        const listeners = this._listeners;
                        const listenerArray = listeners[type];
                        if (listenerArray !== undefined) {
                            const index = listenerArray.indexOf(listener);
                            if (index !== -1) {
                                listenerArray.splice(index, 1)
                            }
                        }
                    }
                    dispatchEvent(event) {
                        if (this._listeners === undefined) return;
                        const listeners = this._listeners;
                        const listenerArray = listeners[event.type];
                        if (listenerArray !== undefined) {
                            event.target = this;
                            const array = listenerArray.slice(0);
                            for (let i = 0, l = array.length; i < l; i++) {
                                array[i].call(this, event)
                            }
                            event.target = null
                        }
                    }
                }
                const _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
                let _seed = 1234567;
                const DEG2RAD = Math.PI / 180;
                const RAD2DEG = 180 / Math.PI;

                function generateUUID() {
                    const d0 = Math.random() * 0xffffffff | 0;
                    const d1 = Math.random() * 0xffffffff | 0;
                    const d2 = Math.random() * 0xffffffff | 0;
                    const d3 = Math.random() * 0xffffffff | 0;
                    const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];
                    return uuid.toLowerCase()
                }

                function clamp(value, min, max) {
                    return Math.max(min, Math.min(max, value))
                }

                function euclideanModulo(n, m) {
                    return ((n % m) + m) % m
                }

                function mapLinear(x, a1, a2, b1, b2) {
                    return b1 + (x - a1) * (b2 - b1) / (a2 - a1)
                }

                function inverseLerp(x, y, value) {
                    if (x !== y) {
                        return (value - x) / (y - x)
                    } else {
                        return 0
                    }
                }

                function lerp(x, y, t) {
                    return (1 - t) * x + t * y
                }

                function damp(x, y, lambda, dt) {
                    return lerp(x, y, 1 - Math.exp(-lambda * dt))
                }

                function pingpong(x, length = 1) {
                    return length - Math.abs(euclideanModulo(x, length * 2) - length)
                }

                function smoothstep(x, min, max) {
                    if (x <= min) return 0;
                    if (x >= max) return 1;
                    x = (x - min) / (max - min);
                    return x * x * (3 - 2 * x)
                }

                function smootherstep(x, min, max) {
                    if (x <= min) return 0;
                    if (x >= max) return 1;
                    x = (x - min) / (max - min);
                    return x * x * x * (x * (x * 6 - 15) + 10)
                }

                function randInt(low, high) {
                    return low + Math.floor(Math.random() * (high - low + 1))
                }

                function randFloat(low, high) {
                    return low + Math.random() * (high - low)
                }

                function randFloatSpread(range) {
                    return range * (0.5 - Math.random())
                }

                function seededRandom(s) {
                    if (s !== undefined) _seed = s;
                    let t = _seed += 0x6D2B79F5;
                    t = Math.imul(t ^ t >>> 15, t | 1);
                    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                    return ((t ^ t >>> 14) >>> 0) / 4294967296
                }

                function degToRad(degrees) {
                    return degrees * DEG2RAD
                }

                function radToDeg(radians) {
                    return radians * RAD2DEG
                }

                function isPowerOfTwo(value) {
                    return (value & (value - 1)) === 0 && value !== 0
                }

                function ceilPowerOfTwo(value) {
                    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2))
                }

                function floorPowerOfTwo(value) {
                    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))
                }

                function setQuaternionFromProperEuler(q, a, b, c, order) {
                    const cos = Math.cos;
                    const sin = Math.sin;
                    const c2 = cos(b / 2);
                    const s2 = sin(b / 2);
                    const c13 = cos((a + c) / 2);
                    const s13 = sin((a + c) / 2);
                    const c1_3 = cos((a - c) / 2);
                    const s1_3 = sin((a - c) / 2);
                    const c3_1 = cos((c - a) / 2);
                    const s3_1 = sin((c - a) / 2);
                    switch (order) {
                        case 'XYX':
                            q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
                            break;
                        case 'YZY':
                            q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
                            break;
                        case 'ZXZ':
                            q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
                            break;
                        case 'XZX':
                            q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
                            break;
                        case 'YXY':
                            q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
                            break;
                        case 'ZYZ':
                            q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
                            break;
                        default:
                            console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order)
                    }
                }

                function denormalize(value, array) {
                    switch (array.constructor) {
                        case Float32Array:
                            return value;
                        case Uint32Array:
                            return value / 4294967295.0;
                        case Uint16Array:
                            return value / 65535.0;
                        case Uint8Array:
                            return value / 255.0;
                        case Int32Array:
                            return Math.max(value / 2147483647.0, -1.0);
                        case Int16Array:
                            return Math.max(value / 32767.0, -1.0);
                        case Int8Array:
                            return Math.max(value / 127.0, -1.0);
                        default:
                            throw new Error('Invalid component type.')
                    }
                }

                function normalize(value, array) {
                    switch (array.constructor) {
                        case Float32Array:
                            return value;
                        case Uint32Array:
                            return Math.round(value * 4294967295.0);
                        case Uint16Array:
                            return Math.round(value * 65535.0);
                        case Uint8Array:
                            return Math.round(value * 255.0);
                        case Int32Array:
                            return Math.round(value * 2147483647.0);
                        case Int16Array:
                            return Math.round(value * 32767.0);
                        case Int8Array:
                            return Math.round(value * 127.0);
                        default:
                            throw new Error('Invalid component type.')
                    }
                }
                const MathUtils = {
                    DEG2RAD: DEG2RAD,
                    RAD2DEG: RAD2DEG,
                    generateUUID: generateUUID,
                    clamp: clamp,
                    euclideanModulo: euclideanModulo,
                    mapLinear: mapLinear,
                    inverseLerp: inverseLerp,
                    lerp: lerp,
                    damp: damp,
                    pingpong: pingpong,
                    smoothstep: smoothstep,
                    smootherstep: smootherstep,
                    randInt: randInt,
                    randFloat: randFloat,
                    randFloatSpread: randFloatSpread,
                    seededRandom: seededRandom,
                    degToRad: degToRad,
                    radToDeg: radToDeg,
                    isPowerOfTwo: isPowerOfTwo,
                    ceilPowerOfTwo: ceilPowerOfTwo,
                    floorPowerOfTwo: floorPowerOfTwo,
                    setQuaternionFromProperEuler: setQuaternionFromProperEuler,
                    normalize: normalize,
                    denormalize: denormalize
                };
                class Vector2 {
                    constructor(x = 0, y = 0) {
                        Vector2.prototype.isVector2 = !0;
                        this.x = x;
                        this.y = y
                    }
                    get width() {
                        return this.x
                    }
                    set width(value) {
                        this.x = value
                    }
                    get height() {
                        return this.y
                    }
                    set height(value) {
                        this.y = value
                    }
                    set(x, y) {
                        this.x = x;
                        this.y = y;
                        return this
                    }
                    setScalar(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        return this
                    }
                    setX(x) {
                        this.x = x;
                        return this
                    }
                    setY(y) {
                        this.y = y;
                        return this
                    }
                    setComponent(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                        return this
                    }
                    getComponent(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y)
                    }
                    copy(v) {
                        this.x = v.x;
                        this.y = v.y;
                        return this
                    }
                    add(v) {
                        this.x += v.x;
                        this.y += v.y;
                        return this
                    }
                    addScalar(s) {
                        this.x += s;
                        this.y += s;
                        return this
                    }
                    addVectors(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        return this
                    }
                    addScaledVector(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        return this
                    }
                    sub(v) {
                        this.x -= v.x;
                        this.y -= v.y;
                        return this
                    }
                    subScalar(s) {
                        this.x -= s;
                        this.y -= s;
                        return this
                    }
                    subVectors(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        return this
                    }
                    multiply(v) {
                        this.x *= v.x;
                        this.y *= v.y;
                        return this
                    }
                    multiplyScalar(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        return this
                    }
                    divide(v) {
                        this.x /= v.x;
                        this.y /= v.y;
                        return this
                    }
                    divideScalar(scalar) {
                        return this.multiplyScalar(1 / scalar)
                    }
                    applyMatrix3(m) {
                        const x = this.x,
                            y = this.y;
                        const e = m.elements;
                        this.x = e[0] * x + e[3] * y + e[6];
                        this.y = e[1] * x + e[4] * y + e[7];
                        return this
                    }
                    min(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        return this
                    }
                    max(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        return this
                    }
                    clamp(min, max) {
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        return this
                    }
                    clampScalar(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        return this
                    }
                    clampLength(min, max) {
                        const length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                    }
                    floor() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        return this
                    }
                    ceil() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        return this
                    }
                    round() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        return this
                    }
                    roundToZero() {
                        this.x = Math.trunc(this.x);
                        this.y = Math.trunc(this.y);
                        return this
                    }
                    negate() {
                        this.x = -this.x;
                        this.y = -this.y;
                        return this
                    }
                    dot(v) {
                        return this.x * v.x + this.y * v.y
                    }
                    cross(v) {
                        return this.x * v.y - this.y * v.x
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    angle() {
                        const angle = Math.atan2(-this.y, -this.x) + Math.PI;
                        return angle
                    }
                    angleTo(v) {
                        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
                        if (denominator === 0) return Math.PI / 2;
                        const theta = this.dot(v) / denominator;
                        return Math.acos(clamp(theta, -1, 1))
                    }
                    distanceTo(v) {
                        return Math.sqrt(this.distanceToSquared(v))
                    }
                    distanceToSquared(v) {
                        const dx = this.x - v.x,
                            dy = this.y - v.y;
                        return dx * dx + dy * dy
                    }
                    manhattanDistanceTo(v) {
                        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
                    }
                    setLength(length) {
                        return this.normalize().multiplyScalar(length)
                    }
                    lerp(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        return this
                    }
                    lerpVectors(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        return this
                    }
                    equals(v) {
                        return ((v.x === this.x) && (v.y === this.y))
                    }
                    fromArray(array, offset = 0) {
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        return array
                    }
                    fromBufferAttribute(attribute, index) {
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        return this
                    }
                    rotateAround(center, angle) {
                        const c = Math.cos(angle),
                            s = Math.sin(angle);
                        const x = this.x - center.x;
                        const y = this.y - center.y;
                        this.x = x * c - y * s + center.x;
                        this.y = x * s + y * c + center.y;
                        return this
                    }
                    random() {
                        this.x = Math.random();
                        this.y = Math.random();
                        return this
                    }*[Symbol.iterator]() {
                        yield this.x;
                        yield this.y
                    }
                }
                class Matrix3 {
                    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                        Matrix3.prototype.isMatrix3 = !0;
                        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                        if (n11 !== undefined) {
                            this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33)
                        }
                    }
                    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
                        const te = this.elements;
                        te[0] = n11;
                        te[1] = n21;
                        te[2] = n31;
                        te[3] = n12;
                        te[4] = n22;
                        te[5] = n32;
                        te[6] = n13;
                        te[7] = n23;
                        te[8] = n33;
                        return this
                    }
                    identity() {
                        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
                        return this
                    }
                    copy(m) {
                        const te = this.elements;
                        const me = m.elements;
                        te[0] = me[0];
                        te[1] = me[1];
                        te[2] = me[2];
                        te[3] = me[3];
                        te[4] = me[4];
                        te[5] = me[5];
                        te[6] = me[6];
                        te[7] = me[7];
                        te[8] = me[8];
                        return this
                    }
                    extractBasis(xAxis, yAxis, zAxis) {
                        xAxis.setFromMatrix3Column(this, 0);
                        yAxis.setFromMatrix3Column(this, 1);
                        zAxis.setFromMatrix3Column(this, 2);
                        return this
                    }
                    setFromMatrix4(m) {
                        const me = m.elements;
                        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
                        return this
                    }
                    multiply(m) {
                        return this.multiplyMatrices(this, m)
                    }
                    premultiply(m) {
                        return this.multiplyMatrices(m, this)
                    }
                    multiplyMatrices(a, b) {
                        const ae = a.elements;
                        const be = b.elements;
                        const te = this.elements;
                        const a11 = ae[0],
                            a12 = ae[3],
                            a13 = ae[6];
                        const a21 = ae[1],
                            a22 = ae[4],
                            a23 = ae[7];
                        const a31 = ae[2],
                            a32 = ae[5],
                            a33 = ae[8];
                        const b11 = be[0],
                            b12 = be[3],
                            b13 = be[6];
                        const b21 = be[1],
                            b22 = be[4],
                            b23 = be[7];
                        const b31 = be[2],
                            b32 = be[5],
                            b33 = be[8];
                        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
                        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
                        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
                        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
                        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
                        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
                        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
                        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
                        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
                        return this
                    }
                    multiplyScalar(s) {
                        const te = this.elements;
                        te[0] *= s;
                        te[3] *= s;
                        te[6] *= s;
                        te[1] *= s;
                        te[4] *= s;
                        te[7] *= s;
                        te[2] *= s;
                        te[5] *= s;
                        te[8] *= s;
                        return this
                    }
                    determinant() {
                        const te = this.elements;
                        const a = te[0],
                            b = te[1],
                            c = te[2],
                            d = te[3],
                            e = te[4],
                            f = te[5],
                            g = te[6],
                            h = te[7],
                            i = te[8];
                        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g
                    }
                    invert() {
                        const te = this.elements,
                            n11 = te[0],
                            n21 = te[1],
                            n31 = te[2],
                            n12 = te[3],
                            n22 = te[4],
                            n32 = te[5],
                            n13 = te[6],
                            n23 = te[7],
                            n33 = te[8],
                            t11 = n33 * n22 - n32 * n23,
                            t12 = n32 * n13 - n33 * n12,
                            t13 = n23 * n12 - n22 * n13,
                            det = n11 * t11 + n21 * t12 + n31 * t13;
                        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const detInv = 1 / det;
                        te[0] = t11 * detInv;
                        te[1] = (n31 * n23 - n33 * n21) * detInv;
                        te[2] = (n32 * n21 - n31 * n22) * detInv;
                        te[3] = t12 * detInv;
                        te[4] = (n33 * n11 - n31 * n13) * detInv;
                        te[5] = (n31 * n12 - n32 * n11) * detInv;
                        te[6] = t13 * detInv;
                        te[7] = (n21 * n13 - n23 * n11) * detInv;
                        te[8] = (n22 * n11 - n21 * n12) * detInv;
                        return this
                    }
                    transpose() {
                        let tmp;
                        const m = this.elements;
                        tmp = m[1];
                        m[1] = m[3];
                        m[3] = tmp;
                        tmp = m[2];
                        m[2] = m[6];
                        m[6] = tmp;
                        tmp = m[5];
                        m[5] = m[7];
                        m[7] = tmp;
                        return this
                    }
                    getNormalMatrix(matrix4) {
                        return this.setFromMatrix4(matrix4).invert().transpose()
                    }
                    transposeIntoArray(r) {
                        const m = this.elements;
                        r[0] = m[0];
                        r[1] = m[3];
                        r[2] = m[6];
                        r[3] = m[1];
                        r[4] = m[4];
                        r[5] = m[7];
                        r[6] = m[2];
                        r[7] = m[5];
                        r[8] = m[8];
                        return this
                    }
                    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
                        const c = Math.cos(rotation);
                        const s = Math.sin(rotation);
                        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
                        return this
                    }
                    scale(sx, sy) {
                        this.premultiply(_m3.makeScale(sx, sy));
                        return this
                    }
                    rotate(theta) {
                        this.premultiply(_m3.makeRotation(-theta));
                        return this
                    }
                    translate(tx, ty) {
                        this.premultiply(_m3.makeTranslation(tx, ty));
                        return this
                    }
                    makeTranslation(x, y) {
                        if (x.isVector2) {
                            this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1)
                        } else {
                            this.set(1, 0, x, 0, 1, y, 0, 0, 1)
                        }
                        return this
                    }
                    makeRotation(theta) {
                        const c = Math.cos(theta);
                        const s = Math.sin(theta);
                        this.set(c, -s, 0, s, c, 0, 0, 0, 1);
                        return this
                    }
                    makeScale(x, y) {
                        this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
                        return this
                    }
                    equals(matrix) {
                        const te = this.elements;
                        const me = matrix.elements;
                        for (let i = 0; i < 9; i++) {
                            if (te[i] !== me[i]) return !1
                        }
                        return !0
                    }
                    fromArray(array, offset = 0) {
                        for (let i = 0; i < 9; i++) {
                            this.elements[i] = array[i + offset]
                        }
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        const te = this.elements;
                        array[offset] = te[0];
                        array[offset + 1] = te[1];
                        array[offset + 2] = te[2];
                        array[offset + 3] = te[3];
                        array[offset + 4] = te[4];
                        array[offset + 5] = te[5];
                        array[offset + 6] = te[6];
                        array[offset + 7] = te[7];
                        array[offset + 8] = te[8];
                        return array
                    }
                    clone() {
                        return new this.constructor().fromArray(this.elements)
                    }
                }
                const _m3 = new Matrix3();

                function arrayNeedsUint32(array) {
                    for (let i = array.length - 1; i >= 0; --i) {
                        if (array[i] >= 65535) return !0
                    }
                    return !1
                }
                const TYPED_ARRAYS = {
                    Int8Array: Int8Array,
                    Uint8Array: Uint8Array,
                    Uint8ClampedArray: Uint8ClampedArray,
                    Int16Array: Int16Array,
                    Uint16Array: Uint16Array,
                    Int32Array: Int32Array,
                    Uint32Array: Uint32Array,
                    Float32Array: Float32Array,
                    Float64Array: Float64Array
                };

                function getTypedArray(type, buffer) {
                    return new TYPED_ARRAYS[type](buffer)
                }

                function createElementNS(name) {
                    return document.createElementNS('http://www.w3.org/1999/xhtml', name)
                }

                function createCanvasElement() {
                    const canvas = createElementNS('canvas');
                    canvas.style.display = 'block';
                    return canvas
                }
                const _cache = {};

                function warnOnce(message) {
                    if (message in _cache) return;
                    _cache[message] = !0;
                    console.warn(message)
                }

                function probeAsync(gl, sync, interval) {
                    return new Promise(function(resolve, reject) {
                        function probe() {
                            switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                                case gl.WAIT_FAILED:
                                    reject();
                                    break;
                                case gl.TIMEOUT_EXPIRED:
                                    setTimeout(probe, interval);
                                    break;
                                default:
                                    resolve()
                            }
                        }
                        setTimeout(probe, interval)
                    })
                }
                const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(0.8224621, 0.177538, 0.0, 0.0331941, 0.9668058, 0.0, 0.0170827, 0.0723974, 0.9105199, );
                const LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(1.2249401, -0.2249404, 0.0, -0.0420569, 1.0420571, 0.0, -0.0196376, -0.0786361, 1.0982735);
                const COLOR_SPACES = {
                    [LinearSRGBColorSpace]: {
                        transfer: LinearTransfer,
                        primaries: Rec709Primaries,
                        luminanceCoefficients: [0.2126, 0.7152, 0.0722],
                        toReference: (color) => color,
                        fromReference: (color) => color,
                    },
                    [SRGBColorSpace]: {
                        transfer: SRGBTransfer,
                        primaries: Rec709Primaries,
                        luminanceCoefficients: [0.2126, 0.7152, 0.0722],
                        toReference: (color) => color.convertSRGBToLinear(),
                        fromReference: (color) => color.convertLinearToSRGB(),
                    },
                    [LinearDisplayP3ColorSpace]: {
                        transfer: LinearTransfer,
                        primaries: P3Primaries,
                        luminanceCoefficients: [0.2289, 0.6917, 0.0793],
                        toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
                        fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3),
                    },
                    [DisplayP3ColorSpace]: {
                        transfer: SRGBTransfer,
                        primaries: P3Primaries,
                        luminanceCoefficients: [0.2289, 0.6917, 0.0793],
                        toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
                        fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB(),
                    },
                };
                const SUPPORTED_WORKING_COLOR_SPACES = new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
                const ColorManagement = {
                    enabled: !0,
                    _workingColorSpace: LinearSRGBColorSpace,
                    get workingColorSpace() {
                        return this._workingColorSpace
                    },
                    set workingColorSpace(colorSpace) {
                        if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
                            throw new Error(`Unsupported working color space, "${ colorSpace }".`)
                        }
                        this._workingColorSpace = colorSpace
                    },
                    convert: function(color, sourceColorSpace, targetColorSpace) {
                        if (this.enabled === !1 || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
                            return color
                        }
                        const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
                        const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
                        return targetFromReference(sourceToReference(color))
                    },
                    fromWorkingColorSpace: function(color, targetColorSpace) {
                        return this.convert(color, this._workingColorSpace, targetColorSpace)
                    },
                    toWorkingColorSpace: function(color, sourceColorSpace) {
                        return this.convert(color, sourceColorSpace, this._workingColorSpace)
                    },
                    getPrimaries: function(colorSpace) {
                        return COLOR_SPACES[colorSpace].primaries
                    },
                    getTransfer: function(colorSpace) {
                        if (colorSpace === NoColorSpace) return LinearTransfer;
                        return COLOR_SPACES[colorSpace].transfer
                    },
                    getLuminanceCoefficients: function(target, colorSpace = this._workingColorSpace) {
                        return target.fromArray(COLOR_SPACES[colorSpace].luminanceCoefficients)
                    },
                };

                function SRGBToLinear(c) {
                    return (c < 0.04045) ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)
                }

                function LinearToSRGB(c) {
                    return (c < 0.0031308) ? c * 12.92 : 1.055 * (Math.pow(c, 0.41666)) - 0.055
                }
                let _canvas;
                class ImageUtils {
                    static getDataURL(image) {
                        if (/^data:/i.test(image.src)) {
                            return image.src
                        }
                        if (typeof HTMLCanvasElement === 'undefined') {
                            return image.src
                        }
                        let canvas;
                        if (image instanceof HTMLCanvasElement) {
                            canvas = image
                        } else {
                            if (_canvas === undefined) _canvas = createElementNS('canvas');
                            _canvas.width = image.width;
                            _canvas.height = image.height;
                            const context = _canvas.getContext('2d');
                            if (image instanceof ImageData) {
                                context.putImageData(image, 0, 0)
                            } else {
                                context.drawImage(image, 0, 0, image.width, image.height)
                            }
                            canvas = _canvas
                        }
                        if (canvas.width > 2048 || canvas.height > 2048) {
                            console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
                            return canvas.toDataURL('image/jpeg', 0.6)
                        } else {
                            return canvas.toDataURL('image/png')
                        }
                    }
                    static sRGBToLinear(image) {
                        if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) || (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) || (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                            const canvas = createElementNS('canvas');
                            canvas.width = image.width;
                            canvas.height = image.height;
                            const context = canvas.getContext('2d');
                            context.drawImage(image, 0, 0, image.width, image.height);
                            const imageData = context.getImageData(0, 0, image.width, image.height);
                            const data = imageData.data;
                            for (let i = 0; i < data.length; i++) {
                                data[i] = SRGBToLinear(data[i] / 255) * 255
                            }
                            context.putImageData(imageData, 0, 0);
                            return canvas
                        } else if (image.data) {
                            const data = image.data.slice(0);
                            for (let i = 0; i < data.length; i++) {
                                if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
                                    data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255)
                                } else {
                                    data[i] = SRGBToLinear(data[i])
                                }
                            }
                            return {
                                data: data,
                                width: image.width,
                                height: image.height
                            }
                        } else {
                            console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
                            return image
                        }
                    }
                }
                let _sourceId = 0;
                class Source {
                    constructor(data = null) {
                        this.isSource = !0;
                        Object.defineProperty(this, 'id', {
                            value: _sourceId++
                        });
                        this.uuid = generateUUID();
                        this.data = data;
                        this.dataReady = !0;
                        this.version = 0
                    }
                    set needsUpdate(value) {
                        if (value === !0) this.version++
                    }
                    toJSON(meta) {
                        const isRootObject = (meta === undefined || typeof meta === 'string');
                        if (!isRootObject && meta.images[this.uuid] !== undefined) {
                            return meta.images[this.uuid]
                        }
                        const output = {
                            uuid: this.uuid,
                            url: ''
                        };
                        const data = this.data;
                        if (data !== null) {
                            let url;
                            if (Array.isArray(data)) {
                                url = [];
                                for (let i = 0, l = data.length; i < l; i++) {
                                    if (data[i].isDataTexture) {
                                        url.push(serializeImage(data[i].image))
                                    } else {
                                        url.push(serializeImage(data[i]))
                                    }
                                }
                            } else {
                                url = serializeImage(data)
                            }
                            output.url = url
                        }
                        if (!isRootObject) {
                            meta.images[this.uuid] = output
                        }
                        return output
                    }
                }

                function serializeImage(image) {
                    if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) || (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) || (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)) {
                        return ImageUtils.getDataURL(image)
                    } else {
                        if (image.data) {
                            return {
                                data: Array.from(image.data),
                                width: image.width,
                                height: image.height,
                                type: image.data.constructor.name
                            }
                        } else {
                            console.warn('THREE.Texture: Unable to serialize Texture.');
                            return {}
                        }
                    }
                }
                let _textureId = 0;
                class Texture extends EventDispatcher {
                    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
                        super();
                        this.isTexture = !0;
                        Object.defineProperty(this, 'id', {
                            value: _textureId++
                        });
                        this.uuid = generateUUID();
                        this.name = '';
                        this.source = new Source(image);
                        this.mipmaps = [];
                        this.mapping = mapping;
                        this.channel = 0;
                        this.wrapS = wrapS;
                        this.wrapT = wrapT;
                        this.magFilter = magFilter;
                        this.minFilter = minFilter;
                        this.anisotropy = anisotropy;
                        this.format = format;
                        this.internalFormat = null;
                        this.type = type;
                        this.offset = new Vector2(0, 0);
                        this.repeat = new Vector2(1, 1);
                        this.center = new Vector2(0, 0);
                        this.rotation = 0;
                        this.matrixAutoUpdate = !0;
                        this.matrix = new Matrix3();
                        this.generateMipmaps = !0;
                        this.premultiplyAlpha = !1;
                        this.flipY = !0;
                        this.unpackAlignment = 4;
                        this.colorSpace = colorSpace;
                        this.userData = {};
                        this.version = 0;
                        this.onUpdate = null;
                        this.isRenderTargetTexture = !1;
                        this.pmremVersion = 0
                    }
                    get image() {
                        return this.source.data
                    }
                    set image(value = null) {
                        this.source.data = value
                    }
                    updateMatrix() {
                        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(source) {
                        this.name = source.name;
                        this.source = source.source;
                        this.mipmaps = source.mipmaps.slice(0);
                        this.mapping = source.mapping;
                        this.channel = source.channel;
                        this.wrapS = source.wrapS;
                        this.wrapT = source.wrapT;
                        this.magFilter = source.magFilter;
                        this.minFilter = source.minFilter;
                        this.anisotropy = source.anisotropy;
                        this.format = source.format;
                        this.internalFormat = source.internalFormat;
                        this.type = source.type;
                        this.offset.copy(source.offset);
                        this.repeat.copy(source.repeat);
                        this.center.copy(source.center);
                        this.rotation = source.rotation;
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        this.matrix.copy(source.matrix);
                        this.generateMipmaps = source.generateMipmaps;
                        this.premultiplyAlpha = source.premultiplyAlpha;
                        this.flipY = source.flipY;
                        this.unpackAlignment = source.unpackAlignment;
                        this.colorSpace = source.colorSpace;
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        this.needsUpdate = !0;
                        return this
                    }
                    toJSON(meta) {
                        const isRootObject = (meta === undefined || typeof meta === 'string');
                        if (!isRootObject && meta.textures[this.uuid] !== undefined) {
                            return meta.textures[this.uuid]
                        }
                        const output = {
                            metadata: {
                                version: 4.6,
                                type: 'Texture',
                                generator: 'Texture.toJSON'
                            },
                            uuid: this.uuid,
                            name: this.name,
                            image: this.source.toJSON(meta).uuid,
                            mapping: this.mapping,
                            channel: this.channel,
                            repeat: [this.repeat.x, this.repeat.y],
                            offset: [this.offset.x, this.offset.y],
                            center: [this.center.x, this.center.y],
                            rotation: this.rotation,
                            wrap: [this.wrapS, this.wrapT],
                            format: this.format,
                            internalFormat: this.internalFormat,
                            type: this.type,
                            colorSpace: this.colorSpace,
                            minFilter: this.minFilter,
                            magFilter: this.magFilter,
                            anisotropy: this.anisotropy,
                            flipY: this.flipY,
                            generateMipmaps: this.generateMipmaps,
                            premultiplyAlpha: this.premultiplyAlpha,
                            unpackAlignment: this.unpackAlignment
                        };
                        if (Object.keys(this.userData).length > 0) output.userData = this.userData;
                        if (!isRootObject) {
                            meta.textures[this.uuid] = output
                        }
                        return output
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        })
                    }
                    transformUv(uv) {
                        if (this.mapping !== UVMapping) return uv;
                        uv.applyMatrix3(this.matrix);
                        if (uv.x < 0 || uv.x > 1) {
                            switch (this.wrapS) {
                                case RepeatWrapping:
                                    uv.x = uv.x - Math.floor(uv.x);
                                    break;
                                case ClampToEdgeWrapping:
                                    uv.x = uv.x < 0 ? 0 : 1;
                                    break;
                                case MirroredRepeatWrapping:
                                    if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                                        uv.x = Math.ceil(uv.x) - uv.x
                                    } else {
                                        uv.x = uv.x - Math.floor(uv.x)
                                    }
                                    break
                            }
                        }
                        if (uv.y < 0 || uv.y > 1) {
                            switch (this.wrapT) {
                                case RepeatWrapping:
                                    uv.y = uv.y - Math.floor(uv.y);
                                    break;
                                case ClampToEdgeWrapping:
                                    uv.y = uv.y < 0 ? 0 : 1;
                                    break;
                                case MirroredRepeatWrapping:
                                    if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                                        uv.y = Math.ceil(uv.y) - uv.y
                                    } else {
                                        uv.y = uv.y - Math.floor(uv.y)
                                    }
                                    break
                            }
                        }
                        if (this.flipY) {
                            uv.y = 1 - uv.y
                        }
                        return uv
                    }
                    set needsUpdate(value) {
                        if (value === !0) {
                            this.version++;
                            this.source.needsUpdate = !0
                        }
                    }
                    set needsPMREMUpdate(value) {
                        if (value === !0) {
                            this.pmremVersion++
                        }
                    }
                }
                Texture.DEFAULT_IMAGE = null;
                Texture.DEFAULT_MAPPING = UVMapping;
                Texture.DEFAULT_ANISOTROPY = 1;
                class Vector4 {
                    constructor(x = 0, y = 0, z = 0, w = 1) {
                        Vector4.prototype.isVector4 = !0;
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this.w = w
                    }
                    get width() {
                        return this.z
                    }
                    set width(value) {
                        this.z = value
                    }
                    get height() {
                        return this.w
                    }
                    set height(value) {
                        this.w = value
                    }
                    set(x, y, z, w) {
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        this.w = w;
                        return this
                    }
                    setScalar(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        this.z = scalar;
                        this.w = scalar;
                        return this
                    }
                    setX(x) {
                        this.x = x;
                        return this
                    }
                    setY(y) {
                        this.y = y;
                        return this
                    }
                    setZ(z) {
                        this.z = z;
                        return this
                    }
                    setW(w) {
                        this.w = w;
                        return this
                    }
                    setComponent(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            case 2:
                                this.z = value;
                                break;
                            case 3:
                                this.w = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                        return this
                    }
                    getComponent(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            case 3:
                                return this.w;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z, this.w)
                    }
                    copy(v) {
                        this.x = v.x;
                        this.y = v.y;
                        this.z = v.z;
                        this.w = (v.w !== undefined) ? v.w : 1;
                        return this
                    }
                    add(v) {
                        this.x += v.x;
                        this.y += v.y;
                        this.z += v.z;
                        this.w += v.w;
                        return this
                    }
                    addScalar(s) {
                        this.x += s;
                        this.y += s;
                        this.z += s;
                        this.w += s;
                        return this
                    }
                    addVectors(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        this.z = a.z + b.z;
                        this.w = a.w + b.w;
                        return this
                    }
                    addScaledVector(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        this.z += v.z * s;
                        this.w += v.w * s;
                        return this
                    }
                    sub(v) {
                        this.x -= v.x;
                        this.y -= v.y;
                        this.z -= v.z;
                        this.w -= v.w;
                        return this
                    }
                    subScalar(s) {
                        this.x -= s;
                        this.y -= s;
                        this.z -= s;
                        this.w -= s;
                        return this
                    }
                    subVectors(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        this.z = a.z - b.z;
                        this.w = a.w - b.w;
                        return this
                    }
                    multiply(v) {
                        this.x *= v.x;
                        this.y *= v.y;
                        this.z *= v.z;
                        this.w *= v.w;
                        return this
                    }
                    multiplyScalar(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        this.z *= scalar;
                        this.w *= scalar;
                        return this
                    }
                    applyMatrix4(m) {
                        const x = this.x,
                            y = this.y,
                            z = this.z,
                            w = this.w;
                        const e = m.elements;
                        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
                        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
                        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
                        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
                        return this
                    }
                    divideScalar(scalar) {
                        return this.multiplyScalar(1 / scalar)
                    }
                    setAxisAngleFromQuaternion(q) {
                        this.w = 2 * Math.acos(q.w);
                        const s = Math.sqrt(1 - q.w * q.w);
                        if (s < 0.0001) {
                            this.x = 1;
                            this.y = 0;
                            this.z = 0
                        } else {
                            this.x = q.x / s;
                            this.y = q.y / s;
                            this.z = q.z / s
                        }
                        return this
                    }
                    setAxisAngleFromRotationMatrix(m) {
                        let angle, x, y, z;
                        const epsilon = 0.01,
                            epsilon2 = 0.1,
                            te = m.elements,
                            m11 = te[0],
                            m12 = te[4],
                            m13 = te[8],
                            m21 = te[1],
                            m22 = te[5],
                            m23 = te[9],
                            m31 = te[2],
                            m32 = te[6],
                            m33 = te[10];
                        if ((Math.abs(m12 - m21) < epsilon) && (Math.abs(m13 - m31) < epsilon) && (Math.abs(m23 - m32) < epsilon)) {
                            if ((Math.abs(m12 + m21) < epsilon2) && (Math.abs(m13 + m31) < epsilon2) && (Math.abs(m23 + m32) < epsilon2) && (Math.abs(m11 + m22 + m33 - 3) < epsilon2)) {
                                this.set(1, 0, 0, 0);
                                return this
                            }
                            angle = Math.PI;
                            const xx = (m11 + 1) / 2;
                            const yy = (m22 + 1) / 2;
                            const zz = (m33 + 1) / 2;
                            const xy = (m12 + m21) / 4;
                            const xz = (m13 + m31) / 4;
                            const yz = (m23 + m32) / 4;
                            if ((xx > yy) && (xx > zz)) {
                                if (xx < epsilon) {
                                    x = 0;
                                    y = 0.707106781;
                                    z = 0.707106781
                                } else {
                                    x = Math.sqrt(xx);
                                    y = xy / x;
                                    z = xz / x
                                }
                            } else if (yy > zz) {
                                if (yy < epsilon) {
                                    x = 0.707106781;
                                    y = 0;
                                    z = 0.707106781
                                } else {
                                    y = Math.sqrt(yy);
                                    x = xy / y;
                                    z = yz / y
                                }
                            } else {
                                if (zz < epsilon) {
                                    x = 0.707106781;
                                    y = 0.707106781;
                                    z = 0
                                } else {
                                    z = Math.sqrt(zz);
                                    x = xz / z;
                                    y = yz / z
                                }
                            }
                            this.set(x, y, z, angle);
                            return this
                        }
                        let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
                        if (Math.abs(s) < 0.001) s = 1;
                        this.x = (m32 - m23) / s;
                        this.y = (m13 - m31) / s;
                        this.z = (m21 - m12) / s;
                        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
                        return this
                    }
                    setFromMatrixPosition(m) {
                        const e = m.elements;
                        this.x = e[12];
                        this.y = e[13];
                        this.z = e[14];
                        this.w = e[15];
                        return this
                    }
                    min(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        this.z = Math.min(this.z, v.z);
                        this.w = Math.min(this.w, v.w);
                        return this
                    }
                    max(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        this.z = Math.max(this.z, v.z);
                        this.w = Math.max(this.w, v.w);
                        return this
                    }
                    clamp(min, max) {
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        this.z = Math.max(min.z, Math.min(max.z, this.z));
                        this.w = Math.max(min.w, Math.min(max.w, this.w));
                        return this
                    }
                    clampScalar(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        this.z = Math.max(minVal, Math.min(maxVal, this.z));
                        this.w = Math.max(minVal, Math.min(maxVal, this.w));
                        return this
                    }
                    clampLength(min, max) {
                        const length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                    }
                    floor() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        this.z = Math.floor(this.z);
                        this.w = Math.floor(this.w);
                        return this
                    }
                    ceil() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        this.z = Math.ceil(this.z);
                        this.w = Math.ceil(this.w);
                        return this
                    }
                    round() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        this.z = Math.round(this.z);
                        this.w = Math.round(this.w);
                        return this
                    }
                    roundToZero() {
                        this.x = Math.trunc(this.x);
                        this.y = Math.trunc(this.y);
                        this.z = Math.trunc(this.z);
                        this.w = Math.trunc(this.w);
                        return this
                    }
                    negate() {
                        this.x = -this.x;
                        this.y = -this.y;
                        this.z = -this.z;
                        this.w = -this.w;
                        return this
                    }
                    dot(v) {
                        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(length) {
                        return this.normalize().multiplyScalar(length)
                    }
                    lerp(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        this.z += (v.z - this.z) * alpha;
                        this.w += (v.w - this.w) * alpha;
                        return this
                    }
                    lerpVectors(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        this.z = v1.z + (v2.z - v1.z) * alpha;
                        this.w = v1.w + (v2.w - v1.w) * alpha;
                        return this
                    }
                    equals(v) {
                        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z) && (v.w === this.w))
                    }
                    fromArray(array, offset = 0) {
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        this.z = array[offset + 2];
                        this.w = array[offset + 3];
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        array[offset + 2] = this.z;
                        array[offset + 3] = this.w;
                        return array
                    }
                    fromBufferAttribute(attribute, index) {
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        this.z = attribute.getZ(index);
                        this.w = attribute.getW(index);
                        return this
                    }
                    random() {
                        this.x = Math.random();
                        this.y = Math.random();
                        this.z = Math.random();
                        this.w = Math.random();
                        return this
                    }*[Symbol.iterator]() {
                        yield this.x;
                        yield this.y;
                        yield this.z;
                        yield this.w
                    }
                }
                class RenderTarget extends EventDispatcher {
                    constructor(width = 1, height = 1, options = {}) {
                        super();
                        this.isRenderTarget = !0;
                        this.width = width;
                        this.height = height;
                        this.depth = 1;
                        this.scissor = new Vector4(0, 0, width, height);
                        this.scissorTest = !1;
                        this.viewport = new Vector4(0, 0, width, height);
                        const image = {
                            width: width,
                            height: height,
                            depth: 1
                        };
                        options = Object.assign({
                            generateMipmaps: !1,
                            internalFormat: null,
                            minFilter: LinearFilter,
                            depthBuffer: !0,
                            stencilBuffer: !1,
                            resolveDepthBuffer: !0,
                            resolveStencilBuffer: !0,
                            depthTexture: null,
                            samples: 0,
                            count: 1
                        }, options);
                        const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
                        texture.flipY = !1;
                        texture.generateMipmaps = options.generateMipmaps;
                        texture.internalFormat = options.internalFormat;
                        this.textures = [];
                        const count = options.count;
                        for (let i = 0; i < count; i++) {
                            this.textures[i] = texture.clone();
                            this.textures[i].isRenderTargetTexture = !0
                        }
                        this.depthBuffer = options.depthBuffer;
                        this.stencilBuffer = options.stencilBuffer;
                        this.resolveDepthBuffer = options.resolveDepthBuffer;
                        this.resolveStencilBuffer = options.resolveStencilBuffer;
                        this.depthTexture = options.depthTexture;
                        this.samples = options.samples
                    }
                    get texture() {
                        return this.textures[0]
                    }
                    set texture(value) {
                        this.textures[0] = value
                    }
                    setSize(width, height, depth = 1) {
                        if (this.width !== width || this.height !== height || this.depth !== depth) {
                            this.width = width;
                            this.height = height;
                            this.depth = depth;
                            for (let i = 0, il = this.textures.length; i < il; i++) {
                                this.textures[i].image.width = width;
                                this.textures[i].image.height = height;
                                this.textures[i].image.depth = depth
                            }
                            this.dispose()
                        }
                        this.viewport.set(0, 0, width, height);
                        this.scissor.set(0, 0, width, height)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(source) {
                        this.width = source.width;
                        this.height = source.height;
                        this.depth = source.depth;
                        this.scissor.copy(source.scissor);
                        this.scissorTest = source.scissorTest;
                        this.viewport.copy(source.viewport);
                        this.textures.length = 0;
                        for (let i = 0, il = source.textures.length; i < il; i++) {
                            this.textures[i] = source.textures[i].clone();
                            this.textures[i].isRenderTargetTexture = !0
                        }
                        const image = Object.assign({}, source.texture.image);
                        this.texture.source = new Source(image);
                        this.depthBuffer = source.depthBuffer;
                        this.stencilBuffer = source.stencilBuffer;
                        this.resolveDepthBuffer = source.resolveDepthBuffer;
                        this.resolveStencilBuffer = source.resolveStencilBuffer;
                        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
                        this.samples = source.samples;
                        return this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        })
                    }
                }
                class WebGLRenderTarget extends RenderTarget {
                    constructor(width = 1, height = 1, options = {}) {
                        super(width, height, options);
                        this.isWebGLRenderTarget = !0
                    }
                }
                class DataArrayTexture extends Texture {
                    constructor(data = null, width = 1, height = 1, depth = 1) {
                        super(null);
                        this.isDataArrayTexture = !0;
                        this.image = {
                            data,
                            width,
                            height,
                            depth
                        };
                        this.magFilter = NearestFilter;
                        this.minFilter = NearestFilter;
                        this.wrapR = ClampToEdgeWrapping;
                        this.generateMipmaps = !1;
                        this.flipY = !1;
                        this.unpackAlignment = 1;
                        this.layerUpdates = new Set()
                    }
                    addLayerUpdate(layerIndex) {
                        this.layerUpdates.add(layerIndex)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                class WebGLArrayRenderTarget extends WebGLRenderTarget {
                    constructor(width = 1, height = 1, depth = 1, options = {}) {
                        super(width, height, options);
                        this.isWebGLArrayRenderTarget = !0;
                        this.depth = depth;
                        this.texture = new DataArrayTexture(null, width, height, depth);
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                class Data3DTexture extends Texture {
                    constructor(data = null, width = 1, height = 1, depth = 1) {
                        super(null);
                        this.isData3DTexture = !0;
                        this.image = {
                            data,
                            width,
                            height,
                            depth
                        };
                        this.magFilter = NearestFilter;
                        this.minFilter = NearestFilter;
                        this.wrapR = ClampToEdgeWrapping;
                        this.generateMipmaps = !1;
                        this.flipY = !1;
                        this.unpackAlignment = 1
                    }
                }
                class WebGL3DRenderTarget extends WebGLRenderTarget {
                    constructor(width = 1, height = 1, depth = 1, options = {}) {
                        super(width, height, options);
                        this.isWebGL3DRenderTarget = !0;
                        this.depth = depth;
                        this.texture = new Data3DTexture(null, width, height, depth);
                        this.texture.isRenderTargetTexture = !0
                    }
                }
                class Quaternion {
                    constructor(x = 0, y = 0, z = 0, w = 1) {
                        this.isQuaternion = !0;
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._w = w
                    }
                    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
                        let x0 = src0[srcOffset0 + 0],
                            y0 = src0[srcOffset0 + 1],
                            z0 = src0[srcOffset0 + 2],
                            w0 = src0[srcOffset0 + 3];
                        const x1 = src1[srcOffset1 + 0],
                            y1 = src1[srcOffset1 + 1],
                            z1 = src1[srcOffset1 + 2],
                            w1 = src1[srcOffset1 + 3];
                        if (t === 0) {
                            dst[dstOffset + 0] = x0;
                            dst[dstOffset + 1] = y0;
                            dst[dstOffset + 2] = z0;
                            dst[dstOffset + 3] = w0;
                            return
                        }
                        if (t === 1) {
                            dst[dstOffset + 0] = x1;
                            dst[dstOffset + 1] = y1;
                            dst[dstOffset + 2] = z1;
                            dst[dstOffset + 3] = w1;
                            return
                        }
                        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
                            let s = 1 - t;
                            const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
                                dir = (cos >= 0 ? 1 : -1),
                                sqrSin = 1 - cos * cos;
                            if (sqrSin > Number.EPSILON) {
                                const sin = Math.sqrt(sqrSin),
                                    len = Math.atan2(sin, cos * dir);
                                s = Math.sin(s * len) / sin;
                                t = Math.sin(t * len) / sin
                            }
                            const tDir = t * dir;
                            x0 = x0 * s + x1 * tDir;
                            y0 = y0 * s + y1 * tDir;
                            z0 = z0 * s + z1 * tDir;
                            w0 = w0 * s + w1 * tDir;
                            if (s === 1 - t) {
                                const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
                                x0 *= f;
                                y0 *= f;
                                z0 *= f;
                                w0 *= f
                            }
                        }
                        dst[dstOffset] = x0;
                        dst[dstOffset + 1] = y0;
                        dst[dstOffset + 2] = z0;
                        dst[dstOffset + 3] = w0
                    }
                    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
                        const x0 = src0[srcOffset0];
                        const y0 = src0[srcOffset0 + 1];
                        const z0 = src0[srcOffset0 + 2];
                        const w0 = src0[srcOffset0 + 3];
                        const x1 = src1[srcOffset1];
                        const y1 = src1[srcOffset1 + 1];
                        const z1 = src1[srcOffset1 + 2];
                        const w1 = src1[srcOffset1 + 3];
                        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
                        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
                        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
                        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
                        return dst
                    }
                    get x() {
                        return this._x
                    }
                    set x(value) {
                        this._x = value;
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(value) {
                        this._y = value;
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(value) {
                        this._z = value;
                        this._onChangeCallback()
                    }
                    get w() {
                        return this._w
                    }
                    set w(value) {
                        this._w = value;
                        this._onChangeCallback()
                    }
                    set(x, y, z, w) {
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._w = w;
                        this._onChangeCallback();
                        return this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._w)
                    }
                    copy(quaternion) {
                        this._x = quaternion.x;
                        this._y = quaternion.y;
                        this._z = quaternion.z;
                        this._w = quaternion.w;
                        this._onChangeCallback();
                        return this
                    }
                    setFromEuler(euler, update = !0) {
                        const x = euler._x,
                            y = euler._y,
                            z = euler._z,
                            order = euler._order;
                        const cos = Math.cos;
                        const sin = Math.sin;
                        const c1 = cos(x / 2);
                        const c2 = cos(y / 2);
                        const c3 = cos(z / 2);
                        const s1 = sin(x / 2);
                        const s2 = sin(y / 2);
                        const s3 = sin(z / 2);
                        switch (order) {
                            case 'XYZ':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'YXZ':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            case 'ZXY':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'ZYX':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            case 'YZX':
                                this._x = s1 * c2 * c3 + c1 * s2 * s3;
                                this._y = c1 * s2 * c3 + s1 * c2 * s3;
                                this._z = c1 * c2 * s3 - s1 * s2 * c3;
                                this._w = c1 * c2 * c3 - s1 * s2 * s3;
                                break;
                            case 'XZY':
                                this._x = s1 * c2 * c3 - c1 * s2 * s3;
                                this._y = c1 * s2 * c3 - s1 * c2 * s3;
                                this._z = c1 * c2 * s3 + s1 * s2 * c3;
                                this._w = c1 * c2 * c3 + s1 * s2 * s3;
                                break;
                            default:
                                console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order)
                        }
                        if (update === !0) this._onChangeCallback();
                        return this
                    }
                    setFromAxisAngle(axis, angle) {
                        const halfAngle = angle / 2,
                            s = Math.sin(halfAngle);
                        this._x = axis.x * s;
                        this._y = axis.y * s;
                        this._z = axis.z * s;
                        this._w = Math.cos(halfAngle);
                        this._onChangeCallback();
                        return this
                    }
                    setFromRotationMatrix(m) {
                        const te = m.elements,
                            m11 = te[0],
                            m12 = te[4],
                            m13 = te[8],
                            m21 = te[1],
                            m22 = te[5],
                            m23 = te[9],
                            m31 = te[2],
                            m32 = te[6],
                            m33 = te[10],
                            trace = m11 + m22 + m33;
                        if (trace > 0) {
                            const s = 0.5 / Math.sqrt(trace + 1.0);
                            this._w = 0.25 / s;
                            this._x = (m32 - m23) * s;
                            this._y = (m13 - m31) * s;
                            this._z = (m21 - m12) * s
                        } else if (m11 > m22 && m11 > m33) {
                            const s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                            this._w = (m32 - m23) / s;
                            this._x = 0.25 * s;
                            this._y = (m12 + m21) / s;
                            this._z = (m13 + m31) / s
                        } else if (m22 > m33) {
                            const s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                            this._w = (m13 - m31) / s;
                            this._x = (m12 + m21) / s;
                            this._y = 0.25 * s;
                            this._z = (m23 + m32) / s
                        } else {
                            const s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                            this._w = (m21 - m12) / s;
                            this._x = (m13 + m31) / s;
                            this._y = (m23 + m32) / s;
                            this._z = 0.25 * s
                        }
                        this._onChangeCallback();
                        return this
                    }
                    setFromUnitVectors(vFrom, vTo) {
                        let r = vFrom.dot(vTo) + 1;
                        if (r < Number.EPSILON) {
                            r = 0;
                            if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
                                this._x = -vFrom.y;
                                this._y = vFrom.x;
                                this._z = 0;
                                this._w = r
                            } else {
                                this._x = 0;
                                this._y = -vFrom.z;
                                this._z = vFrom.y;
                                this._w = r
                            }
                        } else {
                            this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
                            this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
                            this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
                            this._w = r
                        }
                        return this.normalize()
                    }
                    angleTo(q) {
                        return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)))
                    }
                    rotateTowards(q, step) {
                        const angle = this.angleTo(q);
                        if (angle === 0) return this;
                        const t = Math.min(1, step / angle);
                        this.slerp(q, t);
                        return this
                    }
                    identity() {
                        return this.set(0, 0, 0, 1)
                    }
                    invert() {
                        return this.conjugate()
                    }
                    conjugate() {
                        this._x *= -1;
                        this._y *= -1;
                        this._z *= -1;
                        this._onChangeCallback();
                        return this
                    }
                    dot(v) {
                        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
                    }
                    lengthSq() {
                        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                    }
                    length() {
                        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                    }
                    normalize() {
                        let l = this.length();
                        if (l === 0) {
                            this._x = 0;
                            this._y = 0;
                            this._z = 0;
                            this._w = 1
                        } else {
                            l = 1 / l;
                            this._x = this._x * l;
                            this._y = this._y * l;
                            this._z = this._z * l;
                            this._w = this._w * l
                        }
                        this._onChangeCallback();
                        return this
                    }
                    multiply(q) {
                        return this.multiplyQuaternions(this, q)
                    }
                    premultiply(q) {
                        return this.multiplyQuaternions(q, this)
                    }
                    multiplyQuaternions(a, b) {
                        const qax = a._x,
                            qay = a._y,
                            qaz = a._z,
                            qaw = a._w;
                        const qbx = b._x,
                            qby = b._y,
                            qbz = b._z,
                            qbw = b._w;
                        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
                        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
                        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
                        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
                        this._onChangeCallback();
                        return this
                    }
                    slerp(qb, t) {
                        if (t === 0) return this;
                        if (t === 1) return this.copy(qb);
                        const x = this._x,
                            y = this._y,
                            z = this._z,
                            w = this._w;
                        let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
                        if (cosHalfTheta < 0) {
                            this._w = -qb._w;
                            this._x = -qb._x;
                            this._y = -qb._y;
                            this._z = -qb._z;
                            cosHalfTheta = -cosHalfTheta
                        } else {
                            this.copy(qb)
                        }
                        if (cosHalfTheta >= 1.0) {
                            this._w = w;
                            this._x = x;
                            this._y = y;
                            this._z = z;
                            return this
                        }
                        const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
                        if (sqrSinHalfTheta <= Number.EPSILON) {
                            const s = 1 - t;
                            this._w = s * w + t * this._w;
                            this._x = s * x + t * this._x;
                            this._y = s * y + t * this._y;
                            this._z = s * z + t * this._z;
                            this.normalize();
                            return this
                        }
                        const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
                        const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
                        const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
                            ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
                        this._w = (w * ratioA + this._w * ratioB);
                        this._x = (x * ratioA + this._x * ratioB);
                        this._y = (y * ratioA + this._y * ratioB);
                        this._z = (z * ratioA + this._z * ratioB);
                        this._onChangeCallback();
                        return this
                    }
                    slerpQuaternions(qa, qb, t) {
                        return this.copy(qa).slerp(qb, t)
                    }
                    random() {
                        const theta1 = 2 * Math.PI * Math.random();
                        const theta2 = 2 * Math.PI * Math.random();
                        const x0 = Math.random();
                        const r1 = Math.sqrt(1 - x0);
                        const r2 = Math.sqrt(x0);
                        return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2), )
                    }
                    equals(quaternion) {
                        return (quaternion._x === this._x) && (quaternion._y === this._y) && (quaternion._z === this._z) && (quaternion._w === this._w)
                    }
                    fromArray(array, offset = 0) {
                        this._x = array[offset];
                        this._y = array[offset + 1];
                        this._z = array[offset + 2];
                        this._w = array[offset + 3];
                        this._onChangeCallback();
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this._x;
                        array[offset + 1] = this._y;
                        array[offset + 2] = this._z;
                        array[offset + 3] = this._w;
                        return array
                    }
                    fromBufferAttribute(attribute, index) {
                        this._x = attribute.getX(index);
                        this._y = attribute.getY(index);
                        this._z = attribute.getZ(index);
                        this._w = attribute.getW(index);
                        this._onChangeCallback();
                        return this
                    }
                    toJSON() {
                        return this.toArray()
                    }
                    _onChange(callback) {
                        this._onChangeCallback = callback;
                        return this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x;
                        yield this._y;
                        yield this._z;
                        yield this._w
                    }
                }
                class Vector3 {
                    constructor(x = 0, y = 0, z = 0) {
                        Vector3.prototype.isVector3 = !0;
                        this.x = x;
                        this.y = y;
                        this.z = z
                    }
                    set(x, y, z) {
                        if (z === undefined) z = this.z;
                        this.x = x;
                        this.y = y;
                        this.z = z;
                        return this
                    }
                    setScalar(scalar) {
                        this.x = scalar;
                        this.y = scalar;
                        this.z = scalar;
                        return this
                    }
                    setX(x) {
                        this.x = x;
                        return this
                    }
                    setY(y) {
                        this.y = y;
                        return this
                    }
                    setZ(z) {
                        this.z = z;
                        return this
                    }
                    setComponent(index, value) {
                        switch (index) {
                            case 0:
                                this.x = value;
                                break;
                            case 1:
                                this.y = value;
                                break;
                            case 2:
                                this.z = value;
                                break;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                        return this
                    }
                    getComponent(index) {
                        switch (index) {
                            case 0:
                                return this.x;
                            case 1:
                                return this.y;
                            case 2:
                                return this.z;
                            default:
                                throw new Error('index is out of range: ' + index)
                        }
                    }
                    clone() {
                        return new this.constructor(this.x, this.y, this.z)
                    }
                    copy(v) {
                        this.x = v.x;
                        this.y = v.y;
                        this.z = v.z;
                        return this
                    }
                    add(v) {
                        this.x += v.x;
                        this.y += v.y;
                        this.z += v.z;
                        return this
                    }
                    addScalar(s) {
                        this.x += s;
                        this.y += s;
                        this.z += s;
                        return this
                    }
                    addVectors(a, b) {
                        this.x = a.x + b.x;
                        this.y = a.y + b.y;
                        this.z = a.z + b.z;
                        return this
                    }
                    addScaledVector(v, s) {
                        this.x += v.x * s;
                        this.y += v.y * s;
                        this.z += v.z * s;
                        return this
                    }
                    sub(v) {
                        this.x -= v.x;
                        this.y -= v.y;
                        this.z -= v.z;
                        return this
                    }
                    subScalar(s) {
                        this.x -= s;
                        this.y -= s;
                        this.z -= s;
                        return this
                    }
                    subVectors(a, b) {
                        this.x = a.x - b.x;
                        this.y = a.y - b.y;
                        this.z = a.z - b.z;
                        return this
                    }
                    multiply(v) {
                        this.x *= v.x;
                        this.y *= v.y;
                        this.z *= v.z;
                        return this
                    }
                    multiplyScalar(scalar) {
                        this.x *= scalar;
                        this.y *= scalar;
                        this.z *= scalar;
                        return this
                    }
                    multiplyVectors(a, b) {
                        this.x = a.x * b.x;
                        this.y = a.y * b.y;
                        this.z = a.z * b.z;
                        return this
                    }
                    applyEuler(euler) {
                        return this.applyQuaternion(_quaternion$4.setFromEuler(euler))
                    }
                    applyAxisAngle(axis, angle) {
                        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle))
                    }
                    applyMatrix3(m) {
                        const x = this.x,
                            y = this.y,
                            z = this.z;
                        const e = m.elements;
                        this.x = e[0] * x + e[3] * y + e[6] * z;
                        this.y = e[1] * x + e[4] * y + e[7] * z;
                        this.z = e[2] * x + e[5] * y + e[8] * z;
                        return this
                    }
                    applyNormalMatrix(m) {
                        return this.applyMatrix3(m).normalize()
                    }
                    applyMatrix4(m) {
                        const x = this.x,
                            y = this.y,
                            z = this.z;
                        const e = m.elements;
                        const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
                        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
                        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
                        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
                        return this
                    }
                    applyQuaternion(q) {
                        const vx = this.x,
                            vy = this.y,
                            vz = this.z;
                        const qx = q.x,
                            qy = q.y,
                            qz = q.z,
                            qw = q.w;
                        const tx = 2 * (qy * vz - qz * vy);
                        const ty = 2 * (qz * vx - qx * vz);
                        const tz = 2 * (qx * vy - qy * vx);
                        this.x = vx + qw * tx + qy * tz - qz * ty;
                        this.y = vy + qw * ty + qz * tx - qx * tz;
                        this.z = vz + qw * tz + qx * ty - qy * tx;
                        return this
                    }
                    project(camera) {
                        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)
                    }
                    unproject(camera) {
                        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)
                    }
                    transformDirection(m) {
                        const x = this.x,
                            y = this.y,
                            z = this.z;
                        const e = m.elements;
                        this.x = e[0] * x + e[4] * y + e[8] * z;
                        this.y = e[1] * x + e[5] * y + e[9] * z;
                        this.z = e[2] * x + e[6] * y + e[10] * z;
                        return this.normalize()
                    }
                    divide(v) {
                        this.x /= v.x;
                        this.y /= v.y;
                        this.z /= v.z;
                        return this
                    }
                    divideScalar(scalar) {
                        return this.multiplyScalar(1 / scalar)
                    }
                    min(v) {
                        this.x = Math.min(this.x, v.x);
                        this.y = Math.min(this.y, v.y);
                        this.z = Math.min(this.z, v.z);
                        return this
                    }
                    max(v) {
                        this.x = Math.max(this.x, v.x);
                        this.y = Math.max(this.y, v.y);
                        this.z = Math.max(this.z, v.z);
                        return this
                    }
                    clamp(min, max) {
                        this.x = Math.max(min.x, Math.min(max.x, this.x));
                        this.y = Math.max(min.y, Math.min(max.y, this.y));
                        this.z = Math.max(min.z, Math.min(max.z, this.z));
                        return this
                    }
                    clampScalar(minVal, maxVal) {
                        this.x = Math.max(minVal, Math.min(maxVal, this.x));
                        this.y = Math.max(minVal, Math.min(maxVal, this.y));
                        this.z = Math.max(minVal, Math.min(maxVal, this.z));
                        return this
                    }
                    clampLength(min, max) {
                        const length = this.length();
                        return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)))
                    }
                    floor() {
                        this.x = Math.floor(this.x);
                        this.y = Math.floor(this.y);
                        this.z = Math.floor(this.z);
                        return this
                    }
                    ceil() {
                        this.x = Math.ceil(this.x);
                        this.y = Math.ceil(this.y);
                        this.z = Math.ceil(this.z);
                        return this
                    }
                    round() {
                        this.x = Math.round(this.x);
                        this.y = Math.round(this.y);
                        this.z = Math.round(this.z);
                        return this
                    }
                    roundToZero() {
                        this.x = Math.trunc(this.x);
                        this.y = Math.trunc(this.y);
                        this.z = Math.trunc(this.z);
                        return this
                    }
                    negate() {
                        this.x = -this.x;
                        this.y = -this.y;
                        this.z = -this.z;
                        return this
                    }
                    dot(v) {
                        return this.x * v.x + this.y * v.y + this.z * v.z
                    }
                    lengthSq() {
                        return this.x * this.x + this.y * this.y + this.z * this.z
                    }
                    length() {
                        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                    }
                    manhattanLength() {
                        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                    }
                    normalize() {
                        return this.divideScalar(this.length() || 1)
                    }
                    setLength(length) {
                        return this.normalize().multiplyScalar(length)
                    }
                    lerp(v, alpha) {
                        this.x += (v.x - this.x) * alpha;
                        this.y += (v.y - this.y) * alpha;
                        this.z += (v.z - this.z) * alpha;
                        return this
                    }
                    lerpVectors(v1, v2, alpha) {
                        this.x = v1.x + (v2.x - v1.x) * alpha;
                        this.y = v1.y + (v2.y - v1.y) * alpha;
                        this.z = v1.z + (v2.z - v1.z) * alpha;
                        return this
                    }
                    cross(v) {
                        return this.crossVectors(this, v)
                    }
                    crossVectors(a, b) {
                        const ax = a.x,
                            ay = a.y,
                            az = a.z;
                        const bx = b.x,
                            by = b.y,
                            bz = b.z;
                        this.x = ay * bz - az * by;
                        this.y = az * bx - ax * bz;
                        this.z = ax * by - ay * bx;
                        return this
                    }
                    projectOnVector(v) {
                        const denominator = v.lengthSq();
                        if (denominator === 0) return this.set(0, 0, 0);
                        const scalar = v.dot(this) / denominator;
                        return this.copy(v).multiplyScalar(scalar)
                    }
                    projectOnPlane(planeNormal) {
                        _vector$c.copy(this).projectOnVector(planeNormal);
                        return this.sub(_vector$c)
                    }
                    reflect(normal) {
                        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)))
                    }
                    angleTo(v) {
                        const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
                        if (denominator === 0) return Math.PI / 2;
                        const theta = this.dot(v) / denominator;
                        return Math.acos(clamp(theta, -1, 1))
                    }
                    distanceTo(v) {
                        return Math.sqrt(this.distanceToSquared(v))
                    }
                    distanceToSquared(v) {
                        const dx = this.x - v.x,
                            dy = this.y - v.y,
                            dz = this.z - v.z;
                        return dx * dx + dy * dy + dz * dz
                    }
                    manhattanDistanceTo(v) {
                        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
                    }
                    setFromSpherical(s) {
                        return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
                    }
                    setFromSphericalCoords(radius, phi, theta) {
                        const sinPhiRadius = Math.sin(phi) * radius;
                        this.x = sinPhiRadius * Math.sin(theta);
                        this.y = Math.cos(phi) * radius;
                        this.z = sinPhiRadius * Math.cos(theta);
                        return this
                    }
                    setFromCylindrical(c) {
                        return this.setFromCylindricalCoords(c.radius, c.theta, c.y)
                    }
                    setFromCylindricalCoords(radius, theta, y) {
                        this.x = radius * Math.sin(theta);
                        this.y = y;
                        this.z = radius * Math.cos(theta);
                        return this
                    }
                    setFromMatrixPosition(m) {
                        const e = m.elements;
                        this.x = e[12];
                        this.y = e[13];
                        this.z = e[14];
                        return this
                    }
                    setFromMatrixScale(m) {
                        const sx = this.setFromMatrixColumn(m, 0).length();
                        const sy = this.setFromMatrixColumn(m, 1).length();
                        const sz = this.setFromMatrixColumn(m, 2).length();
                        this.x = sx;
                        this.y = sy;
                        this.z = sz;
                        return this
                    }
                    setFromMatrixColumn(m, index) {
                        return this.fromArray(m.elements, index * 4)
                    }
                    setFromMatrix3Column(m, index) {
                        return this.fromArray(m.elements, index * 3)
                    }
                    setFromEuler(e) {
                        this.x = e._x;
                        this.y = e._y;
                        this.z = e._z;
                        return this
                    }
                    setFromColor(c) {
                        this.x = c.r;
                        this.y = c.g;
                        this.z = c.b;
                        return this
                    }
                    equals(v) {
                        return ((v.x === this.x) && (v.y === this.y) && (v.z === this.z))
                    }
                    fromArray(array, offset = 0) {
                        this.x = array[offset];
                        this.y = array[offset + 1];
                        this.z = array[offset + 2];
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this.x;
                        array[offset + 1] = this.y;
                        array[offset + 2] = this.z;
                        return array
                    }
                    fromBufferAttribute(attribute, index) {
                        this.x = attribute.getX(index);
                        this.y = attribute.getY(index);
                        this.z = attribute.getZ(index);
                        return this
                    }
                    random() {
                        this.x = Math.random();
                        this.y = Math.random();
                        this.z = Math.random();
                        return this
                    }
                    randomDirection() {
                        const theta = Math.random() * Math.PI * 2;
                        const u = Math.random() * 2 - 1;
                        const c = Math.sqrt(1 - u * u);
                        this.x = c * Math.cos(theta);
                        this.y = u;
                        this.z = c * Math.sin(theta);
                        return this
                    }*[Symbol.iterator]() {
                        yield this.x;
                        yield this.y;
                        yield this.z
                    }
                }
                const _vector$c = new Vector3();
                const _quaternion$4 = new Quaternion();
                class Box3 {
                    constructor(min = new Vector3(+Infinity, +Infinity, +Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
                        this.isBox3 = !0;
                        this.min = min;
                        this.max = max
                    }
                    set(min, max) {
                        this.min.copy(min);
                        this.max.copy(max);
                        return this
                    }
                    setFromArray(array) {
                        this.makeEmpty();
                        for (let i = 0, il = array.length; i < il; i += 3) {
                            this.expandByPoint(_vector$b.fromArray(array, i))
                        }
                        return this
                    }
                    setFromBufferAttribute(attribute) {
                        this.makeEmpty();
                        for (let i = 0, il = attribute.count; i < il; i++) {
                            this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i))
                        }
                        return this
                    }
                    setFromPoints(points) {
                        this.makeEmpty();
                        for (let i = 0, il = points.length; i < il; i++) {
                            this.expandByPoint(points[i])
                        }
                        return this
                    }
                    setFromCenterAndSize(center, size) {
                        const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this
                    }
                    setFromObject(object, precise = !1) {
                        this.makeEmpty();
                        return this.expandByObject(object, precise)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(box) {
                        this.min.copy(box.min);
                        this.max.copy(box.max);
                        return this
                    }
                    makeEmpty() {
                        this.min.x = this.min.y = this.min.z = +Infinity;
                        this.max.x = this.max.y = this.max.z = -Infinity;
                        return this
                    }
                    isEmpty() {
                        return (this.max.x < this.min.x) || (this.max.y < this.min.y) || (this.max.z < this.min.z)
                    }
                    getCenter(target) {
                        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5)
                    }
                    getSize(target) {
                        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min)
                    }
                    expandByPoint(point) {
                        this.min.min(point);
                        this.max.max(point);
                        return this
                    }
                    expandByVector(vector) {
                        this.min.sub(vector);
                        this.max.add(vector);
                        return this
                    }
                    expandByScalar(scalar) {
                        this.min.addScalar(-scalar);
                        this.max.addScalar(scalar);
                        return this
                    }
                    expandByObject(object, precise = !1) {
                        object.updateWorldMatrix(!1, !1);
                        const geometry = object.geometry;
                        if (geometry !== undefined) {
                            const positionAttribute = geometry.getAttribute('position');
                            if (precise === !0 && positionAttribute !== undefined && object.isInstancedMesh !== !0) {
                                for (let i = 0, l = positionAttribute.count; i < l; i++) {
                                    if (object.isMesh === !0) {
                                        object.getVertexPosition(i, _vector$b)
                                    } else {
                                        _vector$b.fromBufferAttribute(positionAttribute, i)
                                    }
                                    _vector$b.applyMatrix4(object.matrixWorld);
                                    this.expandByPoint(_vector$b)
                                }
                            } else {
                                if (object.boundingBox !== undefined) {
                                    if (object.boundingBox === null) {
                                        object.computeBoundingBox()
                                    }
                                    _box$4.copy(object.boundingBox)
                                } else {
                                    if (geometry.boundingBox === null) {
                                        geometry.computeBoundingBox()
                                    }
                                    _box$4.copy(geometry.boundingBox)
                                }
                                _box$4.applyMatrix4(object.matrixWorld);
                                this.union(_box$4)
                            }
                        }
                        const children = object.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            this.expandByObject(children[i], precise)
                        }
                        return this
                    }
                    containsPoint(point) {
                        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z
                    }
                    containsBox(box) {
                        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z
                    }
                    getParameter(point, target) {
                        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z))
                    }
                    intersectsBox(box) {
                        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z
                    }
                    intersectsSphere(sphere) {
                        this.clampPoint(sphere.center, _vector$b);
                        return _vector$b.distanceToSquared(sphere.center) <= (sphere.radius * sphere.radius)
                    }
                    intersectsPlane(plane) {
                        let min, max;
                        if (plane.normal.x > 0) {
                            min = plane.normal.x * this.min.x;
                            max = plane.normal.x * this.max.x
                        } else {
                            min = plane.normal.x * this.max.x;
                            max = plane.normal.x * this.min.x
                        }
                        if (plane.normal.y > 0) {
                            min += plane.normal.y * this.min.y;
                            max += plane.normal.y * this.max.y
                        } else {
                            min += plane.normal.y * this.max.y;
                            max += plane.normal.y * this.min.y
                        }
                        if (plane.normal.z > 0) {
                            min += plane.normal.z * this.min.z;
                            max += plane.normal.z * this.max.z
                        } else {
                            min += plane.normal.z * this.max.z;
                            max += plane.normal.z * this.min.z
                        }
                        return (min <= -plane.constant && max >= -plane.constant)
                    }
                    intersectsTriangle(triangle) {
                        if (this.isEmpty()) {
                            return !1
                        }
                        this.getCenter(_center);
                        _extents.subVectors(this.max, _center);
                        _v0$3.subVectors(triangle.a, _center);
                        _v1$7.subVectors(triangle.b, _center);
                        _v2$4.subVectors(triangle.c, _center);
                        _f0.subVectors(_v1$7, _v0$3);
                        _f1.subVectors(_v2$4, _v1$7);
                        _f2.subVectors(_v0$3, _v2$4);
                        let axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
                        if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
                            return !1
                        }
                        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
                        if (!satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)) {
                            return !1
                        }
                        _triangleNormal.crossVectors(_f0, _f1);
                        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
                        return satForAxes(axes, _v0$3, _v1$7, _v2$4, _extents)
                    }
                    clampPoint(point, target) {
                        return target.copy(point).clamp(this.min, this.max)
                    }
                    distanceToPoint(point) {
                        return this.clampPoint(point, _vector$b).distanceTo(point)
                    }
                    getBoundingSphere(target) {
                        if (this.isEmpty()) {
                            target.makeEmpty()
                        } else {
                            this.getCenter(target.center);
                            target.radius = this.getSize(_vector$b).length() * 0.5
                        }
                        return target
                    }
                    intersect(box) {
                        this.min.max(box.min);
                        this.max.min(box.max);
                        if (this.isEmpty()) this.makeEmpty();
                        return this
                    }
                    union(box) {
                        this.min.min(box.min);
                        this.max.max(box.max);
                        return this
                    }
                    applyMatrix4(matrix) {
                        if (this.isEmpty()) return this;
                        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
                        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
                        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
                        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
                        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
                        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
                        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
                        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
                        this.setFromPoints(_points);
                        return this
                    }
                    translate(offset) {
                        this.min.add(offset);
                        this.max.add(offset);
                        return this
                    }
                    equals(box) {
                        return box.min.equals(this.min) && box.max.equals(this.max)
                    }
                }
                const _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
                const _vector$b = new Vector3();
                const _box$4 = new Box3();
                const _v0$3 = new Vector3();
                const _v1$7 = new Vector3();
                const _v2$4 = new Vector3();
                const _f0 = new Vector3();
                const _f1 = new Vector3();
                const _f2 = new Vector3();
                const _center = new Vector3();
                const _extents = new Vector3();
                const _triangleNormal = new Vector3();
                const _testAxis = new Vector3();

                function satForAxes(axes, v0, v1, v2, extents) {
                    for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
                        _testAxis.fromArray(axes, i);
                        const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
                        const p0 = v0.dot(_testAxis);
                        const p1 = v1.dot(_testAxis);
                        const p2 = v2.dot(_testAxis);
                        if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                            return !1
                        }
                    }
                    return !0
                }
                const _box$3 = new Box3();
                const _v1$6 = new Vector3();
                const _v2$3 = new Vector3();
                class Sphere {
                    constructor(center = new Vector3(), radius = -1) {
                        this.isSphere = !0;
                        this.center = center;
                        this.radius = radius
                    }
                    set(center, radius) {
                        this.center.copy(center);
                        this.radius = radius;
                        return this
                    }
                    setFromPoints(points, optionalCenter) {
                        const center = this.center;
                        if (optionalCenter !== undefined) {
                            center.copy(optionalCenter)
                        } else {
                            _box$3.setFromPoints(points).getCenter(center)
                        }
                        let maxRadiusSq = 0;
                        for (let i = 0, il = points.length; i < il; i++) {
                            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]))
                        }
                        this.radius = Math.sqrt(maxRadiusSq);
                        return this
                    }
                    copy(sphere) {
                        this.center.copy(sphere.center);
                        this.radius = sphere.radius;
                        return this
                    }
                    isEmpty() {
                        return (this.radius < 0)
                    }
                    makeEmpty() {
                        this.center.set(0, 0, 0);
                        this.radius = -1;
                        return this
                    }
                    containsPoint(point) {
                        return (point.distanceToSquared(this.center) <= (this.radius * this.radius))
                    }
                    distanceToPoint(point) {
                        return (point.distanceTo(this.center) - this.radius)
                    }
                    intersectsSphere(sphere) {
                        const radiusSum = this.radius + sphere.radius;
                        return sphere.center.distanceToSquared(this.center) <= (radiusSum * radiusSum)
                    }
                    intersectsBox(box) {
                        return box.intersectsSphere(this)
                    }
                    intersectsPlane(plane) {
                        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius
                    }
                    clampPoint(point, target) {
                        const deltaLengthSq = this.center.distanceToSquared(point);
                        target.copy(point);
                        if (deltaLengthSq > (this.radius * this.radius)) {
                            target.sub(this.center).normalize();
                            target.multiplyScalar(this.radius).add(this.center)
                        }
                        return target
                    }
                    getBoundingBox(target) {
                        if (this.isEmpty()) {
                            target.makeEmpty();
                            return target
                        }
                        target.set(this.center, this.center);
                        target.expandByScalar(this.radius);
                        return target
                    }
                    applyMatrix4(matrix) {
                        this.center.applyMatrix4(matrix);
                        this.radius = this.radius * matrix.getMaxScaleOnAxis();
                        return this
                    }
                    translate(offset) {
                        this.center.add(offset);
                        return this
                    }
                    expandByPoint(point) {
                        if (this.isEmpty()) {
                            this.center.copy(point);
                            this.radius = 0;
                            return this
                        }
                        _v1$6.subVectors(point, this.center);
                        const lengthSq = _v1$6.lengthSq();
                        if (lengthSq > (this.radius * this.radius)) {
                            const length = Math.sqrt(lengthSq);
                            const delta = (length - this.radius) * 0.5;
                            this.center.addScaledVector(_v1$6, delta / length);
                            this.radius += delta
                        }
                        return this
                    }
                    union(sphere) {
                        if (sphere.isEmpty()) {
                            return this
                        }
                        if (this.isEmpty()) {
                            this.copy(sphere);
                            return this
                        }
                        if (this.center.equals(sphere.center) === !0) {
                            this.radius = Math.max(this.radius, sphere.radius)
                        } else {
                            _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
                            this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
                            this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3))
                        }
                        return this
                    }
                    equals(sphere) {
                        return sphere.center.equals(this.center) && (sphere.radius === this.radius)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                const _vector$a = new Vector3();
                const _segCenter = new Vector3();
                const _segDir = new Vector3();
                const _diff = new Vector3();
                const _edge1 = new Vector3();
                const _edge2 = new Vector3();
                const _normal$1 = new Vector3();
                class Ray {
                    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
                        this.origin = origin;
                        this.direction = direction
                    }
                    set(origin, direction) {
                        this.origin.copy(origin);
                        this.direction.copy(direction);
                        return this
                    }
                    copy(ray) {
                        this.origin.copy(ray.origin);
                        this.direction.copy(ray.direction);
                        return this
                    }
                    at(t, target) {
                        return target.copy(this.origin).addScaledVector(this.direction, t)
                    }
                    lookAt(v) {
                        this.direction.copy(v).sub(this.origin).normalize();
                        return this
                    }
                    recast(t) {
                        this.origin.copy(this.at(t, _vector$a));
                        return this
                    }
                    closestPointToPoint(point, target) {
                        target.subVectors(point, this.origin);
                        const directionDistance = target.dot(this.direction);
                        if (directionDistance < 0) {
                            return target.copy(this.origin)
                        }
                        return target.copy(this.origin).addScaledVector(this.direction, directionDistance)
                    }
                    distanceToPoint(point) {
                        return Math.sqrt(this.distanceSqToPoint(point))
                    }
                    distanceSqToPoint(point) {
                        const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
                        if (directionDistance < 0) {
                            return this.origin.distanceToSquared(point)
                        }
                        _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
                        return _vector$a.distanceToSquared(point)
                    }
                    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
                        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
                        _segDir.copy(v1).sub(v0).normalize();
                        _diff.copy(this.origin).sub(_segCenter);
                        const segExtent = v0.distanceTo(v1) * 0.5;
                        const a01 = -this.direction.dot(_segDir);
                        const b0 = _diff.dot(this.direction);
                        const b1 = -_diff.dot(_segDir);
                        const c = _diff.lengthSq();
                        const det = Math.abs(1 - a01 * a01);
                        let s0, s1, sqrDist, extDet;
                        if (det > 0) {
                            s0 = a01 * b1 - b0;
                            s1 = a01 * b0 - b1;
                            extDet = segExtent * det;
                            if (s0 >= 0) {
                                if (s1 >= -extDet) {
                                    if (s1 <= extDet) {
                                        const invDet = 1 / det;
                                        s0 *= invDet;
                                        s1 *= invDet;
                                        sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
                                    } else {
                                        s1 = segExtent;
                                        s0 = Math.max(0, -(a01 * s1 + b0));
                                        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                    }
                                } else {
                                    s1 = -segExtent;
                                    s0 = Math.max(0, -(a01 * s1 + b0));
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                }
                            } else {
                                if (s1 <= -extDet) {
                                    s0 = Math.max(0, -(-a01 * segExtent + b0));
                                    s1 = (s0 > 0) ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                } else if (s1 <= extDet) {
                                    s0 = 0;
                                    s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = s1 * (s1 + 2 * b1) + c
                                } else {
                                    s0 = Math.max(0, -(a01 * segExtent + b0));
                                    s1 = (s0 > 0) ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
                                    sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                                }
                            }
                        } else {
                            s1 = (a01 > 0) ? -segExtent : segExtent;
                            s0 = Math.max(0, -(a01 * s1 + b0));
                            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
                        }
                        if (optionalPointOnRay) {
                            optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0)
                        }
                        if (optionalPointOnSegment) {
                            optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1)
                        }
                        return sqrDist
                    }
                    intersectSphere(sphere, target) {
                        _vector$a.subVectors(sphere.center, this.origin);
                        const tca = _vector$a.dot(this.direction);
                        const d2 = _vector$a.dot(_vector$a) - tca * tca;
                        const radius2 = sphere.radius * sphere.radius;
                        if (d2 > radius2) return null;
                        const thc = Math.sqrt(radius2 - d2);
                        const t0 = tca - thc;
                        const t1 = tca + thc;
                        if (t1 < 0) return null;
                        if (t0 < 0) return this.at(t1, target);
                        return this.at(t0, target)
                    }
                    intersectsSphere(sphere) {
                        return this.distanceSqToPoint(sphere.center) <= (sphere.radius * sphere.radius)
                    }
                    distanceToPlane(plane) {
                        const denominator = plane.normal.dot(this.direction);
                        if (denominator === 0) {
                            if (plane.distanceToPoint(this.origin) === 0) {
                                return 0
                            }
                            return null
                        }
                        const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
                        return t >= 0 ? t : null
                    }
                    intersectPlane(plane, target) {
                        const t = this.distanceToPlane(plane);
                        if (t === null) {
                            return null
                        }
                        return this.at(t, target)
                    }
                    intersectsPlane(plane) {
                        const distToPoint = plane.distanceToPoint(this.origin);
                        if (distToPoint === 0) {
                            return !0
                        }
                        const denominator = plane.normal.dot(this.direction);
                        if (denominator * distToPoint < 0) {
                            return !0
                        }
                        return !1
                    }
                    intersectBox(box, target) {
                        let tmin, tmax, tymin, tymax, tzmin, tzmax;
                        const invdirx = 1 / this.direction.x,
                            invdiry = 1 / this.direction.y,
                            invdirz = 1 / this.direction.z;
                        const origin = this.origin;
                        if (invdirx >= 0) {
                            tmin = (box.min.x - origin.x) * invdirx;
                            tmax = (box.max.x - origin.x) * invdirx
                        } else {
                            tmin = (box.max.x - origin.x) * invdirx;
                            tmax = (box.min.x - origin.x) * invdirx
                        }
                        if (invdiry >= 0) {
                            tymin = (box.min.y - origin.y) * invdiry;
                            tymax = (box.max.y - origin.y) * invdiry
                        } else {
                            tymin = (box.max.y - origin.y) * invdiry;
                            tymax = (box.min.y - origin.y) * invdiry
                        }
                        if ((tmin > tymax) || (tymin > tmax)) return null;
                        if (tymin > tmin || isNaN(tmin)) tmin = tymin;
                        if (tymax < tmax || isNaN(tmax)) tmax = tymax;
                        if (invdirz >= 0) {
                            tzmin = (box.min.z - origin.z) * invdirz;
                            tzmax = (box.max.z - origin.z) * invdirz
                        } else {
                            tzmin = (box.max.z - origin.z) * invdirz;
                            tzmax = (box.min.z - origin.z) * invdirz
                        }
                        if ((tmin > tzmax) || (tzmin > tmax)) return null;
                        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
                        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
                        if (tmax < 0) return null;
                        return this.at(tmin >= 0 ? tmin : tmax, target)
                    }
                    intersectsBox(box) {
                        return this.intersectBox(box, _vector$a) !== null
                    }
                    intersectTriangle(a, b, c, backfaceCulling, target) {
                        _edge1.subVectors(b, a);
                        _edge2.subVectors(c, a);
                        _normal$1.crossVectors(_edge1, _edge2);
                        let DdN = this.direction.dot(_normal$1);
                        let sign;
                        if (DdN > 0) {
                            if (backfaceCulling) return null;
                            sign = 1
                        } else if (DdN < 0) {
                            sign = -1;
                            DdN = -DdN
                        } else {
                            return null
                        }
                        _diff.subVectors(this.origin, a);
                        const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
                        if (DdQxE2 < 0) {
                            return null
                        }
                        const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
                        if (DdE1xQ < 0) {
                            return null
                        }
                        if (DdQxE2 + DdE1xQ > DdN) {
                            return null
                        }
                        const QdN = -sign * _diff.dot(_normal$1);
                        if (QdN < 0) {
                            return null
                        }
                        return this.at(QdN / DdN, target)
                    }
                    applyMatrix4(matrix4) {
                        this.origin.applyMatrix4(matrix4);
                        this.direction.transformDirection(matrix4);
                        return this
                    }
                    equals(ray) {
                        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                class Matrix4 {
                    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                        Matrix4.prototype.isMatrix4 = !0;
                        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
                        if (n11 !== undefined) {
                            this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44)
                        }
                    }
                    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
                        const te = this.elements;
                        te[0] = n11;
                        te[4] = n12;
                        te[8] = n13;
                        te[12] = n14;
                        te[1] = n21;
                        te[5] = n22;
                        te[9] = n23;
                        te[13] = n24;
                        te[2] = n31;
                        te[6] = n32;
                        te[10] = n33;
                        te[14] = n34;
                        te[3] = n41;
                        te[7] = n42;
                        te[11] = n43;
                        te[15] = n44;
                        return this
                    }
                    identity() {
                        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                        return this
                    }
                    clone() {
                        return new Matrix4().fromArray(this.elements)
                    }
                    copy(m) {
                        const te = this.elements;
                        const me = m.elements;
                        te[0] = me[0];
                        te[1] = me[1];
                        te[2] = me[2];
                        te[3] = me[3];
                        te[4] = me[4];
                        te[5] = me[5];
                        te[6] = me[6];
                        te[7] = me[7];
                        te[8] = me[8];
                        te[9] = me[9];
                        te[10] = me[10];
                        te[11] = me[11];
                        te[12] = me[12];
                        te[13] = me[13];
                        te[14] = me[14];
                        te[15] = me[15];
                        return this
                    }
                    copyPosition(m) {
                        const te = this.elements,
                            me = m.elements;
                        te[12] = me[12];
                        te[13] = me[13];
                        te[14] = me[14];
                        return this
                    }
                    setFromMatrix3(m) {
                        const me = m.elements;
                        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
                        return this
                    }
                    extractBasis(xAxis, yAxis, zAxis) {
                        xAxis.setFromMatrixColumn(this, 0);
                        yAxis.setFromMatrixColumn(this, 1);
                        zAxis.setFromMatrixColumn(this, 2);
                        return this
                    }
                    makeBasis(xAxis, yAxis, zAxis) {
                        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
                        return this
                    }
                    extractRotation(m) {
                        const te = this.elements;
                        const me = m.elements;
                        const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
                        const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
                        const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
                        te[0] = me[0] * scaleX;
                        te[1] = me[1] * scaleX;
                        te[2] = me[2] * scaleX;
                        te[3] = 0;
                        te[4] = me[4] * scaleY;
                        te[5] = me[5] * scaleY;
                        te[6] = me[6] * scaleY;
                        te[7] = 0;
                        te[8] = me[8] * scaleZ;
                        te[9] = me[9] * scaleZ;
                        te[10] = me[10] * scaleZ;
                        te[11] = 0;
                        te[12] = 0;
                        te[13] = 0;
                        te[14] = 0;
                        te[15] = 1;
                        return this
                    }
                    makeRotationFromEuler(euler) {
                        const te = this.elements;
                        const x = euler.x,
                            y = euler.y,
                            z = euler.z;
                        const a = Math.cos(x),
                            b = Math.sin(x);
                        const c = Math.cos(y),
                            d = Math.sin(y);
                        const e = Math.cos(z),
                            f = Math.sin(z);
                        if (euler.order === 'XYZ') {
                            const ae = a * e,
                                af = a * f,
                                be = b * e,
                                bf = b * f;
                            te[0] = c * e;
                            te[4] = -c * f;
                            te[8] = d;
                            te[1] = af + be * d;
                            te[5] = ae - bf * d;
                            te[9] = -b * c;
                            te[2] = bf - ae * d;
                            te[6] = be + af * d;
                            te[10] = a * c
                        } else if (euler.order === 'YXZ') {
                            const ce = c * e,
                                cf = c * f,
                                de = d * e,
                                df = d * f;
                            te[0] = ce + df * b;
                            te[4] = de * b - cf;
                            te[8] = a * d;
                            te[1] = a * f;
                            te[5] = a * e;
                            te[9] = -b;
                            te[2] = cf * b - de;
                            te[6] = df + ce * b;
                            te[10] = a * c
                        } else if (euler.order === 'ZXY') {
                            const ce = c * e,
                                cf = c * f,
                                de = d * e,
                                df = d * f;
                            te[0] = ce - df * b;
                            te[4] = -a * f;
                            te[8] = de + cf * b;
                            te[1] = cf + de * b;
                            te[5] = a * e;
                            te[9] = df - ce * b;
                            te[2] = -a * d;
                            te[6] = b;
                            te[10] = a * c
                        } else if (euler.order === 'ZYX') {
                            const ae = a * e,
                                af = a * f,
                                be = b * e,
                                bf = b * f;
                            te[0] = c * e;
                            te[4] = be * d - af;
                            te[8] = ae * d + bf;
                            te[1] = c * f;
                            te[5] = bf * d + ae;
                            te[9] = af * d - be;
                            te[2] = -d;
                            te[6] = b * c;
                            te[10] = a * c
                        } else if (euler.order === 'YZX') {
                            const ac = a * c,
                                ad = a * d,
                                bc = b * c,
                                bd = b * d;
                            te[0] = c * e;
                            te[4] = bd - ac * f;
                            te[8] = bc * f + ad;
                            te[1] = f;
                            te[5] = a * e;
                            te[9] = -b * e;
                            te[2] = -d * e;
                            te[6] = ad * f + bc;
                            te[10] = ac - bd * f
                        } else if (euler.order === 'XZY') {
                            const ac = a * c,
                                ad = a * d,
                                bc = b * c,
                                bd = b * d;
                            te[0] = c * e;
                            te[4] = -f;
                            te[8] = d * e;
                            te[1] = ac * f + bd;
                            te[5] = a * e;
                            te[9] = ad * f - bc;
                            te[2] = bc * f - ad;
                            te[6] = b * e;
                            te[10] = bd * f + ac
                        }
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = 0;
                        te[12] = 0;
                        te[13] = 0;
                        te[14] = 0;
                        te[15] = 1;
                        return this
                    }
                    makeRotationFromQuaternion(q) {
                        return this.compose(_zero, q, _one)
                    }
                    lookAt(eye, target, up) {
                        const te = this.elements;
                        _z.subVectors(eye, target);
                        if (_z.lengthSq() === 0) {
                            _z.z = 1
                        }
                        _z.normalize();
                        _x.crossVectors(up, _z);
                        if (_x.lengthSq() === 0) {
                            if (Math.abs(up.z) === 1) {
                                _z.x += 0.0001
                            } else {
                                _z.z += 0.0001
                            }
                            _z.normalize();
                            _x.crossVectors(up, _z)
                        }
                        _x.normalize();
                        _y.crossVectors(_z, _x);
                        te[0] = _x.x;
                        te[4] = _y.x;
                        te[8] = _z.x;
                        te[1] = _x.y;
                        te[5] = _y.y;
                        te[9] = _z.y;
                        te[2] = _x.z;
                        te[6] = _y.z;
                        te[10] = _z.z;
                        return this
                    }
                    multiply(m) {
                        return this.multiplyMatrices(this, m)
                    }
                    premultiply(m) {
                        return this.multiplyMatrices(m, this)
                    }
                    multiplyMatrices(a, b) {
                        const ae = a.elements;
                        const be = b.elements;
                        const te = this.elements;
                        const a11 = ae[0],
                            a12 = ae[4],
                            a13 = ae[8],
                            a14 = ae[12];
                        const a21 = ae[1],
                            a22 = ae[5],
                            a23 = ae[9],
                            a24 = ae[13];
                        const a31 = ae[2],
                            a32 = ae[6],
                            a33 = ae[10],
                            a34 = ae[14];
                        const a41 = ae[3],
                            a42 = ae[7],
                            a43 = ae[11],
                            a44 = ae[15];
                        const b11 = be[0],
                            b12 = be[4],
                            b13 = be[8],
                            b14 = be[12];
                        const b21 = be[1],
                            b22 = be[5],
                            b23 = be[9],
                            b24 = be[13];
                        const b31 = be[2],
                            b32 = be[6],
                            b33 = be[10],
                            b34 = be[14];
                        const b41 = be[3],
                            b42 = be[7],
                            b43 = be[11],
                            b44 = be[15];
                        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
                        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
                        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
                        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
                        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
                        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
                        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
                        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
                        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
                        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
                        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
                        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
                        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
                        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
                        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
                        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
                        return this
                    }
                    multiplyScalar(s) {
                        const te = this.elements;
                        te[0] *= s;
                        te[4] *= s;
                        te[8] *= s;
                        te[12] *= s;
                        te[1] *= s;
                        te[5] *= s;
                        te[9] *= s;
                        te[13] *= s;
                        te[2] *= s;
                        te[6] *= s;
                        te[10] *= s;
                        te[14] *= s;
                        te[3] *= s;
                        te[7] *= s;
                        te[11] *= s;
                        te[15] *= s;
                        return this
                    }
                    determinant() {
                        const te = this.elements;
                        const n11 = te[0],
                            n12 = te[4],
                            n13 = te[8],
                            n14 = te[12];
                        const n21 = te[1],
                            n22 = te[5],
                            n23 = te[9],
                            n24 = te[13];
                        const n31 = te[2],
                            n32 = te[6],
                            n33 = te[10],
                            n34 = te[14];
                        const n41 = te[3],
                            n42 = te[7],
                            n43 = te[11],
                            n44 = te[15];
                        return (n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31))
                    }
                    transpose() {
                        const te = this.elements;
                        let tmp;
                        tmp = te[1];
                        te[1] = te[4];
                        te[4] = tmp;
                        tmp = te[2];
                        te[2] = te[8];
                        te[8] = tmp;
                        tmp = te[6];
                        te[6] = te[9];
                        te[9] = tmp;
                        tmp = te[3];
                        te[3] = te[12];
                        te[12] = tmp;
                        tmp = te[7];
                        te[7] = te[13];
                        te[13] = tmp;
                        tmp = te[11];
                        te[11] = te[14];
                        te[14] = tmp;
                        return this
                    }
                    setPosition(x, y, z) {
                        const te = this.elements;
                        if (x.isVector3) {
                            te[12] = x.x;
                            te[13] = x.y;
                            te[14] = x.z
                        } else {
                            te[12] = x;
                            te[13] = y;
                            te[14] = z
                        }
                        return this
                    }
                    invert() {
                        const te = this.elements,
                            n11 = te[0],
                            n21 = te[1],
                            n31 = te[2],
                            n41 = te[3],
                            n12 = te[4],
                            n22 = te[5],
                            n32 = te[6],
                            n42 = te[7],
                            n13 = te[8],
                            n23 = te[9],
                            n33 = te[10],
                            n43 = te[11],
                            n14 = te[12],
                            n24 = te[13],
                            n34 = te[14],
                            n44 = te[15],
                            t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
                            t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
                            t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
                            t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
                        const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
                        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                        const detInv = 1 / det;
                        te[0] = t11 * detInv;
                        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
                        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
                        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
                        te[4] = t12 * detInv;
                        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
                        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
                        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
                        te[8] = t13 * detInv;
                        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
                        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
                        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
                        te[12] = t14 * detInv;
                        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
                        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
                        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
                        return this
                    }
                    scale(v) {
                        const te = this.elements;
                        const x = v.x,
                            y = v.y,
                            z = v.z;
                        te[0] *= x;
                        te[4] *= y;
                        te[8] *= z;
                        te[1] *= x;
                        te[5] *= y;
                        te[9] *= z;
                        te[2] *= x;
                        te[6] *= y;
                        te[10] *= z;
                        te[3] *= x;
                        te[7] *= y;
                        te[11] *= z;
                        return this
                    }
                    getMaxScaleOnAxis() {
                        const te = this.elements;
                        const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
                        const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
                        const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
                        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))
                    }
                    makeTranslation(x, y, z) {
                        if (x.isVector3) {
                            this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1)
                        } else {
                            this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1)
                        }
                        return this
                    }
                    makeRotationX(theta) {
                        const c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
                        return this
                    }
                    makeRotationY(theta) {
                        const c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
                        return this
                    }
                    makeRotationZ(theta) {
                        const c = Math.cos(theta),
                            s = Math.sin(theta);
                        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                        return this
                    }
                    makeRotationAxis(axis, angle) {
                        const c = Math.cos(angle);
                        const s = Math.sin(angle);
                        const t = 1 - c;
                        const x = axis.x,
                            y = axis.y,
                            z = axis.z;
                        const tx = t * x,
                            ty = t * y;
                        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
                        return this
                    }
                    makeScale(x, y, z) {
                        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
                        return this
                    }
                    makeShear(xy, xz, yx, yz, zx, zy) {
                        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
                        return this
                    }
                    compose(position, quaternion, scale) {
                        const te = this.elements;
                        const x = quaternion._x,
                            y = quaternion._y,
                            z = quaternion._z,
                            w = quaternion._w;
                        const x2 = x + x,
                            y2 = y + y,
                            z2 = z + z;
                        const xx = x * x2,
                            xy = x * y2,
                            xz = x * z2;
                        const yy = y * y2,
                            yz = y * z2,
                            zz = z * z2;
                        const wx = w * x2,
                            wy = w * y2,
                            wz = w * z2;
                        const sx = scale.x,
                            sy = scale.y,
                            sz = scale.z;
                        te[0] = (1 - (yy + zz)) * sx;
                        te[1] = (xy + wz) * sx;
                        te[2] = (xz - wy) * sx;
                        te[3] = 0;
                        te[4] = (xy - wz) * sy;
                        te[5] = (1 - (xx + zz)) * sy;
                        te[6] = (yz + wx) * sy;
                        te[7] = 0;
                        te[8] = (xz + wy) * sz;
                        te[9] = (yz - wx) * sz;
                        te[10] = (1 - (xx + yy)) * sz;
                        te[11] = 0;
                        te[12] = position.x;
                        te[13] = position.y;
                        te[14] = position.z;
                        te[15] = 1;
                        return this
                    }
                    decompose(position, quaternion, scale) {
                        const te = this.elements;
                        let sx = _v1$5.set(te[0], te[1], te[2]).length();
                        const sy = _v1$5.set(te[4], te[5], te[6]).length();
                        const sz = _v1$5.set(te[8], te[9], te[10]).length();
                        const det = this.determinant();
                        if (det < 0) sx = -sx;
                        position.x = te[12];
                        position.y = te[13];
                        position.z = te[14];
                        _m1$4.copy(this);
                        const invSX = 1 / sx;
                        const invSY = 1 / sy;
                        const invSZ = 1 / sz;
                        _m1$4.elements[0] *= invSX;
                        _m1$4.elements[1] *= invSX;
                        _m1$4.elements[2] *= invSX;
                        _m1$4.elements[4] *= invSY;
                        _m1$4.elements[5] *= invSY;
                        _m1$4.elements[6] *= invSY;
                        _m1$4.elements[8] *= invSZ;
                        _m1$4.elements[9] *= invSZ;
                        _m1$4.elements[10] *= invSZ;
                        quaternion.setFromRotationMatrix(_m1$4);
                        scale.x = sx;
                        scale.y = sy;
                        scale.z = sz;
                        return this
                    }
                    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
                        const te = this.elements;
                        const x = 2 * near / (right - left);
                        const y = 2 * near / (top - bottom);
                        const a = (right + left) / (right - left);
                        const b = (top + bottom) / (top - bottom);
                        let c, d;
                        if (coordinateSystem === WebGLCoordinateSystem) {
                            c = -(far + near) / (far - near);
                            d = (-2 * far * near) / (far - near)
                        } else if (coordinateSystem === WebGPUCoordinateSystem) {
                            c = -far / (far - near);
                            d = (-far * near) / (far - near)
                        } else {
                            throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem)
                        }
                        te[0] = x;
                        te[4] = 0;
                        te[8] = a;
                        te[12] = 0;
                        te[1] = 0;
                        te[5] = y;
                        te[9] = b;
                        te[13] = 0;
                        te[2] = 0;
                        te[6] = 0;
                        te[10] = c;
                        te[14] = d;
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = -1;
                        te[15] = 0;
                        return this
                    }
                    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
                        const te = this.elements;
                        const w = 1.0 / (right - left);
                        const h = 1.0 / (top - bottom);
                        const p = 1.0 / (far - near);
                        const x = (right + left) * w;
                        const y = (top + bottom) * h;
                        let z, zInv;
                        if (coordinateSystem === WebGLCoordinateSystem) {
                            z = (far + near) * p;
                            zInv = -2 * p
                        } else if (coordinateSystem === WebGPUCoordinateSystem) {
                            z = near * p;
                            zInv = -1 * p
                        } else {
                            throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem)
                        }
                        te[0] = 2 * w;
                        te[4] = 0;
                        te[8] = 0;
                        te[12] = -x;
                        te[1] = 0;
                        te[5] = 2 * h;
                        te[9] = 0;
                        te[13] = -y;
                        te[2] = 0;
                        te[6] = 0;
                        te[10] = zInv;
                        te[14] = -z;
                        te[3] = 0;
                        te[7] = 0;
                        te[11] = 0;
                        te[15] = 1;
                        return this
                    }
                    equals(matrix) {
                        const te = this.elements;
                        const me = matrix.elements;
                        for (let i = 0; i < 16; i++) {
                            if (te[i] !== me[i]) return !1
                        }
                        return !0
                    }
                    fromArray(array, offset = 0) {
                        for (let i = 0; i < 16; i++) {
                            this.elements[i] = array[i + offset]
                        }
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        const te = this.elements;
                        array[offset] = te[0];
                        array[offset + 1] = te[1];
                        array[offset + 2] = te[2];
                        array[offset + 3] = te[3];
                        array[offset + 4] = te[4];
                        array[offset + 5] = te[5];
                        array[offset + 6] = te[6];
                        array[offset + 7] = te[7];
                        array[offset + 8] = te[8];
                        array[offset + 9] = te[9];
                        array[offset + 10] = te[10];
                        array[offset + 11] = te[11];
                        array[offset + 12] = te[12];
                        array[offset + 13] = te[13];
                        array[offset + 14] = te[14];
                        array[offset + 15] = te[15];
                        return array
                    }
                }
                const _v1$5 = new Vector3();
                const _m1$4 = new Matrix4();
                const _zero = new Vector3(0, 0, 0);
                const _one = new Vector3(1, 1, 1);
                const _x = new Vector3();
                const _y = new Vector3();
                const _z = new Vector3();
                const _matrix$2 = new Matrix4();
                const _quaternion$3 = new Quaternion();
                class Euler {
                    constructor(x = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {
                        this.isEuler = !0;
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._order = order
                    }
                    get x() {
                        return this._x
                    }
                    set x(value) {
                        this._x = value;
                        this._onChangeCallback()
                    }
                    get y() {
                        return this._y
                    }
                    set y(value) {
                        this._y = value;
                        this._onChangeCallback()
                    }
                    get z() {
                        return this._z
                    }
                    set z(value) {
                        this._z = value;
                        this._onChangeCallback()
                    }
                    get order() {
                        return this._order
                    }
                    set order(value) {
                        this._order = value;
                        this._onChangeCallback()
                    }
                    set(x, y, z, order = this._order) {
                        this._x = x;
                        this._y = y;
                        this._z = z;
                        this._order = order;
                        this._onChangeCallback();
                        return this
                    }
                    clone() {
                        return new this.constructor(this._x, this._y, this._z, this._order)
                    }
                    copy(euler) {
                        this._x = euler._x;
                        this._y = euler._y;
                        this._z = euler._z;
                        this._order = euler._order;
                        this._onChangeCallback();
                        return this
                    }
                    setFromRotationMatrix(m, order = this._order, update = !0) {
                        const te = m.elements;
                        const m11 = te[0],
                            m12 = te[4],
                            m13 = te[8];
                        const m21 = te[1],
                            m22 = te[5],
                            m23 = te[9];
                        const m31 = te[2],
                            m32 = te[6],
                            m33 = te[10];
                        switch (order) {
                            case 'XYZ':
                                this._y = Math.asin(clamp(m13, -1, 1));
                                if (Math.abs(m13) < 0.9999999) {
                                    this._x = Math.atan2(-m23, m33);
                                    this._z = Math.atan2(-m12, m11)
                                } else {
                                    this._x = Math.atan2(m32, m22);
                                    this._z = 0
                                }
                                break;
                            case 'YXZ':
                                this._x = Math.asin(-clamp(m23, -1, 1));
                                if (Math.abs(m23) < 0.9999999) {
                                    this._y = Math.atan2(m13, m33);
                                    this._z = Math.atan2(m21, m22)
                                } else {
                                    this._y = Math.atan2(-m31, m11);
                                    this._z = 0
                                }
                                break;
                            case 'ZXY':
                                this._x = Math.asin(clamp(m32, -1, 1));
                                if (Math.abs(m32) < 0.9999999) {
                                    this._y = Math.atan2(-m31, m33);
                                    this._z = Math.atan2(-m12, m22)
                                } else {
                                    this._y = 0;
                                    this._z = Math.atan2(m21, m11)
                                }
                                break;
                            case 'ZYX':
                                this._y = Math.asin(-clamp(m31, -1, 1));
                                if (Math.abs(m31) < 0.9999999) {
                                    this._x = Math.atan2(m32, m33);
                                    this._z = Math.atan2(m21, m11)
                                } else {
                                    this._x = 0;
                                    this._z = Math.atan2(-m12, m22)
                                }
                                break;
                            case 'YZX':
                                this._z = Math.asin(clamp(m21, -1, 1));
                                if (Math.abs(m21) < 0.9999999) {
                                    this._x = Math.atan2(-m23, m22);
                                    this._y = Math.atan2(-m31, m11)
                                } else {
                                    this._x = 0;
                                    this._y = Math.atan2(m13, m33)
                                }
                                break;
                            case 'XZY':
                                this._z = Math.asin(-clamp(m12, -1, 1));
                                if (Math.abs(m12) < 0.9999999) {
                                    this._x = Math.atan2(m32, m22);
                                    this._y = Math.atan2(m13, m11)
                                } else {
                                    this._x = Math.atan2(-m23, m33);
                                    this._y = 0
                                }
                                break;
                            default:
                                console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order)
                        }
                        this._order = order;
                        if (update === !0) this._onChangeCallback();
                        return this
                    }
                    setFromQuaternion(q, order, update) {
                        _matrix$2.makeRotationFromQuaternion(q);
                        return this.setFromRotationMatrix(_matrix$2, order, update)
                    }
                    setFromVector3(v, order = this._order) {
                        return this.set(v.x, v.y, v.z, order)
                    }
                    reorder(newOrder) {
                        _quaternion$3.setFromEuler(this);
                        return this.setFromQuaternion(_quaternion$3, newOrder)
                    }
                    equals(euler) {
                        return (euler._x === this._x) && (euler._y === this._y) && (euler._z === this._z) && (euler._order === this._order)
                    }
                    fromArray(array) {
                        this._x = array[0];
                        this._y = array[1];
                        this._z = array[2];
                        if (array[3] !== undefined) this._order = array[3];
                        this._onChangeCallback();
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this._x;
                        array[offset + 1] = this._y;
                        array[offset + 2] = this._z;
                        array[offset + 3] = this._order;
                        return array
                    }
                    _onChange(callback) {
                        this._onChangeCallback = callback;
                        return this
                    }
                    _onChangeCallback() {}*[Symbol.iterator]() {
                        yield this._x;
                        yield this._y;
                        yield this._z;
                        yield this._order
                    }
                }
                Euler.DEFAULT_ORDER = 'XYZ';
                class Layers {
                    constructor() {
                        this.mask = 1 | 0
                    }
                    set(channel) {
                        this.mask = (1 << channel | 0) >>> 0
                    }
                    enable(channel) {
                        this.mask |= 1 << channel | 0
                    }
                    enableAll() {
                        this.mask = 0xffffffff | 0
                    }
                    toggle(channel) {
                        this.mask ^= 1 << channel | 0
                    }
                    disable(channel) {
                        this.mask &= ~(1 << channel | 0)
                    }
                    disableAll() {
                        this.mask = 0
                    }
                    test(layers) {
                        return (this.mask & layers.mask) !== 0
                    }
                    isEnabled(channel) {
                        return (this.mask & (1 << channel | 0)) !== 0
                    }
                }
                let _object3DId = 0;
                const _v1$4 = new Vector3();
                const _q1 = new Quaternion();
                const _m1$3 = new Matrix4();
                const _target = new Vector3();
                const _position$3 = new Vector3();
                const _scale$2 = new Vector3();
                const _quaternion$2 = new Quaternion();
                const _xAxis = new Vector3(1, 0, 0);
                const _yAxis = new Vector3(0, 1, 0);
                const _zAxis = new Vector3(0, 0, 1);
                const _addedEvent = {
                    type: 'added'
                };
                const _removedEvent = {
                    type: 'removed'
                };
                const _childaddedEvent = {
                    type: 'childadded',
                    child: null
                };
                const _childremovedEvent = {
                    type: 'childremoved',
                    child: null
                };
                class Object3D extends EventDispatcher {
                    constructor() {
                        super();
                        this.isObject3D = !0;
                        Object.defineProperty(this, 'id', {
                            value: _object3DId++
                        });
                        this.uuid = generateUUID();
                        this.name = '';
                        this.type = 'Object3D';
                        this.parent = null;
                        this.children = [];
                        this.up = Object3D.DEFAULT_UP.clone();
                        const position = new Vector3();
                        const rotation = new Euler();
                        const quaternion = new Quaternion();
                        const scale = new Vector3(1, 1, 1);

                        function onRotationChange() {
                            quaternion.setFromEuler(rotation, !1)
                        }

                        function onQuaternionChange() {
                            rotation.setFromQuaternion(quaternion, undefined, !1)
                        }
                        rotation._onChange(onRotationChange);
                        quaternion._onChange(onQuaternionChange);
                        Object.defineProperties(this, {
                            position: {
                                configurable: !0,
                                enumerable: !0,
                                value: position
                            },
                            rotation: {
                                configurable: !0,
                                enumerable: !0,
                                value: rotation
                            },
                            quaternion: {
                                configurable: !0,
                                enumerable: !0,
                                value: quaternion
                            },
                            scale: {
                                configurable: !0,
                                enumerable: !0,
                                value: scale
                            },
                            modelViewMatrix: {
                                value: new Matrix4()
                            },
                            normalMatrix: {
                                value: new Matrix3()
                            }
                        });
                        this.matrix = new Matrix4();
                        this.matrixWorld = new Matrix4();
                        this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
                        this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
                        this.matrixWorldNeedsUpdate = !1;
                        this.layers = new Layers();
                        this.visible = !0;
                        this.castShadow = !1;
                        this.receiveShadow = !1;
                        this.frustumCulled = !0;
                        this.renderOrder = 0;
                        this.animations = [];
                        this.userData = {}
                    }
                    onBeforeShadow() {}
                    onAfterShadow() {}
                    onBeforeRender() {}
                    onAfterRender() {}
                    applyMatrix4(matrix) {
                        if (this.matrixAutoUpdate) this.updateMatrix();
                        this.matrix.premultiply(matrix);
                        this.matrix.decompose(this.position, this.quaternion, this.scale)
                    }
                    applyQuaternion(q) {
                        this.quaternion.premultiply(q);
                        return this
                    }
                    setRotationFromAxisAngle(axis, angle) {
                        this.quaternion.setFromAxisAngle(axis, angle)
                    }
                    setRotationFromEuler(euler) {
                        this.quaternion.setFromEuler(euler, !0)
                    }
                    setRotationFromMatrix(m) {
                        this.quaternion.setFromRotationMatrix(m)
                    }
                    setRotationFromQuaternion(q) {
                        this.quaternion.copy(q)
                    }
                    rotateOnAxis(axis, angle) {
                        _q1.setFromAxisAngle(axis, angle);
                        this.quaternion.multiply(_q1);
                        return this
                    }
                    rotateOnWorldAxis(axis, angle) {
                        _q1.setFromAxisAngle(axis, angle);
                        this.quaternion.premultiply(_q1);
                        return this
                    }
                    rotateX(angle) {
                        return this.rotateOnAxis(_xAxis, angle)
                    }
                    rotateY(angle) {
                        return this.rotateOnAxis(_yAxis, angle)
                    }
                    rotateZ(angle) {
                        return this.rotateOnAxis(_zAxis, angle)
                    }
                    translateOnAxis(axis, distance) {
                        _v1$4.copy(axis).applyQuaternion(this.quaternion);
                        this.position.add(_v1$4.multiplyScalar(distance));
                        return this
                    }
                    translateX(distance) {
                        return this.translateOnAxis(_xAxis, distance)
                    }
                    translateY(distance) {
                        return this.translateOnAxis(_yAxis, distance)
                    }
                    translateZ(distance) {
                        return this.translateOnAxis(_zAxis, distance)
                    }
                    localToWorld(vector) {
                        this.updateWorldMatrix(!0, !1);
                        return vector.applyMatrix4(this.matrixWorld)
                    }
                    worldToLocal(vector) {
                        this.updateWorldMatrix(!0, !1);
                        return vector.applyMatrix4(_m1$3.copy(this.matrixWorld).invert())
                    }
                    lookAt(x, y, z) {
                        if (x.isVector3) {
                            _target.copy(x)
                        } else {
                            _target.set(x, y, z)
                        }
                        const parent = this.parent;
                        this.updateWorldMatrix(!0, !1);
                        _position$3.setFromMatrixPosition(this.matrixWorld);
                        if (this.isCamera || this.isLight) {
                            _m1$3.lookAt(_position$3, _target, this.up)
                        } else {
                            _m1$3.lookAt(_target, _position$3, this.up)
                        }
                        this.quaternion.setFromRotationMatrix(_m1$3);
                        if (parent) {
                            _m1$3.extractRotation(parent.matrixWorld);
                            _q1.setFromRotationMatrix(_m1$3);
                            this.quaternion.premultiply(_q1.invert())
                        }
                    }
                    add(object) {
                        if (arguments.length > 1) {
                            for (let i = 0; i < arguments.length; i++) {
                                this.add(arguments[i])
                            }
                            return this
                        }
                        if (object === this) {
                            console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
                            return this
                        }
                        if (object && object.isObject3D) {
                            object.removeFromParent();
                            object.parent = this;
                            this.children.push(object);
                            object.dispatchEvent(_addedEvent);
                            _childaddedEvent.child = object;
                            this.dispatchEvent(_childaddedEvent);
                            _childaddedEvent.child = null
                        } else {
                            console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object)
                        }
                        return this
                    }
                    remove(object) {
                        if (arguments.length > 1) {
                            for (let i = 0; i < arguments.length; i++) {
                                this.remove(arguments[i])
                            }
                            return this
                        }
                        const index = this.children.indexOf(object);
                        if (index !== -1) {
                            object.parent = null;
                            this.children.splice(index, 1);
                            object.dispatchEvent(_removedEvent);
                            _childremovedEvent.child = object;
                            this.dispatchEvent(_childremovedEvent);
                            _childremovedEvent.child = null
                        }
                        return this
                    }
                    removeFromParent() {
                        const parent = this.parent;
                        if (parent !== null) {
                            parent.remove(this)
                        }
                        return this
                    }
                    clear() {
                        return this.remove(...this.children)
                    }
                    attach(object) {
                        this.updateWorldMatrix(!0, !1);
                        _m1$3.copy(this.matrixWorld).invert();
                        if (object.parent !== null) {
                            object.parent.updateWorldMatrix(!0, !1);
                            _m1$3.multiply(object.parent.matrixWorld)
                        }
                        object.applyMatrix4(_m1$3);
                        object.removeFromParent();
                        object.parent = this;
                        this.children.push(object);
                        object.updateWorldMatrix(!1, !0);
                        object.dispatchEvent(_addedEvent);
                        _childaddedEvent.child = object;
                        this.dispatchEvent(_childaddedEvent);
                        _childaddedEvent.child = null;
                        return this
                    }
                    getObjectById(id) {
                        return this.getObjectByProperty('id', id)
                    }
                    getObjectByName(name) {
                        return this.getObjectByProperty('name', name)
                    }
                    getObjectByProperty(name, value) {
                        if (this[name] === value) return this;
                        for (let i = 0, l = this.children.length; i < l; i++) {
                            const child = this.children[i];
                            const object = child.getObjectByProperty(name, value);
                            if (object !== undefined) {
                                return object
                            }
                        }
                        return undefined
                    }
                    getObjectsByProperty(name, value, result = []) {
                        if (this[name] === value) result.push(this);
                        const children = this.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            children[i].getObjectsByProperty(name, value, result)
                        }
                        return result
                    }
                    getWorldPosition(target) {
                        this.updateWorldMatrix(!0, !1);
                        return target.setFromMatrixPosition(this.matrixWorld)
                    }
                    getWorldQuaternion(target) {
                        this.updateWorldMatrix(!0, !1);
                        this.matrixWorld.decompose(_position$3, target, _scale$2);
                        return target
                    }
                    getWorldScale(target) {
                        this.updateWorldMatrix(!0, !1);
                        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
                        return target
                    }
                    getWorldDirection(target) {
                        this.updateWorldMatrix(!0, !1);
                        const e = this.matrixWorld.elements;
                        return target.set(e[8], e[9], e[10]).normalize()
                    }
                    raycast() {}
                    traverse(callback) {
                        callback(this);
                        const children = this.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            children[i].traverse(callback)
                        }
                    }
                    traverseVisible(callback) {
                        if (this.visible === !1) return;
                        callback(this);
                        const children = this.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            children[i].traverseVisible(callback)
                        }
                    }
                    traverseAncestors(callback) {
                        const parent = this.parent;
                        if (parent !== null) {
                            callback(parent);
                            parent.traverseAncestors(callback)
                        }
                    }
                    updateMatrix() {
                        this.matrix.compose(this.position, this.quaternion, this.scale);
                        this.matrixWorldNeedsUpdate = !0
                    }
                    updateMatrixWorld(force) {
                        if (this.matrixAutoUpdate) this.updateMatrix();
                        if (this.matrixWorldNeedsUpdate || force) {
                            if (this.matrixWorldAutoUpdate === !0) {
                                if (this.parent === null) {
                                    this.matrixWorld.copy(this.matrix)
                                } else {
                                    this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)
                                }
                            }
                            this.matrixWorldNeedsUpdate = !1;
                            force = !0
                        }
                        const children = this.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            const child = children[i];
                            child.updateMatrixWorld(force)
                        }
                    }
                    updateWorldMatrix(updateParents, updateChildren) {
                        const parent = this.parent;
                        if (updateParents === !0 && parent !== null) {
                            parent.updateWorldMatrix(!0, !1)
                        }
                        if (this.matrixAutoUpdate) this.updateMatrix();
                        if (this.matrixWorldAutoUpdate === !0) {
                            if (this.parent === null) {
                                this.matrixWorld.copy(this.matrix)
                            } else {
                                this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)
                            }
                        }
                        if (updateChildren === !0) {
                            const children = this.children;
                            for (let i = 0, l = children.length; i < l; i++) {
                                const child = children[i];
                                child.updateWorldMatrix(!1, !0)
                            }
                        }
                    }
                    toJSON(meta) {
                        const isRootObject = (meta === undefined || typeof meta === 'string');
                        const output = {};
                        if (isRootObject) {
                            meta = {
                                geometries: {},
                                materials: {},
                                textures: {},
                                images: {},
                                shapes: {},
                                skeletons: {},
                                animations: {},
                                nodes: {}
                            };
                            output.metadata = {
                                version: 4.6,
                                type: 'Object',
                                generator: 'Object3D.toJSON'
                            }
                        }
                        const object = {};
                        object.uuid = this.uuid;
                        object.type = this.type;
                        if (this.name !== '') object.name = this.name;
                        if (this.castShadow === !0) object.castShadow = !0;
                        if (this.receiveShadow === !0) object.receiveShadow = !0;
                        if (this.visible === !1) object.visible = !1;
                        if (this.frustumCulled === !1) object.frustumCulled = !1;
                        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
                        if (Object.keys(this.userData).length > 0) object.userData = this.userData;
                        object.layers = this.layers.mask;
                        object.matrix = this.matrix.toArray();
                        object.up = this.up.toArray();
                        if (this.matrixAutoUpdate === !1) object.matrixAutoUpdate = !1;
                        if (this.isInstancedMesh) {
                            object.type = 'InstancedMesh';
                            object.count = this.count;
                            object.instanceMatrix = this.instanceMatrix.toJSON();
                            if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON()
                        }
                        if (this.isBatchedMesh) {
                            object.type = 'BatchedMesh';
                            object.perObjectFrustumCulled = this.perObjectFrustumCulled;
                            object.sortObjects = this.sortObjects;
                            object.drawRanges = this._drawRanges;
                            object.reservedRanges = this._reservedRanges;
                            object.visibility = this._visibility;
                            object.active = this._active;
                            object.bounds = this._bounds.map(bound => ({
                                boxInitialized: bound.boxInitialized,
                                boxMin: bound.box.min.toArray(),
                                boxMax: bound.box.max.toArray(),
                                sphereInitialized: bound.sphereInitialized,
                                sphereRadius: bound.sphere.radius,
                                sphereCenter: bound.sphere.center.toArray()
                            }));
                            object.maxInstanceCount = this._maxInstanceCount;
                            object.maxVertexCount = this._maxVertexCount;
                            object.maxIndexCount = this._maxIndexCount;
                            object.geometryInitialized = this._geometryInitialized;
                            object.geometryCount = this._geometryCount;
                            object.matricesTexture = this._matricesTexture.toJSON(meta);
                            if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
                            if (this.boundingSphere !== null) {
                                object.boundingSphere = {
                                    center: object.boundingSphere.center.toArray(),
                                    radius: object.boundingSphere.radius
                                }
                            }
                            if (this.boundingBox !== null) {
                                object.boundingBox = {
                                    min: object.boundingBox.min.toArray(),
                                    max: object.boundingBox.max.toArray()
                                }
                            }
                        }

                        function serialize(library, element) {
                            if (library[element.uuid] === undefined) {
                                library[element.uuid] = element.toJSON(meta)
                            }
                            return element.uuid
                        }
                        if (this.isScene) {
                            if (this.background) {
                                if (this.background.isColor) {
                                    object.background = this.background.toJSON()
                                } else if (this.background.isTexture) {
                                    object.background = this.background.toJSON(meta).uuid
                                }
                            }
                            if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0) {
                                object.environment = this.environment.toJSON(meta).uuid
                            }
                        } else if (this.isMesh || this.isLine || this.isPoints) {
                            object.geometry = serialize(meta.geometries, this.geometry);
                            const parameters = this.geometry.parameters;
                            if (parameters !== undefined && parameters.shapes !== undefined) {
                                const shapes = parameters.shapes;
                                if (Array.isArray(shapes)) {
                                    for (let i = 0, l = shapes.length; i < l; i++) {
                                        const shape = shapes[i];
                                        serialize(meta.shapes, shape)
                                    }
                                } else {
                                    serialize(meta.shapes, shapes)
                                }
                            }
                        }
                        if (this.isSkinnedMesh) {
                            object.bindMode = this.bindMode;
                            object.bindMatrix = this.bindMatrix.toArray();
                            if (this.skeleton !== undefined) {
                                serialize(meta.skeletons, this.skeleton);
                                object.skeleton = this.skeleton.uuid
                            }
                        }
                        if (this.material !== undefined) {
                            if (Array.isArray(this.material)) {
                                const uuids = [];
                                for (let i = 0, l = this.material.length; i < l; i++) {
                                    uuids.push(serialize(meta.materials, this.material[i]))
                                }
                                object.material = uuids
                            } else {
                                object.material = serialize(meta.materials, this.material)
                            }
                        }
                        if (this.children.length > 0) {
                            object.children = [];
                            for (let i = 0; i < this.children.length; i++) {
                                object.children.push(this.children[i].toJSON(meta).object)
                            }
                        }
                        if (this.animations.length > 0) {
                            object.animations = [];
                            for (let i = 0; i < this.animations.length; i++) {
                                const animation = this.animations[i];
                                object.animations.push(serialize(meta.animations, animation))
                            }
                        }
                        if (isRootObject) {
                            const geometries = extractFromCache(meta.geometries);
                            const materials = extractFromCache(meta.materials);
                            const textures = extractFromCache(meta.textures);
                            const images = extractFromCache(meta.images);
                            const shapes = extractFromCache(meta.shapes);
                            const skeletons = extractFromCache(meta.skeletons);
                            const animations = extractFromCache(meta.animations);
                            const nodes = extractFromCache(meta.nodes);
                            if (geometries.length > 0) output.geometries = geometries;
                            if (materials.length > 0) output.materials = materials;
                            if (textures.length > 0) output.textures = textures;
                            if (images.length > 0) output.images = images;
                            if (shapes.length > 0) output.shapes = shapes;
                            if (skeletons.length > 0) output.skeletons = skeletons;
                            if (animations.length > 0) output.animations = animations;
                            if (nodes.length > 0) output.nodes = nodes
                        }
                        output.object = object;
                        return output;

                        function extractFromCache(cache) {
                            const values = [];
                            for (const key in cache) {
                                const data = cache[key];
                                delete data.metadata;
                                values.push(data)
                            }
                            return values
                        }
                    }
                    clone(recursive) {
                        return new this.constructor().copy(this, recursive)
                    }
                    copy(source, recursive = !0) {
                        this.name = source.name;
                        this.up.copy(source.up);
                        this.position.copy(source.position);
                        this.rotation.order = source.rotation.order;
                        this.quaternion.copy(source.quaternion);
                        this.scale.copy(source.scale);
                        this.matrix.copy(source.matrix);
                        this.matrixWorld.copy(source.matrixWorld);
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
                        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
                        this.layers.mask = source.layers.mask;
                        this.visible = source.visible;
                        this.castShadow = source.castShadow;
                        this.receiveShadow = source.receiveShadow;
                        this.frustumCulled = source.frustumCulled;
                        this.renderOrder = source.renderOrder;
                        this.animations = source.animations.slice();
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        if (recursive === !0) {
                            for (let i = 0; i < source.children.length; i++) {
                                const child = source.children[i];
                                this.add(child.clone())
                            }
                        }
                        return this
                    }
                }
                Object3D.DEFAULT_UP = new Vector3(0, 1, 0);
                Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0;
                Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
                const _v0$2 = new Vector3();
                const _v1$3 = new Vector3();
                const _v2$2 = new Vector3();
                const _v3$2 = new Vector3();
                const _vab = new Vector3();
                const _vac = new Vector3();
                const _vbc = new Vector3();
                const _vap = new Vector3();
                const _vbp = new Vector3();
                const _vcp = new Vector3();
                class Triangle {
                    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
                        this.a = a;
                        this.b = b;
                        this.c = c
                    }
                    static getNormal(a, b, c, target) {
                        target.subVectors(c, b);
                        _v0$2.subVectors(a, b);
                        target.cross(_v0$2);
                        const targetLengthSq = target.lengthSq();
                        if (targetLengthSq > 0) {
                            return target.multiplyScalar(1 / Math.sqrt(targetLengthSq))
                        }
                        return target.set(0, 0, 0)
                    }
                    static getBarycoord(point, a, b, c, target) {
                        _v0$2.subVectors(c, a);
                        _v1$3.subVectors(b, a);
                        _v2$2.subVectors(point, a);
                        const dot00 = _v0$2.dot(_v0$2);
                        const dot01 = _v0$2.dot(_v1$3);
                        const dot02 = _v0$2.dot(_v2$2);
                        const dot11 = _v1$3.dot(_v1$3);
                        const dot12 = _v1$3.dot(_v2$2);
                        const denom = (dot00 * dot11 - dot01 * dot01);
                        if (denom === 0) {
                            target.set(0, 0, 0);
                            return null
                        }
                        const invDenom = 1 / denom;
                        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
                        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
                        return target.set(1 - u - v, v, u)
                    }
                    static containsPoint(point, a, b, c) {
                        if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
                            return !1
                        }
                        return (_v3$2.x >= 0) && (_v3$2.y >= 0) && ((_v3$2.x + _v3$2.y) <= 1)
                    }
                    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
                        if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
                            target.x = 0;
                            target.y = 0;
                            if ('z' in target) target.z = 0;
                            if ('w' in target) target.w = 0;
                            return null
                        }
                        target.setScalar(0);
                        target.addScaledVector(v1, _v3$2.x);
                        target.addScaledVector(v2, _v3$2.y);
                        target.addScaledVector(v3, _v3$2.z);
                        return target
                    }
                    static isFrontFacing(a, b, c, direction) {
                        _v0$2.subVectors(c, b);
                        _v1$3.subVectors(a, b);
                        return (_v0$2.cross(_v1$3).dot(direction) < 0) ? !0 : !1
                    }
                    set(a, b, c) {
                        this.a.copy(a);
                        this.b.copy(b);
                        this.c.copy(c);
                        return this
                    }
                    setFromPointsAndIndices(points, i0, i1, i2) {
                        this.a.copy(points[i0]);
                        this.b.copy(points[i1]);
                        this.c.copy(points[i2]);
                        return this
                    }
                    setFromAttributeAndIndices(attribute, i0, i1, i2) {
                        this.a.fromBufferAttribute(attribute, i0);
                        this.b.fromBufferAttribute(attribute, i1);
                        this.c.fromBufferAttribute(attribute, i2);
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(triangle) {
                        this.a.copy(triangle.a);
                        this.b.copy(triangle.b);
                        this.c.copy(triangle.c);
                        return this
                    }
                    getArea() {
                        _v0$2.subVectors(this.c, this.b);
                        _v1$3.subVectors(this.a, this.b);
                        return _v0$2.cross(_v1$3).length() * 0.5
                    }
                    getMidpoint(target) {
                        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                    }
                    getNormal(target) {
                        return Triangle.getNormal(this.a, this.b, this.c, target)
                    }
                    getPlane(target) {
                        return target.setFromCoplanarPoints(this.a, this.b, this.c)
                    }
                    getBarycoord(point, target) {
                        return Triangle.getBarycoord(point, this.a, this.b, this.c, target)
                    }
                    getInterpolation(point, v1, v2, v3, target) {
                        return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target)
                    }
                    containsPoint(point) {
                        return Triangle.containsPoint(point, this.a, this.b, this.c)
                    }
                    isFrontFacing(direction) {
                        return Triangle.isFrontFacing(this.a, this.b, this.c, direction)
                    }
                    intersectsBox(box) {
                        return box.intersectsTriangle(this)
                    }
                    closestPointToPoint(p, target) {
                        const a = this.a,
                            b = this.b,
                            c = this.c;
                        let v, w;
                        _vab.subVectors(b, a);
                        _vac.subVectors(c, a);
                        _vap.subVectors(p, a);
                        const d1 = _vab.dot(_vap);
                        const d2 = _vac.dot(_vap);
                        if (d1 <= 0 && d2 <= 0) {
                            return target.copy(a)
                        }
                        _vbp.subVectors(p, b);
                        const d3 = _vab.dot(_vbp);
                        const d4 = _vac.dot(_vbp);
                        if (d3 >= 0 && d4 <= d3) {
                            return target.copy(b)
                        }
                        const vc = d1 * d4 - d3 * d2;
                        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                            v = d1 / (d1 - d3);
                            return target.copy(a).addScaledVector(_vab, v)
                        }
                        _vcp.subVectors(p, c);
                        const d5 = _vab.dot(_vcp);
                        const d6 = _vac.dot(_vcp);
                        if (d6 >= 0 && d5 <= d6) {
                            return target.copy(c)
                        }
                        const vb = d5 * d2 - d1 * d6;
                        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                            w = d2 / (d2 - d6);
                            return target.copy(a).addScaledVector(_vac, w)
                        }
                        const va = d3 * d6 - d5 * d4;
                        if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                            _vbc.subVectors(c, b);
                            w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                            return target.copy(b).addScaledVector(_vbc, w)
                        }
                        const denom = 1 / (va + vb + vc);
                        v = vb * denom;
                        w = vc * denom;
                        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w)
                    }
                    equals(triangle) {
                        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c)
                    }
                }
                const _colorKeywords = {
                    'aliceblue': 0xF0F8FF,
                    'antiquewhite': 0xFAEBD7,
                    'aqua': 0x00FFFF,
                    'aquamarine': 0x7FFFD4,
                    'azure': 0xF0FFFF,
                    'beige': 0xF5F5DC,
                    'bisque': 0xFFE4C4,
                    'black': 0x000000,
                    'blanchedalmond': 0xFFEBCD,
                    'blue': 0x0000FF,
                    'blueviolet': 0x8A2BE2,
                    'brown': 0xA52A2A,
                    'burlywood': 0xDEB887,
                    'cadetblue': 0x5F9EA0,
                    'chartreuse': 0x7FFF00,
                    'chocolate': 0xD2691E,
                    'coral': 0xFF7F50,
                    'cornflowerblue': 0x6495ED,
                    'cornsilk': 0xFFF8DC,
                    'crimson': 0xDC143C,
                    'cyan': 0x00FFFF,
                    'darkblue': 0x00008B,
                    'darkcyan': 0x008B8B,
                    'darkgoldenrod': 0xB8860B,
                    'darkgray': 0xA9A9A9,
                    'darkgreen': 0x006400,
                    'darkgrey': 0xA9A9A9,
                    'darkkhaki': 0xBDB76B,
                    'darkmagenta': 0x8B008B,
                    'darkolivegreen': 0x556B2F,
                    'darkorange': 0xFF8C00,
                    'darkorchid': 0x9932CC,
                    'darkred': 0x8B0000,
                    'darksalmon': 0xE9967A,
                    'darkseagreen': 0x8FBC8F,
                    'darkslateblue': 0x483D8B,
                    'darkslategray': 0x2F4F4F,
                    'darkslategrey': 0x2F4F4F,
                    'darkturquoise': 0x00CED1,
                    'darkviolet': 0x9400D3,
                    'deeppink': 0xFF1493,
                    'deepskyblue': 0x00BFFF,
                    'dimgray': 0x696969,
                    'dimgrey': 0x696969,
                    'dodgerblue': 0x1E90FF,
                    'firebrick': 0xB22222,
                    'floralwhite': 0xFFFAF0,
                    'forestgreen': 0x228B22,
                    'fuchsia': 0xFF00FF,
                    'gainsboro': 0xDCDCDC,
                    'ghostwhite': 0xF8F8FF,
                    'gold': 0xFFD700,
                    'goldenrod': 0xDAA520,
                    'gray': 0x808080,
                    'green': 0x008000,
                    'greenyellow': 0xADFF2F,
                    'grey': 0x808080,
                    'honeydew': 0xF0FFF0,
                    'hotpink': 0xFF69B4,
                    'indianred': 0xCD5C5C,
                    'indigo': 0x4B0082,
                    'ivory': 0xFFFFF0,
                    'khaki': 0xF0E68C,
                    'lavender': 0xE6E6FA,
                    'lavenderblush': 0xFFF0F5,
                    'lawngreen': 0x7CFC00,
                    'lemonchiffon': 0xFFFACD,
                    'lightblue': 0xADD8E6,
                    'lightcoral': 0xF08080,
                    'lightcyan': 0xE0FFFF,
                    'lightgoldenrodyellow': 0xFAFAD2,
                    'lightgray': 0xD3D3D3,
                    'lightgreen': 0x90EE90,
                    'lightgrey': 0xD3D3D3,
                    'lightpink': 0xFFB6C1,
                    'lightsalmon': 0xFFA07A,
                    'lightseagreen': 0x20B2AA,
                    'lightskyblue': 0x87CEFA,
                    'lightslategray': 0x778899,
                    'lightslategrey': 0x778899,
                    'lightsteelblue': 0xB0C4DE,
                    'lightyellow': 0xFFFFE0,
                    'lime': 0x00FF00,
                    'limegreen': 0x32CD32,
                    'linen': 0xFAF0E6,
                    'magenta': 0xFF00FF,
                    'maroon': 0x800000,
                    'mediumaquamarine': 0x66CDAA,
                    'mediumblue': 0x0000CD,
                    'mediumorchid': 0xBA55D3,
                    'mediumpurple': 0x9370DB,
                    'mediumseagreen': 0x3CB371,
                    'mediumslateblue': 0x7B68EE,
                    'mediumspringgreen': 0x00FA9A,
                    'mediumturquoise': 0x48D1CC,
                    'mediumvioletred': 0xC71585,
                    'midnightblue': 0x191970,
                    'mintcream': 0xF5FFFA,
                    'mistyrose': 0xFFE4E1,
                    'moccasin': 0xFFE4B5,
                    'navajowhite': 0xFFDEAD,
                    'navy': 0x000080,
                    'oldlace': 0xFDF5E6,
                    'olive': 0x808000,
                    'olivedrab': 0x6B8E23,
                    'orange': 0xFFA500,
                    'orangered': 0xFF4500,
                    'orchid': 0xDA70D6,
                    'palegoldenrod': 0xEEE8AA,
                    'palegreen': 0x98FB98,
                    'paleturquoise': 0xAFEEEE,
                    'palevioletred': 0xDB7093,
                    'papayawhip': 0xFFEFD5,
                    'peachpuff': 0xFFDAB9,
                    'peru': 0xCD853F,
                    'pink': 0xFFC0CB,
                    'plum': 0xDDA0DD,
                    'powderblue': 0xB0E0E6,
                    'purple': 0x800080,
                    'rebeccapurple': 0x663399,
                    'red': 0xFF0000,
                    'rosybrown': 0xBC8F8F,
                    'royalblue': 0x4169E1,
                    'saddlebrown': 0x8B4513,
                    'salmon': 0xFA8072,
                    'sandybrown': 0xF4A460,
                    'seagreen': 0x2E8B57,
                    'seashell': 0xFFF5EE,
                    'sienna': 0xA0522D,
                    'silver': 0xC0C0C0,
                    'skyblue': 0x87CEEB,
                    'slateblue': 0x6A5ACD,
                    'slategray': 0x708090,
                    'slategrey': 0x708090,
                    'snow': 0xFFFAFA,
                    'springgreen': 0x00FF7F,
                    'steelblue': 0x4682B4,
                    'tan': 0xD2B48C,
                    'teal': 0x008080,
                    'thistle': 0xD8BFD8,
                    'tomato': 0xFF6347,
                    'turquoise': 0x40E0D0,
                    'violet': 0xEE82EE,
                    'wheat': 0xF5DEB3,
                    'white': 0xFFFFFF,
                    'whitesmoke': 0xF5F5F5,
                    'yellow': 0xFFFF00,
                    'yellowgreen': 0x9ACD32
                };
                const _hslA = {
                    h: 0,
                    s: 0,
                    l: 0
                };
                const _hslB = {
                    h: 0,
                    s: 0,
                    l: 0
                };

                function hue2rgb(p, q, t) {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1 / 6) return p + (q - p) * 6 * t;
                    if (t < 1 / 2) return q;
                    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
                    return p
                }
                class Color {
                    constructor(r, g, b) {
                        this.isColor = !0;
                        this.r = 1;
                        this.g = 1;
                        this.b = 1;
                        return this.set(r, g, b)
                    }
                    set(r, g, b) {
                        if (g === undefined && b === undefined) {
                            const value = r;
                            if (value && value.isColor) {
                                this.copy(value)
                            } else if (typeof value === 'number') {
                                this.setHex(value)
                            } else if (typeof value === 'string') {
                                this.setStyle(value)
                            }
                        } else {
                            this.setRGB(r, g, b)
                        }
                        return this
                    }
                    setScalar(scalar) {
                        this.r = scalar;
                        this.g = scalar;
                        this.b = scalar;
                        return this
                    }
                    setHex(hex, colorSpace = SRGBColorSpace) {
                        hex = Math.floor(hex);
                        this.r = (hex >> 16 & 255) / 255;
                        this.g = (hex >> 8 & 255) / 255;
                        this.b = (hex & 255) / 255;
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this
                    }
                    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
                        this.r = r;
                        this.g = g;
                        this.b = b;
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this
                    }
                    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
                        h = euclideanModulo(h, 1);
                        s = clamp(s, 0, 1);
                        l = clamp(l, 0, 1);
                        if (s === 0) {
                            this.r = this.g = this.b = l
                        } else {
                            const p = l <= 0.5 ? l * (1 + s) : l + s - (l * s);
                            const q = (2 * l) - p;
                            this.r = hue2rgb(q, p, h + 1 / 3);
                            this.g = hue2rgb(q, p, h);
                            this.b = hue2rgb(q, p, h - 1 / 3)
                        }
                        ColorManagement.toWorkingColorSpace(this, colorSpace);
                        return this
                    }
                    setStyle(style, colorSpace = SRGBColorSpace) {
                        function handleAlpha(string) {
                            if (string === undefined) return;
                            if (parseFloat(string) < 1) {
                                console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.')
                            }
                        }
                        let m;
                        if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
                            let color;
                            const name = m[1];
                            const components = m[2];
                            switch (name) {
                                case 'rgb':
                                case 'rgba':
                                    if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        handleAlpha(color[4]);
                                        return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace)
                                    }
                                    if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        handleAlpha(color[4]);
                                        return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace)
                                    }
                                    break;
                                case 'hsl':
                                case 'hsla':
                                    if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                                        handleAlpha(color[4]);
                                        return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace)
                                    }
                                    break;
                                default:
                                    console.warn('THREE.Color: Unknown color model ' + style)
                            }
                        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
                            const hex = m[1];
                            const size = hex.length;
                            if (size === 3) {
                                return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace)
                            } else if (size === 6) {
                                return this.setHex(parseInt(hex, 16), colorSpace)
                            } else {
                                console.warn('THREE.Color: Invalid hex color ' + style)
                            }
                        } else if (style && style.length > 0) {
                            return this.setColorName(style, colorSpace)
                        }
                        return this
                    }
                    setColorName(style, colorSpace = SRGBColorSpace) {
                        const hex = _colorKeywords[style.toLowerCase()];
                        if (hex !== undefined) {
                            this.setHex(hex, colorSpace)
                        } else {
                            console.warn('THREE.Color: Unknown color ' + style)
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor(this.r, this.g, this.b)
                    }
                    copy(color) {
                        this.r = color.r;
                        this.g = color.g;
                        this.b = color.b;
                        return this
                    }
                    copySRGBToLinear(color) {
                        this.r = SRGBToLinear(color.r);
                        this.g = SRGBToLinear(color.g);
                        this.b = SRGBToLinear(color.b);
                        return this
                    }
                    copyLinearToSRGB(color) {
                        this.r = LinearToSRGB(color.r);
                        this.g = LinearToSRGB(color.g);
                        this.b = LinearToSRGB(color.b);
                        return this
                    }
                    convertSRGBToLinear() {
                        this.copySRGBToLinear(this);
                        return this
                    }
                    convertLinearToSRGB() {
                        this.copyLinearToSRGB(this);
                        return this
                    }
                    getHex(colorSpace = SRGBColorSpace) {
                        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
                        return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255))
                    }
                    getHexString(colorSpace = SRGBColorSpace) {
                        return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6)
                    }
                    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
                        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
                        const r = _color.r,
                            g = _color.g,
                            b = _color.b;
                        const max = Math.max(r, g, b);
                        const min = Math.min(r, g, b);
                        let hue, saturation;
                        const lightness = (min + max) / 2.0;
                        if (min === max) {
                            hue = 0;
                            saturation = 0
                        } else {
                            const delta = max - min;
                            saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
                            switch (max) {
                                case r:
                                    hue = (g - b) / delta + (g < b ? 6 : 0);
                                    break;
                                case g:
                                    hue = (b - r) / delta + 2;
                                    break;
                                case b:
                                    hue = (r - g) / delta + 4;
                                    break
                            }
                            hue /= 6
                        }
                        target.h = hue;
                        target.s = saturation;
                        target.l = lightness;
                        return target
                    }
                    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
                        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
                        target.r = _color.r;
                        target.g = _color.g;
                        target.b = _color.b;
                        return target
                    }
                    getStyle(colorSpace = SRGBColorSpace) {
                        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
                        const r = _color.r,
                            g = _color.g,
                            b = _color.b;
                        if (colorSpace !== SRGBColorSpace) {
                            return `color(${ colorSpace } ${ r.toFixed( 3 ) } ${ g.toFixed( 3 ) } ${ b.toFixed( 3 ) })`
                        }
                        return `rgb(${ Math.round( r * 255 ) },${ Math.round( g * 255 ) },${ Math.round( b * 255 ) })`
                    }
                    offsetHSL(h, s, l) {
                        this.getHSL(_hslA);
                        return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l)
                    }
                    add(color) {
                        this.r += color.r;
                        this.g += color.g;
                        this.b += color.b;
                        return this
                    }
                    addColors(color1, color2) {
                        this.r = color1.r + color2.r;
                        this.g = color1.g + color2.g;
                        this.b = color1.b + color2.b;
                        return this
                    }
                    addScalar(s) {
                        this.r += s;
                        this.g += s;
                        this.b += s;
                        return this
                    }
                    sub(color) {
                        this.r = Math.max(0, this.r - color.r);
                        this.g = Math.max(0, this.g - color.g);
                        this.b = Math.max(0, this.b - color.b);
                        return this
                    }
                    multiply(color) {
                        this.r *= color.r;
                        this.g *= color.g;
                        this.b *= color.b;
                        return this
                    }
                    multiplyScalar(s) {
                        this.r *= s;
                        this.g *= s;
                        this.b *= s;
                        return this
                    }
                    lerp(color, alpha) {
                        this.r += (color.r - this.r) * alpha;
                        this.g += (color.g - this.g) * alpha;
                        this.b += (color.b - this.b) * alpha;
                        return this
                    }
                    lerpColors(color1, color2, alpha) {
                        this.r = color1.r + (color2.r - color1.r) * alpha;
                        this.g = color1.g + (color2.g - color1.g) * alpha;
                        this.b = color1.b + (color2.b - color1.b) * alpha;
                        return this
                    }
                    lerpHSL(color, alpha) {
                        this.getHSL(_hslA);
                        color.getHSL(_hslB);
                        const h = lerp(_hslA.h, _hslB.h, alpha);
                        const s = lerp(_hslA.s, _hslB.s, alpha);
                        const l = lerp(_hslA.l, _hslB.l, alpha);
                        this.setHSL(h, s, l);
                        return this
                    }
                    setFromVector3(v) {
                        this.r = v.x;
                        this.g = v.y;
                        this.b = v.z;
                        return this
                    }
                    applyMatrix3(m) {
                        const r = this.r,
                            g = this.g,
                            b = this.b;
                        const e = m.elements;
                        this.r = e[0] * r + e[3] * g + e[6] * b;
                        this.g = e[1] * r + e[4] * g + e[7] * b;
                        this.b = e[2] * r + e[5] * g + e[8] * b;
                        return this
                    }
                    equals(c) {
                        return (c.r === this.r) && (c.g === this.g) && (c.b === this.b)
                    }
                    fromArray(array, offset = 0) {
                        this.r = array[offset];
                        this.g = array[offset + 1];
                        this.b = array[offset + 2];
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        array[offset] = this.r;
                        array[offset + 1] = this.g;
                        array[offset + 2] = this.b;
                        return array
                    }
                    fromBufferAttribute(attribute, index) {
                        this.r = attribute.getX(index);
                        this.g = attribute.getY(index);
                        this.b = attribute.getZ(index);
                        return this
                    }
                    toJSON() {
                        return this.getHex()
                    }*[Symbol.iterator]() {
                        yield this.r;
                        yield this.g;
                        yield this.b
                    }
                }
                const _color = new Color();
                Color.NAMES = _colorKeywords;
                let _materialId = 0;
                class Material extends EventDispatcher {
                    constructor() {
                        super();
                        this.isMaterial = !0;
                        Object.defineProperty(this, 'id', {
                            value: _materialId++
                        });
                        this.uuid = generateUUID();
                        this.name = '';
                        this.type = 'Material';
                        this.blending = NormalBlending;
                        this.side = FrontSide;
                        this.vertexColors = !1;
                        this.opacity = 1;
                        this.transparent = !1;
                        this.alphaHash = !1;
                        this.blendSrc = SrcAlphaFactor;
                        this.blendDst = OneMinusSrcAlphaFactor;
                        this.blendEquation = AddEquation;
                        this.blendSrcAlpha = null;
                        this.blendDstAlpha = null;
                        this.blendEquationAlpha = null;
                        this.blendColor = new Color(0, 0, 0);
                        this.blendAlpha = 0;
                        this.depthFunc = LessEqualDepth;
                        this.depthTest = !0;
                        this.depthWrite = !0;
                        this.stencilWriteMask = 0xff;
                        this.stencilFunc = AlwaysStencilFunc;
                        this.stencilRef = 0;
                        this.stencilFuncMask = 0xff;
                        this.stencilFail = KeepStencilOp;
                        this.stencilZFail = KeepStencilOp;
                        this.stencilZPass = KeepStencilOp;
                        this.stencilWrite = !1;
                        this.clippingPlanes = null;
                        this.clipIntersection = !1;
                        this.clipShadows = !1;
                        this.shadowSide = null;
                        this.colorWrite = !0;
                        this.precision = null;
                        this.polygonOffset = !1;
                        this.polygonOffsetFactor = 0;
                        this.polygonOffsetUnits = 0;
                        this.dithering = !1;
                        this.alphaToCoverage = !1;
                        this.premultipliedAlpha = !1;
                        this.forceSinglePass = !1;
                        this.visible = !0;
                        this.toneMapped = !0;
                        this.userData = {};
                        this.version = 0;
                        this._alphaTest = 0
                    }
                    get alphaTest() {
                        return this._alphaTest
                    }
                    set alphaTest(value) {
                        if (this._alphaTest > 0 !== value > 0) {
                            this.version++
                        }
                        this._alphaTest = value
                    }
                    onBeforeCompile() {}
                    customProgramCacheKey() {
                        return this.onBeforeCompile.toString()
                    }
                    setValues(values) {
                        if (values === undefined) return;
                        for (const key in values) {
                            const newValue = values[key];
                            if (newValue === undefined) {
                                console.warn(`THREE.Material: parameter '${ key }' has value of undefined.`);
                                continue
                            }
                            const currentValue = this[key];
                            if (currentValue === undefined) {
                                console.warn(`THREE.Material: '${ key }' is not a property of THREE.${ this.type }.`);
                                continue
                            }
                            if (currentValue && currentValue.isColor) {
                                currentValue.set(newValue)
                            } else if ((currentValue && currentValue.isVector3) && (newValue && newValue.isVector3)) {
                                currentValue.copy(newValue)
                            } else {
                                this[key] = newValue
                            }
                        }
                    }
                    toJSON(meta) {
                        const isRootObject = (meta === undefined || typeof meta === 'string');
                        if (isRootObject) {
                            meta = {
                                textures: {},
                                images: {}
                            }
                        }
                        const data = {
                            metadata: {
                                version: 4.6,
                                type: 'Material',
                                generator: 'Material.toJSON'
                            }
                        };
                        data.uuid = this.uuid;
                        data.type = this.type;
                        if (this.name !== '') data.name = this.name;
                        if (this.color && this.color.isColor) data.color = this.color.getHex();
                        if (this.roughness !== undefined) data.roughness = this.roughness;
                        if (this.metalness !== undefined) data.metalness = this.metalness;
                        if (this.sheen !== undefined) data.sheen = this.sheen;
                        if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
                        if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
                        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
                        if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
                        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
                        if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
                        if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
                        if (this.shininess !== undefined) data.shininess = this.shininess;
                        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
                        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
                        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
                            data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid
                        }
                        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
                            data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid
                        }
                        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
                            data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
                            data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()
                        }
                        if (this.dispersion !== undefined) data.dispersion = this.dispersion;
                        if (this.iridescence !== undefined) data.iridescence = this.iridescence;
                        if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
                        if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
                        if (this.iridescenceMap && this.iridescenceMap.isTexture) {
                            data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid
                        }
                        if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
                            data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid
                        }
                        if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
                        if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
                        if (this.anisotropyMap && this.anisotropyMap.isTexture) {
                            data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid
                        }
                        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
                        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
                        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
                        if (this.lightMap && this.lightMap.isTexture) {
                            data.lightMap = this.lightMap.toJSON(meta).uuid;
                            data.lightMapIntensity = this.lightMapIntensity
                        }
                        if (this.aoMap && this.aoMap.isTexture) {
                            data.aoMap = this.aoMap.toJSON(meta).uuid;
                            data.aoMapIntensity = this.aoMapIntensity
                        }
                        if (this.bumpMap && this.bumpMap.isTexture) {
                            data.bumpMap = this.bumpMap.toJSON(meta).uuid;
                            data.bumpScale = this.bumpScale
                        }
                        if (this.normalMap && this.normalMap.isTexture) {
                            data.normalMap = this.normalMap.toJSON(meta).uuid;
                            data.normalMapType = this.normalMapType;
                            data.normalScale = this.normalScale.toArray()
                        }
                        if (this.displacementMap && this.displacementMap.isTexture) {
                            data.displacementMap = this.displacementMap.toJSON(meta).uuid;
                            data.displacementScale = this.displacementScale;
                            data.displacementBias = this.displacementBias
                        }
                        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
                        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
                        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
                        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
                        if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
                        if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
                        if (this.envMap && this.envMap.isTexture) {
                            data.envMap = this.envMap.toJSON(meta).uuid;
                            if (this.combine !== undefined) data.combine = this.combine
                        }
                        if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();
                        if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
                        if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
                        if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
                        if (this.gradientMap && this.gradientMap.isTexture) {
                            data.gradientMap = this.gradientMap.toJSON(meta).uuid
                        }
                        if (this.transmission !== undefined) data.transmission = this.transmission;
                        if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
                        if (this.thickness !== undefined) data.thickness = this.thickness;
                        if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
                        if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
                        if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
                        if (this.size !== undefined) data.size = this.size;
                        if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
                        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
                        if (this.blending !== NormalBlending) data.blending = this.blending;
                        if (this.side !== FrontSide) data.side = this.side;
                        if (this.vertexColors === !0) data.vertexColors = !0;
                        if (this.opacity < 1) data.opacity = this.opacity;
                        if (this.transparent === !0) data.transparent = !0;
                        if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
                        if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
                        if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
                        if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
                        if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
                        if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
                        if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
                        if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
                        if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
                        if (this.depthTest === !1) data.depthTest = this.depthTest;
                        if (this.depthWrite === !1) data.depthWrite = this.depthWrite;
                        if (this.colorWrite === !1) data.colorWrite = this.colorWrite;
                        if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
                        if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
                        if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
                        if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
                        if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
                        if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
                        if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
                        if (this.stencilWrite === !0) data.stencilWrite = this.stencilWrite;
                        if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
                        if (this.polygonOffset === !0) data.polygonOffset = !0;
                        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
                        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
                        if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
                        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
                        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
                        if (this.scale !== undefined) data.scale = this.scale;
                        if (this.dithering === !0) data.dithering = !0;
                        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
                        if (this.alphaHash === !0) data.alphaHash = !0;
                        if (this.alphaToCoverage === !0) data.alphaToCoverage = !0;
                        if (this.premultipliedAlpha === !0) data.premultipliedAlpha = !0;
                        if (this.forceSinglePass === !0) data.forceSinglePass = !0;
                        if (this.wireframe === !0) data.wireframe = !0;
                        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
                        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
                        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
                        if (this.flatShading === !0) data.flatShading = !0;
                        if (this.visible === !1) data.visible = !1;
                        if (this.toneMapped === !1) data.toneMapped = !1;
                        if (this.fog === !1) data.fog = !1;
                        if (Object.keys(this.userData).length > 0) data.userData = this.userData;

                        function extractFromCache(cache) {
                            const values = [];
                            for (const key in cache) {
                                const data = cache[key];
                                delete data.metadata;
                                values.push(data)
                            }
                            return values
                        }
                        if (isRootObject) {
                            const textures = extractFromCache(meta.textures);
                            const images = extractFromCache(meta.images);
                            if (textures.length > 0) data.textures = textures;
                            if (images.length > 0) data.images = images
                        }
                        return data
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(source) {
                        this.name = source.name;
                        this.blending = source.blending;
                        this.side = source.side;
                        this.vertexColors = source.vertexColors;
                        this.opacity = source.opacity;
                        this.transparent = source.transparent;
                        this.blendSrc = source.blendSrc;
                        this.blendDst = source.blendDst;
                        this.blendEquation = source.blendEquation;
                        this.blendSrcAlpha = source.blendSrcAlpha;
                        this.blendDstAlpha = source.blendDstAlpha;
                        this.blendEquationAlpha = source.blendEquationAlpha;
                        this.blendColor.copy(source.blendColor);
                        this.blendAlpha = source.blendAlpha;
                        this.depthFunc = source.depthFunc;
                        this.depthTest = source.depthTest;
                        this.depthWrite = source.depthWrite;
                        this.stencilWriteMask = source.stencilWriteMask;
                        this.stencilFunc = source.stencilFunc;
                        this.stencilRef = source.stencilRef;
                        this.stencilFuncMask = source.stencilFuncMask;
                        this.stencilFail = source.stencilFail;
                        this.stencilZFail = source.stencilZFail;
                        this.stencilZPass = source.stencilZPass;
                        this.stencilWrite = source.stencilWrite;
                        const srcPlanes = source.clippingPlanes;
                        let dstPlanes = null;
                        if (srcPlanes !== null) {
                            const n = srcPlanes.length;
                            dstPlanes = new Array(n);
                            for (let i = 0; i !== n; ++i) {
                                dstPlanes[i] = srcPlanes[i].clone()
                            }
                        }
                        this.clippingPlanes = dstPlanes;
                        this.clipIntersection = source.clipIntersection;
                        this.clipShadows = source.clipShadows;
                        this.shadowSide = source.shadowSide;
                        this.colorWrite = source.colorWrite;
                        this.precision = source.precision;
                        this.polygonOffset = source.polygonOffset;
                        this.polygonOffsetFactor = source.polygonOffsetFactor;
                        this.polygonOffsetUnits = source.polygonOffsetUnits;
                        this.dithering = source.dithering;
                        this.alphaTest = source.alphaTest;
                        this.alphaHash = source.alphaHash;
                        this.alphaToCoverage = source.alphaToCoverage;
                        this.premultipliedAlpha = source.premultipliedAlpha;
                        this.forceSinglePass = source.forceSinglePass;
                        this.visible = source.visible;
                        this.toneMapped = source.toneMapped;
                        this.userData = JSON.parse(JSON.stringify(source.userData));
                        return this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        })
                    }
                    set needsUpdate(value) {
                        if (value === !0) this.version++
                    }
                    onBuild() {
                        console.warn('Material: onBuild() has been removed.')
                    }
                    onBeforeRender() {
                        console.warn('Material: onBeforeRender() has been removed.')
                    }
                }
                class MeshBasicMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshBasicMaterial = !0;
                        this.type = 'MeshBasicMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.lightMap = null;
                        this.lightMapIntensity = 1.0;
                        this.aoMap = null;
                        this.aoMapIntensity = 1.0;
                        this.specularMap = null;
                        this.alphaMap = null;
                        this.envMap = null;
                        this.envMapRotation = new Euler();
                        this.combine = MultiplyOperation;
                        this.reflectivity = 1;
                        this.refractionRatio = 0.98;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.wireframeLinecap = 'round';
                        this.wireframeLinejoin = 'round';
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.envMapRotation.copy(source.envMapRotation);
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.fog = source.fog;
                        return this
                    }
                }
                const _tables = _generateTables();

                function _generateTables() {
                    const buffer = new ArrayBuffer(4);
                    const floatView = new Float32Array(buffer);
                    const uint32View = new Uint32Array(buffer);
                    const baseTable = new Uint32Array(512);
                    const shiftTable = new Uint32Array(512);
                    for (let i = 0; i < 256; ++i) {
                        const e = i - 127;
                        if (e < -27) {
                            baseTable[i] = 0x0000;
                            baseTable[i | 0x100] = 0x8000;
                            shiftTable[i] = 24;
                            shiftTable[i | 0x100] = 24
                        } else if (e < -14) {
                            baseTable[i] = 0x0400 >> (-e - 14);
                            baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;
                            shiftTable[i] = -e - 1;
                            shiftTable[i | 0x100] = -e - 1
                        } else if (e <= 15) {
                            baseTable[i] = (e + 15) << 10;
                            baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;
                            shiftTable[i] = 13;
                            shiftTable[i | 0x100] = 13
                        } else if (e < 128) {
                            baseTable[i] = 0x7c00;
                            baseTable[i | 0x100] = 0xfc00;
                            shiftTable[i] = 24;
                            shiftTable[i | 0x100] = 24
                        } else {
                            baseTable[i] = 0x7c00;
                            baseTable[i | 0x100] = 0xfc00;
                            shiftTable[i] = 13;
                            shiftTable[i | 0x100] = 13
                        }
                    }
                    const mantissaTable = new Uint32Array(2048);
                    const exponentTable = new Uint32Array(64);
                    const offsetTable = new Uint32Array(64);
                    for (let i = 1; i < 1024; ++i) {
                        let m = i << 13;
                        let e = 0;
                        while ((m & 0x00800000) === 0) {
                            m <<= 1;
                            e -= 0x00800000
                        }
                        m &= ~0x00800000;
                        e += 0x38800000;
                        mantissaTable[i] = m | e
                    }
                    for (let i = 1024; i < 2048; ++i) {
                        mantissaTable[i] = 0x38000000 + ((i - 1024) << 13)
                    }
                    for (let i = 1; i < 31; ++i) {
                        exponentTable[i] = i << 23
                    }
                    exponentTable[31] = 0x47800000;
                    exponentTable[32] = 0x80000000;
                    for (let i = 33; i < 63; ++i) {
                        exponentTable[i] = 0x80000000 + ((i - 32) << 23)
                    }
                    exponentTable[63] = 0xc7800000;
                    for (let i = 1; i < 64; ++i) {
                        if (i !== 32) {
                            offsetTable[i] = 1024
                        }
                    }
                    return {
                        floatView: floatView,
                        uint32View: uint32View,
                        baseTable: baseTable,
                        shiftTable: shiftTable,
                        mantissaTable: mantissaTable,
                        exponentTable: exponentTable,
                        offsetTable: offsetTable
                    }
                }

                function toHalfFloat(val) {
                    if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
                    val = clamp(val, -65504, 65504);
                    _tables.floatView[0] = val;
                    const f = _tables.uint32View[0];
                    const e = (f >> 23) & 0x1ff;
                    return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e])
                }

                function fromHalfFloat(val) {
                    const m = val >> 10;
                    _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
                    return _tables.floatView[0]
                }
                const DataUtils = {
                    toHalfFloat: toHalfFloat,
                    fromHalfFloat: fromHalfFloat,
                };
                const _vector$9 = new Vector3();
                const _vector2$1 = new Vector2();
                class BufferAttribute {
                    constructor(array, itemSize, normalized = !1) {
                        if (Array.isArray(array)) {
                            throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.')
                        }
                        this.isBufferAttribute = !0;
                        this.name = '';
                        this.array = array;
                        this.itemSize = itemSize;
                        this.count = array !== undefined ? array.length / itemSize : 0;
                        this.normalized = normalized;
                        this.usage = StaticDrawUsage;
                        this._updateRange = {
                            offset: 0,
                            count: -1
                        };
                        this.updateRanges = [];
                        this.gpuType = FloatType;
                        this.version = 0
                    }
                    onUploadCallback() {}
                    set needsUpdate(value) {
                        if (value === !0) this.version++
                    }
                    get updateRange() {
                        warnOnce('THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.');
                        return this._updateRange
                    }
                    setUsage(value) {
                        this.usage = value;
                        return this
                    }
                    addUpdateRange(start, count) {
                        this.updateRanges.push({
                            start,
                            count
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(source) {
                        this.name = source.name;
                        this.array = new source.array.constructor(source.array);
                        this.itemSize = source.itemSize;
                        this.count = source.count;
                        this.normalized = source.normalized;
                        this.usage = source.usage;
                        this.gpuType = source.gpuType;
                        return this
                    }
                    copyAt(index1, attribute, index2) {
                        index1 *= this.itemSize;
                        index2 *= attribute.itemSize;
                        for (let i = 0, l = this.itemSize; i < l; i++) {
                            this.array[index1 + i] = attribute.array[index2 + i]
                        }
                        return this
                    }
                    copyArray(array) {
                        this.array.set(array);
                        return this
                    }
                    applyMatrix3(m) {
                        if (this.itemSize === 2) {
                            for (let i = 0, l = this.count; i < l; i++) {
                                _vector2$1.fromBufferAttribute(this, i);
                                _vector2$1.applyMatrix3(m);
                                this.setXY(i, _vector2$1.x, _vector2$1.y)
                            }
                        } else if (this.itemSize === 3) {
                            for (let i = 0, l = this.count; i < l; i++) {
                                _vector$9.fromBufferAttribute(this, i);
                                _vector$9.applyMatrix3(m);
                                this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)
                            }
                        }
                        return this
                    }
                    applyMatrix4(m) {
                        for (let i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.applyMatrix4(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)
                        }
                        return this
                    }
                    applyNormalMatrix(m) {
                        for (let i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.applyNormalMatrix(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)
                        }
                        return this
                    }
                    transformDirection(m) {
                        for (let i = 0, l = this.count; i < l; i++) {
                            _vector$9.fromBufferAttribute(this, i);
                            _vector$9.transformDirection(m);
                            this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z)
                        }
                        return this
                    }
                    set(value, offset = 0) {
                        this.array.set(value, offset);
                        return this
                    }
                    getComponent(index, component) {
                        let value = this.array[index * this.itemSize + component];
                        if (this.normalized) value = denormalize(value, this.array);
                        return value
                    }
                    setComponent(index, component, value) {
                        if (this.normalized) value = normalize(value, this.array);
                        this.array[index * this.itemSize + component] = value;
                        return this
                    }
                    getX(index) {
                        let x = this.array[index * this.itemSize];
                        if (this.normalized) x = denormalize(x, this.array);
                        return x
                    }
                    setX(index, x) {
                        if (this.normalized) x = normalize(x, this.array);
                        this.array[index * this.itemSize] = x;
                        return this
                    }
                    getY(index) {
                        let y = this.array[index * this.itemSize + 1];
                        if (this.normalized) y = denormalize(y, this.array);
                        return y
                    }
                    setY(index, y) {
                        if (this.normalized) y = normalize(y, this.array);
                        this.array[index * this.itemSize + 1] = y;
                        return this
                    }
                    getZ(index) {
                        let z = this.array[index * this.itemSize + 2];
                        if (this.normalized) z = denormalize(z, this.array);
                        return z
                    }
                    setZ(index, z) {
                        if (this.normalized) z = normalize(z, this.array);
                        this.array[index * this.itemSize + 2] = z;
                        return this
                    }
                    getW(index) {
                        let w = this.array[index * this.itemSize + 3];
                        if (this.normalized) w = denormalize(w, this.array);
                        return w
                    }
                    setW(index, w) {
                        if (this.normalized) w = normalize(w, this.array);
                        this.array[index * this.itemSize + 3] = w;
                        return this
                    }
                    setXY(index, x, y) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array)
                        }
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        return this
                    }
                    setXYZ(index, x, y, z) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array)
                        }
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        this.array[index + 2] = z;
                        return this
                    }
                    setXYZW(index, x, y, z, w) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array);
                            w = normalize(w, this.array)
                        }
                        this.array[index + 0] = x;
                        this.array[index + 1] = y;
                        this.array[index + 2] = z;
                        this.array[index + 3] = w;
                        return this
                    }
                    onUpload(callback) {
                        this.onUploadCallback = callback;
                        return this
                    }
                    clone() {
                        return new this.constructor(this.array, this.itemSize).copy(this)
                    }
                    toJSON() {
                        const data = {
                            itemSize: this.itemSize,
                            type: this.array.constructor.name,
                            array: Array.from(this.array),
                            normalized: this.normalized
                        };
                        if (this.name !== '') data.name = this.name;
                        if (this.usage !== StaticDrawUsage) data.usage = this.usage;
                        return data
                    }
                }
                class Int8BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Int8Array(array), itemSize, normalized)
                    }
                }
                class Uint8BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Uint8Array(array), itemSize, normalized)
                    }
                }
                class Uint8ClampedBufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Uint8ClampedArray(array), itemSize, normalized)
                    }
                }
                class Int16BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Int16Array(array), itemSize, normalized)
                    }
                }
                class Uint16BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Uint16Array(array), itemSize, normalized)
                    }
                }
                class Int32BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Int32Array(array), itemSize, normalized)
                    }
                }
                class Uint32BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Uint32Array(array), itemSize, normalized)
                    }
                }
                class Float16BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Uint16Array(array), itemSize, normalized);
                        this.isFloat16BufferAttribute = !0
                    }
                    getX(index) {
                        let x = fromHalfFloat(this.array[index * this.itemSize]);
                        if (this.normalized) x = denormalize(x, this.array);
                        return x
                    }
                    setX(index, x) {
                        if (this.normalized) x = normalize(x, this.array);
                        this.array[index * this.itemSize] = toHalfFloat(x);
                        return this
                    }
                    getY(index) {
                        let y = fromHalfFloat(this.array[index * this.itemSize + 1]);
                        if (this.normalized) y = denormalize(y, this.array);
                        return y
                    }
                    setY(index, y) {
                        if (this.normalized) y = normalize(y, this.array);
                        this.array[index * this.itemSize + 1] = toHalfFloat(y);
                        return this
                    }
                    getZ(index) {
                        let z = fromHalfFloat(this.array[index * this.itemSize + 2]);
                        if (this.normalized) z = denormalize(z, this.array);
                        return z
                    }
                    setZ(index, z) {
                        if (this.normalized) z = normalize(z, this.array);
                        this.array[index * this.itemSize + 2] = toHalfFloat(z);
                        return this
                    }
                    getW(index) {
                        let w = fromHalfFloat(this.array[index * this.itemSize + 3]);
                        if (this.normalized) w = denormalize(w, this.array);
                        return w
                    }
                    setW(index, w) {
                        if (this.normalized) w = normalize(w, this.array);
                        this.array[index * this.itemSize + 3] = toHalfFloat(w);
                        return this
                    }
                    setXY(index, x, y) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array)
                        }
                        this.array[index + 0] = toHalfFloat(x);
                        this.array[index + 1] = toHalfFloat(y);
                        return this
                    }
                    setXYZ(index, x, y, z) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array)
                        }
                        this.array[index + 0] = toHalfFloat(x);
                        this.array[index + 1] = toHalfFloat(y);
                        this.array[index + 2] = toHalfFloat(z);
                        return this
                    }
                    setXYZW(index, x, y, z, w) {
                        index *= this.itemSize;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array);
                            w = normalize(w, this.array)
                        }
                        this.array[index + 0] = toHalfFloat(x);
                        this.array[index + 1] = toHalfFloat(y);
                        this.array[index + 2] = toHalfFloat(z);
                        this.array[index + 3] = toHalfFloat(w);
                        return this
                    }
                }
                class Float32BufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized) {
                        super(new Float32Array(array), itemSize, normalized)
                    }
                }
                let _id$2 = 0;
                const _m1$2 = new Matrix4();
                const _obj = new Object3D();
                const _offset = new Vector3();
                const _box$2 = new Box3();
                const _boxMorphTargets = new Box3();
                const _vector$8 = new Vector3();
                class BufferGeometry extends EventDispatcher {
                    constructor() {
                        super();
                        this.isBufferGeometry = !0;
                        Object.defineProperty(this, 'id', {
                            value: _id$2++
                        });
                        this.uuid = generateUUID();
                        this.name = '';
                        this.type = 'BufferGeometry';
                        this.index = null;
                        this.attributes = {};
                        this.morphAttributes = {};
                        this.morphTargetsRelative = !1;
                        this.groups = [];
                        this.boundingBox = null;
                        this.boundingSphere = null;
                        this.drawRange = {
                            start: 0,
                            count: Infinity
                        };
                        this.userData = {}
                    }
                    getIndex() {
                        return this.index
                    }
                    setIndex(index) {
                        if (Array.isArray(index)) {
                            this.index = new(arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1)
                        } else {
                            this.index = index
                        }
                        return this
                    }
                    getAttribute(name) {
                        return this.attributes[name]
                    }
                    setAttribute(name, attribute) {
                        this.attributes[name] = attribute;
                        return this
                    }
                    deleteAttribute(name) {
                        delete this.attributes[name];
                        return this
                    }
                    hasAttribute(name) {
                        return this.attributes[name] !== undefined
                    }
                    addGroup(start, count, materialIndex = 0) {
                        this.groups.push({
                            start: start,
                            count: count,
                            materialIndex: materialIndex
                        })
                    }
                    clearGroups() {
                        this.groups = []
                    }
                    setDrawRange(start, count) {
                        this.drawRange.start = start;
                        this.drawRange.count = count
                    }
                    applyMatrix4(matrix) {
                        const position = this.attributes.position;
                        if (position !== undefined) {
                            position.applyMatrix4(matrix);
                            position.needsUpdate = !0
                        }
                        const normal = this.attributes.normal;
                        if (normal !== undefined) {
                            const normalMatrix = new Matrix3().getNormalMatrix(matrix);
                            normal.applyNormalMatrix(normalMatrix);
                            normal.needsUpdate = !0
                        }
                        const tangent = this.attributes.tangent;
                        if (tangent !== undefined) {
                            tangent.transformDirection(matrix);
                            tangent.needsUpdate = !0
                        }
                        if (this.boundingBox !== null) {
                            this.computeBoundingBox()
                        }
                        if (this.boundingSphere !== null) {
                            this.computeBoundingSphere()
                        }
                        return this
                    }
                    applyQuaternion(q) {
                        _m1$2.makeRotationFromQuaternion(q);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    rotateX(angle) {
                        _m1$2.makeRotationX(angle);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    rotateY(angle) {
                        _m1$2.makeRotationY(angle);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    rotateZ(angle) {
                        _m1$2.makeRotationZ(angle);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    translate(x, y, z) {
                        _m1$2.makeTranslation(x, y, z);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    scale(x, y, z) {
                        _m1$2.makeScale(x, y, z);
                        this.applyMatrix4(_m1$2);
                        return this
                    }
                    lookAt(vector) {
                        _obj.lookAt(vector);
                        _obj.updateMatrix();
                        this.applyMatrix4(_obj.matrix);
                        return this
                    }
                    center() {
                        this.computeBoundingBox();
                        this.boundingBox.getCenter(_offset).negate();
                        this.translate(_offset.x, _offset.y, _offset.z);
                        return this
                    }
                    setFromPoints(points) {
                        const position = [];
                        for (let i = 0, l = points.length; i < l; i++) {
                            const point = points[i];
                            position.push(point.x, point.y, point.z || 0)
                        }
                        this.setAttribute('position', new Float32BufferAttribute(position, 3));
                        return this
                    }
                    computeBoundingBox() {
                        if (this.boundingBox === null) {
                            this.boundingBox = new Box3()
                        }
                        const position = this.attributes.position;
                        const morphAttributesPosition = this.morphAttributes.position;
                        if (position && position.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
                            this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
                            return
                        }
                        if (position !== undefined) {
                            this.boundingBox.setFromBufferAttribute(position);
                            if (morphAttributesPosition) {
                                for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    const morphAttribute = morphAttributesPosition[i];
                                    _box$2.setFromBufferAttribute(morphAttribute);
                                    if (this.morphTargetsRelative) {
                                        _vector$8.addVectors(this.boundingBox.min, _box$2.min);
                                        this.boundingBox.expandByPoint(_vector$8);
                                        _vector$8.addVectors(this.boundingBox.max, _box$2.max);
                                        this.boundingBox.expandByPoint(_vector$8)
                                    } else {
                                        this.boundingBox.expandByPoint(_box$2.min);
                                        this.boundingBox.expandByPoint(_box$2.max)
                                    }
                                }
                            }
                        } else {
                            this.boundingBox.makeEmpty()
                        }
                        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
                            console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                    computeBoundingSphere() {
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere()
                        }
                        const position = this.attributes.position;
                        const morphAttributesPosition = this.morphAttributes.position;
                        if (position && position.isGLBufferAttribute) {
                            console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
                            this.boundingSphere.set(new Vector3(), Infinity);
                            return
                        }
                        if (position) {
                            const center = this.boundingSphere.center;
                            _box$2.setFromBufferAttribute(position);
                            if (morphAttributesPosition) {
                                for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    const morphAttribute = morphAttributesPosition[i];
                                    _boxMorphTargets.setFromBufferAttribute(morphAttribute);
                                    if (this.morphTargetsRelative) {
                                        _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
                                        _box$2.expandByPoint(_vector$8);
                                        _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
                                        _box$2.expandByPoint(_vector$8)
                                    } else {
                                        _box$2.expandByPoint(_boxMorphTargets.min);
                                        _box$2.expandByPoint(_boxMorphTargets.max)
                                    }
                                }
                            }
                            _box$2.getCenter(center);
                            let maxRadiusSq = 0;
                            for (let i = 0, il = position.count; i < il; i++) {
                                _vector$8.fromBufferAttribute(position, i);
                                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8))
                            }
                            if (morphAttributesPosition) {
                                for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
                                    const morphAttribute = morphAttributesPosition[i];
                                    const morphTargetsRelative = this.morphTargetsRelative;
                                    for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
                                        _vector$8.fromBufferAttribute(morphAttribute, j);
                                        if (morphTargetsRelative) {
                                            _offset.fromBufferAttribute(position, j);
                                            _vector$8.add(_offset)
                                        }
                                        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8))
                                    }
                                }
                            }
                            this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
                            if (isNaN(this.boundingSphere.radius)) {
                                console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                            }
                        }
                    }
                    computeTangents() {
                        const index = this.index;
                        const attributes = this.attributes;
                        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
                            console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
                            return
                        }
                        const positionAttribute = attributes.position;
                        const normalAttribute = attributes.normal;
                        const uvAttribute = attributes.uv;
                        if (this.hasAttribute('tangent') === !1) {
                            this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4))
                        }
                        const tangentAttribute = this.getAttribute('tangent');
                        const tan1 = [],
                            tan2 = [];
                        for (let i = 0; i < positionAttribute.count; i++) {
                            tan1[i] = new Vector3();
                            tan2[i] = new Vector3()
                        }
                        const vA = new Vector3(),
                            vB = new Vector3(),
                            vC = new Vector3(),
                            uvA = new Vector2(),
                            uvB = new Vector2(),
                            uvC = new Vector2(),
                            sdir = new Vector3(),
                            tdir = new Vector3();

                        function handleTriangle(a, b, c) {
                            vA.fromBufferAttribute(positionAttribute, a);
                            vB.fromBufferAttribute(positionAttribute, b);
                            vC.fromBufferAttribute(positionAttribute, c);
                            uvA.fromBufferAttribute(uvAttribute, a);
                            uvB.fromBufferAttribute(uvAttribute, b);
                            uvC.fromBufferAttribute(uvAttribute, c);
                            vB.sub(vA);
                            vC.sub(vA);
                            uvB.sub(uvA);
                            uvC.sub(uvA);
                            const r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);
                            if (!isFinite(r)) return;
                            sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
                            tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
                            tan1[a].add(sdir);
                            tan1[b].add(sdir);
                            tan1[c].add(sdir);
                            tan2[a].add(tdir);
                            tan2[b].add(tdir);
                            tan2[c].add(tdir)
                        }
                        let groups = this.groups;
                        if (groups.length === 0) {
                            groups = [{
                                start: 0,
                                count: index.count
                            }]
                        }
                        for (let i = 0, il = groups.length; i < il; ++i) {
                            const group = groups[i];
                            const start = group.start;
                            const count = group.count;
                            for (let j = start, jl = start + count; j < jl; j += 3) {
                                handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2))
                            }
                        }
                        const tmp = new Vector3(),
                            tmp2 = new Vector3();
                        const n = new Vector3(),
                            n2 = new Vector3();

                        function handleVertex(v) {
                            n.fromBufferAttribute(normalAttribute, v);
                            n2.copy(n);
                            const t = tan1[v];
                            tmp.copy(t);
                            tmp.sub(n.multiplyScalar(n.dot(t))).normalize();
                            tmp2.crossVectors(n2, t);
                            const test = tmp2.dot(tan2[v]);
                            const w = (test < 0.0) ? -1.0 : 1.0;
                            tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w)
                        }
                        for (let i = 0, il = groups.length; i < il; ++i) {
                            const group = groups[i];
                            const start = group.start;
                            const count = group.count;
                            for (let j = start, jl = start + count; j < jl; j += 3) {
                                handleVertex(index.getX(j + 0));
                                handleVertex(index.getX(j + 1));
                                handleVertex(index.getX(j + 2))
                            }
                        }
                    }
                    computeVertexNormals() {
                        const index = this.index;
                        const positionAttribute = this.getAttribute('position');
                        if (positionAttribute !== undefined) {
                            let normalAttribute = this.getAttribute('normal');
                            if (normalAttribute === undefined) {
                                normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
                                this.setAttribute('normal', normalAttribute)
                            } else {
                                for (let i = 0, il = normalAttribute.count; i < il; i++) {
                                    normalAttribute.setXYZ(i, 0, 0, 0)
                                }
                            }
                            const pA = new Vector3(),
                                pB = new Vector3(),
                                pC = new Vector3();
                            const nA = new Vector3(),
                                nB = new Vector3(),
                                nC = new Vector3();
                            const cb = new Vector3(),
                                ab = new Vector3();
                            if (index) {
                                for (let i = 0, il = index.count; i < il; i += 3) {
                                    const vA = index.getX(i + 0);
                                    const vB = index.getX(i + 1);
                                    const vC = index.getX(i + 2);
                                    pA.fromBufferAttribute(positionAttribute, vA);
                                    pB.fromBufferAttribute(positionAttribute, vB);
                                    pC.fromBufferAttribute(positionAttribute, vC);
                                    cb.subVectors(pC, pB);
                                    ab.subVectors(pA, pB);
                                    cb.cross(ab);
                                    nA.fromBufferAttribute(normalAttribute, vA);
                                    nB.fromBufferAttribute(normalAttribute, vB);
                                    nC.fromBufferAttribute(normalAttribute, vC);
                                    nA.add(cb);
                                    nB.add(cb);
                                    nC.add(cb);
                                    normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
                                    normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
                                    normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z)
                                }
                            } else {
                                for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
                                    pA.fromBufferAttribute(positionAttribute, i + 0);
                                    pB.fromBufferAttribute(positionAttribute, i + 1);
                                    pC.fromBufferAttribute(positionAttribute, i + 2);
                                    cb.subVectors(pC, pB);
                                    ab.subVectors(pA, pB);
                                    cb.cross(ab);
                                    normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
                                    normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
                                    normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z)
                                }
                            }
                            this.normalizeNormals();
                            normalAttribute.needsUpdate = !0
                        }
                    }
                    normalizeNormals() {
                        const normals = this.attributes.normal;
                        for (let i = 0, il = normals.count; i < il; i++) {
                            _vector$8.fromBufferAttribute(normals, i);
                            _vector$8.normalize();
                            normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z)
                        }
                    }
                    toNonIndexed() {
                        function convertBufferAttribute(attribute, indices) {
                            const array = attribute.array;
                            const itemSize = attribute.itemSize;
                            const normalized = attribute.normalized;
                            const array2 = new array.constructor(indices.length * itemSize);
                            let index = 0,
                                index2 = 0;
                            for (let i = 0, l = indices.length; i < l; i++) {
                                if (attribute.isInterleavedBufferAttribute) {
                                    index = indices[i] * attribute.data.stride + attribute.offset
                                } else {
                                    index = indices[i] * itemSize
                                }
                                for (let j = 0; j < itemSize; j++) {
                                    array2[index2++] = array[index++]
                                }
                            }
                            return new BufferAttribute(array2, itemSize, normalized)
                        }
                        if (this.index === null) {
                            console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
                            return this
                        }
                        const geometry2 = new BufferGeometry();
                        const indices = this.index.array;
                        const attributes = this.attributes;
                        for (const name in attributes) {
                            const attribute = attributes[name];
                            const newAttribute = convertBufferAttribute(attribute, indices);
                            geometry2.setAttribute(name, newAttribute)
                        }
                        const morphAttributes = this.morphAttributes;
                        for (const name in morphAttributes) {
                            const morphArray = [];
                            const morphAttribute = morphAttributes[name];
                            for (let i = 0, il = morphAttribute.length; i < il; i++) {
                                const attribute = morphAttribute[i];
                                const newAttribute = convertBufferAttribute(attribute, indices);
                                morphArray.push(newAttribute)
                            }
                            geometry2.morphAttributes[name] = morphArray
                        }
                        geometry2.morphTargetsRelative = this.morphTargetsRelative;
                        const groups = this.groups;
                        for (let i = 0, l = groups.length; i < l; i++) {
                            const group = groups[i];
                            geometry2.addGroup(group.start, group.count, group.materialIndex)
                        }
                        return geometry2
                    }
                    toJSON() {
                        const data = {
                            metadata: {
                                version: 4.6,
                                type: 'BufferGeometry',
                                generator: 'BufferGeometry.toJSON'
                            }
                        };
                        data.uuid = this.uuid;
                        data.type = this.type;
                        if (this.name !== '') data.name = this.name;
                        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
                        if (this.parameters !== undefined) {
                            const parameters = this.parameters;
                            for (const key in parameters) {
                                if (parameters[key] !== undefined) data[key] = parameters[key]
                            }
                            return data
                        }
                        data.data = {
                            attributes: {}
                        };
                        const index = this.index;
                        if (index !== null) {
                            data.data.index = {
                                type: index.array.constructor.name,
                                array: Array.prototype.slice.call(index.array)
                            }
                        }
                        const attributes = this.attributes;
                        for (const key in attributes) {
                            const attribute = attributes[key];
                            data.data.attributes[key] = attribute.toJSON(data.data)
                        }
                        const morphAttributes = {};
                        let hasMorphAttributes = !1;
                        for (const key in this.morphAttributes) {
                            const attributeArray = this.morphAttributes[key];
                            const array = [];
                            for (let i = 0, il = attributeArray.length; i < il; i++) {
                                const attribute = attributeArray[i];
                                array.push(attribute.toJSON(data.data))
                            }
                            if (array.length > 0) {
                                morphAttributes[key] = array;
                                hasMorphAttributes = !0
                            }
                        }
                        if (hasMorphAttributes) {
                            data.data.morphAttributes = morphAttributes;
                            data.data.morphTargetsRelative = this.morphTargetsRelative
                        }
                        const groups = this.groups;
                        if (groups.length > 0) {
                            data.data.groups = JSON.parse(JSON.stringify(groups))
                        }
                        const boundingSphere = this.boundingSphere;
                        if (boundingSphere !== null) {
                            data.data.boundingSphere = {
                                center: boundingSphere.center.toArray(),
                                radius: boundingSphere.radius
                            }
                        }
                        return data
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(source) {
                        this.index = null;
                        this.attributes = {};
                        this.morphAttributes = {};
                        this.groups = [];
                        this.boundingBox = null;
                        this.boundingSphere = null;
                        const data = {};
                        this.name = source.name;
                        const index = source.index;
                        if (index !== null) {
                            this.setIndex(index.clone(data))
                        }
                        const attributes = source.attributes;
                        for (const name in attributes) {
                            const attribute = attributes[name];
                            this.setAttribute(name, attribute.clone(data))
                        }
                        const morphAttributes = source.morphAttributes;
                        for (const name in morphAttributes) {
                            const array = [];
                            const morphAttribute = morphAttributes[name];
                            for (let i = 0, l = morphAttribute.length; i < l; i++) {
                                array.push(morphAttribute[i].clone(data))
                            }
                            this.morphAttributes[name] = array
                        }
                        this.morphTargetsRelative = source.morphTargetsRelative;
                        const groups = source.groups;
                        for (let i = 0, l = groups.length; i < l; i++) {
                            const group = groups[i];
                            this.addGroup(group.start, group.count, group.materialIndex)
                        }
                        const boundingBox = source.boundingBox;
                        if (boundingBox !== null) {
                            this.boundingBox = boundingBox.clone()
                        }
                        const boundingSphere = source.boundingSphere;
                        if (boundingSphere !== null) {
                            this.boundingSphere = boundingSphere.clone()
                        }
                        this.drawRange.start = source.drawRange.start;
                        this.drawRange.count = source.drawRange.count;
                        this.userData = source.userData;
                        return this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        })
                    }
                }
                const _inverseMatrix$3 = new Matrix4();
                const _ray$3 = new Ray();
                const _sphere$6 = new Sphere();
                const _sphereHitAt = new Vector3();
                const _vA$1 = new Vector3();
                const _vB$1 = new Vector3();
                const _vC$1 = new Vector3();
                const _tempA = new Vector3();
                const _morphA = new Vector3();
                const _uvA$1 = new Vector2();
                const _uvB$1 = new Vector2();
                const _uvC$1 = new Vector2();
                const _normalA = new Vector3();
                const _normalB = new Vector3();
                const _normalC = new Vector3();
                const _intersectionPoint = new Vector3();
                const _intersectionPointWorld = new Vector3();
                class Mesh extends Object3D {
                    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
                        super();
                        this.isMesh = !0;
                        this.type = 'Mesh';
                        this.geometry = geometry;
                        this.material = material;
                        this.updateMorphTargets()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        if (source.morphTargetInfluences !== undefined) {
                            this.morphTargetInfluences = source.morphTargetInfluences.slice()
                        }
                        if (source.morphTargetDictionary !== undefined) {
                            this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)
                        }
                        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
                        this.geometry = source.geometry;
                        return this
                    }
                    updateMorphTargets() {
                        const geometry = this.geometry;
                        const morphAttributes = geometry.morphAttributes;
                        const keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            const morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    const name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m
                                }
                            }
                        }
                    }
                    getVertexPosition(index, target) {
                        const geometry = this.geometry;
                        const position = geometry.attributes.position;
                        const morphPosition = geometry.morphAttributes.position;
                        const morphTargetsRelative = geometry.morphTargetsRelative;
                        target.fromBufferAttribute(position, index);
                        const morphInfluences = this.morphTargetInfluences;
                        if (morphPosition && morphInfluences) {
                            _morphA.set(0, 0, 0);
                            for (let i = 0, il = morphPosition.length; i < il; i++) {
                                const influence = morphInfluences[i];
                                const morphAttribute = morphPosition[i];
                                if (influence === 0) continue;
                                _tempA.fromBufferAttribute(morphAttribute, index);
                                if (morphTargetsRelative) {
                                    _morphA.addScaledVector(_tempA, influence)
                                } else {
                                    _morphA.addScaledVector(_tempA.sub(target), influence)
                                }
                            }
                            target.add(_morphA)
                        }
                        return target
                    }
                    raycast(raycaster, intersects) {
                        const geometry = this.geometry;
                        const material = this.material;
                        const matrixWorld = this.matrixWorld;
                        if (material === undefined) return;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        _sphere$6.copy(geometry.boundingSphere);
                        _sphere$6.applyMatrix4(matrixWorld);
                        _ray$3.copy(raycaster.ray).recast(raycaster.near);
                        if (_sphere$6.containsPoint(_ray$3.origin) === !1) {
                            if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
                            if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return
                        }
                        _inverseMatrix$3.copy(matrixWorld).invert();
                        _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
                        if (geometry.boundingBox !== null) {
                            if (_ray$3.intersectsBox(geometry.boundingBox) === !1) return
                        }
                        this._computeIntersections(raycaster, intersects, _ray$3)
                    }
                    _computeIntersections(raycaster, intersects, rayLocalSpace) {
                        let intersection;
                        const geometry = this.geometry;
                        const material = this.material;
                        const index = geometry.index;
                        const position = geometry.attributes.position;
                        const uv = geometry.attributes.uv;
                        const uv1 = geometry.attributes.uv1;
                        const normal = geometry.attributes.normal;
                        const groups = geometry.groups;
                        const drawRange = geometry.drawRange;
                        if (index !== null) {
                            if (Array.isArray(material)) {
                                for (let i = 0, il = groups.length; i < il; i++) {
                                    const group = groups[i];
                                    const groupMaterial = material[group.materialIndex];
                                    const start = Math.max(group.start, drawRange.start);
                                    const end = Math.min(index.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                                    for (let j = start, jl = end; j < jl; j += 3) {
                                        const a = index.getX(j);
                                        const b = index.getX(j + 1);
                                        const c = index.getX(j + 2);
                                        intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(j / 3);
                                            intersection.face.materialIndex = group.materialIndex;
                                            intersects.push(intersection)
                                        }
                                    }
                                }
                            } else {
                                const start = Math.max(0, drawRange.start);
                                const end = Math.min(index.count, (drawRange.start + drawRange.count));
                                for (let i = start, il = end; i < il; i += 3) {
                                    const a = index.getX(i);
                                    const b = index.getX(i + 1);
                                    const c = index.getX(i + 2);
                                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(i / 3);
                                        intersects.push(intersection)
                                    }
                                }
                            }
                        } else if (position !== undefined) {
                            if (Array.isArray(material)) {
                                for (let i = 0, il = groups.length; i < il; i++) {
                                    const group = groups[i];
                                    const groupMaterial = material[group.materialIndex];
                                    const start = Math.max(group.start, drawRange.start);
                                    const end = Math.min(position.count, Math.min((group.start + group.count), (drawRange.start + drawRange.count)));
                                    for (let j = start, jl = end; j < jl; j += 3) {
                                        const a = j;
                                        const b = j + 1;
                                        const c = j + 2;
                                        intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                                        if (intersection) {
                                            intersection.faceIndex = Math.floor(j / 3);
                                            intersection.face.materialIndex = group.materialIndex;
                                            intersects.push(intersection)
                                        }
                                    }
                                }
                            } else {
                                const start = Math.max(0, drawRange.start);
                                const end = Math.min(position.count, (drawRange.start + drawRange.count));
                                for (let i = start, il = end; i < il; i += 3) {
                                    const a = i;
                                    const b = i + 1;
                                    const c = i + 2;
                                    intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                                    if (intersection) {
                                        intersection.faceIndex = Math.floor(i / 3);
                                        intersects.push(intersection)
                                    }
                                }
                            }
                        }
                    }
                }

                function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
                    let intersect;
                    if (material.side === BackSide) {
                        intersect = ray.intersectTriangle(pC, pB, pA, !0, point)
                    } else {
                        intersect = ray.intersectTriangle(pA, pB, pC, (material.side === FrontSide), point)
                    }
                    if (intersect === null) return null;
                    _intersectionPointWorld.copy(point);
                    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
                    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
                    if (distance < raycaster.near || distance > raycaster.far) return null;
                    return {
                        distance: distance,
                        point: _intersectionPointWorld.clone(),
                        object: object
                    }
                }

                function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
                    object.getVertexPosition(a, _vA$1);
                    object.getVertexPosition(b, _vB$1);
                    object.getVertexPosition(c, _vC$1);
                    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
                    if (intersection) {
                        if (uv) {
                            _uvA$1.fromBufferAttribute(uv, a);
                            _uvB$1.fromBufferAttribute(uv, b);
                            _uvC$1.fromBufferAttribute(uv, c);
                            intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())
                        }
                        if (uv1) {
                            _uvA$1.fromBufferAttribute(uv1, a);
                            _uvB$1.fromBufferAttribute(uv1, b);
                            _uvC$1.fromBufferAttribute(uv1, c);
                            intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2())
                        }
                        if (normal) {
                            _normalA.fromBufferAttribute(normal, a);
                            _normalB.fromBufferAttribute(normal, b);
                            _normalC.fromBufferAttribute(normal, c);
                            intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector3());
                            if (intersection.normal.dot(ray.direction) > 0) {
                                intersection.normal.multiplyScalar(-1)
                            }
                        }
                        const face = {
                            a: a,
                            b: b,
                            c: c,
                            normal: new Vector3(),
                            materialIndex: 0
                        };
                        Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
                        intersection.face = face
                    }
                    return intersection
                }
                class BoxGeometry extends BufferGeometry {
                    constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
                        super();
                        this.type = 'BoxGeometry';
                        this.parameters = {
                            width: width,
                            height: height,
                            depth: depth,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments,
                            depthSegments: depthSegments
                        };
                        const scope = this;
                        widthSegments = Math.floor(widthSegments);
                        heightSegments = Math.floor(heightSegments);
                        depthSegments = Math.floor(depthSegments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        let numberOfVertices = 0;
                        let groupStart = 0;
                        buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0);
                        buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
                        buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2);
                        buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
                        buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4);
                        buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
                            const segmentWidth = width / gridX;
                            const segmentHeight = height / gridY;
                            const widthHalf = width / 2;
                            const heightHalf = height / 2;
                            const depthHalf = depth / 2;
                            const gridX1 = gridX + 1;
                            const gridY1 = gridY + 1;
                            let vertexCounter = 0;
                            let groupCount = 0;
                            const vector = new Vector3();
                            for (let iy = 0; iy < gridY1; iy++) {
                                const y = iy * segmentHeight - heightHalf;
                                for (let ix = 0; ix < gridX1; ix++) {
                                    const x = ix * segmentWidth - widthHalf;
                                    vector[u] = x * udir;
                                    vector[v] = y * vdir;
                                    vector[w] = depthHalf;
                                    vertices.push(vector.x, vector.y, vector.z);
                                    vector[u] = 0;
                                    vector[v] = 0;
                                    vector[w] = depth > 0 ? 1 : -1;
                                    normals.push(vector.x, vector.y, vector.z);
                                    uvs.push(ix / gridX);
                                    uvs.push(1 - (iy / gridY));
                                    vertexCounter += 1
                                }
                            }
                            for (let iy = 0; iy < gridY; iy++) {
                                for (let ix = 0; ix < gridX; ix++) {
                                    const a = numberOfVertices + ix + gridX1 * iy;
                                    const b = numberOfVertices + ix + gridX1 * (iy + 1);
                                    const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
                                    const d = numberOfVertices + (ix + 1) + gridX1 * iy;
                                    indices.push(a, b, d);
                                    indices.push(b, c, d);
                                    groupCount += 6
                                }
                            }
                            scope.addGroup(groupStart, groupCount, materialIndex);
                            groupStart += groupCount;
                            numberOfVertices += vertexCounter
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)
                    }
                }

                function cloneUniforms(src) {
                    const dst = {};
                    for (const u in src) {
                        dst[u] = {};
                        for (const p in src[u]) {
                            const property = src[u][p];
                            if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
                                if (property.isRenderTargetTexture) {
                                    console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
                                    dst[u][p] = null
                                } else {
                                    dst[u][p] = property.clone()
                                }
                            } else if (Array.isArray(property)) {
                                dst[u][p] = property.slice()
                            } else {
                                dst[u][p] = property
                            }
                        }
                    }
                    return dst
                }

                function mergeUniforms(uniforms) {
                    const merged = {};
                    for (let u = 0; u < uniforms.length; u++) {
                        const tmp = cloneUniforms(uniforms[u]);
                        for (const p in tmp) {
                            merged[p] = tmp[p]
                        }
                    }
                    return merged
                }

                function cloneUniformsGroups(src) {
                    const dst = [];
                    for (let u = 0; u < src.length; u++) {
                        dst.push(src[u].clone())
                    }
                    return dst
                }

                function getUnlitUniformColorSpace(renderer) {
                    const currentRenderTarget = renderer.getRenderTarget();
                    if (currentRenderTarget === null) {
                        return renderer.outputColorSpace
                    }
                    if (currentRenderTarget.isXRRenderTarget === !0) {
                        return currentRenderTarget.texture.colorSpace
                    }
                    return ColorManagement.workingColorSpace
                }
                const UniformsUtils = {
                    clone: cloneUniforms,
                    merge: mergeUniforms
                };
                var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
                var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
                class ShaderMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isShaderMaterial = !0;
                        this.type = 'ShaderMaterial';
                        this.defines = {};
                        this.uniforms = {};
                        this.uniformsGroups = [];
                        this.vertexShader = default_vertex;
                        this.fragmentShader = default_fragment;
                        this.linewidth = 1;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.fog = !1;
                        this.lights = !1;
                        this.clipping = !1;
                        this.forceSinglePass = !0;
                        this.extensions = {
                            clipCullDistance: !1,
                            multiDraw: !1
                        };
                        this.defaultAttributeValues = {
                            'color': [1, 1, 1],
                            'uv': [0, 0],
                            'uv1': [0, 0]
                        };
                        this.index0AttributeName = undefined;
                        this.uniformsNeedUpdate = !1;
                        this.glslVersion = null;
                        if (parameters !== undefined) {
                            this.setValues(parameters)
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.fragmentShader = source.fragmentShader;
                        this.vertexShader = source.vertexShader;
                        this.uniforms = cloneUniforms(source.uniforms);
                        this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
                        this.defines = Object.assign({}, source.defines);
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.fog = source.fog;
                        this.lights = source.lights;
                        this.clipping = source.clipping;
                        this.extensions = Object.assign({}, source.extensions);
                        this.glslVersion = source.glslVersion;
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.glslVersion = this.glslVersion;
                        data.uniforms = {};
                        for (const name in this.uniforms) {
                            const uniform = this.uniforms[name];
                            const value = uniform.value;
                            if (value && value.isTexture) {
                                data.uniforms[name] = {
                                    type: 't',
                                    value: value.toJSON(meta).uuid
                                }
                            } else if (value && value.isColor) {
                                data.uniforms[name] = {
                                    type: 'c',
                                    value: value.getHex()
                                }
                            } else if (value && value.isVector2) {
                                data.uniforms[name] = {
                                    type: 'v2',
                                    value: value.toArray()
                                }
                            } else if (value && value.isVector3) {
                                data.uniforms[name] = {
                                    type: 'v3',
                                    value: value.toArray()
                                }
                            } else if (value && value.isVector4) {
                                data.uniforms[name] = {
                                    type: 'v4',
                                    value: value.toArray()
                                }
                            } else if (value && value.isMatrix3) {
                                data.uniforms[name] = {
                                    type: 'm3',
                                    value: value.toArray()
                                }
                            } else if (value && value.isMatrix4) {
                                data.uniforms[name] = {
                                    type: 'm4',
                                    value: value.toArray()
                                }
                            } else {
                                data.uniforms[name] = {
                                    value: value
                                }
                            }
                        }
                        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
                        data.vertexShader = this.vertexShader;
                        data.fragmentShader = this.fragmentShader;
                        data.lights = this.lights;
                        data.clipping = this.clipping;
                        const extensions = {};
                        for (const key in this.extensions) {
                            if (this.extensions[key] === !0) extensions[key] = !0
                        }
                        if (Object.keys(extensions).length > 0) data.extensions = extensions;
                        return data
                    }
                }
                class Camera extends Object3D {
                    constructor() {
                        super();
                        this.isCamera = !0;
                        this.type = 'Camera';
                        this.matrixWorldInverse = new Matrix4();
                        this.projectionMatrix = new Matrix4();
                        this.projectionMatrixInverse = new Matrix4();
                        this.coordinateSystem = WebGLCoordinateSystem
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.matrixWorldInverse.copy(source.matrixWorldInverse);
                        this.projectionMatrix.copy(source.projectionMatrix);
                        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
                        this.coordinateSystem = source.coordinateSystem;
                        return this
                    }
                    getWorldDirection(target) {
                        return super.getWorldDirection(target).negate()
                    }
                    updateMatrixWorld(force) {
                        super.updateMatrixWorld(force);
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    updateWorldMatrix(updateParents, updateChildren) {
                        super.updateWorldMatrix(updateParents, updateChildren);
                        this.matrixWorldInverse.copy(this.matrixWorld).invert()
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                const _v3$1 = new Vector3();
                const _minTarget = new Vector2();
                const _maxTarget = new Vector2();
                class PerspectiveCamera extends Camera {
                    constructor(fov = 50, aspect = 1, near = 0.1, far = 2000) {
                        super();
                        this.isPerspectiveCamera = !0;
                        this.type = 'PerspectiveCamera';
                        this.fov = fov;
                        this.zoom = 1;
                        this.near = near;
                        this.far = far;
                        this.focus = 10;
                        this.aspect = aspect;
                        this.view = null;
                        this.filmGauge = 35;
                        this.filmOffset = 0;
                        this.updateProjectionMatrix()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.fov = source.fov;
                        this.zoom = source.zoom;
                        this.near = source.near;
                        this.far = source.far;
                        this.focus = source.focus;
                        this.aspect = source.aspect;
                        this.view = source.view === null ? null : Object.assign({}, source.view);
                        this.filmGauge = source.filmGauge;
                        this.filmOffset = source.filmOffset;
                        return this
                    }
                    setFocalLength(focalLength) {
                        const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
                        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
                        this.updateProjectionMatrix()
                    }
                    getFocalLength() {
                        const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
                        return 0.5 * this.getFilmHeight() / vExtentSlope
                    }
                    getEffectiveFOV() {
                        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
                    }
                    getFilmWidth() {
                        return this.filmGauge * Math.min(this.aspect, 1)
                    }
                    getFilmHeight() {
                        return this.filmGauge / Math.max(this.aspect, 1)
                    }
                    getViewBounds(distance, minTarget, maxTarget) {
                        _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
                        minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
                        _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
                        maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z)
                    }
                    getViewSize(distance, target) {
                        this.getViewBounds(distance, _minTarget, _maxTarget);
                        return target.subVectors(_maxTarget, _minTarget)
                    }
                    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
                        this.aspect = fullWidth / fullHeight;
                        if (this.view === null) {
                            this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }
                        }
                        this.view.enabled = !0;
                        this.view.fullWidth = fullWidth;
                        this.view.fullHeight = fullHeight;
                        this.view.offsetX = x;
                        this.view.offsetY = y;
                        this.view.width = width;
                        this.view.height = height;
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        if (this.view !== null) {
                            this.view.enabled = !1
                        }
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const near = this.near;
                        let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
                        let height = 2 * top;
                        let width = this.aspect * height;
                        let left = -0.5 * width;
                        const view = this.view;
                        if (this.view !== null && this.view.enabled) {
                            const fullWidth = view.fullWidth,
                                fullHeight = view.fullHeight;
                            left += view.offsetX * width / fullWidth;
                            top -= view.offsetY * height / fullHeight;
                            width *= view.width / fullWidth;
                            height *= view.height / fullHeight
                        }
                        const skew = this.filmOffset;
                        if (skew !== 0) left += near * skew / this.getFilmWidth();
                        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.object.fov = this.fov;
                        data.object.zoom = this.zoom;
                        data.object.near = this.near;
                        data.object.far = this.far;
                        data.object.focus = this.focus;
                        data.object.aspect = this.aspect;
                        if (this.view !== null) data.object.view = Object.assign({}, this.view);
                        data.object.filmGauge = this.filmGauge;
                        data.object.filmOffset = this.filmOffset;
                        return data
                    }
                }
                const fov = -90;
                const aspect = 1;
                class CubeCamera extends Object3D {
                    constructor(near, far, renderTarget) {
                        super();
                        this.type = 'CubeCamera';
                        this.renderTarget = renderTarget;
                        this.coordinateSystem = null;
                        this.activeMipmapLevel = 0;
                        const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPX.layers = this.layers;
                        this.add(cameraPX);
                        const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNX.layers = this.layers;
                        this.add(cameraNX);
                        const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPY.layers = this.layers;
                        this.add(cameraPY);
                        const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNY.layers = this.layers;
                        this.add(cameraNY);
                        const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
                        cameraPZ.layers = this.layers;
                        this.add(cameraPZ);
                        const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
                        cameraNZ.layers = this.layers;
                        this.add(cameraNZ)
                    }
                    updateCoordinateSystem() {
                        const coordinateSystem = this.coordinateSystem;
                        const cameras = this.children.concat();
                        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
                        for (const camera of cameras) this.remove(camera);
                        if (coordinateSystem === WebGLCoordinateSystem) {
                            cameraPX.up.set(0, 1, 0);
                            cameraPX.lookAt(1, 0, 0);
                            cameraNX.up.set(0, 1, 0);
                            cameraNX.lookAt(-1, 0, 0);
                            cameraPY.up.set(0, 0, -1);
                            cameraPY.lookAt(0, 1, 0);
                            cameraNY.up.set(0, 0, 1);
                            cameraNY.lookAt(0, -1, 0);
                            cameraPZ.up.set(0, 1, 0);
                            cameraPZ.lookAt(0, 0, 1);
                            cameraNZ.up.set(0, 1, 0);
                            cameraNZ.lookAt(0, 0, -1)
                        } else if (coordinateSystem === WebGPUCoordinateSystem) {
                            cameraPX.up.set(0, -1, 0);
                            cameraPX.lookAt(-1, 0, 0);
                            cameraNX.up.set(0, -1, 0);
                            cameraNX.lookAt(1, 0, 0);
                            cameraPY.up.set(0, 0, 1);
                            cameraPY.lookAt(0, 1, 0);
                            cameraNY.up.set(0, 0, -1);
                            cameraNY.lookAt(0, -1, 0);
                            cameraPZ.up.set(0, -1, 0);
                            cameraPZ.lookAt(0, 0, 1);
                            cameraNZ.up.set(0, -1, 0);
                            cameraNZ.lookAt(0, 0, -1)
                        } else {
                            throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem)
                        }
                        for (const camera of cameras) {
                            this.add(camera);
                            camera.updateMatrixWorld()
                        }
                    }
                    update(renderer, scene) {
                        if (this.parent === null) this.updateMatrixWorld();
                        const {
                            renderTarget,
                            activeMipmapLevel
                        } = this;
                        if (this.coordinateSystem !== renderer.coordinateSystem) {
                            this.coordinateSystem = renderer.coordinateSystem;
                            this.updateCoordinateSystem()
                        }
                        const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
                        const currentRenderTarget = renderer.getRenderTarget();
                        const currentActiveCubeFace = renderer.getActiveCubeFace();
                        const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
                        const currentXrEnabled = renderer.xr.enabled;
                        renderer.xr.enabled = !1;
                        const generateMipmaps = renderTarget.texture.generateMipmaps;
                        renderTarget.texture.generateMipmaps = !1;
                        renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
                        renderer.render(scene, cameraPX);
                        renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
                        renderer.render(scene, cameraNX);
                        renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
                        renderer.render(scene, cameraPY);
                        renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
                        renderer.render(scene, cameraNY);
                        renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
                        renderer.render(scene, cameraPZ);
                        renderTarget.texture.generateMipmaps = generateMipmaps;
                        renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
                        renderer.render(scene, cameraNZ);
                        renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
                        renderer.xr.enabled = currentXrEnabled;
                        renderTarget.texture.needsPMREMUpdate = !0
                    }
                }
                class CubeTexture extends Texture {
                    constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
                        images = images !== undefined ? images : [];
                        mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
                        super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
                        this.isCubeTexture = !0;
                        this.flipY = !1
                    }
                    get images() {
                        return this.image
                    }
                    set images(value) {
                        this.image = value
                    }
                }
                class WebGLCubeRenderTarget extends WebGLRenderTarget {
                    constructor(size = 1, options = {}) {
                        super(size, size, options);
                        this.isWebGLCubeRenderTarget = !0;
                        const image = {
                            width: size,
                            height: size,
                            depth: 1
                        };
                        const images = [image, image, image, image, image, image];
                        this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
                        this.texture.isRenderTargetTexture = !0;
                        this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : !1;
                        this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter
                    }
                    fromEquirectangularTexture(renderer, texture) {
                        this.texture.type = texture.type;
                        this.texture.colorSpace = texture.colorSpace;
                        this.texture.generateMipmaps = texture.generateMipmaps;
                        this.texture.minFilter = texture.minFilter;
                        this.texture.magFilter = texture.magFilter;
                        const shader = {
                            uniforms: {
                                tEquirect: {
                                    value: null
                                },
                            },
                            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
                        };
                        const geometry = new BoxGeometry(5, 5, 5);
                        const material = new ShaderMaterial({
                            name: 'CubemapFromEquirect',
                            uniforms: cloneUniforms(shader.uniforms),
                            vertexShader: shader.vertexShader,
                            fragmentShader: shader.fragmentShader,
                            side: BackSide,
                            blending: NoBlending
                        });
                        material.uniforms.tEquirect.value = texture;
                        const mesh = new Mesh(geometry, material);
                        const currentMinFilter = texture.minFilter;
                        if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
                        const camera = new CubeCamera(1, 10, this);
                        camera.update(renderer, mesh);
                        texture.minFilter = currentMinFilter;
                        mesh.geometry.dispose();
                        mesh.material.dispose();
                        return this
                    }
                    clear(renderer, color, depth, stencil) {
                        const currentRenderTarget = renderer.getRenderTarget();
                        for (let i = 0; i < 6; i++) {
                            renderer.setRenderTarget(this, i);
                            renderer.clear(color, depth, stencil)
                        }
                        renderer.setRenderTarget(currentRenderTarget)
                    }
                }
                const _vector1 = new Vector3();
                const _vector2 = new Vector3();
                const _normalMatrix = new Matrix3();
                class Plane {
                    constructor(normal = new Vector3(1, 0, 0), constant = 0) {
                        this.isPlane = !0;
                        this.normal = normal;
                        this.constant = constant
                    }
                    set(normal, constant) {
                        this.normal.copy(normal);
                        this.constant = constant;
                        return this
                    }
                    setComponents(x, y, z, w) {
                        this.normal.set(x, y, z);
                        this.constant = w;
                        return this
                    }
                    setFromNormalAndCoplanarPoint(normal, point) {
                        this.normal.copy(normal);
                        this.constant = -point.dot(this.normal);
                        return this
                    }
                    setFromCoplanarPoints(a, b, c) {
                        const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
                        this.setFromNormalAndCoplanarPoint(normal, a);
                        return this
                    }
                    copy(plane) {
                        this.normal.copy(plane.normal);
                        this.constant = plane.constant;
                        return this
                    }
                    normalize() {
                        const inverseNormalLength = 1.0 / this.normal.length();
                        this.normal.multiplyScalar(inverseNormalLength);
                        this.constant *= inverseNormalLength;
                        return this
                    }
                    negate() {
                        this.constant *= -1;
                        this.normal.negate();
                        return this
                    }
                    distanceToPoint(point) {
                        return this.normal.dot(point) + this.constant
                    }
                    distanceToSphere(sphere) {
                        return this.distanceToPoint(sphere.center) - sphere.radius
                    }
                    projectPoint(point, target) {
                        return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point))
                    }
                    intersectLine(line, target) {
                        const direction = line.delta(_vector1);
                        const denominator = this.normal.dot(direction);
                        if (denominator === 0) {
                            if (this.distanceToPoint(line.start) === 0) {
                                return target.copy(line.start)
                            }
                            return null
                        }
                        const t = -(line.start.dot(this.normal) + this.constant) / denominator;
                        if (t < 0 || t > 1) {
                            return null
                        }
                        return target.copy(line.start).addScaledVector(direction, t)
                    }
                    intersectsLine(line) {
                        const startSign = this.distanceToPoint(line.start);
                        const endSign = this.distanceToPoint(line.end);
                        return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0)
                    }
                    intersectsBox(box) {
                        return box.intersectsPlane(this)
                    }
                    intersectsSphere(sphere) {
                        return sphere.intersectsPlane(this)
                    }
                    coplanarPoint(target) {
                        return target.copy(this.normal).multiplyScalar(-this.constant)
                    }
                    applyMatrix4(matrix, optionalNormalMatrix) {
                        const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
                        const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
                        const normal = this.normal.applyMatrix3(normalMatrix).normalize();
                        this.constant = -referencePoint.dot(normal);
                        return this
                    }
                    translate(offset) {
                        this.constant -= offset.dot(this.normal);
                        return this
                    }
                    equals(plane) {
                        return plane.normal.equals(this.normal) && (plane.constant === this.constant)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                const _sphere$5 = new Sphere();
                const _vector$7 = new Vector3();
                class Frustum {
                    constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
                        this.planes = [p0, p1, p2, p3, p4, p5]
                    }
                    set(p0, p1, p2, p3, p4, p5) {
                        const planes = this.planes;
                        planes[0].copy(p0);
                        planes[1].copy(p1);
                        planes[2].copy(p2);
                        planes[3].copy(p3);
                        planes[4].copy(p4);
                        planes[5].copy(p5);
                        return this
                    }
                    copy(frustum) {
                        const planes = this.planes;
                        for (let i = 0; i < 6; i++) {
                            planes[i].copy(frustum.planes[i])
                        }
                        return this
                    }
                    setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
                        const planes = this.planes;
                        const me = m.elements;
                        const me0 = me[0],
                            me1 = me[1],
                            me2 = me[2],
                            me3 = me[3];
                        const me4 = me[4],
                            me5 = me[5],
                            me6 = me[6],
                            me7 = me[7];
                        const me8 = me[8],
                            me9 = me[9],
                            me10 = me[10],
                            me11 = me[11];
                        const me12 = me[12],
                            me13 = me[13],
                            me14 = me[14],
                            me15 = me[15];
                        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
                        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
                        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
                        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
                        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
                        if (coordinateSystem === WebGLCoordinateSystem) {
                            planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize()
                        } else if (coordinateSystem === WebGPUCoordinateSystem) {
                            planes[5].setComponents(me2, me6, me10, me14).normalize()
                        } else {
                            throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem)
                        }
                        return this
                    }
                    intersectsObject(object) {
                        if (object.boundingSphere !== undefined) {
                            if (object.boundingSphere === null) object.computeBoundingSphere();
                            _sphere$5.copy(object.boundingSphere).applyMatrix4(object.matrixWorld)
                        } else {
                            const geometry = object.geometry;
                            if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                            _sphere$5.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)
                        }
                        return this.intersectsSphere(_sphere$5)
                    }
                    intersectsSprite(sprite) {
                        _sphere$5.center.set(0, 0, 0);
                        _sphere$5.radius = 0.7071067811865476;
                        _sphere$5.applyMatrix4(sprite.matrixWorld);
                        return this.intersectsSphere(_sphere$5)
                    }
                    intersectsSphere(sphere) {
                        const planes = this.planes;
                        const center = sphere.center;
                        const negRadius = -sphere.radius;
                        for (let i = 0; i < 6; i++) {
                            const distance = planes[i].distanceToPoint(center);
                            if (distance < negRadius) {
                                return !1
                            }
                        }
                        return !0
                    }
                    intersectsBox(box) {
                        const planes = this.planes;
                        for (let i = 0; i < 6; i++) {
                            const plane = planes[i];
                            _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
                            _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
                            _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;
                            if (plane.distanceToPoint(_vector$7) < 0) {
                                return !1
                            }
                        }
                        return !0
                    }
                    containsPoint(point) {
                        const planes = this.planes;
                        for (let i = 0; i < 6; i++) {
                            if (planes[i].distanceToPoint(point) < 0) {
                                return !1
                            }
                        }
                        return !0
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }

                function WebGLAnimation() {
                    let context = null;
                    let isAnimating = !1;
                    let animationLoop = null;
                    let requestId = null;

                    function onAnimationFrame(time, frame) {
                        animationLoop(time, frame);
                        requestId = context.requestAnimationFrame(onAnimationFrame)
                    }
                    return {
                        start: function() {
                            if (isAnimating === !0) return;
                            if (animationLoop === null) return;
                            requestId = context.requestAnimationFrame(onAnimationFrame);
                            isAnimating = !0
                        },
                        stop: function() {
                            context.cancelAnimationFrame(requestId);
                            isAnimating = !1
                        },
                        setAnimationLoop: function(callback) {
                            animationLoop = callback
                        },
                        setContext: function(value) {
                            context = value
                        }
                    }
                }

                function WebGLAttributes(gl) {
                    const buffers = new WeakMap();

                    function createBuffer(attribute, bufferType) {
                        const array = attribute.array;
                        const usage = attribute.usage;
                        const size = array.byteLength;
                        const buffer = gl.createBuffer();
                        gl.bindBuffer(bufferType, buffer);
                        gl.bufferData(bufferType, array, usage);
                        attribute.onUploadCallback();
                        let type;
                        if (array instanceof Float32Array) {
                            type = gl.FLOAT
                        } else if (array instanceof Uint16Array) {
                            if (attribute.isFloat16BufferAttribute) {
                                type = gl.HALF_FLOAT
                            } else {
                                type = gl.UNSIGNED_SHORT
                            }
                        } else if (array instanceof Int16Array) {
                            type = gl.SHORT
                        } else if (array instanceof Uint32Array) {
                            type = gl.UNSIGNED_INT
                        } else if (array instanceof Int32Array) {
                            type = gl.INT
                        } else if (array instanceof Int8Array) {
                            type = gl.BYTE
                        } else if (array instanceof Uint8Array) {
                            type = gl.UNSIGNED_BYTE
                        } else if (array instanceof Uint8ClampedArray) {
                            type = gl.UNSIGNED_BYTE
                        } else {
                            throw new Error('THREE.WebGLAttributes: Unsupported buffer data format: ' + array)
                        }
                        return {
                            buffer: buffer,
                            type: type,
                            bytesPerElement: array.BYTES_PER_ELEMENT,
                            version: attribute.version,
                            size: size
                        }
                    }

                    function updateBuffer(buffer, attribute, bufferType) {
                        const array = attribute.array;
                        const updateRange = attribute._updateRange;
                        const updateRanges = attribute.updateRanges;
                        gl.bindBuffer(bufferType, buffer);
                        if (updateRange.count === -1 && updateRanges.length === 0) {
                            gl.bufferSubData(bufferType, 0, array)
                        }
                        if (updateRanges.length !== 0) {
                            for (let i = 0, l = updateRanges.length; i < l; i++) {
                                const range = updateRanges[i];
                                gl.bufferSubData(bufferType, range.start * array.BYTES_PER_ELEMENT, array, range.start, range.count)
                            }
                            attribute.clearUpdateRanges()
                        }
                        if (updateRange.count !== -1) {
                            gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
                            updateRange.count = -1
                        }
                        attribute.onUploadCallback()
                    }

                    function get(attribute) {
                        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                        return buffers.get(attribute)
                    }

                    function remove(attribute) {
                        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                        const data = buffers.get(attribute);
                        if (data) {
                            gl.deleteBuffer(data.buffer);
                            buffers.delete(attribute)
                        }
                    }

                    function update(attribute, bufferType) {
                        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
                        if (attribute.isGLBufferAttribute) {
                            const cached = buffers.get(attribute);
                            if (!cached || cached.version < attribute.version) {
                                buffers.set(attribute, {
                                    buffer: attribute.buffer,
                                    type: attribute.type,
                                    bytesPerElement: attribute.elementSize,
                                    version: attribute.version
                                })
                            }
                            return
                        }
                        const data = buffers.get(attribute);
                        if (data === undefined) {
                            buffers.set(attribute, createBuffer(attribute, bufferType))
                        } else if (data.version < attribute.version) {
                            if (data.size !== attribute.array.byteLength) {
                                throw new Error('THREE.WebGLAttributes: The size of the buffer attribute\'s array buffer does not match the original size. Resizing buffer attributes is not supported.')
                            }
                            updateBuffer(data.buffer, attribute, bufferType);
                            data.version = attribute.version
                        }
                    }
                    return {
                        get: get,
                        remove: remove,
                        update: update
                    }
                }
                class PlaneGeometry extends BufferGeometry {
                    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
                        super();
                        this.type = 'PlaneGeometry';
                        this.parameters = {
                            width: width,
                            height: height,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments
                        };
                        const width_half = width / 2;
                        const height_half = height / 2;
                        const gridX = Math.floor(widthSegments);
                        const gridY = Math.floor(heightSegments);
                        const gridX1 = gridX + 1;
                        const gridY1 = gridY + 1;
                        const segment_width = width / gridX;
                        const segment_height = height / gridY;
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        for (let iy = 0; iy < gridY1; iy++) {
                            const y = iy * segment_height - height_half;
                            for (let ix = 0; ix < gridX1; ix++) {
                                const x = ix * segment_width - width_half;
                                vertices.push(x, -y, 0);
                                normals.push(0, 0, 1);
                                uvs.push(ix / gridX);
                                uvs.push(1 - (iy / gridY))
                            }
                        }
                        for (let iy = 0; iy < gridY; iy++) {
                            for (let ix = 0; ix < gridX; ix++) {
                                const a = ix + gridX1 * iy;
                                const b = ix + gridX1 * (iy + 1);
                                const c = (ix + 1) + gridX1 * (iy + 1);
                                const d = (ix + 1) + gridX1 * iy;
                                indices.push(a, b, d);
                                indices.push(b, c, d)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments)
                    }
                }
                var alphahash_fragment = "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
                var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif";
                var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
                var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
                var alphatest_fragment = "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif";
                var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";
                var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";
                var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
                var batching_pars_vertex = "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif";
                var batching_vertex = "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
                var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif";
                var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
                var bsdfs = "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated";
                var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";
                var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
                var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif";
                var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
                var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";
                var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";
                var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";
                var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";
                var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif";
                var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif";
                var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
                var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";
                var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
                var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
                var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
                var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
                var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
                var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
                var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n\tvec3( 0.8224621, 0.177538, 0.0 ),\n\tvec3( 0.0331941, 0.9668058, 0.0 ),\n\tvec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.2249401, - 0.2249404, 0.0 ),\n\tvec3( - 0.0420569, 1.0420571, 0.0 ),\n\tvec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n\treturn vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
                var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
                var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
                var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
                var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
                var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
                var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";
                var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";
                var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
                var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
                var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}";
                var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
                var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
                var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert";
                var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";
                var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif";
                var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
                var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon";
                var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
                var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong";
                var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
                var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
                var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
                var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";
                var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
                var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
                var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
                var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
                var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
                var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";
                var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
                var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
                var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
                var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
                var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
                var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif";
                var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";
                var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
                var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif";
                var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif";
                var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
                var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
                var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
                var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";
                var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";
                var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif";
                var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
                var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
                var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif";
                var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";
                var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
                var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}";
                var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
                var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
                var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
                var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
                var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
                var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
                var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif";
                var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
                var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif";
                var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";
                var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
                var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif";
                var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
                var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
                var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
                var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
                var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
                var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
                var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
                var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif";
                var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
                var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif";
                var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
                var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
                const vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
                const fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
                const vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
                const fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
                const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
                const fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
                const vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
                const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}";
                const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
                const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
                const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
                const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}";
                const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
                const vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
                const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
                const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";
                const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";
                const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
                const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
                const vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
                const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
                const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}";
                const ShaderChunk = {
                    alphahash_fragment: alphahash_fragment,
                    alphahash_pars_fragment: alphahash_pars_fragment,
                    alphamap_fragment: alphamap_fragment,
                    alphamap_pars_fragment: alphamap_pars_fragment,
                    alphatest_fragment: alphatest_fragment,
                    alphatest_pars_fragment: alphatest_pars_fragment,
                    aomap_fragment: aomap_fragment,
                    aomap_pars_fragment: aomap_pars_fragment,
                    batching_pars_vertex: batching_pars_vertex,
                    batching_vertex: batching_vertex,
                    begin_vertex: begin_vertex,
                    beginnormal_vertex: beginnormal_vertex,
                    bsdfs: bsdfs,
                    iridescence_fragment: iridescence_fragment,
                    bumpmap_pars_fragment: bumpmap_pars_fragment,
                    clipping_planes_fragment: clipping_planes_fragment,
                    clipping_planes_pars_fragment: clipping_planes_pars_fragment,
                    clipping_planes_pars_vertex: clipping_planes_pars_vertex,
                    clipping_planes_vertex: clipping_planes_vertex,
                    color_fragment: color_fragment,
                    color_pars_fragment: color_pars_fragment,
                    color_pars_vertex: color_pars_vertex,
                    color_vertex: color_vertex,
                    common: common,
                    cube_uv_reflection_fragment: cube_uv_reflection_fragment,
                    defaultnormal_vertex: defaultnormal_vertex,
                    displacementmap_pars_vertex: displacementmap_pars_vertex,
                    displacementmap_vertex: displacementmap_vertex,
                    emissivemap_fragment: emissivemap_fragment,
                    emissivemap_pars_fragment: emissivemap_pars_fragment,
                    colorspace_fragment: colorspace_fragment,
                    colorspace_pars_fragment: colorspace_pars_fragment,
                    envmap_fragment: envmap_fragment,
                    envmap_common_pars_fragment: envmap_common_pars_fragment,
                    envmap_pars_fragment: envmap_pars_fragment,
                    envmap_pars_vertex: envmap_pars_vertex,
                    envmap_physical_pars_fragment: envmap_physical_pars_fragment,
                    envmap_vertex: envmap_vertex,
                    fog_vertex: fog_vertex,
                    fog_pars_vertex: fog_pars_vertex,
                    fog_fragment: fog_fragment,
                    fog_pars_fragment: fog_pars_fragment,
                    gradientmap_pars_fragment: gradientmap_pars_fragment,
                    lightmap_pars_fragment: lightmap_pars_fragment,
                    lights_lambert_fragment: lights_lambert_fragment,
                    lights_lambert_pars_fragment: lights_lambert_pars_fragment,
                    lights_pars_begin: lights_pars_begin,
                    lights_toon_fragment: lights_toon_fragment,
                    lights_toon_pars_fragment: lights_toon_pars_fragment,
                    lights_phong_fragment: lights_phong_fragment,
                    lights_phong_pars_fragment: lights_phong_pars_fragment,
                    lights_physical_fragment: lights_physical_fragment,
                    lights_physical_pars_fragment: lights_physical_pars_fragment,
                    lights_fragment_begin: lights_fragment_begin,
                    lights_fragment_maps: lights_fragment_maps,
                    lights_fragment_end: lights_fragment_end,
                    logdepthbuf_fragment: logdepthbuf_fragment,
                    logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
                    logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
                    logdepthbuf_vertex: logdepthbuf_vertex,
                    map_fragment: map_fragment,
                    map_pars_fragment: map_pars_fragment,
                    map_particle_fragment: map_particle_fragment,
                    map_particle_pars_fragment: map_particle_pars_fragment,
                    metalnessmap_fragment: metalnessmap_fragment,
                    metalnessmap_pars_fragment: metalnessmap_pars_fragment,
                    morphinstance_vertex: morphinstance_vertex,
                    morphcolor_vertex: morphcolor_vertex,
                    morphnormal_vertex: morphnormal_vertex,
                    morphtarget_pars_vertex: morphtarget_pars_vertex,
                    morphtarget_vertex: morphtarget_vertex,
                    normal_fragment_begin: normal_fragment_begin,
                    normal_fragment_maps: normal_fragment_maps,
                    normal_pars_fragment: normal_pars_fragment,
                    normal_pars_vertex: normal_pars_vertex,
                    normal_vertex: normal_vertex,
                    normalmap_pars_fragment: normalmap_pars_fragment,
                    clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
                    clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
                    clearcoat_pars_fragment: clearcoat_pars_fragment,
                    iridescence_pars_fragment: iridescence_pars_fragment,
                    opaque_fragment: opaque_fragment,
                    packing: packing,
                    premultiplied_alpha_fragment: premultiplied_alpha_fragment,
                    project_vertex: project_vertex,
                    dithering_fragment: dithering_fragment,
                    dithering_pars_fragment: dithering_pars_fragment,
                    roughnessmap_fragment: roughnessmap_fragment,
                    roughnessmap_pars_fragment: roughnessmap_pars_fragment,
                    shadowmap_pars_fragment: shadowmap_pars_fragment,
                    shadowmap_pars_vertex: shadowmap_pars_vertex,
                    shadowmap_vertex: shadowmap_vertex,
                    shadowmask_pars_fragment: shadowmask_pars_fragment,
                    skinbase_vertex: skinbase_vertex,
                    skinning_pars_vertex: skinning_pars_vertex,
                    skinning_vertex: skinning_vertex,
                    skinnormal_vertex: skinnormal_vertex,
                    specularmap_fragment: specularmap_fragment,
                    specularmap_pars_fragment: specularmap_pars_fragment,
                    tonemapping_fragment: tonemapping_fragment,
                    tonemapping_pars_fragment: tonemapping_pars_fragment,
                    transmission_fragment: transmission_fragment,
                    transmission_pars_fragment: transmission_pars_fragment,
                    uv_pars_fragment: uv_pars_fragment,
                    uv_pars_vertex: uv_pars_vertex,
                    uv_vertex: uv_vertex,
                    worldpos_vertex: worldpos_vertex,
                    background_vert: vertex$h,
                    background_frag: fragment$h,
                    backgroundCube_vert: vertex$g,
                    backgroundCube_frag: fragment$g,
                    cube_vert: vertex$f,
                    cube_frag: fragment$f,
                    depth_vert: vertex$e,
                    depth_frag: fragment$e,
                    distanceRGBA_vert: vertex$d,
                    distanceRGBA_frag: fragment$d,
                    equirect_vert: vertex$c,
                    equirect_frag: fragment$c,
                    linedashed_vert: vertex$b,
                    linedashed_frag: fragment$b,
                    meshbasic_vert: vertex$a,
                    meshbasic_frag: fragment$a,
                    meshlambert_vert: vertex$9,
                    meshlambert_frag: fragment$9,
                    meshmatcap_vert: vertex$8,
                    meshmatcap_frag: fragment$8,
                    meshnormal_vert: vertex$7,
                    meshnormal_frag: fragment$7,
                    meshphong_vert: vertex$6,
                    meshphong_frag: fragment$6,
                    meshphysical_vert: vertex$5,
                    meshphysical_frag: fragment$5,
                    meshtoon_vert: vertex$4,
                    meshtoon_frag: fragment$4,
                    points_vert: vertex$3,
                    points_frag: fragment$3,
                    shadow_vert: vertex$2,
                    shadow_frag: fragment$2,
                    sprite_vert: vertex$1,
                    sprite_frag: fragment$1
                };
                const UniformsLib = {
                    common: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new Matrix3()
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new Matrix3()
                        },
                        alphaTest: {
                            value: 0
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        },
                        specularMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        envMapRotation: {
                            value: new Matrix3()
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1.0
                        },
                        ior: {
                            value: 1.5
                        },
                        refractionRatio: {
                            value: 0.98
                        },
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        },
                        aoMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        },
                        lightMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpMapTransform: {
                            value: new Matrix3()
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalMapTransform: {
                            value: new Matrix3()
                        },
                        normalScale: {
                            value: new Vector2(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementMapTransform: {
                            value: new Matrix3()
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        },
                        emissiveMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        },
                        metalnessMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        },
                        roughnessMapTransform: {
                            value: new Matrix3()
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 0.00025
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2000
                        },
                        fogColor: {
                            value: new Color(0xffffff)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {}
                            }
                        },
                        directionalLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {}
                            }
                        },
                        spotLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotLightMap: {
                            value: []
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotLightMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {}
                            }
                        },
                        pointLightShadows: {
                            value: [],
                            properties: {
                                shadowIntensity: 1,
                                shadowBias: {},
                                shadowNormalBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        },
                        ltc_1: {
                            value: null
                        },
                        ltc_2: {
                            value: null
                        }
                    },
                    points: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        size: {
                            value: 1.0
                        },
                        scale: {
                            value: 1.0
                        },
                        map: {
                            value: null
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new Matrix3()
                        },
                        alphaTest: {
                            value: 0
                        },
                        uvTransform: {
                            value: new Matrix3()
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new Color(0xffffff)
                        },
                        opacity: {
                            value: 1.0
                        },
                        center: {
                            value: new Vector2(0.5, 0.5)
                        },
                        rotation: {
                            value: 0.0
                        },
                        map: {
                            value: null
                        },
                        mapTransform: {
                            value: new Matrix3()
                        },
                        alphaMap: {
                            value: null
                        },
                        alphaMapTransform: {
                            value: new Matrix3()
                        },
                        alphaTest: {
                            value: 0
                        }
                    }
                };
                const ShaderLib = {
                    basic: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
                        vertexShader: ShaderChunk.meshbasic_vert,
                        fragmentShader: ShaderChunk.meshbasic_frag
                    },
                    lambert: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
                            emissive: {
                                value: new Color(0x000000)
                            }
                        }]),
                        vertexShader: ShaderChunk.meshlambert_vert,
                        fragmentShader: ShaderChunk.meshlambert_frag
                    },
                    phong: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
                            emissive: {
                                value: new Color(0x000000)
                            },
                            specular: {
                                value: new Color(0x111111)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: ShaderChunk.meshphong_vert,
                        fragmentShader: ShaderChunk.meshphong_frag
                    },
                    standard: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
                            emissive: {
                                value: new Color(0x000000)
                            },
                            roughness: {
                                value: 1.0
                            },
                            metalness: {
                                value: 0.0
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: ShaderChunk.meshphysical_vert,
                        fragmentShader: ShaderChunk.meshphysical_frag
                    },
                    toon: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
                            emissive: {
                                value: new Color(0x000000)
                            }
                        }]),
                        vertexShader: ShaderChunk.meshtoon_vert,
                        fragmentShader: ShaderChunk.meshtoon_frag
                    },
                    matcap: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: ShaderChunk.meshmatcap_vert,
                        fragmentShader: ShaderChunk.meshmatcap_frag
                    },
                    points: {
                        uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
                        vertexShader: ShaderChunk.points_vert,
                        fragmentShader: ShaderChunk.points_frag
                    },
                    dashed: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: ShaderChunk.linedashed_vert,
                        fragmentShader: ShaderChunk.linedashed_frag
                    },
                    depth: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
                        vertexShader: ShaderChunk.depth_vert,
                        fragmentShader: ShaderChunk.depth_frag
                    },
                    normal: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
                            opacity: {
                                value: 1.0
                            }
                        }]),
                        vertexShader: ShaderChunk.meshnormal_vert,
                        fragmentShader: ShaderChunk.meshnormal_frag
                    },
                    sprite: {
                        uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
                        vertexShader: ShaderChunk.sprite_vert,
                        fragmentShader: ShaderChunk.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Matrix3()
                            },
                            t2D: {
                                value: null
                            },
                            backgroundIntensity: {
                                value: 1
                            }
                        },
                        vertexShader: ShaderChunk.background_vert,
                        fragmentShader: ShaderChunk.background_frag
                    },
                    backgroundCube: {
                        uniforms: {
                            envMap: {
                                value: null
                            },
                            flipEnvMap: {
                                value: -1
                            },
                            backgroundBlurriness: {
                                value: 0
                            },
                            backgroundIntensity: {
                                value: 1
                            },
                            backgroundRotation: {
                                value: new Matrix3()
                            }
                        },
                        vertexShader: ShaderChunk.backgroundCube_vert,
                        fragmentShader: ShaderChunk.backgroundCube_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1.0
                            }
                        },
                        vertexShader: ShaderChunk.cube_vert,
                        fragmentShader: ShaderChunk.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            },
                        },
                        vertexShader: ShaderChunk.equirect_vert,
                        fragmentShader: ShaderChunk.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
                            referencePosition: {
                                value: new Vector3()
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1000
                            }
                        }]),
                        vertexShader: ShaderChunk.distanceRGBA_vert,
                        fragmentShader: ShaderChunk.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
                            color: {
                                value: new Color(0x00000)
                            },
                            opacity: {
                                value: 1.0
                            }
                        }, ]),
                        vertexShader: ShaderChunk.shadow_vert,
                        fragmentShader: ShaderChunk.shadow_frag
                    }
                };
                ShaderLib.physical = {
                    uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
                        clearcoat: {
                            value: 0
                        },
                        clearcoatMap: {
                            value: null
                        },
                        clearcoatMapTransform: {
                            value: new Matrix3()
                        },
                        clearcoatNormalMap: {
                            value: null
                        },
                        clearcoatNormalMapTransform: {
                            value: new Matrix3()
                        },
                        clearcoatNormalScale: {
                            value: new Vector2(1, 1)
                        },
                        clearcoatRoughness: {
                            value: 0
                        },
                        clearcoatRoughnessMap: {
                            value: null
                        },
                        clearcoatRoughnessMapTransform: {
                            value: new Matrix3()
                        },
                        dispersion: {
                            value: 0
                        },
                        iridescence: {
                            value: 0
                        },
                        iridescenceMap: {
                            value: null
                        },
                        iridescenceMapTransform: {
                            value: new Matrix3()
                        },
                        iridescenceIOR: {
                            value: 1.3
                        },
                        iridescenceThicknessMinimum: {
                            value: 100
                        },
                        iridescenceThicknessMaximum: {
                            value: 400
                        },
                        iridescenceThicknessMap: {
                            value: null
                        },
                        iridescenceThicknessMapTransform: {
                            value: new Matrix3()
                        },
                        sheen: {
                            value: 0
                        },
                        sheenColor: {
                            value: new Color(0x000000)
                        },
                        sheenColorMap: {
                            value: null
                        },
                        sheenColorMapTransform: {
                            value: new Matrix3()
                        },
                        sheenRoughness: {
                            value: 1
                        },
                        sheenRoughnessMap: {
                            value: null
                        },
                        sheenRoughnessMapTransform: {
                            value: new Matrix3()
                        },
                        transmission: {
                            value: 0
                        },
                        transmissionMap: {
                            value: null
                        },
                        transmissionMapTransform: {
                            value: new Matrix3()
                        },
                        transmissionSamplerSize: {
                            value: new Vector2()
                        },
                        transmissionSamplerMap: {
                            value: null
                        },
                        thickness: {
                            value: 0
                        },
                        thicknessMap: {
                            value: null
                        },
                        thicknessMapTransform: {
                            value: new Matrix3()
                        },
                        attenuationDistance: {
                            value: 0
                        },
                        attenuationColor: {
                            value: new Color(0x000000)
                        },
                        specularColor: {
                            value: new Color(1, 1, 1)
                        },
                        specularColorMap: {
                            value: null
                        },
                        specularColorMapTransform: {
                            value: new Matrix3()
                        },
                        specularIntensity: {
                            value: 1
                        },
                        specularIntensityMap: {
                            value: null
                        },
                        specularIntensityMapTransform: {
                            value: new Matrix3()
                        },
                        anisotropyVector: {
                            value: new Vector2()
                        },
                        anisotropyMap: {
                            value: null
                        },
                        anisotropyMapTransform: {
                            value: new Matrix3()
                        },
                    }]),
                    vertexShader: ShaderChunk.meshphysical_vert,
                    fragmentShader: ShaderChunk.meshphysical_frag
                };
                const _rgb = {
                    r: 0,
                    b: 0,
                    g: 0
                };
                const _e1$1 = new Euler();
                const _m1$1 = new Matrix4();

                function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
                    const clearColor = new Color(0x000000);
                    let clearAlpha = alpha === !0 ? 0 : 1;
                    let planeMesh;
                    let boxMesh;
                    let currentBackground = null;
                    let currentBackgroundVersion = 0;
                    let currentTonemapping = null;

                    function getBackground(scene) {
                        let background = scene.isScene === !0 ? scene.background : null;
                        if (background && background.isTexture) {
                            const usePMREM = scene.backgroundBlurriness > 0;
                            background = (usePMREM ? cubeuvmaps : cubemaps).get(background)
                        }
                        return background
                    }

                    function render(scene) {
                        let forceClear = !1;
                        const background = getBackground(scene);
                        if (background === null) {
                            setClear(clearColor, clearAlpha)
                        } else if (background && background.isColor) {
                            setClear(background, 1);
                            forceClear = !0
                        }
                        const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
                        if (environmentBlendMode === 'additive') {
                            state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha)
                        } else if (environmentBlendMode === 'alpha-blend') {
                            state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha)
                        }
                        if (renderer.autoClear || forceClear) {
                            state.buffers.depth.setTest(!0);
                            state.buffers.depth.setMask(!0);
                            state.buffers.color.setMask(!0);
                            renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil)
                        }
                    }

                    function addToRenderList(renderList, scene) {
                        const background = getBackground(scene);
                        if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
                            if (boxMesh === undefined) {
                                boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({
                                    name: 'BackgroundCubeMaterial',
                                    uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
                                    vertexShader: ShaderLib.backgroundCube.vertexShader,
                                    fragmentShader: ShaderLib.backgroundCube.fragmentShader,
                                    side: BackSide,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                }));
                                boxMesh.geometry.deleteAttribute('normal');
                                boxMesh.geometry.deleteAttribute('uv');
                                boxMesh.onBeforeRender = function(renderer, scene, camera) {
                                    this.matrixWorld.copyPosition(camera.matrixWorld)
                                };
                                Object.defineProperty(boxMesh.material, 'envMap', {
                                    get: function() {
                                        return this.uniforms.envMap.value
                                    }
                                });
                                objects.update(boxMesh)
                            }
                            _e1$1.copy(scene.backgroundRotation);
                            _e1$1.x *= -1;
                            _e1$1.y *= -1;
                            _e1$1.z *= -1;
                            if (background.isCubeTexture && background.isRenderTargetTexture === !1) {
                                _e1$1.y *= -1;
                                _e1$1.z *= -1
                            }
                            boxMesh.material.uniforms.envMap.value = background;
                            boxMesh.material.uniforms.flipEnvMap.value = (background.isCubeTexture && background.isRenderTargetTexture === !1) ? -1 : 1;
                            boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
                            boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
                            boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$1.makeRotationFromEuler(_e1$1));
                            boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
                            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                                boxMesh.material.needsUpdate = !0;
                                currentBackground = background;
                                currentBackgroundVersion = background.version;
                                currentTonemapping = renderer.toneMapping
                            }
                            boxMesh.layers.enableAll();
                            renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null)
                        } else if (background && background.isTexture) {
                            if (planeMesh === undefined) {
                                planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({
                                    name: 'BackgroundMaterial',
                                    uniforms: cloneUniforms(ShaderLib.background.uniforms),
                                    vertexShader: ShaderLib.background.vertexShader,
                                    fragmentShader: ShaderLib.background.fragmentShader,
                                    side: FrontSide,
                                    depthTest: !1,
                                    depthWrite: !1,
                                    fog: !1
                                }));
                                planeMesh.geometry.deleteAttribute('normal');
                                Object.defineProperty(planeMesh.material, 'map', {
                                    get: function() {
                                        return this.uniforms.t2D.value
                                    }
                                });
                                objects.update(planeMesh)
                            }
                            planeMesh.material.uniforms.t2D.value = background;
                            planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
                            planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
                            if (background.matrixAutoUpdate === !0) {
                                background.updateMatrix()
                            }
                            planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
                            if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
                                planeMesh.material.needsUpdate = !0;
                                currentBackground = background;
                                currentBackgroundVersion = background.version;
                                currentTonemapping = renderer.toneMapping
                            }
                            planeMesh.layers.enableAll();
                            renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null)
                        }
                    }

                    function setClear(color, alpha) {
                        color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
                        state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha, premultipliedAlpha)
                    }
                    return {
                        getClearColor: function() {
                            return clearColor
                        },
                        setClearColor: function(color, alpha = 1) {
                            clearColor.set(color);
                            clearAlpha = alpha;
                            setClear(clearColor, clearAlpha)
                        },
                        getClearAlpha: function() {
                            return clearAlpha
                        },
                        setClearAlpha: function(alpha) {
                            clearAlpha = alpha;
                            setClear(clearColor, clearAlpha)
                        },
                        render: render,
                        addToRenderList: addToRenderList
                    }
                }

                function WebGLBindingStates(gl, attributes) {
                    const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                    const bindingStates = {};
                    const defaultState = createBindingState(null);
                    let currentState = defaultState;
                    let forceUpdate = !1;

                    function setup(object, material, program, geometry, index) {
                        let updateBuffers = !1;
                        const state = getBindingState(geometry, program, material);
                        if (currentState !== state) {
                            currentState = state;
                            bindVertexArrayObject(currentState.object)
                        }
                        updateBuffers = needsUpdate(object, geometry, program, index);
                        if (updateBuffers) saveCache(object, geometry, program, index);
                        if (index !== null) {
                            attributes.update(index, gl.ELEMENT_ARRAY_BUFFER)
                        }
                        if (updateBuffers || forceUpdate) {
                            forceUpdate = !1;
                            setupVertexAttributes(object, material, program, geometry);
                            if (index !== null) {
                                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer)
                            }
                        }
                    }

                    function createVertexArrayObject() {
                        return gl.createVertexArray()
                    }

                    function bindVertexArrayObject(vao) {
                        return gl.bindVertexArray(vao)
                    }

                    function deleteVertexArrayObject(vao) {
                        return gl.deleteVertexArray(vao)
                    }

                    function getBindingState(geometry, program, material) {
                        const wireframe = (material.wireframe === !0);
                        let programMap = bindingStates[geometry.id];
                        if (programMap === undefined) {
                            programMap = {};
                            bindingStates[geometry.id] = programMap
                        }
                        let stateMap = programMap[program.id];
                        if (stateMap === undefined) {
                            stateMap = {};
                            programMap[program.id] = stateMap
                        }
                        let state = stateMap[wireframe];
                        if (state === undefined) {
                            state = createBindingState(createVertexArrayObject());
                            stateMap[wireframe] = state
                        }
                        return state
                    }

                    function createBindingState(vao) {
                        const newAttributes = [];
                        const enabledAttributes = [];
                        const attributeDivisors = [];
                        for (let i = 0; i < maxVertexAttributes; i++) {
                            newAttributes[i] = 0;
                            enabledAttributes[i] = 0;
                            attributeDivisors[i] = 0
                        }
                        return {
                            geometry: null,
                            program: null,
                            wireframe: !1,
                            newAttributes: newAttributes,
                            enabledAttributes: enabledAttributes,
                            attributeDivisors: attributeDivisors,
                            object: vao,
                            attributes: {},
                            index: null
                        }
                    }

                    function needsUpdate(object, geometry, program, index) {
                        const cachedAttributes = currentState.attributes;
                        const geometryAttributes = geometry.attributes;
                        let attributesNum = 0;
                        const programAttributes = program.getAttributes();
                        for (const name in programAttributes) {
                            const programAttribute = programAttributes[name];
                            if (programAttribute.location >= 0) {
                                const cachedAttribute = cachedAttributes[name];
                                let geometryAttribute = geometryAttributes[name];
                                if (geometryAttribute === undefined) {
                                    if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                                    if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor
                                }
                                if (cachedAttribute === undefined) return !0;
                                if (cachedAttribute.attribute !== geometryAttribute) return !0;
                                if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return !0;
                                attributesNum++
                            }
                        }
                        if (currentState.attributesNum !== attributesNum) return !0;
                        if (currentState.index !== index) return !0;
                        return !1
                    }

                    function saveCache(object, geometry, program, index) {
                        const cache = {};
                        const attributes = geometry.attributes;
                        let attributesNum = 0;
                        const programAttributes = program.getAttributes();
                        for (const name in programAttributes) {
                            const programAttribute = programAttributes[name];
                            if (programAttribute.location >= 0) {
                                let attribute = attributes[name];
                                if (attribute === undefined) {
                                    if (name === 'instanceMatrix' && object.instanceMatrix) attribute = object.instanceMatrix;
                                    if (name === 'instanceColor' && object.instanceColor) attribute = object.instanceColor
                                }
                                const data = {};
                                data.attribute = attribute;
                                if (attribute && attribute.data) {
                                    data.data = attribute.data
                                }
                                cache[name] = data;
                                attributesNum++
                            }
                        }
                        currentState.attributes = cache;
                        currentState.attributesNum = attributesNum;
                        currentState.index = index
                    }

                    function initAttributes() {
                        const newAttributes = currentState.newAttributes;
                        for (let i = 0, il = newAttributes.length; i < il; i++) {
                            newAttributes[i] = 0
                        }
                    }

                    function enableAttribute(attribute) {
                        enableAttributeAndDivisor(attribute, 0)
                    }

                    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
                        const newAttributes = currentState.newAttributes;
                        const enabledAttributes = currentState.enabledAttributes;
                        const attributeDivisors = currentState.attributeDivisors;
                        newAttributes[attribute] = 1;
                        if (enabledAttributes[attribute] === 0) {
                            gl.enableVertexAttribArray(attribute);
                            enabledAttributes[attribute] = 1
                        }
                        if (attributeDivisors[attribute] !== meshPerAttribute) {
                            gl.vertexAttribDivisor(attribute, meshPerAttribute);
                            attributeDivisors[attribute] = meshPerAttribute
                        }
                    }

                    function disableUnusedAttributes() {
                        const newAttributes = currentState.newAttributes;
                        const enabledAttributes = currentState.enabledAttributes;
                        for (let i = 0, il = enabledAttributes.length; i < il; i++) {
                            if (enabledAttributes[i] !== newAttributes[i]) {
                                gl.disableVertexAttribArray(i);
                                enabledAttributes[i] = 0
                            }
                        }
                    }

                    function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
                        if (integer === !0) {
                            gl.vertexAttribIPointer(index, size, type, stride, offset)
                        } else {
                            gl.vertexAttribPointer(index, size, type, normalized, stride, offset)
                        }
                    }

                    function setupVertexAttributes(object, material, program, geometry) {
                        initAttributes();
                        const geometryAttributes = geometry.attributes;
                        const programAttributes = program.getAttributes();
                        const materialDefaultAttributeValues = material.defaultAttributeValues;
                        for (const name in programAttributes) {
                            const programAttribute = programAttributes[name];
                            if (programAttribute.location >= 0) {
                                let geometryAttribute = geometryAttributes[name];
                                if (geometryAttribute === undefined) {
                                    if (name === 'instanceMatrix' && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
                                    if (name === 'instanceColor' && object.instanceColor) geometryAttribute = object.instanceColor
                                }
                                if (geometryAttribute !== undefined) {
                                    const normalized = geometryAttribute.normalized;
                                    const size = geometryAttribute.itemSize;
                                    const attribute = attributes.get(geometryAttribute);
                                    if (attribute === undefined) continue;
                                    const buffer = attribute.buffer;
                                    const type = attribute.type;
                                    const bytesPerElement = attribute.bytesPerElement;
                                    const integer = (type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
                                    if (geometryAttribute.isInterleavedBufferAttribute) {
                                        const data = geometryAttribute.data;
                                        const stride = data.stride;
                                        const offset = geometryAttribute.offset;
                                        if (data.isInstancedInterleavedBuffer) {
                                            for (let i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute)
                                            }
                                            if (object.isInstancedMesh !== !0 && geometry._maxInstanceCount === undefined) {
                                                geometry._maxInstanceCount = data.meshPerAttribute * data.count
                                            }
                                        } else {
                                            for (let i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttribute(programAttribute.location + i)
                                            }
                                        }
                                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                                        for (let i = 0; i < programAttribute.locationSize; i++) {
                                            vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, stride * bytesPerElement, (offset + (size / programAttribute.locationSize) * i) * bytesPerElement, integer)
                                        }
                                    } else {
                                        if (geometryAttribute.isInstancedBufferAttribute) {
                                            for (let i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute)
                                            }
                                            if (object.isInstancedMesh !== !0 && geometry._maxInstanceCount === undefined) {
                                                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count
                                            }
                                        } else {
                                            for (let i = 0; i < programAttribute.locationSize; i++) {
                                                enableAttribute(programAttribute.location + i)
                                            }
                                        }
                                        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                                        for (let i = 0; i < programAttribute.locationSize; i++) {
                                            vertexAttribPointer(programAttribute.location + i, size / programAttribute.locationSize, type, normalized, size * bytesPerElement, (size / programAttribute.locationSize) * i * bytesPerElement, integer)
                                        }
                                    }
                                } else if (materialDefaultAttributeValues !== undefined) {
                                    const value = materialDefaultAttributeValues[name];
                                    if (value !== undefined) {
                                        switch (value.length) {
                                            case 2:
                                                gl.vertexAttrib2fv(programAttribute.location, value);
                                                break;
                                            case 3:
                                                gl.vertexAttrib3fv(programAttribute.location, value);
                                                break;
                                            case 4:
                                                gl.vertexAttrib4fv(programAttribute.location, value);
                                                break;
                                            default:
                                                gl.vertexAttrib1fv(programAttribute.location, value)
                                        }
                                    }
                                }
                            }
                        }
                        disableUnusedAttributes()
                    }

                    function dispose() {
                        reset();
                        for (const geometryId in bindingStates) {
                            const programMap = bindingStates[geometryId];
                            for (const programId in programMap) {
                                const stateMap = programMap[programId];
                                for (const wireframe in stateMap) {
                                    deleteVertexArrayObject(stateMap[wireframe].object);
                                    delete stateMap[wireframe]
                                }
                                delete programMap[programId]
                            }
                            delete bindingStates[geometryId]
                        }
                    }

                    function releaseStatesOfGeometry(geometry) {
                        if (bindingStates[geometry.id] === undefined) return;
                        const programMap = bindingStates[geometry.id];
                        for (const programId in programMap) {
                            const stateMap = programMap[programId];
                            for (const wireframe in stateMap) {
                                deleteVertexArrayObject(stateMap[wireframe].object);
                                delete stateMap[wireframe]
                            }
                            delete programMap[programId]
                        }
                        delete bindingStates[geometry.id]
                    }

                    function releaseStatesOfProgram(program) {
                        for (const geometryId in bindingStates) {
                            const programMap = bindingStates[geometryId];
                            if (programMap[program.id] === undefined) continue;
                            const stateMap = programMap[program.id];
                            for (const wireframe in stateMap) {
                                deleteVertexArrayObject(stateMap[wireframe].object);
                                delete stateMap[wireframe]
                            }
                            delete programMap[program.id]
                        }
                    }

                    function reset() {
                        resetDefaultState();
                        forceUpdate = !0;
                        if (currentState === defaultState) return;
                        currentState = defaultState;
                        bindVertexArrayObject(currentState.object)
                    }

                    function resetDefaultState() {
                        defaultState.geometry = null;
                        defaultState.program = null;
                        defaultState.wireframe = !1
                    }
                    return {
                        setup: setup,
                        reset: reset,
                        resetDefaultState: resetDefaultState,
                        dispose: dispose,
                        releaseStatesOfGeometry: releaseStatesOfGeometry,
                        releaseStatesOfProgram: releaseStatesOfProgram,
                        initAttributes: initAttributes,
                        enableAttribute: enableAttribute,
                        disableUnusedAttributes: disableUnusedAttributes
                    }
                }

                function WebGLBufferRenderer(gl, extensions, info) {
                    let mode;

                    function setMode(value) {
                        mode = value
                    }

                    function render(start, count) {
                        gl.drawArrays(mode, start, count);
                        info.update(count, mode, 1)
                    }

                    function renderInstances(start, count, primcount) {
                        if (primcount === 0) return;
                        gl.drawArraysInstanced(mode, start, count, primcount);
                        info.update(count, mode, primcount)
                    }

                    function renderMultiDraw(starts, counts, drawCount) {
                        if (drawCount === 0) return;
                        const extension = extensions.get('WEBGL_multi_draw');
                        extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
                        let elementCount = 0;
                        for (let i = 0; i < drawCount; i++) {
                            elementCount += counts[i]
                        }
                        info.update(elementCount, mode, 1)
                    }

                    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
                        if (drawCount === 0) return;
                        const extension = extensions.get('WEBGL_multi_draw');
                        if (extension === null) {
                            for (let i = 0; i < starts.length; i++) {
                                renderInstances(starts[i], counts[i], primcount[i])
                            }
                        } else {
                            extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
                            let elementCount = 0;
                            for (let i = 0; i < drawCount; i++) {
                                elementCount += counts[i]
                            }
                            for (let i = 0; i < primcount.length; i++) {
                                info.update(elementCount, mode, primcount[i])
                            }
                        }
                    }
                    this.setMode = setMode;
                    this.render = render;
                    this.renderInstances = renderInstances;
                    this.renderMultiDraw = renderMultiDraw;
                    this.renderMultiDrawInstances = renderMultiDrawInstances
                }

                function WebGLCapabilities(gl, extensions, parameters, utils) {
                    let maxAnisotropy;

                    function getMaxAnisotropy() {
                        if (maxAnisotropy !== undefined) return maxAnisotropy;
                        if (extensions.has('EXT_texture_filter_anisotropic') === !0) {
                            const extension = extensions.get('EXT_texture_filter_anisotropic');
                            maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
                        } else {
                            maxAnisotropy = 0
                        }
                        return maxAnisotropy
                    }

                    function textureFormatReadable(textureFormat) {
                        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
                            return !1
                        }
                        return !0
                    }

                    function textureTypeReadable(textureType) {
                        const halfFloatSupportedByExt = (textureType === HalfFloatType) && (extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float'));
                        if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && textureType !== FloatType && !halfFloatSupportedByExt) {
                            return !1
                        }
                        return !0
                    }

                    function getMaxPrecision(precision) {
                        if (precision === 'highp') {
                            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                                return 'highp'
                            }
                            precision = 'mediump'
                        }
                        if (precision === 'mediump') {
                            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                                return 'mediump'
                            }
                        }
                        return 'lowp'
                    }
                    let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
                    const maxPrecision = getMaxPrecision(precision);
                    if (maxPrecision !== precision) {
                        console.warn('THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.');
                        precision = maxPrecision
                    }
                    const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === !0;
                    const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                    const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                    const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                    const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                    const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                    const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
                    const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                    const vertexTextures = maxVertexTextures > 0;
                    const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
                    return {
                        isWebGL2: !0,
                        getMaxAnisotropy: getMaxAnisotropy,
                        getMaxPrecision: getMaxPrecision,
                        textureFormatReadable: textureFormatReadable,
                        textureTypeReadable: textureTypeReadable,
                        precision: precision,
                        logarithmicDepthBuffer: logarithmicDepthBuffer,
                        maxTextures: maxTextures,
                        maxVertexTextures: maxVertexTextures,
                        maxTextureSize: maxTextureSize,
                        maxCubemapSize: maxCubemapSize,
                        maxAttributes: maxAttributes,
                        maxVertexUniforms: maxVertexUniforms,
                        maxVaryings: maxVaryings,
                        maxFragmentUniforms: maxFragmentUniforms,
                        vertexTextures: vertexTextures,
                        maxSamples: maxSamples
                    }
                }

                function WebGLClipping(properties) {
                    const scope = this;
                    let globalState = null,
                        numGlobalPlanes = 0,
                        localClippingEnabled = !1,
                        renderingShadows = !1;
                    const plane = new Plane(),
                        viewNormalMatrix = new Matrix3(),
                        uniform = {
                            value: null,
                            needsUpdate: !1
                        };
                    this.uniform = uniform;
                    this.numPlanes = 0;
                    this.numIntersection = 0;
                    this.init = function(planes, enableLocalClipping) {
                        const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
                        localClippingEnabled = enableLocalClipping;
                        numGlobalPlanes = planes.length;
                        return enabled
                    };
                    this.beginShadows = function() {
                        renderingShadows = !0;
                        projectPlanes(null)
                    };
                    this.endShadows = function() {
                        renderingShadows = !1
                    };
                    this.setGlobalState = function(planes, camera) {
                        globalState = projectPlanes(planes, camera, 0)
                    };
                    this.setState = function(material, camera, useCache) {
                        const planes = material.clippingPlanes,
                            clipIntersection = material.clipIntersection,
                            clipShadows = material.clipShadows;
                        const materialProperties = properties.get(material);
                        if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
                            if (renderingShadows) {
                                projectPlanes(null)
                            } else {
                                resetGlobalState()
                            }
                        } else {
                            const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
                                lGlobal = nGlobal * 4;
                            let dstArray = materialProperties.clippingState || null;
                            uniform.value = dstArray;
                            dstArray = projectPlanes(planes, camera, lGlobal, useCache);
                            for (let i = 0; i !== lGlobal; ++i) {
                                dstArray[i] = globalState[i]
                            }
                            materialProperties.clippingState = dstArray;
                            this.numIntersection = clipIntersection ? this.numPlanes : 0;
                            this.numPlanes += nGlobal
                        }
                    };

                    function resetGlobalState() {
                        if (uniform.value !== globalState) {
                            uniform.value = globalState;
                            uniform.needsUpdate = numGlobalPlanes > 0
                        }
                        scope.numPlanes = numGlobalPlanes;
                        scope.numIntersection = 0
                    }

                    function projectPlanes(planes, camera, dstOffset, skipTransform) {
                        const nPlanes = planes !== null ? planes.length : 0;
                        let dstArray = null;
                        if (nPlanes !== 0) {
                            dstArray = uniform.value;
                            if (skipTransform !== !0 || dstArray === null) {
                                const flatSize = dstOffset + nPlanes * 4,
                                    viewMatrix = camera.matrixWorldInverse;
                                viewNormalMatrix.getNormalMatrix(viewMatrix);
                                if (dstArray === null || dstArray.length < flatSize) {
                                    dstArray = new Float32Array(flatSize)
                                }
                                for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
                                    plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
                                    plane.normal.toArray(dstArray, i4);
                                    dstArray[i4 + 3] = plane.constant
                                }
                            }
                            uniform.value = dstArray;
                            uniform.needsUpdate = !0
                        }
                        scope.numPlanes = nPlanes;
                        scope.numIntersection = 0;
                        return dstArray
                    }
                }

                function WebGLCubeMaps(renderer) {
                    let cubemaps = new WeakMap();

                    function mapTextureMapping(texture, mapping) {
                        if (mapping === EquirectangularReflectionMapping) {
                            texture.mapping = CubeReflectionMapping
                        } else if (mapping === EquirectangularRefractionMapping) {
                            texture.mapping = CubeRefractionMapping
                        }
                        return texture
                    }

                    function get(texture) {
                        if (texture && texture.isTexture) {
                            const mapping = texture.mapping;
                            if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
                                if (cubemaps.has(texture)) {
                                    const cubemap = cubemaps.get(texture).texture;
                                    return mapTextureMapping(cubemap, texture.mapping)
                                } else {
                                    const image = texture.image;
                                    if (image && image.height > 0) {
                                        const renderTarget = new WebGLCubeRenderTarget(image.height);
                                        renderTarget.fromEquirectangularTexture(renderer, texture);
                                        cubemaps.set(texture, renderTarget);
                                        texture.addEventListener('dispose', onTextureDispose);
                                        return mapTextureMapping(renderTarget.texture, texture.mapping)
                                    } else {
                                        return null
                                    }
                                }
                            }
                        }
                        return texture
                    }

                    function onTextureDispose(event) {
                        const texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        const cubemap = cubemaps.get(texture);
                        if (cubemap !== undefined) {
                            cubemaps.delete(texture);
                            cubemap.dispose()
                        }
                    }

                    function dispose() {
                        cubemaps = new WeakMap()
                    }
                    return {
                        get: get,
                        dispose: dispose
                    }
                }
                class OrthographicCamera extends Camera {
                    constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2000) {
                        super();
                        this.isOrthographicCamera = !0;
                        this.type = 'OrthographicCamera';
                        this.zoom = 1;
                        this.view = null;
                        this.left = left;
                        this.right = right;
                        this.top = top;
                        this.bottom = bottom;
                        this.near = near;
                        this.far = far;
                        this.updateProjectionMatrix()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.left = source.left;
                        this.right = source.right;
                        this.top = source.top;
                        this.bottom = source.bottom;
                        this.near = source.near;
                        this.far = source.far;
                        this.zoom = source.zoom;
                        this.view = source.view === null ? null : Object.assign({}, source.view);
                        return this
                    }
                    setViewOffset(fullWidth, fullHeight, x, y, width, height) {
                        if (this.view === null) {
                            this.view = {
                                enabled: !0,
                                fullWidth: 1,
                                fullHeight: 1,
                                offsetX: 0,
                                offsetY: 0,
                                width: 1,
                                height: 1
                            }
                        }
                        this.view.enabled = !0;
                        this.view.fullWidth = fullWidth;
                        this.view.fullHeight = fullHeight;
                        this.view.offsetX = x;
                        this.view.offsetY = y;
                        this.view.width = width;
                        this.view.height = height;
                        this.updateProjectionMatrix()
                    }
                    clearViewOffset() {
                        if (this.view !== null) {
                            this.view.enabled = !1
                        }
                        this.updateProjectionMatrix()
                    }
                    updateProjectionMatrix() {
                        const dx = (this.right - this.left) / (2 * this.zoom);
                        const dy = (this.top - this.bottom) / (2 * this.zoom);
                        const cx = (this.right + this.left) / 2;
                        const cy = (this.top + this.bottom) / 2;
                        let left = cx - dx;
                        let right = cx + dx;
                        let top = cy + dy;
                        let bottom = cy - dy;
                        if (this.view !== null && this.view.enabled) {
                            const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
                            const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
                            left += scaleW * this.view.offsetX;
                            right = left + scaleW * this.view.width;
                            top -= scaleH * this.view.offsetY;
                            bottom = top - scaleH * this.view.height
                        }
                        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
                        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.object.zoom = this.zoom;
                        data.object.left = this.left;
                        data.object.right = this.right;
                        data.object.top = this.top;
                        data.object.bottom = this.bottom;
                        data.object.near = this.near;
                        data.object.far = this.far;
                        if (this.view !== null) data.object.view = Object.assign({}, this.view);
                        return data
                    }
                }
                const LOD_MIN = 4;
                const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
                const MAX_SAMPLES = 20;
                const _flatCamera = new OrthographicCamera();
                const _clearColor = new Color();
                let _oldTarget = null;
                let _oldActiveCubeFace = 0;
                let _oldActiveMipmapLevel = 0;
                let _oldXrEnabled = !1;
                const PHI = (1 + Math.sqrt(5)) / 2;
                const INV_PHI = 1 / PHI;
                const _axisDirections = [new Vector3(-PHI, INV_PHI, 0), new Vector3(PHI, INV_PHI, 0), new Vector3(-INV_PHI, 0, PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(0, PHI, INV_PHI), new Vector3(-1, 1, -1), new Vector3(1, 1, -1), new Vector3(-1, 1, 1), new Vector3(1, 1, 1)];
                class PMREMGenerator {
                    constructor(renderer) {
                        this._renderer = renderer;
                        this._pingPongRenderTarget = null;
                        this._lodMax = 0;
                        this._cubeSize = 0;
                        this._lodPlanes = [];
                        this._sizeLods = [];
                        this._sigmas = [];
                        this._blurMaterial = null;
                        this._cubemapMaterial = null;
                        this._equirectMaterial = null;
                        this._compileMaterial(this._blurMaterial)
                    }
                    fromScene(scene, sigma = 0, near = 0.1, far = 100) {
                        _oldTarget = this._renderer.getRenderTarget();
                        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
                        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
                        _oldXrEnabled = this._renderer.xr.enabled;
                        this._renderer.xr.enabled = !1;
                        this._setSize(256);
                        const cubeUVRenderTarget = this._allocateTargets();
                        cubeUVRenderTarget.depthBuffer = !0;
                        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
                        if (sigma > 0) {
                            this._blur(cubeUVRenderTarget, 0, 0, sigma)
                        }
                        this._applyPMREM(cubeUVRenderTarget);
                        this._cleanup(cubeUVRenderTarget);
                        return cubeUVRenderTarget
                    }
                    fromEquirectangular(equirectangular, renderTarget = null) {
                        return this._fromTexture(equirectangular, renderTarget)
                    }
                    fromCubemap(cubemap, renderTarget = null) {
                        return this._fromTexture(cubemap, renderTarget)
                    }
                    compileCubemapShader() {
                        if (this._cubemapMaterial === null) {
                            this._cubemapMaterial = _getCubemapMaterial();
                            this._compileMaterial(this._cubemapMaterial)
                        }
                    }
                    compileEquirectangularShader() {
                        if (this._equirectMaterial === null) {
                            this._equirectMaterial = _getEquirectMaterial();
                            this._compileMaterial(this._equirectMaterial)
                        }
                    }
                    dispose() {
                        this._dispose();
                        if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
                        if (this._equirectMaterial !== null) this._equirectMaterial.dispose()
                    }
                    _setSize(cubeSize) {
                        this._lodMax = Math.floor(Math.log2(cubeSize));
                        this._cubeSize = Math.pow(2, this._lodMax)
                    }
                    _dispose() {
                        if (this._blurMaterial !== null) this._blurMaterial.dispose();
                        if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
                        for (let i = 0; i < this._lodPlanes.length; i++) {
                            this._lodPlanes[i].dispose()
                        }
                    }
                    _cleanup(outputTarget) {
                        this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
                        this._renderer.xr.enabled = _oldXrEnabled;
                        outputTarget.scissorTest = !1;
                        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height)
                    }
                    _fromTexture(texture, renderTarget) {
                        if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
                            this._setSize(texture.image.length === 0 ? 16 : (texture.image[0].width || texture.image[0].image.width))
                        } else {
                            this._setSize(texture.image.width / 4)
                        }
                        _oldTarget = this._renderer.getRenderTarget();
                        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
                        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
                        _oldXrEnabled = this._renderer.xr.enabled;
                        this._renderer.xr.enabled = !1;
                        const cubeUVRenderTarget = renderTarget || this._allocateTargets();
                        this._textureToCubeUV(texture, cubeUVRenderTarget);
                        this._applyPMREM(cubeUVRenderTarget);
                        this._cleanup(cubeUVRenderTarget);
                        return cubeUVRenderTarget
                    }
                    _allocateTargets() {
                        const width = 3 * Math.max(this._cubeSize, 16 * 7);
                        const height = 4 * this._cubeSize;
                        const params = {
                            magFilter: LinearFilter,
                            minFilter: LinearFilter,
                            generateMipmaps: !1,
                            type: HalfFloatType,
                            format: RGBAFormat,
                            colorSpace: LinearSRGBColorSpace,
                            depthBuffer: !1
                        };
                        const cubeUVRenderTarget = _createRenderTarget(width, height, params);
                        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
                            if (this._pingPongRenderTarget !== null) {
                                this._dispose()
                            }
                            this._pingPongRenderTarget = _createRenderTarget(width, height, params);
                            const {
                                _lodMax
                            } = this;
                            ({
                                sizeLods: this._sizeLods,
                                lodPlanes: this._lodPlanes,
                                sigmas: this._sigmas
                            } = _createPlanes(_lodMax));
                            this._blurMaterial = _getBlurShader(_lodMax, width, height)
                        }
                        return cubeUVRenderTarget
                    }
                    _compileMaterial(material) {
                        const tmpMesh = new Mesh(this._lodPlanes[0], material);
                        this._renderer.compile(tmpMesh, _flatCamera)
                    }
                    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
                        const fov = 90;
                        const aspect = 1;
                        const cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
                        const upSign = [1, -1, 1, 1, 1, 1];
                        const forwardSign = [1, 1, 1, -1, -1, -1];
                        const renderer = this._renderer;
                        const originalAutoClear = renderer.autoClear;
                        const toneMapping = renderer.toneMapping;
                        renderer.getClearColor(_clearColor);
                        renderer.toneMapping = NoToneMapping;
                        renderer.autoClear = !1;
                        const backgroundMaterial = new MeshBasicMaterial({
                            name: 'PMREM.Background',
                            side: BackSide,
                            depthWrite: !1,
                            depthTest: !1,
                        });
                        const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);
                        let useSolidColor = !1;
                        const background = scene.background;
                        if (background) {
                            if (background.isColor) {
                                backgroundMaterial.color.copy(background);
                                scene.background = null;
                                useSolidColor = !0
                            }
                        } else {
                            backgroundMaterial.color.copy(_clearColor);
                            useSolidColor = !0
                        }
                        for (let i = 0; i < 6; i++) {
                            const col = i % 3;
                            if (col === 0) {
                                cubeCamera.up.set(0, upSign[i], 0);
                                cubeCamera.lookAt(forwardSign[i], 0, 0)
                            } else if (col === 1) {
                                cubeCamera.up.set(0, 0, upSign[i]);
                                cubeCamera.lookAt(0, forwardSign[i], 0)
                            } else {
                                cubeCamera.up.set(0, upSign[i], 0);
                                cubeCamera.lookAt(0, 0, forwardSign[i])
                            }
                            const size = this._cubeSize;
                            _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
                            renderer.setRenderTarget(cubeUVRenderTarget);
                            if (useSolidColor) {
                                renderer.render(backgroundBox, cubeCamera)
                            }
                            renderer.render(scene, cubeCamera)
                        }
                        backgroundBox.geometry.dispose();
                        backgroundBox.material.dispose();
                        renderer.toneMapping = toneMapping;
                        renderer.autoClear = originalAutoClear;
                        scene.background = background
                    }
                    _textureToCubeUV(texture, cubeUVRenderTarget) {
                        const renderer = this._renderer;
                        const isCubeTexture = (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping);
                        if (isCubeTexture) {
                            if (this._cubemapMaterial === null) {
                                this._cubemapMaterial = _getCubemapMaterial()
                            }
                            this._cubemapMaterial.uniforms.flipEnvMap.value = (texture.isRenderTargetTexture === !1) ? -1 : 1
                        } else {
                            if (this._equirectMaterial === null) {
                                this._equirectMaterial = _getEquirectMaterial()
                            }
                        }
                        const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
                        const mesh = new Mesh(this._lodPlanes[0], material);
                        const uniforms = material.uniforms;
                        uniforms.envMap.value = texture;
                        const size = this._cubeSize;
                        _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
                        renderer.setRenderTarget(cubeUVRenderTarget);
                        renderer.render(mesh, _flatCamera)
                    }
                    _applyPMREM(cubeUVRenderTarget) {
                        const renderer = this._renderer;
                        const autoClear = renderer.autoClear;
                        renderer.autoClear = !1;
                        const n = this._lodPlanes.length;
                        for (let i = 1; i < n; i++) {
                            const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
                            const poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
                            this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis)
                        }
                        renderer.autoClear = autoClear
                    }
                    _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
                        const pingPongRenderTarget = this._pingPongRenderTarget;
                        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
                        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis)
                    }
                    _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
                        const renderer = this._renderer;
                        const blurMaterial = this._blurMaterial;
                        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
                            console.error('blur direction must be either latitudinal or longitudinal!')
                        }
                        const STANDARD_DEVIATIONS = 3;
                        const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial);
                        const blurUniforms = blurMaterial.uniforms;
                        const pixels = this._sizeLods[lodIn] - 1;
                        const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
                        const sigmaPixels = sigmaRadians / radiansPerPixel;
                        const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
                        if (samples > MAX_SAMPLES) {
                            console.warn(`sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}`)
                        }
                        const weights = [];
                        let sum = 0;
                        for (let i = 0; i < MAX_SAMPLES; ++i) {
                            const x = i / sigmaPixels;
                            const weight = Math.exp(-x * x / 2);
                            weights.push(weight);
                            if (i === 0) {
                                sum += weight
                            } else if (i < samples) {
                                sum += 2 * weight
                            }
                        }
                        for (let i = 0; i < weights.length; i++) {
                            weights[i] = weights[i] / sum
                        }
                        blurUniforms.envMap.value = targetIn.texture;
                        blurUniforms.samples.value = samples;
                        blurUniforms.weights.value = weights;
                        blurUniforms.latitudinal.value = direction === 'latitudinal';
                        if (poleAxis) {
                            blurUniforms.poleAxis.value = poleAxis
                        }
                        const {
                            _lodMax
                        } = this;
                        blurUniforms.dTheta.value = radiansPerPixel;
                        blurUniforms.mipInt.value = _lodMax - lodIn;
                        const outputSize = this._sizeLods[lodOut];
                        const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
                        const y = 4 * (this._cubeSize - outputSize);
                        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
                        renderer.setRenderTarget(targetOut);
                        renderer.render(blurMesh, _flatCamera)
                    }
                }

                function _createPlanes(lodMax) {
                    const lodPlanes = [];
                    const sizeLods = [];
                    const sigmas = [];
                    let lod = lodMax;
                    const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
                    for (let i = 0; i < totalLods; i++) {
                        const sizeLod = Math.pow(2, lod);
                        sizeLods.push(sizeLod);
                        let sigma = 1.0 / sizeLod;
                        if (i > lodMax - LOD_MIN) {
                            sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1]
                        } else if (i === 0) {
                            sigma = 0
                        }
                        sigmas.push(sigma);
                        const texelSize = 1.0 / (sizeLod - 2);
                        const min = -texelSize;
                        const max = 1 + texelSize;
                        const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
                        const cubeFaces = 6;
                        const vertices = 6;
                        const positionSize = 3;
                        const uvSize = 2;
                        const faceIndexSize = 1;
                        const position = new Float32Array(positionSize * vertices * cubeFaces);
                        const uv = new Float32Array(uvSize * vertices * cubeFaces);
                        const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
                        for (let face = 0; face < cubeFaces; face++) {
                            const x = (face % 3) * 2 / 3 - 1;
                            const y = face > 2 ? 0 : -1;
                            const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
                            position.set(coordinates, positionSize * vertices * face);
                            uv.set(uv1, uvSize * vertices * face);
                            const fill = [face, face, face, face, face, face];
                            faceIndex.set(fill, faceIndexSize * vertices * face)
                        }
                        const planes = new BufferGeometry();
                        planes.setAttribute('position', new BufferAttribute(position, positionSize));
                        planes.setAttribute('uv', new BufferAttribute(uv, uvSize));
                        planes.setAttribute('faceIndex', new BufferAttribute(faceIndex, faceIndexSize));
                        lodPlanes.push(planes);
                        if (lod > LOD_MIN) {
                            lod--
                        }
                    }
                    return {
                        lodPlanes,
                        sizeLods,
                        sigmas
                    }
                }

                function _createRenderTarget(width, height, params) {
                    const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
                    cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
                    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
                    cubeUVRenderTarget.scissorTest = !0;
                    return cubeUVRenderTarget
                }

                function _setViewport(target, x, y, width, height) {
                    target.viewport.set(x, y, width, height);
                    target.scissor.set(x, y, width, height)
                }

                function _getBlurShader(lodMax, width, height) {
                    const weights = new Float32Array(MAX_SAMPLES);
                    const poleAxis = new Vector3(0, 1, 0);
                    const shaderMaterial = new ShaderMaterial({
                        name: 'SphericalGaussianBlur',
                        defines: {
                            'n': MAX_SAMPLES,
                            'CUBEUV_TEXEL_WIDTH': 1.0 / width,
                            'CUBEUV_TEXEL_HEIGHT': 1.0 / height,
                            'CUBEUV_MAX_MIP': `${lodMax}.0`,
                        },
                        uniforms: {
                            'envMap': {
                                value: null
                            },
                            'samples': {
                                value: 1
                            },
                            'weights': {
                                value: weights
                            },
                            'latitudinal': {
                                value: !1
                            },
                            'dTheta': {
                                value: 0
                            },
                            'mipInt': {
                                value: 0
                            },
                            'poleAxis': {
                                value: poleAxis
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
                        blending: NoBlending,
                        depthTest: !1,
                        depthWrite: !1
                    });
                    return shaderMaterial
                }

                function _getEquirectMaterial() {
                    return new ShaderMaterial({
                        name: 'EquirectangularToCubeUV',
                        uniforms: {
                            'envMap': {
                                value: null
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
                        blending: NoBlending,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function _getCubemapMaterial() {
                    return new ShaderMaterial({
                        name: 'CubemapToCubeUV',
                        uniforms: {
                            'envMap': {
                                value: null
                            },
                            'flipEnvMap': {
                                value: -1
                            }
                        },
                        vertexShader: _getCommonVertexShader(),
                        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
                        blending: NoBlending,
                        depthTest: !1,
                        depthWrite: !1
                    })
                }

                function _getCommonVertexShader() {
                    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
                }

                function WebGLCubeUVMaps(renderer) {
                    let cubeUVmaps = new WeakMap();
                    let pmremGenerator = null;

                    function get(texture) {
                        if (texture && texture.isTexture) {
                            const mapping = texture.mapping;
                            const isEquirectMap = (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping);
                            const isCubeMap = (mapping === CubeReflectionMapping || mapping === CubeRefractionMapping);
                            if (isEquirectMap || isCubeMap) {
                                let renderTarget = cubeUVmaps.get(texture);
                                const currentPMREMVersion = renderTarget !== undefined ? renderTarget.texture.pmremVersion : 0;
                                if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
                                    if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                                    renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
                                    renderTarget.texture.pmremVersion = texture.pmremVersion;
                                    cubeUVmaps.set(texture, renderTarget);
                                    return renderTarget.texture
                                } else {
                                    if (renderTarget !== undefined) {
                                        return renderTarget.texture
                                    } else {
                                        const image = texture.image;
                                        if ((isEquirectMap && image && image.height > 0) || (isCubeMap && image && isCubeTextureComplete(image))) {
                                            if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
                                            renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
                                            renderTarget.texture.pmremVersion = texture.pmremVersion;
                                            cubeUVmaps.set(texture, renderTarget);
                                            texture.addEventListener('dispose', onTextureDispose);
                                            return renderTarget.texture
                                        } else {
                                            return null
                                        }
                                    }
                                }
                            }
                        }
                        return texture
                    }

                    function isCubeTextureComplete(image) {
                        let count = 0;
                        const length = 6;
                        for (let i = 0; i < length; i++) {
                            if (image[i] !== undefined) count++
                        }
                        return count === length
                    }

                    function onTextureDispose(event) {
                        const texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        const cubemapUV = cubeUVmaps.get(texture);
                        if (cubemapUV !== undefined) {
                            cubeUVmaps.delete(texture);
                            cubemapUV.dispose()
                        }
                    }

                    function dispose() {
                        cubeUVmaps = new WeakMap();
                        if (pmremGenerator !== null) {
                            pmremGenerator.dispose();
                            pmremGenerator = null
                        }
                    }
                    return {
                        get: get,
                        dispose: dispose
                    }
                }

                function WebGLExtensions(gl) {
                    const extensions = {};

                    function getExtension(name) {
                        if (extensions[name] !== undefined) {
                            return extensions[name]
                        }
                        let extension;
                        switch (name) {
                            case 'WEBGL_depth_texture':
                                extension = gl.getExtension('WEBGL_depth_texture') || gl.getExtension('MOZ_WEBGL_depth_texture') || gl.getExtension('WEBKIT_WEBGL_depth_texture');
                                break;
                            case 'EXT_texture_filter_anisotropic':
                                extension = gl.getExtension('EXT_texture_filter_anisotropic') || gl.getExtension('MOZ_EXT_texture_filter_anisotropic') || gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
                                break;
                            case 'WEBGL_compressed_texture_s3tc':
                                extension = gl.getExtension('WEBGL_compressed_texture_s3tc') || gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
                                break;
                            case 'WEBGL_compressed_texture_pvrtc':
                                extension = gl.getExtension('WEBGL_compressed_texture_pvrtc') || gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
                                break;
                            default:
                                extension = gl.getExtension(name)
                        }
                        extensions[name] = extension;
                        return extension
                    }
                    return {
                        has: function(name) {
                            return getExtension(name) !== null
                        },
                        init: function() {
                            getExtension('EXT_color_buffer_float');
                            getExtension('WEBGL_clip_cull_distance');
                            getExtension('OES_texture_float_linear');
                            getExtension('EXT_color_buffer_half_float');
                            getExtension('WEBGL_multisampled_render_to_texture');
                            getExtension('WEBGL_render_shared_exponent')
                        },
                        get: function(name) {
                            const extension = getExtension(name);
                            if (extension === null) {
                                warnOnce('THREE.WebGLRenderer: ' + name + ' extension not supported.')
                            }
                            return extension
                        }
                    }
                }

                function WebGLGeometries(gl, attributes, info, bindingStates) {
                    const geometries = {};
                    const wireframeAttributes = new WeakMap();

                    function onGeometryDispose(event) {
                        const geometry = event.target;
                        if (geometry.index !== null) {
                            attributes.remove(geometry.index)
                        }
                        for (const name in geometry.attributes) {
                            attributes.remove(geometry.attributes[name])
                        }
                        for (const name in geometry.morphAttributes) {
                            const array = geometry.morphAttributes[name];
                            for (let i = 0, l = array.length; i < l; i++) {
                                attributes.remove(array[i])
                            }
                        }
                        geometry.removeEventListener('dispose', onGeometryDispose);
                        delete geometries[geometry.id];
                        const attribute = wireframeAttributes.get(geometry);
                        if (attribute) {
                            attributes.remove(attribute);
                            wireframeAttributes.delete(geometry)
                        }
                        bindingStates.releaseStatesOfGeometry(geometry);
                        if (geometry.isInstancedBufferGeometry === !0) {
                            delete geometry._maxInstanceCount
                        }
                        info.memory.geometries--
                    }

                    function get(object, geometry) {
                        if (geometries[geometry.id] === !0) return geometry;
                        geometry.addEventListener('dispose', onGeometryDispose);
                        geometries[geometry.id] = !0;
                        info.memory.geometries++;
                        return geometry
                    }

                    function update(geometry) {
                        const geometryAttributes = geometry.attributes;
                        for (const name in geometryAttributes) {
                            attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER)
                        }
                        const morphAttributes = geometry.morphAttributes;
                        for (const name in morphAttributes) {
                            const array = morphAttributes[name];
                            for (let i = 0, l = array.length; i < l; i++) {
                                attributes.update(array[i], gl.ARRAY_BUFFER)
                            }
                        }
                    }

                    function updateWireframeAttribute(geometry) {
                        const indices = [];
                        const geometryIndex = geometry.index;
                        const geometryPosition = geometry.attributes.position;
                        let version = 0;
                        if (geometryIndex !== null) {
                            const array = geometryIndex.array;
                            version = geometryIndex.version;
                            for (let i = 0, l = array.length; i < l; i += 3) {
                                const a = array[i + 0];
                                const b = array[i + 1];
                                const c = array[i + 2];
                                indices.push(a, b, b, c, c, a)
                            }
                        } else if (geometryPosition !== undefined) {
                            const array = geometryPosition.array;
                            version = geometryPosition.version;
                            for (let i = 0, l = (array.length / 3) - 1; i < l; i += 3) {
                                const a = i + 0;
                                const b = i + 1;
                                const c = i + 2;
                                indices.push(a, b, b, c, c, a)
                            }
                        } else {
                            return
                        }
                        const attribute = new(arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
                        attribute.version = version;
                        const previousAttribute = wireframeAttributes.get(geometry);
                        if (previousAttribute) attributes.remove(previousAttribute);
                        wireframeAttributes.set(geometry, attribute)
                    }

                    function getWireframeAttribute(geometry) {
                        const currentAttribute = wireframeAttributes.get(geometry);
                        if (currentAttribute) {
                            const geometryIndex = geometry.index;
                            if (geometryIndex !== null) {
                                if (currentAttribute.version < geometryIndex.version) {
                                    updateWireframeAttribute(geometry)
                                }
                            }
                        } else {
                            updateWireframeAttribute(geometry)
                        }
                        return wireframeAttributes.get(geometry)
                    }
                    return {
                        get: get,
                        update: update,
                        getWireframeAttribute: getWireframeAttribute
                    }
                }

                function WebGLIndexedBufferRenderer(gl, extensions, info) {
                    let mode;

                    function setMode(value) {
                        mode = value
                    }
                    let type, bytesPerElement;

                    function setIndex(value) {
                        type = value.type;
                        bytesPerElement = value.bytesPerElement
                    }

                    function render(start, count) {
                        gl.drawElements(mode, count, type, start * bytesPerElement);
                        info.update(count, mode, 1)
                    }

                    function renderInstances(start, count, primcount) {
                        if (primcount === 0) return;
                        gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
                        info.update(count, mode, primcount)
                    }

                    function renderMultiDraw(starts, counts, drawCount) {
                        if (drawCount === 0) return;
                        const extension = extensions.get('WEBGL_multi_draw');
                        extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
                        let elementCount = 0;
                        for (let i = 0; i < drawCount; i++) {
                            elementCount += counts[i]
                        }
                        info.update(elementCount, mode, 1)
                    }

                    function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
                        if (drawCount === 0) return;
                        const extension = extensions.get('WEBGL_multi_draw');
                        if (extension === null) {
                            for (let i = 0; i < starts.length; i++) {
                                renderInstances(starts[i] / bytesPerElement, counts[i], primcount[i])
                            }
                        } else {
                            extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
                            let elementCount = 0;
                            for (let i = 0; i < drawCount; i++) {
                                elementCount += counts[i]
                            }
                            for (let i = 0; i < primcount.length; i++) {
                                info.update(elementCount, mode, primcount[i])
                            }
                        }
                    }
                    this.setMode = setMode;
                    this.setIndex = setIndex;
                    this.render = render;
                    this.renderInstances = renderInstances;
                    this.renderMultiDraw = renderMultiDraw;
                    this.renderMultiDrawInstances = renderMultiDrawInstances
                }

                function WebGLInfo(gl) {
                    const memory = {
                        geometries: 0,
                        textures: 0
                    };
                    const render = {
                        frame: 0,
                        calls: 0,
                        triangles: 0,
                        points: 0,
                        lines: 0
                    };

                    function update(count, mode, instanceCount) {
                        render.calls++;
                        switch (mode) {
                            case gl.TRIANGLES:
                                render.triangles += instanceCount * (count / 3);
                                break;
                            case gl.LINES:
                                render.lines += instanceCount * (count / 2);
                                break;
                            case gl.LINE_STRIP:
                                render.lines += instanceCount * (count - 1);
                                break;
                            case gl.LINE_LOOP:
                                render.lines += instanceCount * count;
                                break;
                            case gl.POINTS:
                                render.points += instanceCount * count;
                                break;
                            default:
                                console.error('THREE.WebGLInfo: Unknown draw mode:', mode);
                                break
                        }
                    }

                    function reset() {
                        render.calls = 0;
                        render.triangles = 0;
                        render.points = 0;
                        render.lines = 0
                    }
                    return {
                        memory: memory,
                        render: render,
                        programs: null,
                        autoReset: !0,
                        reset: reset,
                        update: update
                    }
                }

                function WebGLMorphtargets(gl, capabilities, textures) {
                    const morphTextures = new WeakMap();
                    const morph = new Vector4();

                    function update(object, geometry, program) {
                        const objectInfluences = object.morphTargetInfluences;
                        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                        const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                        let entry = morphTextures.get(geometry);
                        if (entry === undefined || entry.count !== morphTargetsCount) {
                            if (entry !== undefined) entry.texture.dispose();
                            const hasMorphPosition = geometry.morphAttributes.position !== undefined;
                            const hasMorphNormals = geometry.morphAttributes.normal !== undefined;
                            const hasMorphColors = geometry.morphAttributes.color !== undefined;
                            const morphTargets = geometry.morphAttributes.position || [];
                            const morphNormals = geometry.morphAttributes.normal || [];
                            const morphColors = geometry.morphAttributes.color || [];
                            let vertexDataCount = 0;
                            if (hasMorphPosition === !0) vertexDataCount = 1;
                            if (hasMorphNormals === !0) vertexDataCount = 2;
                            if (hasMorphColors === !0) vertexDataCount = 3;
                            let width = geometry.attributes.position.count * vertexDataCount;
                            let height = 1;
                            if (width > capabilities.maxTextureSize) {
                                height = Math.ceil(width / capabilities.maxTextureSize);
                                width = capabilities.maxTextureSize
                            }
                            const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
                            const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
                            texture.type = FloatType;
                            texture.needsUpdate = !0;
                            const vertexDataStride = vertexDataCount * 4;
                            for (let i = 0; i < morphTargetsCount; i++) {
                                const morphTarget = morphTargets[i];
                                const morphNormal = morphNormals[i];
                                const morphColor = morphColors[i];
                                const offset = width * height * 4 * i;
                                for (let j = 0; j < morphTarget.count; j++) {
                                    const stride = j * vertexDataStride;
                                    if (hasMorphPosition === !0) {
                                        morph.fromBufferAttribute(morphTarget, j);
                                        buffer[offset + stride + 0] = morph.x;
                                        buffer[offset + stride + 1] = morph.y;
                                        buffer[offset + stride + 2] = morph.z;
                                        buffer[offset + stride + 3] = 0
                                    }
                                    if (hasMorphNormals === !0) {
                                        morph.fromBufferAttribute(morphNormal, j);
                                        buffer[offset + stride + 4] = morph.x;
                                        buffer[offset + stride + 5] = morph.y;
                                        buffer[offset + stride + 6] = morph.z;
                                        buffer[offset + stride + 7] = 0
                                    }
                                    if (hasMorphColors === !0) {
                                        morph.fromBufferAttribute(morphColor, j);
                                        buffer[offset + stride + 8] = morph.x;
                                        buffer[offset + stride + 9] = morph.y;
                                        buffer[offset + stride + 10] = morph.z;
                                        buffer[offset + stride + 11] = (morphColor.itemSize === 4) ? morph.w : 1
                                    }
                                }
                            }
                            entry = {
                                count: morphTargetsCount,
                                texture: texture,
                                size: new Vector2(width, height)
                            };
                            morphTextures.set(geometry, entry);

                            function disposeTexture() {
                                texture.dispose();
                                morphTextures.delete(geometry);
                                geometry.removeEventListener('dispose', disposeTexture)
                            }
                            geometry.addEventListener('dispose', disposeTexture)
                        }
                        if (object.isInstancedMesh === !0 && object.morphTexture !== null) {
                            program.getUniforms().setValue(gl, 'morphTexture', object.morphTexture, textures)
                        } else {
                            let morphInfluencesSum = 0;
                            for (let i = 0; i < objectInfluences.length; i++) {
                                morphInfluencesSum += objectInfluences[i]
                            }
                            const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                            program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);
                            program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences)
                        }
                        program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);
                        program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size)
                    }
                    return {
                        update: update
                    }
                }

                function WebGLObjects(gl, geometries, attributes, info) {
                    let updateMap = new WeakMap();

                    function update(object) {
                        const frame = info.render.frame;
                        const geometry = object.geometry;
                        const buffergeometry = geometries.get(object, geometry);
                        if (updateMap.get(buffergeometry) !== frame) {
                            geometries.update(buffergeometry);
                            updateMap.set(buffergeometry, frame)
                        }
                        if (object.isInstancedMesh) {
                            if (object.hasEventListener('dispose', onInstancedMeshDispose) === !1) {
                                object.addEventListener('dispose', onInstancedMeshDispose)
                            }
                            if (updateMap.get(object) !== frame) {
                                attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
                                if (object.instanceColor !== null) {
                                    attributes.update(object.instanceColor, gl.ARRAY_BUFFER)
                                }
                                updateMap.set(object, frame)
                            }
                        }
                        if (object.isSkinnedMesh) {
                            const skeleton = object.skeleton;
                            if (updateMap.get(skeleton) !== frame) {
                                skeleton.update();
                                updateMap.set(skeleton, frame)
                            }
                        }
                        return buffergeometry
                    }

                    function dispose() {
                        updateMap = new WeakMap()
                    }

                    function onInstancedMeshDispose(event) {
                        const instancedMesh = event.target;
                        instancedMesh.removeEventListener('dispose', onInstancedMeshDispose);
                        attributes.remove(instancedMesh.instanceMatrix);
                        if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor)
                    }
                    return {
                        update: update,
                        dispose: dispose
                    }
                }
                class DepthTexture extends Texture {
                    constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format = DepthFormat) {
                        if (format !== DepthFormat && format !== DepthStencilFormat) {
                            throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat')
                        }
                        if (type === undefined && format === DepthFormat) type = UnsignedIntType;
                        if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
                        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                        this.isDepthTexture = !0;
                        this.image = {
                            width: width,
                            height: height
                        };
                        this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
                        this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
                        this.flipY = !1;
                        this.generateMipmaps = !1;
                        this.compareFunction = null
                    }
                    copy(source) {
                        super.copy(source);
                        this.compareFunction = source.compareFunction;
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
                        return data
                    }
                }
                const emptyTexture = new Texture();
                const emptyShadowTexture = new DepthTexture(1, 1);
                const emptyArrayTexture = new DataArrayTexture();
                const empty3dTexture = new Data3DTexture();
                const emptyCubeTexture = new CubeTexture();
                const arrayCacheF32 = [];
                const arrayCacheI32 = [];
                const mat4array = new Float32Array(16);
                const mat3array = new Float32Array(9);
                const mat2array = new Float32Array(4);

                function flatten(array, nBlocks, blockSize) {
                    const firstElem = array[0];
                    if (firstElem <= 0 || firstElem > 0) return array;
                    const n = nBlocks * blockSize;
                    let r = arrayCacheF32[n];
                    if (r === undefined) {
                        r = new Float32Array(n);
                        arrayCacheF32[n] = r
                    }
                    if (nBlocks !== 0) {
                        firstElem.toArray(r, 0);
                        for (let i = 1, offset = 0; i !== nBlocks; ++i) {
                            offset += blockSize;
                            array[i].toArray(r, offset)
                        }
                    }
                    return r
                }

                function arraysEqual(a, b) {
                    if (a.length !== b.length) return !1;
                    for (let i = 0, l = a.length; i < l; i++) {
                        if (a[i] !== b[i]) return !1
                    }
                    return !0
                }

                function copyArray(a, b) {
                    for (let i = 0, l = b.length; i < l; i++) {
                        a[i] = b[i]
                    }
                }

                function allocTexUnits(textures, n) {
                    let r = arrayCacheI32[n];
                    if (r === undefined) {
                        r = new Int32Array(n);
                        arrayCacheI32[n] = r
                    }
                    for (let i = 0; i !== n; ++i) {
                        r[i] = textures.allocateTextureUnit()
                    }
                    return r
                }

                function setValueV1f(gl, v) {
                    const cache = this.cache;
                    if (cache[0] === v) return;
                    gl.uniform1f(this.addr, v);
                    cache[0] = v
                }

                function setValueV2f(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y) {
                            gl.uniform2f(this.addr, v.x, v.y);
                            cache[0] = v.x;
                            cache[1] = v.y
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform2fv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV3f(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                            gl.uniform3f(this.addr, v.x, v.y, v.z);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z
                        }
                    } else if (v.r !== undefined) {
                        if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
                            gl.uniform3f(this.addr, v.r, v.g, v.b);
                            cache[0] = v.r;
                            cache[1] = v.g;
                            cache[2] = v.b
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform3fv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV4f(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                            gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z;
                            cache[3] = v.w
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform4fv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueM2(gl, v) {
                    const cache = this.cache;
                    const elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v)) return;
                        gl.uniformMatrix2fv(this.addr, !1, v);
                        copyArray(cache, v)
                    } else {
                        if (arraysEqual(cache, elements)) return;
                        mat2array.set(elements);
                        gl.uniformMatrix2fv(this.addr, !1, mat2array);
                        copyArray(cache, elements)
                    }
                }

                function setValueM3(gl, v) {
                    const cache = this.cache;
                    const elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v)) return;
                        gl.uniformMatrix3fv(this.addr, !1, v);
                        copyArray(cache, v)
                    } else {
                        if (arraysEqual(cache, elements)) return;
                        mat3array.set(elements);
                        gl.uniformMatrix3fv(this.addr, !1, mat3array);
                        copyArray(cache, elements)
                    }
                }

                function setValueM4(gl, v) {
                    const cache = this.cache;
                    const elements = v.elements;
                    if (elements === undefined) {
                        if (arraysEqual(cache, v)) return;
                        gl.uniformMatrix4fv(this.addr, !1, v);
                        copyArray(cache, v)
                    } else {
                        if (arraysEqual(cache, elements)) return;
                        mat4array.set(elements);
                        gl.uniformMatrix4fv(this.addr, !1, mat4array);
                        copyArray(cache, elements)
                    }
                }

                function setValueV1i(gl, v) {
                    const cache = this.cache;
                    if (cache[0] === v) return;
                    gl.uniform1i(this.addr, v);
                    cache[0] = v
                }

                function setValueV2i(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y) {
                            gl.uniform2i(this.addr, v.x, v.y);
                            cache[0] = v.x;
                            cache[1] = v.y
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform2iv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV3i(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                            gl.uniform3i(this.addr, v.x, v.y, v.z);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform3iv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV4i(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                            gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z;
                            cache[3] = v.w
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform4iv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV1ui(gl, v) {
                    const cache = this.cache;
                    if (cache[0] === v) return;
                    gl.uniform1ui(this.addr, v);
                    cache[0] = v
                }

                function setValueV2ui(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y) {
                            gl.uniform2ui(this.addr, v.x, v.y);
                            cache[0] = v.x;
                            cache[1] = v.y
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform2uiv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV3ui(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
                            gl.uniform3ui(this.addr, v.x, v.y, v.z);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform3uiv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueV4ui(gl, v) {
                    const cache = this.cache;
                    if (v.x !== undefined) {
                        if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
                            gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
                            cache[0] = v.x;
                            cache[1] = v.y;
                            cache[2] = v.z;
                            cache[3] = v.w
                        }
                    } else {
                        if (arraysEqual(cache, v)) return;
                        gl.uniform4uiv(this.addr, v);
                        copyArray(cache, v)
                    }
                }

                function setValueT1(gl, v, textures) {
                    const cache = this.cache;
                    const unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit
                    }
                    let emptyTexture2D;
                    if (this.type === gl.SAMPLER_2D_SHADOW) {
                        emptyShadowTexture.compareFunction = LessEqualCompare;
                        emptyTexture2D = emptyShadowTexture
                    } else {
                        emptyTexture2D = emptyTexture
                    }
                    textures.setTexture2D(v || emptyTexture2D, unit)
                }

                function setValueT3D1(gl, v, textures) {
                    const cache = this.cache;
                    const unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit
                    }
                    textures.setTexture3D(v || empty3dTexture, unit)
                }

                function setValueT6(gl, v, textures) {
                    const cache = this.cache;
                    const unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit
                    }
                    textures.setTextureCube(v || emptyCubeTexture, unit)
                }

                function setValueT2DArray1(gl, v, textures) {
                    const cache = this.cache;
                    const unit = textures.allocateTextureUnit();
                    if (cache[0] !== unit) {
                        gl.uniform1i(this.addr, unit);
                        cache[0] = unit
                    }
                    textures.setTexture2DArray(v || emptyArrayTexture, unit)
                }

                function getSingularSetter(type) {
                    switch (type) {
                        case 0x1406:
                            return setValueV1f;
                        case 0x8b50:
                            return setValueV2f;
                        case 0x8b51:
                            return setValueV3f;
                        case 0x8b52:
                            return setValueV4f;
                        case 0x8b5a:
                            return setValueM2;
                        case 0x8b5b:
                            return setValueM3;
                        case 0x8b5c:
                            return setValueM4;
                        case 0x1404:
                        case 0x8b56:
                            return setValueV1i;
                        case 0x8b53:
                        case 0x8b57:
                            return setValueV2i;
                        case 0x8b54:
                        case 0x8b58:
                            return setValueV3i;
                        case 0x8b55:
                        case 0x8b59:
                            return setValueV4i;
                        case 0x1405:
                            return setValueV1ui;
                        case 0x8dc6:
                            return setValueV2ui;
                        case 0x8dc7:
                            return setValueV3ui;
                        case 0x8dc8:
                            return setValueV4ui;
                        case 0x8b5e:
                        case 0x8d66:
                        case 0x8dca:
                        case 0x8dd2:
                        case 0x8b62:
                            return setValueT1;
                        case 0x8b5f:
                        case 0x8dcb:
                        case 0x8dd3:
                            return setValueT3D1;
                        case 0x8b60:
                        case 0x8dcc:
                        case 0x8dd4:
                        case 0x8dc5:
                            return setValueT6;
                        case 0x8dc1:
                        case 0x8dcf:
                        case 0x8dd7:
                        case 0x8dc4:
                            return setValueT2DArray1
                    }
                }

                function setValueV1fArray(gl, v) {
                    gl.uniform1fv(this.addr, v)
                }

                function setValueV2fArray(gl, v) {
                    const data = flatten(v, this.size, 2);
                    gl.uniform2fv(this.addr, data)
                }

                function setValueV3fArray(gl, v) {
                    const data = flatten(v, this.size, 3);
                    gl.uniform3fv(this.addr, data)
                }

                function setValueV4fArray(gl, v) {
                    const data = flatten(v, this.size, 4);
                    gl.uniform4fv(this.addr, data)
                }

                function setValueM2Array(gl, v) {
                    const data = flatten(v, this.size, 4);
                    gl.uniformMatrix2fv(this.addr, !1, data)
                }

                function setValueM3Array(gl, v) {
                    const data = flatten(v, this.size, 9);
                    gl.uniformMatrix3fv(this.addr, !1, data)
                }

                function setValueM4Array(gl, v) {
                    const data = flatten(v, this.size, 16);
                    gl.uniformMatrix4fv(this.addr, !1, data)
                }

                function setValueV1iArray(gl, v) {
                    gl.uniform1iv(this.addr, v)
                }

                function setValueV2iArray(gl, v) {
                    gl.uniform2iv(this.addr, v)
                }

                function setValueV3iArray(gl, v) {
                    gl.uniform3iv(this.addr, v)
                }

                function setValueV4iArray(gl, v) {
                    gl.uniform4iv(this.addr, v)
                }

                function setValueV1uiArray(gl, v) {
                    gl.uniform1uiv(this.addr, v)
                }

                function setValueV2uiArray(gl, v) {
                    gl.uniform2uiv(this.addr, v)
                }

                function setValueV3uiArray(gl, v) {
                    gl.uniform3uiv(this.addr, v)
                }

                function setValueV4uiArray(gl, v) {
                    gl.uniform4uiv(this.addr, v)
                }

                function setValueT1Array(gl, v, textures) {
                    const cache = this.cache;
                    const n = v.length;
                    const units = allocTexUnits(textures, n);
                    if (!arraysEqual(cache, units)) {
                        gl.uniform1iv(this.addr, units);
                        copyArray(cache, units)
                    }
                    for (let i = 0; i !== n; ++i) {
                        textures.setTexture2D(v[i] || emptyTexture, units[i])
                    }
                }

                function setValueT3DArray(gl, v, textures) {
                    const cache = this.cache;
                    const n = v.length;
                    const units = allocTexUnits(textures, n);
                    if (!arraysEqual(cache, units)) {
                        gl.uniform1iv(this.addr, units);
                        copyArray(cache, units)
                    }
                    for (let i = 0; i !== n; ++i) {
                        textures.setTexture3D(v[i] || empty3dTexture, units[i])
                    }
                }

                function setValueT6Array(gl, v, textures) {
                    const cache = this.cache;
                    const n = v.length;
                    const units = allocTexUnits(textures, n);
                    if (!arraysEqual(cache, units)) {
                        gl.uniform1iv(this.addr, units);
                        copyArray(cache, units)
                    }
                    for (let i = 0; i !== n; ++i) {
                        textures.setTextureCube(v[i] || emptyCubeTexture, units[i])
                    }
                }

                function setValueT2DArrayArray(gl, v, textures) {
                    const cache = this.cache;
                    const n = v.length;
                    const units = allocTexUnits(textures, n);
                    if (!arraysEqual(cache, units)) {
                        gl.uniform1iv(this.addr, units);
                        copyArray(cache, units)
                    }
                    for (let i = 0; i !== n; ++i) {
                        textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i])
                    }
                }

                function getPureArraySetter(type) {
                    switch (type) {
                        case 0x1406:
                            return setValueV1fArray;
                        case 0x8b50:
                            return setValueV2fArray;
                        case 0x8b51:
                            return setValueV3fArray;
                        case 0x8b52:
                            return setValueV4fArray;
                        case 0x8b5a:
                            return setValueM2Array;
                        case 0x8b5b:
                            return setValueM3Array;
                        case 0x8b5c:
                            return setValueM4Array;
                        case 0x1404:
                        case 0x8b56:
                            return setValueV1iArray;
                        case 0x8b53:
                        case 0x8b57:
                            return setValueV2iArray;
                        case 0x8b54:
                        case 0x8b58:
                            return setValueV3iArray;
                        case 0x8b55:
                        case 0x8b59:
                            return setValueV4iArray;
                        case 0x1405:
                            return setValueV1uiArray;
                        case 0x8dc6:
                            return setValueV2uiArray;
                        case 0x8dc7:
                            return setValueV3uiArray;
                        case 0x8dc8:
                            return setValueV4uiArray;
                        case 0x8b5e:
                        case 0x8d66:
                        case 0x8dca:
                        case 0x8dd2:
                        case 0x8b62:
                            return setValueT1Array;
                        case 0x8b5f:
                        case 0x8dcb:
                        case 0x8dd3:
                            return setValueT3DArray;
                        case 0x8b60:
                        case 0x8dcc:
                        case 0x8dd4:
                        case 0x8dc5:
                            return setValueT6Array;
                        case 0x8dc1:
                        case 0x8dcf:
                        case 0x8dd7:
                        case 0x8dc4:
                            return setValueT2DArrayArray
                    }
                }
                class SingleUniform {
                    constructor(id, activeInfo, addr) {
                        this.id = id;
                        this.addr = addr;
                        this.cache = [];
                        this.type = activeInfo.type;
                        this.setValue = getSingularSetter(activeInfo.type)
                    }
                }
                class PureArrayUniform {
                    constructor(id, activeInfo, addr) {
                        this.id = id;
                        this.addr = addr;
                        this.cache = [];
                        this.type = activeInfo.type;
                        this.size = activeInfo.size;
                        this.setValue = getPureArraySetter(activeInfo.type)
                    }
                }
                class StructuredUniform {
                    constructor(id) {
                        this.id = id;
                        this.seq = [];
                        this.map = {}
                    }
                    setValue(gl, value, textures) {
                        const seq = this.seq;
                        for (let i = 0, n = seq.length; i !== n; ++i) {
                            const u = seq[i];
                            u.setValue(gl, value[u.id], textures)
                        }
                    }
                }
                const RePathPart = /(\w+)(\])?(\[|\.)?/g;

                function addUniform(container, uniformObject) {
                    container.seq.push(uniformObject);
                    container.map[uniformObject.id] = uniformObject
                }

                function parseUniform(activeInfo, addr, container) {
                    const path = activeInfo.name,
                        pathLength = path.length;
                    RePathPart.lastIndex = 0;
                    while (!0) {
                        const match = RePathPart.exec(path),
                            matchEnd = RePathPart.lastIndex;
                        let id = match[1];
                        const idIsIndex = match[2] === ']',
                            subscript = match[3];
                        if (idIsIndex) id = id | 0;
                        if (subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength) {
                            addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
                            break
                        } else {
                            const map = container.map;
                            let next = map[id];
                            if (next === undefined) {
                                next = new StructuredUniform(id);
                                addUniform(container, next)
                            }
                            container = next
                        }
                    }
                }
                class WebGLUniforms {
                    constructor(gl, program) {
                        this.seq = [];
                        this.map = {};
                        const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
                        for (let i = 0; i < n; ++i) {
                            const info = gl.getActiveUniform(program, i),
                                addr = gl.getUniformLocation(program, info.name);
                            parseUniform(info, addr, this)
                        }
                    }
                    setValue(gl, name, value, textures) {
                        const u = this.map[name];
                        if (u !== undefined) u.setValue(gl, value, textures)
                    }
                    setOptional(gl, object, name) {
                        const v = object[name];
                        if (v !== undefined) this.setValue(gl, name, v)
                    }
                    static upload(gl, seq, values, textures) {
                        for (let i = 0, n = seq.length; i !== n; ++i) {
                            const u = seq[i],
                                v = values[u.id];
                            if (v.needsUpdate !== !1) {
                                u.setValue(gl, v.value, textures)
                            }
                        }
                    }
                    static seqWithValue(seq, values) {
                        const r = [];
                        for (let i = 0, n = seq.length; i !== n; ++i) {
                            const u = seq[i];
                            if (u.id in values) r.push(u)
                        }
                        return r
                    }
                }

                function WebGLShader(gl, type, string) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, string);
                    gl.compileShader(shader);
                    return shader
                }
                const COMPLETION_STATUS_KHR = 0x91B1;
                let programIdCount = 0;

                function handleSource(string, errorLine) {
                    const lines = string.split('\n');
                    const lines2 = [];
                    const from = Math.max(errorLine - 6, 0);
                    const to = Math.min(errorLine + 6, lines.length);
                    for (let i = from; i < to; i++) {
                        const line = i + 1;
                        lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[ i ]}`)
                    }
                    return lines2.join('\n')
                }

                function getEncodingComponents(colorSpace) {
                    const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
                    const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
                    let gamutMapping;
                    if (workingPrimaries === encodingPrimaries) {
                        gamutMapping = ''
                    } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
                        gamutMapping = 'LinearDisplayP3ToLinearSRGB'
                    } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
                        gamutMapping = 'LinearSRGBToLinearDisplayP3'
                    }
                    switch (colorSpace) {
                        case LinearSRGBColorSpace:
                        case LinearDisplayP3ColorSpace:
                            return [gamutMapping, 'LinearTransferOETF'];
                        case SRGBColorSpace:
                        case DisplayP3ColorSpace:
                            return [gamutMapping, 'sRGBTransferOETF'];
                        default:
                            console.warn('THREE.WebGLProgram: Unsupported color space:', colorSpace);
                            return [gamutMapping, 'LinearTransferOETF']
                    }
                }

                function getShaderErrors(gl, shader, type) {
                    const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                    const errors = gl.getShaderInfoLog(shader).trim();
                    if (status && errors === '') return '';
                    const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
                    if (errorMatches) {
                        const errorLine = parseInt(errorMatches[1]);
                        return type.toUpperCase() + '\n\n' + errors + '\n\n' + handleSource(gl.getShaderSource(shader), errorLine)
                    } else {
                        return errors
                    }
                }

                function getTexelEncodingFunction(functionName, colorSpace) {
                    const components = getEncodingComponents(colorSpace);
                    return `vec4 ${functionName}( vec4 value ) { return ${components[ 0 ]}( ${components[ 1 ]}( value ) ); }`
                }

                function getToneMappingFunction(functionName, toneMapping) {
                    let toneMappingName;
                    switch (toneMapping) {
                        case LinearToneMapping:
                            toneMappingName = 'Linear';
                            break;
                        case ReinhardToneMapping:
                            toneMappingName = 'Reinhard';
                            break;
                        case CineonToneMapping:
                            toneMappingName = 'OptimizedCineon';
                            break;
                        case ACESFilmicToneMapping:
                            toneMappingName = 'ACESFilmic';
                            break;
                        case AgXToneMapping:
                            toneMappingName = 'AgX';
                            break;
                        case NeutralToneMapping:
                            toneMappingName = 'Neutral';
                            break;
                        case CustomToneMapping:
                            toneMappingName = 'Custom';
                            break;
                        default:
                            console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping);
                            toneMappingName = 'Linear'
                    }
                    return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }'
                }
                const _v0$1 = new Vector3();

                function getLuminanceFunction() {
                    ColorManagement.getLuminanceCoefficients(_v0$1);
                    const r = _v0$1.x.toFixed(4);
                    const g = _v0$1.y.toFixed(4);
                    const b = _v0$1.z.toFixed(4);
                    return ['float luminance( const in vec3 rgb ) {', `	const vec3 weights = vec3( ${ r }, ${ g }, ${ b } );`, '	return dot( weights, rgb );', '}'].join('\n')
                }

                function generateVertexExtensions(parameters) {
                    const chunks = [parameters.extensionClipCullDistance ? '#extension GL_ANGLE_clip_cull_distance : require' : '', parameters.extensionMultiDraw ? '#extension GL_ANGLE_multi_draw : require' : '', ];
                    return chunks.filter(filterEmptyLine).join('\n')
                }

                function generateDefines(defines) {
                    const chunks = [];
                    for (const name in defines) {
                        const value = defines[name];
                        if (value === !1) continue;
                        chunks.push('#define ' + name + ' ' + value)
                    }
                    return chunks.join('\n')
                }

                function fetchAttributeLocations(gl, program) {
                    const attributes = {};
                    const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
                    for (let i = 0; i < n; i++) {
                        const info = gl.getActiveAttrib(program, i);
                        const name = info.name;
                        let locationSize = 1;
                        if (info.type === gl.FLOAT_MAT2) locationSize = 2;
                        if (info.type === gl.FLOAT_MAT3) locationSize = 3;
                        if (info.type === gl.FLOAT_MAT4) locationSize = 4;
                        attributes[name] = {
                            type: info.type,
                            location: gl.getAttribLocation(program, name),
                            locationSize: locationSize
                        }
                    }
                    return attributes
                }

                function filterEmptyLine(string) {
                    return string !== ''
                }

                function replaceLightNums(string, parameters) {
                    const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
                    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows)
                }

                function replaceClippingPlaneNums(string, parameters) {
                    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, (parameters.numClippingPlanes - parameters.numClipIntersection))
                }
                const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

                function resolveIncludes(string) {
                    return string.replace(includePattern, includeReplacer)
                }
                const shaderChunkMap = new Map();

                function includeReplacer(match, include) {
                    let string = ShaderChunk[include];
                    if (string === undefined) {
                        const newInclude = shaderChunkMap.get(include);
                        if (newInclude !== undefined) {
                            string = ShaderChunk[newInclude];
                            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude)
                        } else {
                            throw new Error('Can not resolve #include <' + include + '>')
                        }
                    }
                    return resolveIncludes(string)
                }
                const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

                function unrollLoops(string) {
                    return string.replace(unrollLoopPattern, loopReplacer)
                }

                function loopReplacer(match, start, end, snippet) {
                    let string = '';
                    for (let i = parseInt(start); i < parseInt(end); i++) {
                        string += snippet.replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]').replace(/UNROLLED_LOOP_INDEX/g, i)
                    }
                    return string
                }

                function generatePrecision(parameters) {
                    let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
                    if (parameters.precision === 'highp') {
                        precisionstring += '\n#define HIGH_PRECISION'
                    } else if (parameters.precision === 'mediump') {
                        precisionstring += '\n#define MEDIUM_PRECISION'
                    } else if (parameters.precision === 'lowp') {
                        precisionstring += '\n#define LOW_PRECISION'
                    }
                    return precisionstring
                }

                function generateShadowMapTypeDefine(parameters) {
                    let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
                    if (parameters.shadowMapType === PCFShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF'
                    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT'
                    } else if (parameters.shadowMapType === VSMShadowMap) {
                        shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM'
                    }
                    return shadowMapTypeDefine
                }

                function generateEnvMapTypeDefine(parameters) {
                    let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                    if (parameters.envMap) {
                        switch (parameters.envMapMode) {
                            case CubeReflectionMapping:
                            case CubeRefractionMapping:
                                envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
                                break;
                            case CubeUVReflectionMapping:
                                envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
                                break
                        }
                    }
                    return envMapTypeDefine
                }

                function generateEnvMapModeDefine(parameters) {
                    let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
                    if (parameters.envMap) {
                        switch (parameters.envMapMode) {
                            case CubeRefractionMapping:
                                envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
                                break
                        }
                    }
                    return envMapModeDefine
                }

                function generateEnvMapBlendingDefine(parameters) {
                    let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';
                    if (parameters.envMap) {
                        switch (parameters.combine) {
                            case MultiplyOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
                                break;
                            case MixOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
                                break;
                            case AddOperation:
                                envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
                                break
                        }
                    }
                    return envMapBlendingDefine
                }

                function generateCubeUVSize(parameters) {
                    const imageHeight = parameters.envMapCubeUVHeight;
                    if (imageHeight === null) return null;
                    const maxMip = Math.log2(imageHeight) - 2;
                    const texelHeight = 1.0 / imageHeight;
                    const texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
                    return {
                        texelWidth,
                        texelHeight,
                        maxMip
                    }
                }

                function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
                    const gl = renderer.getContext();
                    const defines = parameters.defines;
                    let vertexShader = parameters.vertexShader;
                    let fragmentShader = parameters.fragmentShader;
                    const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
                    const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
                    const envMapModeDefine = generateEnvMapModeDefine(parameters);
                    const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
                    const envMapCubeUVSize = generateCubeUVSize(parameters);
                    const customVertexExtensions = generateVertexExtensions(parameters);
                    const customDefines = generateDefines(defines);
                    const program = gl.createProgram();
                    let prefixVertex, prefixFragment;
                    let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';
                    if (parameters.isRawShaderMaterial) {
                        prefixVertex = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
                        if (prefixVertex.length > 0) {
                            prefixVertex += '\n'
                        }
                        prefixFragment = ['#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines].filter(filterEmptyLine).join('\n');
                        if (prefixFragment.length > 0) {
                            prefixFragment += '\n'
                        }
                    } else {
                        prefixVertex = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.extensionClipCullDistance ? '#define USE_CLIP_DISTANCE' : '', parameters.batching ? '#define USE_BATCHING' : '', parameters.batchingColor ? '#define USE_BATCHING_COLOR' : '', parameters.instancing ? '#define USE_INSTANCING' : '', parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '', parameters.instancingMorph ? '#define USE_INSTANCING_MORPH' : '', parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.map ? '#define USE_MAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.displacementMap ? '#define USE_DISPLACEMENTMAP' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '', parameters.mapUv ? '#define MAP_UV ' + parameters.mapUv : '', parameters.alphaMapUv ? '#define ALPHAMAP_UV ' + parameters.alphaMapUv : '', parameters.lightMapUv ? '#define LIGHTMAP_UV ' + parameters.lightMapUv : '', parameters.aoMapUv ? '#define AOMAP_UV ' + parameters.aoMapUv : '', parameters.emissiveMapUv ? '#define EMISSIVEMAP_UV ' + parameters.emissiveMapUv : '', parameters.bumpMapUv ? '#define BUMPMAP_UV ' + parameters.bumpMapUv : '', parameters.normalMapUv ? '#define NORMALMAP_UV ' + parameters.normalMapUv : '', parameters.displacementMapUv ? '#define DISPLACEMENTMAP_UV ' + parameters.displacementMapUv : '', parameters.metalnessMapUv ? '#define METALNESSMAP_UV ' + parameters.metalnessMapUv : '', parameters.roughnessMapUv ? '#define ROUGHNESSMAP_UV ' + parameters.roughnessMapUv : '', parameters.anisotropyMapUv ? '#define ANISOTROPYMAP_UV ' + parameters.anisotropyMapUv : '', parameters.clearcoatMapUv ? '#define CLEARCOATMAP_UV ' + parameters.clearcoatMapUv : '', parameters.clearcoatNormalMapUv ? '#define CLEARCOAT_NORMALMAP_UV ' + parameters.clearcoatNormalMapUv : '', parameters.clearcoatRoughnessMapUv ? '#define CLEARCOAT_ROUGHNESSMAP_UV ' + parameters.clearcoatRoughnessMapUv : '', parameters.iridescenceMapUv ? '#define IRIDESCENCEMAP_UV ' + parameters.iridescenceMapUv : '', parameters.iridescenceThicknessMapUv ? '#define IRIDESCENCE_THICKNESSMAP_UV ' + parameters.iridescenceThicknessMapUv : '', parameters.sheenColorMapUv ? '#define SHEEN_COLORMAP_UV ' + parameters.sheenColorMapUv : '', parameters.sheenRoughnessMapUv ? '#define SHEEN_ROUGHNESSMAP_UV ' + parameters.sheenRoughnessMapUv : '', parameters.specularMapUv ? '#define SPECULARMAP_UV ' + parameters.specularMapUv : '', parameters.specularColorMapUv ? '#define SPECULAR_COLORMAP_UV ' + parameters.specularColorMapUv : '', parameters.specularIntensityMapUv ? '#define SPECULAR_INTENSITYMAP_UV ' + parameters.specularIntensityMapUv : '', parameters.transmissionMapUv ? '#define TRANSMISSIONMAP_UV ' + parameters.transmissionMapUv : '', parameters.thicknessMapUv ? '#define THICKNESSMAP_UV ' + parameters.thicknessMapUv : '', parameters.vertexTangents && parameters.flatShading === !1 ? '#define USE_TANGENT' : '', parameters.vertexColors ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.skinning ? '#define USE_SKINNING' : '', parameters.morphTargets ? '#define USE_MORPHTARGETS' : '', parameters.morphNormals && parameters.flatShading === !1 ? '#define USE_MORPHNORMALS' : '', (parameters.morphColors) ? '#define USE_MORPHCOLORS' : '', (parameters.morphTargetsCount > 0) ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride : '', (parameters.morphTargetsCount > 0) ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 modelMatrix;', 'uniform mat4 modelViewMatrix;', 'uniform mat4 projectionMatrix;', 'uniform mat4 viewMatrix;', 'uniform mat3 normalMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', '#ifdef USE_INSTANCING', '	attribute mat4 instanceMatrix;', '#endif', '#ifdef USE_INSTANCING_COLOR', '	attribute vec3 instanceColor;', '#endif', '#ifdef USE_INSTANCING_MORPH', '	uniform sampler2D morphTexture;', '#endif', 'attribute vec3 position;', 'attribute vec3 normal;', 'attribute vec2 uv;', '#ifdef USE_UV1', '	attribute vec2 uv1;', '#endif', '#ifdef USE_UV2', '	attribute vec2 uv2;', '#endif', '#ifdef USE_UV3', '	attribute vec2 uv3;', '#endif', '#ifdef USE_TANGENT', '	attribute vec4 tangent;', '#endif', '#if defined( USE_COLOR_ALPHA )', '	attribute vec4 color;', '#elif defined( USE_COLOR )', '	attribute vec3 color;', '#endif', '#ifdef USE_SKINNING', '	attribute vec4 skinIndex;', '	attribute vec4 skinWeight;', '#endif', '\n'].filter(filterEmptyLine).join('\n');
                        prefixFragment = [generatePrecision(parameters), '#define SHADER_TYPE ' + parameters.shaderType, '#define SHADER_NAME ' + parameters.shaderName, customDefines, parameters.useFog && parameters.fog ? '#define USE_FOG' : '', parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '', parameters.alphaToCoverage ? '#define ALPHA_TO_COVERAGE' : '', parameters.map ? '#define USE_MAP' : '', parameters.matcap ? '#define USE_MATCAP' : '', parameters.envMap ? '#define USE_ENVMAP' : '', parameters.envMap ? '#define ' + envMapTypeDefine : '', parameters.envMap ? '#define ' + envMapModeDefine : '', parameters.envMap ? '#define ' + envMapBlendingDefine : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth : '', envMapCubeUVSize ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight : '', envMapCubeUVSize ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0' : '', parameters.lightMap ? '#define USE_LIGHTMAP' : '', parameters.aoMap ? '#define USE_AOMAP' : '', parameters.bumpMap ? '#define USE_BUMPMAP' : '', parameters.normalMap ? '#define USE_NORMALMAP' : '', parameters.normalMapObjectSpace ? '#define USE_NORMALMAP_OBJECTSPACE' : '', parameters.normalMapTangentSpace ? '#define USE_NORMALMAP_TANGENTSPACE' : '', parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '', parameters.anisotropy ? '#define USE_ANISOTROPY' : '', parameters.anisotropyMap ? '#define USE_ANISOTROPYMAP' : '', parameters.clearcoat ? '#define USE_CLEARCOAT' : '', parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '', parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '', parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '', parameters.dispersion ? '#define USE_DISPERSION' : '', parameters.iridescence ? '#define USE_IRIDESCENCE' : '', parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '', parameters.iridescenceThicknessMap ? '#define USE_IRIDESCENCE_THICKNESSMAP' : '', parameters.specularMap ? '#define USE_SPECULARMAP' : '', parameters.specularColorMap ? '#define USE_SPECULAR_COLORMAP' : '', parameters.specularIntensityMap ? '#define USE_SPECULAR_INTENSITYMAP' : '', parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '', parameters.metalnessMap ? '#define USE_METALNESSMAP' : '', parameters.alphaMap ? '#define USE_ALPHAMAP' : '', parameters.alphaTest ? '#define USE_ALPHATEST' : '', parameters.alphaHash ? '#define USE_ALPHAHASH' : '', parameters.sheen ? '#define USE_SHEEN' : '', parameters.sheenColorMap ? '#define USE_SHEEN_COLORMAP' : '', parameters.sheenRoughnessMap ? '#define USE_SHEEN_ROUGHNESSMAP' : '', parameters.transmission ? '#define USE_TRANSMISSION' : '', parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '', parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '', parameters.vertexTangents && parameters.flatShading === !1 ? '#define USE_TANGENT' : '', parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? '#define USE_COLOR' : '', parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '', parameters.vertexUv1s ? '#define USE_UV1' : '', parameters.vertexUv2s ? '#define USE_UV2' : '', parameters.vertexUv3s ? '#define USE_UV3' : '', parameters.pointsUvs ? '#define USE_POINTS_UV' : '', parameters.gradientMap ? '#define USE_GRADIENTMAP' : '', parameters.flatShading ? '#define FLAT_SHADED' : '', parameters.doubleSided ? '#define DOUBLE_SIDED' : '', parameters.flipSided ? '#define FLIP_SIDED' : '', parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '', parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '', parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '', parameters.numLightProbes > 0 ? '#define USE_LIGHT_PROBES' : '', parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '', parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '', 'uniform mat4 viewMatrix;', 'uniform vec3 cameraPosition;', 'uniform bool isOrthographic;', (parameters.toneMapping !== NoToneMapping) ? '#define TONE_MAPPING' : '', (parameters.toneMapping !== NoToneMapping) ? ShaderChunk.tonemapping_pars_fragment : '', (parameters.toneMapping !== NoToneMapping) ? getToneMappingFunction('toneMapping', parameters.toneMapping) : '', parameters.dithering ? '#define DITHERING' : '', parameters.opaque ? '#define OPAQUE' : '', ShaderChunk.colorspace_pars_fragment, getTexelEncodingFunction('linearToOutputTexel', parameters.outputColorSpace), getLuminanceFunction(), parameters.useDepthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '', '\n'].filter(filterEmptyLine).join('\n')
                    }
                    vertexShader = resolveIncludes(vertexShader);
                    vertexShader = replaceLightNums(vertexShader, parameters);
                    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
                    fragmentShader = resolveIncludes(fragmentShader);
                    fragmentShader = replaceLightNums(fragmentShader, parameters);
                    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
                    vertexShader = unrollLoops(vertexShader);
                    fragmentShader = unrollLoops(fragmentShader);
                    if (parameters.isRawShaderMaterial !== !0) {
                        versionString = '#version 300 es\n';
                        prefixVertex = [customVertexExtensions, '#define attribute in', '#define varying out', '#define texture2D texture'].join('\n') + '\n' + prefixVertex;
                        prefixFragment = ['#define varying in', (parameters.glslVersion === GLSL3) ? '' : 'layout(location = 0) out highp vec4 pc_fragColor;', (parameters.glslVersion === GLSL3) ? '' : '#define gl_FragColor pc_fragColor', '#define gl_FragDepthEXT gl_FragDepth', '#define texture2D texture', '#define textureCube texture', '#define texture2DProj textureProj', '#define texture2DLodEXT textureLod', '#define texture2DProjLodEXT textureProjLod', '#define textureCubeLodEXT textureLod', '#define texture2DGradEXT textureGrad', '#define texture2DProjGradEXT textureProjGrad', '#define textureCubeGradEXT textureGrad'].join('\n') + '\n' + prefixFragment
                    }
                    const vertexGlsl = versionString + prefixVertex + vertexShader;
                    const fragmentGlsl = versionString + prefixFragment + fragmentShader;
                    const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
                    const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
                    gl.attachShader(program, glVertexShader);
                    gl.attachShader(program, glFragmentShader);
                    if (parameters.index0AttributeName !== undefined) {
                        gl.bindAttribLocation(program, 0, parameters.index0AttributeName)
                    } else if (parameters.morphTargets === !0) {
                        gl.bindAttribLocation(program, 0, 'position')
                    }
                    gl.linkProgram(program);

                    function onFirstUse(self) {
                        if (renderer.debug.checkShaderErrors) {
                            const programLog = gl.getProgramInfoLog(program).trim();
                            const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
                            const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
                            let runnable = !0;
                            let haveDiagnostics = !0;
                            if (gl.getProgramParameter(program, gl.LINK_STATUS) === !1) {
                                runnable = !1;
                                if (typeof renderer.debug.onShaderError === 'function') {
                                    renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader)
                                } else {
                                    const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex');
                                    const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment');
                                    console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + '\n\n' + 'Material Name: ' + self.name + '\n' + 'Material Type: ' + self.type + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors)
                                }
                            } else if (programLog !== '') {
                                console.warn('THREE.WebGLProgram: Program Info Log:', programLog)
                            } else if (vertexLog === '' || fragmentLog === '') {
                                haveDiagnostics = !1
                            }
                            if (haveDiagnostics) {
                                self.diagnostics = {
                                    runnable: runnable,
                                    programLog: programLog,
                                    vertexShader: {
                                        log: vertexLog,
                                        prefix: prefixVertex
                                    },
                                    fragmentShader: {
                                        log: fragmentLog,
                                        prefix: prefixFragment
                                    }
                                }
                            }
                        }
                        gl.deleteShader(glVertexShader);
                        gl.deleteShader(glFragmentShader);
                        cachedUniforms = new WebGLUniforms(gl, program);
                        cachedAttributes = fetchAttributeLocations(gl, program)
                    }
                    let cachedUniforms;
                    this.getUniforms = function() {
                        if (cachedUniforms === undefined) {
                            onFirstUse(this)
                        }
                        return cachedUniforms
                    };
                    let cachedAttributes;
                    this.getAttributes = function() {
                        if (cachedAttributes === undefined) {
                            onFirstUse(this)
                        }
                        return cachedAttributes
                    };
                    let programReady = (parameters.rendererExtensionParallelShaderCompile === !1);
                    this.isReady = function() {
                        if (programReady === !1) {
                            programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR)
                        }
                        return programReady
                    };
                    this.destroy = function() {
                        bindingStates.releaseStatesOfProgram(this);
                        gl.deleteProgram(program);
                        this.program = undefined
                    };
                    this.type = parameters.shaderType;
                    this.name = parameters.shaderName;
                    this.id = programIdCount++;
                    this.cacheKey = cacheKey;
                    this.usedTimes = 1;
                    this.program = program;
                    this.vertexShader = glVertexShader;
                    this.fragmentShader = glFragmentShader;
                    return this
                }
                let _id$1 = 0;
                class WebGLShaderCache {
                    constructor() {
                        this.shaderCache = new Map();
                        this.materialCache = new Map()
                    }
                    update(material) {
                        const vertexShader = material.vertexShader;
                        const fragmentShader = material.fragmentShader;
                        const vertexShaderStage = this._getShaderStage(vertexShader);
                        const fragmentShaderStage = this._getShaderStage(fragmentShader);
                        const materialShaders = this._getShaderCacheForMaterial(material);
                        if (materialShaders.has(vertexShaderStage) === !1) {
                            materialShaders.add(vertexShaderStage);
                            vertexShaderStage.usedTimes++
                        }
                        if (materialShaders.has(fragmentShaderStage) === !1) {
                            materialShaders.add(fragmentShaderStage);
                            fragmentShaderStage.usedTimes++
                        }
                        return this
                    }
                    remove(material) {
                        const materialShaders = this.materialCache.get(material);
                        for (const shaderStage of materialShaders) {
                            shaderStage.usedTimes--;
                            if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code)
                        }
                        this.materialCache.delete(material);
                        return this
                    }
                    getVertexShaderID(material) {
                        return this._getShaderStage(material.vertexShader).id
                    }
                    getFragmentShaderID(material) {
                        return this._getShaderStage(material.fragmentShader).id
                    }
                    dispose() {
                        this.shaderCache.clear();
                        this.materialCache.clear()
                    }
                    _getShaderCacheForMaterial(material) {
                        const cache = this.materialCache;
                        let set = cache.get(material);
                        if (set === undefined) {
                            set = new Set();
                            cache.set(material, set)
                        }
                        return set
                    }
                    _getShaderStage(code) {
                        const cache = this.shaderCache;
                        let stage = cache.get(code);
                        if (stage === undefined) {
                            stage = new WebGLShaderStage(code);
                            cache.set(code, stage)
                        }
                        return stage
                    }
                }
                class WebGLShaderStage {
                    constructor(code) {
                        this.id = _id$1++;
                        this.code = code;
                        this.usedTimes = 0
                    }
                }

                function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
                    const _programLayers = new Layers();
                    const _customShaders = new WebGLShaderCache();
                    const _activeChannels = new Set();
                    const programs = [];
                    const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
                    const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
                    let precision = capabilities.precision;
                    const shaderIDs = {
                        MeshDepthMaterial: 'depth',
                        MeshDistanceMaterial: 'distanceRGBA',
                        MeshNormalMaterial: 'normal',
                        MeshBasicMaterial: 'basic',
                        MeshLambertMaterial: 'lambert',
                        MeshPhongMaterial: 'phong',
                        MeshToonMaterial: 'toon',
                        MeshStandardMaterial: 'physical',
                        MeshPhysicalMaterial: 'physical',
                        MeshMatcapMaterial: 'matcap',
                        LineBasicMaterial: 'basic',
                        LineDashedMaterial: 'dashed',
                        PointsMaterial: 'points',
                        ShadowMaterial: 'shadow',
                        SpriteMaterial: 'sprite'
                    };

                    function getChannel(value) {
                        _activeChannels.add(value);
                        if (value === 0) return 'uv';
                        return `uv${ value }`
                    }

                    function getParameters(material, lights, shadows, scene, object) {
                        const fog = scene.fog;
                        const geometry = object.geometry;
                        const environment = material.isMeshStandardMaterial ? scene.environment : null;
                        const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
                        const envMapCubeUVHeight = (!!envMap) && (envMap.mapping === CubeUVReflectionMapping) ? envMap.image.height : null;
                        const shaderID = shaderIDs[material.type];
                        if (material.precision !== null) {
                            precision = capabilities.getMaxPrecision(material.precision);
                            if (precision !== material.precision) {
                                console.warn('THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.')
                            }
                        }
                        const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                        const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                        let morphTextureStride = 0;
                        if (geometry.morphAttributes.position !== undefined) morphTextureStride = 1;
                        if (geometry.morphAttributes.normal !== undefined) morphTextureStride = 2;
                        if (geometry.morphAttributes.color !== undefined) morphTextureStride = 3;
                        let vertexShader, fragmentShader;
                        let customVertexShaderID, customFragmentShaderID;
                        if (shaderID) {
                            const shader = ShaderLib[shaderID];
                            vertexShader = shader.vertexShader;
                            fragmentShader = shader.fragmentShader
                        } else {
                            vertexShader = material.vertexShader;
                            fragmentShader = material.fragmentShader;
                            _customShaders.update(material);
                            customVertexShaderID = _customShaders.getVertexShaderID(material);
                            customFragmentShaderID = _customShaders.getFragmentShaderID(material)
                        }
                        const currentRenderTarget = renderer.getRenderTarget();
                        const IS_INSTANCEDMESH = object.isInstancedMesh === !0;
                        const IS_BATCHEDMESH = object.isBatchedMesh === !0;
                        const HAS_MAP = !!material.map;
                        const HAS_MATCAP = !!material.matcap;
                        const HAS_ENVMAP = !!envMap;
                        const HAS_AOMAP = !!material.aoMap;
                        const HAS_LIGHTMAP = !!material.lightMap;
                        const HAS_BUMPMAP = !!material.bumpMap;
                        const HAS_NORMALMAP = !!material.normalMap;
                        const HAS_DISPLACEMENTMAP = !!material.displacementMap;
                        const HAS_EMISSIVEMAP = !!material.emissiveMap;
                        const HAS_METALNESSMAP = !!material.metalnessMap;
                        const HAS_ROUGHNESSMAP = !!material.roughnessMap;
                        const HAS_ANISOTROPY = material.anisotropy > 0;
                        const HAS_CLEARCOAT = material.clearcoat > 0;
                        const HAS_DISPERSION = material.dispersion > 0;
                        const HAS_IRIDESCENCE = material.iridescence > 0;
                        const HAS_SHEEN = material.sheen > 0;
                        const HAS_TRANSMISSION = material.transmission > 0;
                        const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
                        const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
                        const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
                        const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
                        const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
                        const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
                        const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
                        const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
                        const HAS_SPECULARMAP = !!material.specularMap;
                        const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
                        const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
                        const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
                        const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
                        const HAS_GRADIENTMAP = !!material.gradientMap;
                        const HAS_ALPHAMAP = !!material.alphaMap;
                        const HAS_ALPHATEST = material.alphaTest > 0;
                        const HAS_ALPHAHASH = !!material.alphaHash;
                        const HAS_EXTENSIONS = !!material.extensions;
                        let toneMapping = NoToneMapping;
                        if (material.toneMapped) {
                            if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === !0) {
                                toneMapping = renderer.toneMapping
                            }
                        }
                        const parameters = {
                            shaderID: shaderID,
                            shaderType: material.type,
                            shaderName: material.name,
                            vertexShader: vertexShader,
                            fragmentShader: fragmentShader,
                            defines: material.defines,
                            customVertexShaderID: customVertexShaderID,
                            customFragmentShaderID: customFragmentShaderID,
                            isRawShaderMaterial: material.isRawShaderMaterial === !0,
                            glslVersion: material.glslVersion,
                            precision: precision,
                            batching: IS_BATCHEDMESH,
                            batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
                            instancing: IS_INSTANCEDMESH,
                            instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
                            instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
                            supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
                            outputColorSpace: (currentRenderTarget === null) ? renderer.outputColorSpace : (currentRenderTarget.isXRRenderTarget === !0 ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace),
                            alphaToCoverage: !!material.alphaToCoverage,
                            map: HAS_MAP,
                            matcap: HAS_MATCAP,
                            envMap: HAS_ENVMAP,
                            envMapMode: HAS_ENVMAP && envMap.mapping,
                            envMapCubeUVHeight: envMapCubeUVHeight,
                            aoMap: HAS_AOMAP,
                            lightMap: HAS_LIGHTMAP,
                            bumpMap: HAS_BUMPMAP,
                            normalMap: HAS_NORMALMAP,
                            displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
                            emissiveMap: HAS_EMISSIVEMAP,
                            normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
                            normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
                            metalnessMap: HAS_METALNESSMAP,
                            roughnessMap: HAS_ROUGHNESSMAP,
                            anisotropy: HAS_ANISOTROPY,
                            anisotropyMap: HAS_ANISOTROPYMAP,
                            clearcoat: HAS_CLEARCOAT,
                            clearcoatMap: HAS_CLEARCOATMAP,
                            clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
                            clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
                            dispersion: HAS_DISPERSION,
                            iridescence: HAS_IRIDESCENCE,
                            iridescenceMap: HAS_IRIDESCENCEMAP,
                            iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
                            sheen: HAS_SHEEN,
                            sheenColorMap: HAS_SHEEN_COLORMAP,
                            sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
                            specularMap: HAS_SPECULARMAP,
                            specularColorMap: HAS_SPECULAR_COLORMAP,
                            specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
                            transmission: HAS_TRANSMISSION,
                            transmissionMap: HAS_TRANSMISSIONMAP,
                            thicknessMap: HAS_THICKNESSMAP,
                            gradientMap: HAS_GRADIENTMAP,
                            opaque: material.transparent === !1 && material.blending === NormalBlending && material.alphaToCoverage === !1,
                            alphaMap: HAS_ALPHAMAP,
                            alphaTest: HAS_ALPHATEST,
                            alphaHash: HAS_ALPHAHASH,
                            combine: material.combine,
                            mapUv: HAS_MAP && getChannel(material.map.channel),
                            aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
                            lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
                            bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
                            normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
                            displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
                            emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
                            metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
                            roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
                            anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
                            clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
                            clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
                            clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
                            iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
                            iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
                            sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
                            sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
                            specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
                            specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
                            specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
                            transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
                            thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
                            alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
                            vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
                            vertexColors: material.vertexColors,
                            vertexAlphas: material.vertexColors === !0 && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
                            pointsUvs: object.isPoints === !0 && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
                            fog: !!fog,
                            useFog: material.fog === !0,
                            fogExp2: (!!fog && fog.isFogExp2),
                            flatShading: material.flatShading === !0,
                            sizeAttenuation: material.sizeAttenuation === !0,
                            logarithmicDepthBuffer: logarithmicDepthBuffer,
                            skinning: object.isSkinnedMesh === !0,
                            morphTargets: geometry.morphAttributes.position !== undefined,
                            morphNormals: geometry.morphAttributes.normal !== undefined,
                            morphColors: geometry.morphAttributes.color !== undefined,
                            morphTargetsCount: morphTargetsCount,
                            morphTextureStride: morphTextureStride,
                            numDirLights: lights.directional.length,
                            numPointLights: lights.point.length,
                            numSpotLights: lights.spot.length,
                            numSpotLightMaps: lights.spotLightMap.length,
                            numRectAreaLights: lights.rectArea.length,
                            numHemiLights: lights.hemi.length,
                            numDirLightShadows: lights.directionalShadowMap.length,
                            numPointLightShadows: lights.pointShadowMap.length,
                            numSpotLightShadows: lights.spotShadowMap.length,
                            numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
                            numLightProbes: lights.numLightProbes,
                            numClippingPlanes: clipping.numPlanes,
                            numClipIntersection: clipping.numIntersection,
                            dithering: material.dithering,
                            shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
                            shadowMapType: renderer.shadowMap.type,
                            toneMapping: toneMapping,
                            decodeVideoTexture: HAS_MAP && (material.map.isVideoTexture === !0) && (ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer),
                            premultipliedAlpha: material.premultipliedAlpha,
                            doubleSided: material.side === DoubleSide,
                            flipSided: material.side === BackSide,
                            useDepthPacking: material.depthPacking >= 0,
                            depthPacking: material.depthPacking || 0,
                            index0AttributeName: material.index0AttributeName,
                            extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === !0 && extensions.has('WEBGL_clip_cull_distance'),
                            extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === !0 || IS_BATCHEDMESH) && extensions.has('WEBGL_multi_draw'),
                            rendererExtensionParallelShaderCompile: extensions.has('KHR_parallel_shader_compile'),
                            customProgramCacheKey: material.customProgramCacheKey()
                        };
                        parameters.vertexUv1s = _activeChannels.has(1);
                        parameters.vertexUv2s = _activeChannels.has(2);
                        parameters.vertexUv3s = _activeChannels.has(3);
                        _activeChannels.clear();
                        return parameters
                    }

                    function getProgramCacheKey(parameters) {
                        const array = [];
                        if (parameters.shaderID) {
                            array.push(parameters.shaderID)
                        } else {
                            array.push(parameters.customVertexShaderID);
                            array.push(parameters.customFragmentShaderID)
                        }
                        if (parameters.defines !== undefined) {
                            for (const name in parameters.defines) {
                                array.push(name);
                                array.push(parameters.defines[name])
                            }
                        }
                        if (parameters.isRawShaderMaterial === !1) {
                            getProgramCacheKeyParameters(array, parameters);
                            getProgramCacheKeyBooleans(array, parameters);
                            array.push(renderer.outputColorSpace)
                        }
                        array.push(parameters.customProgramCacheKey);
                        return array.join()
                    }

                    function getProgramCacheKeyParameters(array, parameters) {
                        array.push(parameters.precision);
                        array.push(parameters.outputColorSpace);
                        array.push(parameters.envMapMode);
                        array.push(parameters.envMapCubeUVHeight);
                        array.push(parameters.mapUv);
                        array.push(parameters.alphaMapUv);
                        array.push(parameters.lightMapUv);
                        array.push(parameters.aoMapUv);
                        array.push(parameters.bumpMapUv);
                        array.push(parameters.normalMapUv);
                        array.push(parameters.displacementMapUv);
                        array.push(parameters.emissiveMapUv);
                        array.push(parameters.metalnessMapUv);
                        array.push(parameters.roughnessMapUv);
                        array.push(parameters.anisotropyMapUv);
                        array.push(parameters.clearcoatMapUv);
                        array.push(parameters.clearcoatNormalMapUv);
                        array.push(parameters.clearcoatRoughnessMapUv);
                        array.push(parameters.iridescenceMapUv);
                        array.push(parameters.iridescenceThicknessMapUv);
                        array.push(parameters.sheenColorMapUv);
                        array.push(parameters.sheenRoughnessMapUv);
                        array.push(parameters.specularMapUv);
                        array.push(parameters.specularColorMapUv);
                        array.push(parameters.specularIntensityMapUv);
                        array.push(parameters.transmissionMapUv);
                        array.push(parameters.thicknessMapUv);
                        array.push(parameters.combine);
                        array.push(parameters.fogExp2);
                        array.push(parameters.sizeAttenuation);
                        array.push(parameters.morphTargetsCount);
                        array.push(parameters.morphAttributeCount);
                        array.push(parameters.numDirLights);
                        array.push(parameters.numPointLights);
                        array.push(parameters.numSpotLights);
                        array.push(parameters.numSpotLightMaps);
                        array.push(parameters.numHemiLights);
                        array.push(parameters.numRectAreaLights);
                        array.push(parameters.numDirLightShadows);
                        array.push(parameters.numPointLightShadows);
                        array.push(parameters.numSpotLightShadows);
                        array.push(parameters.numSpotLightShadowsWithMaps);
                        array.push(parameters.numLightProbes);
                        array.push(parameters.shadowMapType);
                        array.push(parameters.toneMapping);
                        array.push(parameters.numClippingPlanes);
                        array.push(parameters.numClipIntersection);
                        array.push(parameters.depthPacking)
                    }

                    function getProgramCacheKeyBooleans(array, parameters) {
                        _programLayers.disableAll();
                        if (parameters.supportsVertexTextures)
                            _programLayers.enable(0);
                        if (parameters.instancing)
                            _programLayers.enable(1);
                        if (parameters.instancingColor)
                            _programLayers.enable(2);
                        if (parameters.instancingMorph)
                            _programLayers.enable(3);
                        if (parameters.matcap)
                            _programLayers.enable(4);
                        if (parameters.envMap)
                            _programLayers.enable(5);
                        if (parameters.normalMapObjectSpace)
                            _programLayers.enable(6);
                        if (parameters.normalMapTangentSpace)
                            _programLayers.enable(7);
                        if (parameters.clearcoat)
                            _programLayers.enable(8);
                        if (parameters.iridescence)
                            _programLayers.enable(9);
                        if (parameters.alphaTest)
                            _programLayers.enable(10);
                        if (parameters.vertexColors)
                            _programLayers.enable(11);
                        if (parameters.vertexAlphas)
                            _programLayers.enable(12);
                        if (parameters.vertexUv1s)
                            _programLayers.enable(13);
                        if (parameters.vertexUv2s)
                            _programLayers.enable(14);
                        if (parameters.vertexUv3s)
                            _programLayers.enable(15);
                        if (parameters.vertexTangents)
                            _programLayers.enable(16);
                        if (parameters.anisotropy)
                            _programLayers.enable(17);
                        if (parameters.alphaHash)
                            _programLayers.enable(18);
                        if (parameters.batching)
                            _programLayers.enable(19);
                        if (parameters.dispersion)
                            _programLayers.enable(20);
                        if (parameters.batchingColor)
                            _programLayers.enable(21);
                        array.push(_programLayers.mask);
                        _programLayers.disableAll();
                        if (parameters.fog)
                            _programLayers.enable(0);
                        if (parameters.useFog)
                            _programLayers.enable(1);
                        if (parameters.flatShading)
                            _programLayers.enable(2);
                        if (parameters.logarithmicDepthBuffer)
                            _programLayers.enable(3);
                        if (parameters.skinning)
                            _programLayers.enable(4);
                        if (parameters.morphTargets)
                            _programLayers.enable(5);
                        if (parameters.morphNormals)
                            _programLayers.enable(6);
                        if (parameters.morphColors)
                            _programLayers.enable(7);
                        if (parameters.premultipliedAlpha)
                            _programLayers.enable(8);
                        if (parameters.shadowMapEnabled)
                            _programLayers.enable(9);
                        if (parameters.doubleSided)
                            _programLayers.enable(10);
                        if (parameters.flipSided)
                            _programLayers.enable(11);
                        if (parameters.useDepthPacking)
                            _programLayers.enable(12);
                        if (parameters.dithering)
                            _programLayers.enable(13);
                        if (parameters.transmission)
                            _programLayers.enable(14);
                        if (parameters.sheen)
                            _programLayers.enable(15);
                        if (parameters.opaque)
                            _programLayers.enable(16);
                        if (parameters.pointsUvs)
                            _programLayers.enable(17);
                        if (parameters.decodeVideoTexture)
                            _programLayers.enable(18);
                        if (parameters.alphaToCoverage)
                            _programLayers.enable(19);
                        array.push(_programLayers.mask)
                    }

                    function getUniforms(material) {
                        const shaderID = shaderIDs[material.type];
                        let uniforms;
                        if (shaderID) {
                            const shader = ShaderLib[shaderID];
                            uniforms = UniformsUtils.clone(shader.uniforms)
                        } else {
                            uniforms = material.uniforms
                        }
                        return uniforms
                    }

                    function acquireProgram(parameters, cacheKey) {
                        let program;
                        for (let p = 0, pl = programs.length; p < pl; p++) {
                            const preexistingProgram = programs[p];
                            if (preexistingProgram.cacheKey === cacheKey) {
                                program = preexistingProgram;
                                ++program.usedTimes;
                                break
                            }
                        }
                        if (program === undefined) {
                            program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
                            programs.push(program)
                        }
                        return program
                    }

                    function releaseProgram(program) {
                        if (--program.usedTimes === 0) {
                            const i = programs.indexOf(program);
                            programs[i] = programs[programs.length - 1];
                            programs.pop();
                            program.destroy()
                        }
                    }

                    function releaseShaderCache(material) {
                        _customShaders.remove(material)
                    }

                    function dispose() {
                        _customShaders.dispose()
                    }
                    return {
                        getParameters: getParameters,
                        getProgramCacheKey: getProgramCacheKey,
                        getUniforms: getUniforms,
                        acquireProgram: acquireProgram,
                        releaseProgram: releaseProgram,
                        releaseShaderCache: releaseShaderCache,
                        programs: programs,
                        dispose: dispose
                    }
                }

                function WebGLProperties() {
                    let properties = new WeakMap();

                    function get(object) {
                        let map = properties.get(object);
                        if (map === undefined) {
                            map = {};
                            properties.set(object, map)
                        }
                        return map
                    }

                    function remove(object) {
                        properties.delete(object)
                    }

                    function update(object, key, value) {
                        properties.get(object)[key] = value
                    }

                    function dispose() {
                        properties = new WeakMap()
                    }
                    return {
                        get: get,
                        remove: remove,
                        update: update,
                        dispose: dispose
                    }
                }

                function painterSortStable(a, b) {
                    if (a.groupOrder !== b.groupOrder) {
                        return a.groupOrder - b.groupOrder
                    } else if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder
                    } else if (a.material.id !== b.material.id) {
                        return a.material.id - b.material.id
                    } else if (a.z !== b.z) {
                        return a.z - b.z
                    } else {
                        return a.id - b.id
                    }
                }

                function reversePainterSortStable(a, b) {
                    if (a.groupOrder !== b.groupOrder) {
                        return a.groupOrder - b.groupOrder
                    } else if (a.renderOrder !== b.renderOrder) {
                        return a.renderOrder - b.renderOrder
                    } else if (a.z !== b.z) {
                        return b.z - a.z
                    } else {
                        return a.id - b.id
                    }
                }

                function WebGLRenderList() {
                    const renderItems = [];
                    let renderItemsIndex = 0;
                    const opaque = [];
                    const transmissive = [];
                    const transparent = [];

                    function init() {
                        renderItemsIndex = 0;
                        opaque.length = 0;
                        transmissive.length = 0;
                        transparent.length = 0
                    }

                    function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
                        let renderItem = renderItems[renderItemsIndex];
                        if (renderItem === undefined) {
                            renderItem = {
                                id: object.id,
                                object: object,
                                geometry: geometry,
                                material: material,
                                groupOrder: groupOrder,
                                renderOrder: object.renderOrder,
                                z: z,
                                group: group
                            };
                            renderItems[renderItemsIndex] = renderItem
                        } else {
                            renderItem.id = object.id;
                            renderItem.object = object;
                            renderItem.geometry = geometry;
                            renderItem.material = material;
                            renderItem.groupOrder = groupOrder;
                            renderItem.renderOrder = object.renderOrder;
                            renderItem.z = z;
                            renderItem.group = group
                        }
                        renderItemsIndex++;
                        return renderItem
                    }

                    function push(object, geometry, material, groupOrder, z, group) {
                        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                        if (material.transmission > 0.0) {
                            transmissive.push(renderItem)
                        } else if (material.transparent === !0) {
                            transparent.push(renderItem)
                        } else {
                            opaque.push(renderItem)
                        }
                    }

                    function unshift(object, geometry, material, groupOrder, z, group) {
                        const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
                        if (material.transmission > 0.0) {
                            transmissive.unshift(renderItem)
                        } else if (material.transparent === !0) {
                            transparent.unshift(renderItem)
                        } else {
                            opaque.unshift(renderItem)
                        }
                    }

                    function sort(customOpaqueSort, customTransparentSort) {
                        if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
                        if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
                        if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable)
                    }

                    function finish() {
                        for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
                            const renderItem = renderItems[i];
                            if (renderItem.id === null) break;
                            renderItem.id = null;
                            renderItem.object = null;
                            renderItem.geometry = null;
                            renderItem.material = null;
                            renderItem.group = null
                        }
                    }
                    return {
                        opaque: opaque,
                        transmissive: transmissive,
                        transparent: transparent,
                        init: init,
                        push: push,
                        unshift: unshift,
                        finish: finish,
                        sort: sort
                    }
                }

                function WebGLRenderLists() {
                    let lists = new WeakMap();

                    function get(scene, renderCallDepth) {
                        const listArray = lists.get(scene);
                        let list;
                        if (listArray === undefined) {
                            list = new WebGLRenderList();
                            lists.set(scene, [list])
                        } else {
                            if (renderCallDepth >= listArray.length) {
                                list = new WebGLRenderList();
                                listArray.push(list)
                            } else {
                                list = listArray[renderCallDepth]
                            }
                        }
                        return list
                    }

                    function dispose() {
                        lists = new WeakMap()
                    }
                    return {
                        get: get,
                        dispose: dispose
                    }
                }

                function UniformsCache() {
                    const lights = {};
                    return {
                        get: function(light) {
                            if (lights[light.id] !== undefined) {
                                return lights[light.id]
                            }
                            let uniforms;
                            switch (light.type) {
                                case 'DirectionalLight':
                                    uniforms = {
                                        direction: new Vector3(),
                                        color: new Color()
                                    };
                                    break;
                                case 'SpotLight':
                                    uniforms = {
                                        position: new Vector3(),
                                        direction: new Vector3(),
                                        color: new Color(),
                                        distance: 0,
                                        coneCos: 0,
                                        penumbraCos: 0,
                                        decay: 0
                                    };
                                    break;
                                case 'PointLight':
                                    uniforms = {
                                        position: new Vector3(),
                                        color: new Color(),
                                        distance: 0,
                                        decay: 0
                                    };
                                    break;
                                case 'HemisphereLight':
                                    uniforms = {
                                        direction: new Vector3(),
                                        skyColor: new Color(),
                                        groundColor: new Color()
                                    };
                                    break;
                                case 'RectAreaLight':
                                    uniforms = {
                                        color: new Color(),
                                        position: new Vector3(),
                                        halfWidth: new Vector3(),
                                        halfHeight: new Vector3()
                                    };
                                    break
                            }
                            lights[light.id] = uniforms;
                            return uniforms
                        }
                    }
                }

                function ShadowUniformsCache() {
                    const lights = {};
                    return {
                        get: function(light) {
                            if (lights[light.id] !== undefined) {
                                return lights[light.id]
                            }
                            let uniforms;
                            switch (light.type) {
                                case 'DirectionalLight':
                                    uniforms = {
                                        shadowIntensity: 1,
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2()
                                    };
                                    break;
                                case 'SpotLight':
                                    uniforms = {
                                        shadowIntensity: 1,
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2()
                                    };
                                    break;
                                case 'PointLight':
                                    uniforms = {
                                        shadowIntensity: 1,
                                        shadowBias: 0,
                                        shadowNormalBias: 0,
                                        shadowRadius: 1,
                                        shadowMapSize: new Vector2(),
                                        shadowCameraNear: 1,
                                        shadowCameraFar: 1000
                                    };
                                    break
                            }
                            lights[light.id] = uniforms;
                            return uniforms
                        }
                    }
                }
                let nextVersion = 0;

                function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
                    return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0)
                }

                function WebGLLights(extensions) {
                    const cache = new UniformsCache();
                    const shadowCache = ShadowUniformsCache();
                    const state = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            numDirectionalShadows: -1,
                            numPointShadows: -1,
                            numSpotShadows: -1,
                            numSpotMaps: -1,
                            numLightProbes: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadow: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotLightMap: [],
                        spotShadow: [],
                        spotShadowMap: [],
                        spotLightMatrix: [],
                        rectArea: [],
                        rectAreaLTC1: null,
                        rectAreaLTC2: null,
                        point: [],
                        pointShadow: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: [],
                        numSpotLightShadowsWithMaps: 0,
                        numLightProbes: 0
                    };
                    for (let i = 0; i < 9; i++) state.probe.push(new Vector3());
                    const vector3 = new Vector3();
                    const matrix4 = new Matrix4();
                    const matrix42 = new Matrix4();

                    function setup(lights) {
                        let r = 0,
                            g = 0,
                            b = 0;
                        for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
                        let directionalLength = 0;
                        let pointLength = 0;
                        let spotLength = 0;
                        let rectAreaLength = 0;
                        let hemiLength = 0;
                        let numDirectionalShadows = 0;
                        let numPointShadows = 0;
                        let numSpotShadows = 0;
                        let numSpotMaps = 0;
                        let numSpotShadowsWithMaps = 0;
                        let numLightProbes = 0;
                        lights.sort(shadowCastingAndTexturingLightsFirst);
                        for (let i = 0, l = lights.length; i < l; i++) {
                            const light = lights[i];
                            const color = light.color;
                            const intensity = light.intensity;
                            const distance = light.distance;
                            const shadowMap = (light.shadow && light.shadow.map) ? light.shadow.map.texture : null;
                            if (light.isAmbientLight) {
                                r += color.r * intensity;
                                g += color.g * intensity;
                                b += color.b * intensity
                            } else if (light.isLightProbe) {
                                for (let j = 0; j < 9; j++) {
                                    state.probe[j].addScaledVector(light.sh.coefficients[j], intensity)
                                }
                                numLightProbes++
                            } else if (light.isDirectionalLight) {
                                const uniforms = cache.get(light);
                                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                                if (light.castShadow) {
                                    const shadow = light.shadow;
                                    const shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowIntensity = shadow.intensity;
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    state.directionalShadow[directionalLength] = shadowUniforms;
                                    state.directionalShadowMap[directionalLength] = shadowMap;
                                    state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
                                    numDirectionalShadows++
                                }
                                state.directional[directionalLength] = uniforms;
                                directionalLength++
                            } else if (light.isSpotLight) {
                                const uniforms = cache.get(light);
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.color.copy(color).multiplyScalar(intensity);
                                uniforms.distance = distance;
                                uniforms.coneCos = Math.cos(light.angle);
                                uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
                                uniforms.decay = light.decay;
                                state.spot[spotLength] = uniforms;
                                const shadow = light.shadow;
                                if (light.map) {
                                    state.spotLightMap[numSpotMaps] = light.map;
                                    numSpotMaps++;
                                    shadow.updateMatrices(light);
                                    if (light.castShadow) numSpotShadowsWithMaps++
                                }
                                state.spotLightMatrix[spotLength] = shadow.matrix;
                                if (light.castShadow) {
                                    const shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowIntensity = shadow.intensity;
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    state.spotShadow[spotLength] = shadowUniforms;
                                    state.spotShadowMap[spotLength] = shadowMap;
                                    numSpotShadows++
                                }
                                spotLength++
                            } else if (light.isRectAreaLight) {
                                const uniforms = cache.get(light);
                                uniforms.color.copy(color).multiplyScalar(intensity);
                                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                                state.rectArea[rectAreaLength] = uniforms;
                                rectAreaLength++
                            } else if (light.isPointLight) {
                                const uniforms = cache.get(light);
                                uniforms.color.copy(light.color).multiplyScalar(light.intensity);
                                uniforms.distance = light.distance;
                                uniforms.decay = light.decay;
                                if (light.castShadow) {
                                    const shadow = light.shadow;
                                    const shadowUniforms = shadowCache.get(light);
                                    shadowUniforms.shadowIntensity = shadow.intensity;
                                    shadowUniforms.shadowBias = shadow.bias;
                                    shadowUniforms.shadowNormalBias = shadow.normalBias;
                                    shadowUniforms.shadowRadius = shadow.radius;
                                    shadowUniforms.shadowMapSize = shadow.mapSize;
                                    shadowUniforms.shadowCameraNear = shadow.camera.near;
                                    shadowUniforms.shadowCameraFar = shadow.camera.far;
                                    state.pointShadow[pointLength] = shadowUniforms;
                                    state.pointShadowMap[pointLength] = shadowMap;
                                    state.pointShadowMatrix[pointLength] = light.shadow.matrix;
                                    numPointShadows++
                                }
                                state.point[pointLength] = uniforms;
                                pointLength++
                            } else if (light.isHemisphereLight) {
                                const uniforms = cache.get(light);
                                uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
                                uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
                                state.hemi[hemiLength] = uniforms;
                                hemiLength++
                            }
                        }
                        if (rectAreaLength > 0) {
                            if (extensions.has('OES_texture_float_linear') === !0) {
                                state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
                                state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2
                            } else {
                                state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
                                state.rectAreaLTC2 = UniformsLib.LTC_HALF_2
                            }
                        }
                        state.ambient[0] = r;
                        state.ambient[1] = g;
                        state.ambient[2] = b;
                        const hash = state.hash;
                        if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
                            state.directional.length = directionalLength;
                            state.spot.length = spotLength;
                            state.rectArea.length = rectAreaLength;
                            state.point.length = pointLength;
                            state.hemi.length = hemiLength;
                            state.directionalShadow.length = numDirectionalShadows;
                            state.directionalShadowMap.length = numDirectionalShadows;
                            state.pointShadow.length = numPointShadows;
                            state.pointShadowMap.length = numPointShadows;
                            state.spotShadow.length = numSpotShadows;
                            state.spotShadowMap.length = numSpotShadows;
                            state.directionalShadowMatrix.length = numDirectionalShadows;
                            state.pointShadowMatrix.length = numPointShadows;
                            state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
                            state.spotLightMap.length = numSpotMaps;
                            state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
                            state.numLightProbes = numLightProbes;
                            hash.directionalLength = directionalLength;
                            hash.pointLength = pointLength;
                            hash.spotLength = spotLength;
                            hash.rectAreaLength = rectAreaLength;
                            hash.hemiLength = hemiLength;
                            hash.numDirectionalShadows = numDirectionalShadows;
                            hash.numPointShadows = numPointShadows;
                            hash.numSpotShadows = numSpotShadows;
                            hash.numSpotMaps = numSpotMaps;
                            hash.numLightProbes = numLightProbes;
                            state.version = nextVersion++
                        }
                    }

                    function setupView(lights, camera) {
                        let directionalLength = 0;
                        let pointLength = 0;
                        let spotLength = 0;
                        let rectAreaLength = 0;
                        let hemiLength = 0;
                        const viewMatrix = camera.matrixWorldInverse;
                        for (let i = 0, l = lights.length; i < l; i++) {
                            const light = lights[i];
                            if (light.isDirectionalLight) {
                                const uniforms = state.directional[directionalLength];
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                vector3.setFromMatrixPosition(light.target.matrixWorld);
                                uniforms.direction.sub(vector3);
                                uniforms.direction.transformDirection(viewMatrix);
                                directionalLength++
                            } else if (light.isSpotLight) {
                                const uniforms = state.spot[spotLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                vector3.setFromMatrixPosition(light.target.matrixWorld);
                                uniforms.direction.sub(vector3);
                                uniforms.direction.transformDirection(viewMatrix);
                                spotLength++
                            } else if (light.isRectAreaLight) {
                                const uniforms = state.rectArea[rectAreaLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                matrix42.identity();
                                matrix4.copy(light.matrixWorld);
                                matrix4.premultiply(viewMatrix);
                                matrix42.extractRotation(matrix4);
                                uniforms.halfWidth.set(light.width * 0.5, 0.0, 0.0);
                                uniforms.halfHeight.set(0.0, light.height * 0.5, 0.0);
                                uniforms.halfWidth.applyMatrix4(matrix42);
                                uniforms.halfHeight.applyMatrix4(matrix42);
                                rectAreaLength++
                            } else if (light.isPointLight) {
                                const uniforms = state.point[pointLength];
                                uniforms.position.setFromMatrixPosition(light.matrixWorld);
                                uniforms.position.applyMatrix4(viewMatrix);
                                pointLength++
                            } else if (light.isHemisphereLight) {
                                const uniforms = state.hemi[hemiLength];
                                uniforms.direction.setFromMatrixPosition(light.matrixWorld);
                                uniforms.direction.transformDirection(viewMatrix);
                                hemiLength++
                            }
                        }
                    }
                    return {
                        setup: setup,
                        setupView: setupView,
                        state: state
                    }
                }

                function WebGLRenderState(extensions) {
                    const lights = new WebGLLights(extensions);
                    const lightsArray = [];
                    const shadowsArray = [];

                    function init(camera) {
                        state.camera = camera;
                        lightsArray.length = 0;
                        shadowsArray.length = 0
                    }

                    function pushLight(light) {
                        lightsArray.push(light)
                    }

                    function pushShadow(shadowLight) {
                        shadowsArray.push(shadowLight)
                    }

                    function setupLights() {
                        lights.setup(lightsArray)
                    }

                    function setupLightsView(camera) {
                        lights.setupView(lightsArray, camera)
                    }
                    const state = {
                        lightsArray: lightsArray,
                        shadowsArray: shadowsArray,
                        camera: null,
                        lights: lights,
                        transmissionRenderTarget: {}
                    };
                    return {
                        init: init,
                        state: state,
                        setupLights: setupLights,
                        setupLightsView: setupLightsView,
                        pushLight: pushLight,
                        pushShadow: pushShadow
                    }
                }

                function WebGLRenderStates(extensions) {
                    let renderStates = new WeakMap();

                    function get(scene, renderCallDepth = 0) {
                        const renderStateArray = renderStates.get(scene);
                        let renderState;
                        if (renderStateArray === undefined) {
                            renderState = new WebGLRenderState(extensions);
                            renderStates.set(scene, [renderState])
                        } else {
                            if (renderCallDepth >= renderStateArray.length) {
                                renderState = new WebGLRenderState(extensions);
                                renderStateArray.push(renderState)
                            } else {
                                renderState = renderStateArray[renderCallDepth]
                            }
                        }
                        return renderState
                    }

                    function dispose() {
                        renderStates = new WeakMap()
                    }
                    return {
                        get: get,
                        dispose: dispose
                    }
                }
                class MeshDepthMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshDepthMaterial = !0;
                        this.type = 'MeshDepthMaterial';
                        this.depthPacking = BasicDepthPacking;
                        this.map = null;
                        this.alphaMap = null;
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.depthPacking = source.depthPacking;
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        return this
                    }
                }
                class MeshDistanceMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshDistanceMaterial = !0;
                        this.type = 'MeshDistanceMaterial';
                        this.map = null;
                        this.alphaMap = null;
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        return this
                    }
                }
                const vertex = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
                const fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

                function WebGLShadowMap(renderer, objects, capabilities) {
                    let _frustum = new Frustum();
                    const _shadowMapSize = new Vector2(),
                        _viewportSize = new Vector2(),
                        _viewport = new Vector4(),
                        _depthMaterial = new MeshDepthMaterial({
                            depthPacking: RGBADepthPacking
                        }),
                        _distanceMaterial = new MeshDistanceMaterial(),
                        _materialCache = {},
                        _maxTextureSize = capabilities.maxTextureSize;
                    const shadowSide = {
                        [FrontSide]: BackSide,
                        [BackSide]: FrontSide,
                        [DoubleSide]: DoubleSide
                    };
                    const shadowMaterialVertical = new ShaderMaterial({
                        defines: {
                            VSM_SAMPLES: 8
                        },
                        uniforms: {
                            shadow_pass: {
                                value: null
                            },
                            resolution: {
                                value: new Vector2()
                            },
                            radius: {
                                value: 4.0
                            }
                        },
                        vertexShader: vertex,
                        fragmentShader: fragment
                    });
                    const shadowMaterialHorizontal = shadowMaterialVertical.clone();
                    shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
                    const fullScreenTri = new BufferGeometry();
                    fullScreenTri.setAttribute('position', new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
                    const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
                    const scope = this;
                    this.enabled = !1;
                    this.autoUpdate = !0;
                    this.needsUpdate = !1;
                    this.type = PCFShadowMap;
                    let _previousType = this.type;
                    this.render = function(lights, scene, camera) {
                        if (scope.enabled === !1) return;
                        if (scope.autoUpdate === !1 && scope.needsUpdate === !1) return;
                        if (lights.length === 0) return;
                        const currentRenderTarget = renderer.getRenderTarget();
                        const activeCubeFace = renderer.getActiveCubeFace();
                        const activeMipmapLevel = renderer.getActiveMipmapLevel();
                        const _state = renderer.state;
                        _state.setBlending(NoBlending);
                        _state.buffers.color.setClear(1, 1, 1, 1);
                        _state.buffers.depth.setTest(!0);
                        _state.setScissorTest(!1);
                        const toVSM = (_previousType !== VSMShadowMap && this.type === VSMShadowMap);
                        const fromVSM = (_previousType === VSMShadowMap && this.type !== VSMShadowMap);
                        for (let i = 0, il = lights.length; i < il; i++) {
                            const light = lights[i];
                            const shadow = light.shadow;
                            if (shadow === undefined) {
                                console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.');
                                continue
                            }
                            if (shadow.autoUpdate === !1 && shadow.needsUpdate === !1) continue;
                            _shadowMapSize.copy(shadow.mapSize);
                            const shadowFrameExtents = shadow.getFrameExtents();
                            _shadowMapSize.multiply(shadowFrameExtents);
                            _viewportSize.copy(shadow.mapSize);
                            if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
                                if (_shadowMapSize.x > _maxTextureSize) {
                                    _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
                                    _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
                                    shadow.mapSize.x = _viewportSize.x
                                }
                                if (_shadowMapSize.y > _maxTextureSize) {
                                    _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
                                    _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
                                    shadow.mapSize.y = _viewportSize.y
                                }
                            }
                            if (shadow.map === null || toVSM === !0 || fromVSM === !0) {
                                const pars = (this.type !== VSMShadowMap) ? {
                                    minFilter: NearestFilter,
                                    magFilter: NearestFilter
                                } : {};
                                if (shadow.map !== null) {
                                    shadow.map.dispose()
                                }
                                shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
                                shadow.map.texture.name = light.name + '.shadowMap';
                                shadow.camera.updateProjectionMatrix()
                            }
                            renderer.setRenderTarget(shadow.map);
                            renderer.clear();
                            const viewportCount = shadow.getViewportCount();
                            for (let vp = 0; vp < viewportCount; vp++) {
                                const viewport = shadow.getViewport(vp);
                                _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
                                _state.viewport(_viewport);
                                shadow.updateMatrices(light, vp);
                                _frustum = shadow.getFrustum();
                                renderObject(scene, camera, shadow.camera, light, this.type)
                            }
                            if (shadow.isPointLightShadow !== !0 && this.type === VSMShadowMap) {
                                VSMPass(shadow, camera)
                            }
                            shadow.needsUpdate = !1
                        }
                        _previousType = this.type;
                        scope.needsUpdate = !1;
                        renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel)
                    };

                    function VSMPass(shadow, camera) {
                        const geometry = objects.update(fullScreenMesh);
                        if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
                            shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
                            shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
                            shadowMaterialVertical.needsUpdate = !0;
                            shadowMaterialHorizontal.needsUpdate = !0
                        }
                        if (shadow.mapPass === null) {
                            shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y)
                        }
                        shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
                        shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
                        shadowMaterialVertical.uniforms.radius.value = shadow.radius;
                        renderer.setRenderTarget(shadow.mapPass);
                        renderer.clear();
                        renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
                        shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
                        shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
                        shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
                        renderer.setRenderTarget(shadow.map);
                        renderer.clear();
                        renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null)
                    }

                    function getDepthMaterial(object, material, light, type) {
                        let result = null;
                        const customMaterial = (light.isPointLight === !0) ? object.customDistanceMaterial : object.customDepthMaterial;
                        if (customMaterial !== undefined) {
                            result = customMaterial
                        } else {
                            result = (light.isPointLight === !0) ? _distanceMaterial : _depthMaterial;
                            if ((renderer.localClippingEnabled && material.clipShadows === !0 && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0) || (material.displacementMap && material.displacementScale !== 0) || (material.alphaMap && material.alphaTest > 0) || (material.map && material.alphaTest > 0)) {
                                const keyA = result.uuid,
                                    keyB = material.uuid;
                                let materialsForVariant = _materialCache[keyA];
                                if (materialsForVariant === undefined) {
                                    materialsForVariant = {};
                                    _materialCache[keyA] = materialsForVariant
                                }
                                let cachedMaterial = materialsForVariant[keyB];
                                if (cachedMaterial === undefined) {
                                    cachedMaterial = result.clone();
                                    materialsForVariant[keyB] = cachedMaterial;
                                    material.addEventListener('dispose', onMaterialDispose)
                                }
                                result = cachedMaterial
                            }
                        }
                        result.visible = material.visible;
                        result.wireframe = material.wireframe;
                        if (type === VSMShadowMap) {
                            result.side = (material.shadowSide !== null) ? material.shadowSide : material.side
                        } else {
                            result.side = (material.shadowSide !== null) ? material.shadowSide : shadowSide[material.side]
                        }
                        result.alphaMap = material.alphaMap;
                        result.alphaTest = material.alphaTest;
                        result.map = material.map;
                        result.clipShadows = material.clipShadows;
                        result.clippingPlanes = material.clippingPlanes;
                        result.clipIntersection = material.clipIntersection;
                        result.displacementMap = material.displacementMap;
                        result.displacementScale = material.displacementScale;
                        result.displacementBias = material.displacementBias;
                        result.wireframeLinewidth = material.wireframeLinewidth;
                        result.linewidth = material.linewidth;
                        if (light.isPointLight === !0 && result.isMeshDistanceMaterial === !0) {
                            const materialProperties = renderer.properties.get(result);
                            materialProperties.light = light
                        }
                        return result
                    }

                    function renderObject(object, camera, shadowCamera, light, type) {
                        if (object.visible === !1) return;
                        const visible = object.layers.test(camera.layers);
                        if (visible && (object.isMesh || object.isLine || object.isPoints)) {
                            if ((object.castShadow || (object.receiveShadow && type === VSMShadowMap)) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
                                object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
                                const geometry = objects.update(object);
                                const material = object.material;
                                if (Array.isArray(material)) {
                                    const groups = geometry.groups;
                                    for (let k = 0, kl = groups.length; k < kl; k++) {
                                        const group = groups[k];
                                        const groupMaterial = material[group.materialIndex];
                                        if (groupMaterial && groupMaterial.visible) {
                                            const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
                                            object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
                                            renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
                                            object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group)
                                        }
                                    }
                                } else if (material.visible) {
                                    const depthMaterial = getDepthMaterial(object, material, light, type);
                                    object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
                                    renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
                                    object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null)
                                }
                            }
                        }
                        const children = object.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            renderObject(children[i], camera, shadowCamera, light, type)
                        }
                    }

                    function onMaterialDispose(event) {
                        const material = event.target;
                        material.removeEventListener('dispose', onMaterialDispose);
                        for (const id in _materialCache) {
                            const cache = _materialCache[id];
                            const uuid = event.target.uuid;
                            if (uuid in cache) {
                                const shadowMaterial = cache[uuid];
                                shadowMaterial.dispose();
                                delete cache[uuid]
                            }
                        }
                    }
                }

                function WebGLState(gl) {
                    function ColorBuffer() {
                        let locked = !1;
                        const color = new Vector4();
                        let currentColorMask = null;
                        const currentColorClear = new Vector4(0, 0, 0, 0);
                        return {
                            setMask: function(colorMask) {
                                if (currentColorMask !== colorMask && !locked) {
                                    gl.colorMask(colorMask, colorMask, colorMask, colorMask);
                                    currentColorMask = colorMask
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock
                            },
                            setClear: function(r, g, b, a, premultipliedAlpha) {
                                if (premultipliedAlpha === !0) {
                                    r *= a;
                                    g *= a;
                                    b *= a
                                }
                                color.set(r, g, b, a);
                                if (currentColorClear.equals(color) === !1) {
                                    gl.clearColor(r, g, b, a);
                                    currentColorClear.copy(color)
                                }
                            },
                            reset: function() {
                                locked = !1;
                                currentColorMask = null;
                                currentColorClear.set(-1, 0, 0, 0)
                            }
                        }
                    }

                    function DepthBuffer() {
                        let locked = !1;
                        let currentDepthMask = null;
                        let currentDepthFunc = null;
                        let currentDepthClear = null;
                        return {
                            setTest: function(depthTest) {
                                if (depthTest) {
                                    enable(gl.DEPTH_TEST)
                                } else {
                                    disable(gl.DEPTH_TEST)
                                }
                            },
                            setMask: function(depthMask) {
                                if (currentDepthMask !== depthMask && !locked) {
                                    gl.depthMask(depthMask);
                                    currentDepthMask = depthMask
                                }
                            },
                            setFunc: function(depthFunc) {
                                if (currentDepthFunc !== depthFunc) {
                                    switch (depthFunc) {
                                        case NeverDepth:
                                            gl.depthFunc(gl.NEVER);
                                            break;
                                        case AlwaysDepth:
                                            gl.depthFunc(gl.ALWAYS);
                                            break;
                                        case LessDepth:
                                            gl.depthFunc(gl.LESS);
                                            break;
                                        case LessEqualDepth:
                                            gl.depthFunc(gl.LEQUAL);
                                            break;
                                        case EqualDepth:
                                            gl.depthFunc(gl.EQUAL);
                                            break;
                                        case GreaterEqualDepth:
                                            gl.depthFunc(gl.GEQUAL);
                                            break;
                                        case GreaterDepth:
                                            gl.depthFunc(gl.GREATER);
                                            break;
                                        case NotEqualDepth:
                                            gl.depthFunc(gl.NOTEQUAL);
                                            break;
                                        default:
                                            gl.depthFunc(gl.LEQUAL)
                                    }
                                    currentDepthFunc = depthFunc
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock
                            },
                            setClear: function(depth) {
                                if (currentDepthClear !== depth) {
                                    gl.clearDepth(depth);
                                    currentDepthClear = depth
                                }
                            },
                            reset: function() {
                                locked = !1;
                                currentDepthMask = null;
                                currentDepthFunc = null;
                                currentDepthClear = null
                            }
                        }
                    }

                    function StencilBuffer() {
                        let locked = !1;
                        let currentStencilMask = null;
                        let currentStencilFunc = null;
                        let currentStencilRef = null;
                        let currentStencilFuncMask = null;
                        let currentStencilFail = null;
                        let currentStencilZFail = null;
                        let currentStencilZPass = null;
                        let currentStencilClear = null;
                        return {
                            setTest: function(stencilTest) {
                                if (!locked) {
                                    if (stencilTest) {
                                        enable(gl.STENCIL_TEST)
                                    } else {
                                        disable(gl.STENCIL_TEST)
                                    }
                                }
                            },
                            setMask: function(stencilMask) {
                                if (currentStencilMask !== stencilMask && !locked) {
                                    gl.stencilMask(stencilMask);
                                    currentStencilMask = stencilMask
                                }
                            },
                            setFunc: function(stencilFunc, stencilRef, stencilMask) {
                                if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
                                    gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
                                    currentStencilFunc = stencilFunc;
                                    currentStencilRef = stencilRef;
                                    currentStencilFuncMask = stencilMask
                                }
                            },
                            setOp: function(stencilFail, stencilZFail, stencilZPass) {
                                if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
                                    gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
                                    currentStencilFail = stencilFail;
                                    currentStencilZFail = stencilZFail;
                                    currentStencilZPass = stencilZPass
                                }
                            },
                            setLocked: function(lock) {
                                locked = lock
                            },
                            setClear: function(stencil) {
                                if (currentStencilClear !== stencil) {
                                    gl.clearStencil(stencil);
                                    currentStencilClear = stencil
                                }
                            },
                            reset: function() {
                                locked = !1;
                                currentStencilMask = null;
                                currentStencilFunc = null;
                                currentStencilRef = null;
                                currentStencilFuncMask = null;
                                currentStencilFail = null;
                                currentStencilZFail = null;
                                currentStencilZPass = null;
                                currentStencilClear = null
                            }
                        }
                    }
                    const colorBuffer = new ColorBuffer();
                    const depthBuffer = new DepthBuffer();
                    const stencilBuffer = new StencilBuffer();
                    const uboBindings = new WeakMap();
                    const uboProgramMap = new WeakMap();
                    let enabledCapabilities = {};
                    let currentBoundFramebuffers = {};
                    let currentDrawbuffers = new WeakMap();
                    let defaultDrawbuffers = [];
                    let currentProgram = null;
                    let currentBlendingEnabled = !1;
                    let currentBlending = null;
                    let currentBlendEquation = null;
                    let currentBlendSrc = null;
                    let currentBlendDst = null;
                    let currentBlendEquationAlpha = null;
                    let currentBlendSrcAlpha = null;
                    let currentBlendDstAlpha = null;
                    let currentBlendColor = new Color(0, 0, 0);
                    let currentBlendAlpha = 0;
                    let currentPremultipledAlpha = !1;
                    let currentFlipSided = null;
                    let currentCullFace = null;
                    let currentLineWidth = null;
                    let currentPolygonOffsetFactor = null;
                    let currentPolygonOffsetUnits = null;
                    const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
                    let lineWidthAvailable = !1;
                    let version = 0;
                    const glVersion = gl.getParameter(gl.VERSION);
                    if (glVersion.indexOf('WebGL') !== -1) {
                        version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
                        lineWidthAvailable = (version >= 1.0)
                    } else if (glVersion.indexOf('OpenGL ES') !== -1) {
                        version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
                        lineWidthAvailable = (version >= 2.0)
                    }
                    let currentTextureSlot = null;
                    let currentBoundTextures = {};
                    const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
                    const viewportParam = gl.getParameter(gl.VIEWPORT);
                    const currentScissor = new Vector4().fromArray(scissorParam);
                    const currentViewport = new Vector4().fromArray(viewportParam);

                    function createTexture(type, target, count, dimensions) {
                        const data = new Uint8Array(4);
                        const texture = gl.createTexture();
                        gl.bindTexture(type, texture);
                        gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                        gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                        for (let i = 0; i < count; i++) {
                            if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
                                gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data)
                            } else {
                                gl.texImage2D(target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data)
                            }
                        }
                        return texture
                    }
                    const emptyTextures = {};
                    emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
                    emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
                    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
                    emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
                    colorBuffer.setClear(0, 0, 0, 1);
                    depthBuffer.setClear(1);
                    stencilBuffer.setClear(0);
                    enable(gl.DEPTH_TEST);
                    depthBuffer.setFunc(LessEqualDepth);
                    setFlipSided(!1);
                    setCullFace(CullFaceBack);
                    enable(gl.CULL_FACE);
                    setBlending(NoBlending);

                    function enable(id) {
                        if (enabledCapabilities[id] !== !0) {
                            gl.enable(id);
                            enabledCapabilities[id] = !0
                        }
                    }

                    function disable(id) {
                        if (enabledCapabilities[id] !== !1) {
                            gl.disable(id);
                            enabledCapabilities[id] = !1
                        }
                    }

                    function bindFramebuffer(target, framebuffer) {
                        if (currentBoundFramebuffers[target] !== framebuffer) {
                            gl.bindFramebuffer(target, framebuffer);
                            currentBoundFramebuffers[target] = framebuffer;
                            if (target === gl.DRAW_FRAMEBUFFER) {
                                currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer
                            }
                            if (target === gl.FRAMEBUFFER) {
                                currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer
                            }
                            return !0
                        }
                        return !1
                    }

                    function drawBuffers(renderTarget, framebuffer) {
                        let drawBuffers = defaultDrawbuffers;
                        let needsUpdate = !1;
                        if (renderTarget) {
                            drawBuffers = currentDrawbuffers.get(framebuffer);
                            if (drawBuffers === undefined) {
                                drawBuffers = [];
                                currentDrawbuffers.set(framebuffer, drawBuffers)
                            }
                            const textures = renderTarget.textures;
                            if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
                                for (let i = 0, il = textures.length; i < il; i++) {
                                    drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i
                                }
                                drawBuffers.length = textures.length;
                                needsUpdate = !0
                            }
                        } else {
                            if (drawBuffers[0] !== gl.BACK) {
                                drawBuffers[0] = gl.BACK;
                                needsUpdate = !0
                            }
                        }
                        if (needsUpdate) {
                            gl.drawBuffers(drawBuffers)
                        }
                    }

                    function useProgram(program) {
                        if (currentProgram !== program) {
                            gl.useProgram(program);
                            currentProgram = program;
                            return !0
                        }
                        return !1
                    }
                    const equationToGL = {
                        [AddEquation]: gl.FUNC_ADD,
                        [SubtractEquation]: gl.FUNC_SUBTRACT,
                        [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
                    };
                    equationToGL[MinEquation] = gl.MIN;
                    equationToGL[MaxEquation] = gl.MAX;
                    const factorToGL = {
                        [ZeroFactor]: gl.ZERO,
                        [OneFactor]: gl.ONE,
                        [SrcColorFactor]: gl.SRC_COLOR,
                        [SrcAlphaFactor]: gl.SRC_ALPHA,
                        [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
                        [DstColorFactor]: gl.DST_COLOR,
                        [DstAlphaFactor]: gl.DST_ALPHA,
                        [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
                        [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
                        [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
                        [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
                        [ConstantColorFactor]: gl.CONSTANT_COLOR,
                        [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
                        [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
                        [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
                    };

                    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
                        if (blending === NoBlending) {
                            if (currentBlendingEnabled === !0) {
                                disable(gl.BLEND);
                                currentBlendingEnabled = !1
                            }
                            return
                        }
                        if (currentBlendingEnabled === !1) {
                            enable(gl.BLEND);
                            currentBlendingEnabled = !0
                        }
                        if (blending !== CustomBlending) {
                            if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
                                if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
                                    gl.blendEquation(gl.FUNC_ADD);
                                    currentBlendEquation = AddEquation;
                                    currentBlendEquationAlpha = AddEquation
                                }
                                if (premultipliedAlpha) {
                                    switch (blending) {
                                        case NormalBlending:
                                            gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case AdditiveBlending:
                                            gl.blendFunc(gl.ONE, gl.ONE);
                                            break;
                                        case SubtractiveBlending:
                                            gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                                            break;
                                        case MultiplyBlending:
                                            gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                                            break;
                                        default:
                                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                                            break
                                    }
                                } else {
                                    switch (blending) {
                                        case NormalBlending:
                                            gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                                            break;
                                        case AdditiveBlending:
                                            gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                                            break;
                                        case SubtractiveBlending:
                                            gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                                            break;
                                        case MultiplyBlending:
                                            gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                                            break;
                                        default:
                                            console.error('THREE.WebGLState: Invalid blending: ', blending);
                                            break
                                    }
                                }
                                currentBlendSrc = null;
                                currentBlendDst = null;
                                currentBlendSrcAlpha = null;
                                currentBlendDstAlpha = null;
                                currentBlendColor.set(0, 0, 0);
                                currentBlendAlpha = 0;
                                currentBlending = blending;
                                currentPremultipledAlpha = premultipliedAlpha
                            }
                            return
                        }
                        blendEquationAlpha = blendEquationAlpha || blendEquation;
                        blendSrcAlpha = blendSrcAlpha || blendSrc;
                        blendDstAlpha = blendDstAlpha || blendDst;
                        if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
                            gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
                            currentBlendEquation = blendEquation;
                            currentBlendEquationAlpha = blendEquationAlpha
                        }
                        if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
                            gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
                            currentBlendSrc = blendSrc;
                            currentBlendDst = blendDst;
                            currentBlendSrcAlpha = blendSrcAlpha;
                            currentBlendDstAlpha = blendDstAlpha
                        }
                        if (blendColor.equals(currentBlendColor) === !1 || blendAlpha !== currentBlendAlpha) {
                            gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
                            currentBlendColor.copy(blendColor);
                            currentBlendAlpha = blendAlpha
                        }
                        currentBlending = blending;
                        currentPremultipledAlpha = !1
                    }

                    function setMaterial(material, frontFaceCW) {
                        material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
                        let flipSided = (material.side === BackSide);
                        if (frontFaceCW) flipSided = !flipSided;
                        setFlipSided(flipSided);
                        (material.blending === NormalBlending && material.transparent === !1) ? setBlending(NoBlending): setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
                        depthBuffer.setFunc(material.depthFunc);
                        depthBuffer.setTest(material.depthTest);
                        depthBuffer.setMask(material.depthWrite);
                        colorBuffer.setMask(material.colorWrite);
                        const stencilWrite = material.stencilWrite;
                        stencilBuffer.setTest(stencilWrite);
                        if (stencilWrite) {
                            stencilBuffer.setMask(material.stencilWriteMask);
                            stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
                            stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass)
                        }
                        setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
                        material.alphaToCoverage === !0 ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE)
                    }

                    function setFlipSided(flipSided) {
                        if (currentFlipSided !== flipSided) {
                            if (flipSided) {
                                gl.frontFace(gl.CW)
                            } else {
                                gl.frontFace(gl.CCW)
                            }
                            currentFlipSided = flipSided
                        }
                    }

                    function setCullFace(cullFace) {
                        if (cullFace !== CullFaceNone) {
                            enable(gl.CULL_FACE);
                            if (cullFace !== currentCullFace) {
                                if (cullFace === CullFaceBack) {
                                    gl.cullFace(gl.BACK)
                                } else if (cullFace === CullFaceFront) {
                                    gl.cullFace(gl.FRONT)
                                } else {
                                    gl.cullFace(gl.FRONT_AND_BACK)
                                }
                            }
                        } else {
                            disable(gl.CULL_FACE)
                        }
                        currentCullFace = cullFace
                    }

                    function setLineWidth(width) {
                        if (width !== currentLineWidth) {
                            if (lineWidthAvailable) gl.lineWidth(width);
                            currentLineWidth = width
                        }
                    }

                    function setPolygonOffset(polygonOffset, factor, units) {
                        if (polygonOffset) {
                            enable(gl.POLYGON_OFFSET_FILL);
                            if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
                                gl.polygonOffset(factor, units);
                                currentPolygonOffsetFactor = factor;
                                currentPolygonOffsetUnits = units
                            }
                        } else {
                            disable(gl.POLYGON_OFFSET_FILL)
                        }
                    }

                    function setScissorTest(scissorTest) {
                        if (scissorTest) {
                            enable(gl.SCISSOR_TEST)
                        } else {
                            disable(gl.SCISSOR_TEST)
                        }
                    }

                    function activeTexture(webglSlot) {
                        if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
                        if (currentTextureSlot !== webglSlot) {
                            gl.activeTexture(webglSlot);
                            currentTextureSlot = webglSlot
                        }
                    }

                    function bindTexture(webglType, webglTexture, webglSlot) {
                        if (webglSlot === undefined) {
                            if (currentTextureSlot === null) {
                                webglSlot = gl.TEXTURE0 + maxTextures - 1
                            } else {
                                webglSlot = currentTextureSlot
                            }
                        }
                        let boundTexture = currentBoundTextures[webglSlot];
                        if (boundTexture === undefined) {
                            boundTexture = {
                                type: undefined,
                                texture: undefined
                            };
                            currentBoundTextures[webglSlot] = boundTexture
                        }
                        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
                            if (currentTextureSlot !== webglSlot) {
                                gl.activeTexture(webglSlot);
                                currentTextureSlot = webglSlot
                            }
                            gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
                            boundTexture.type = webglType;
                            boundTexture.texture = webglTexture
                        }
                    }

                    function unbindTexture() {
                        const boundTexture = currentBoundTextures[currentTextureSlot];
                        if (boundTexture !== undefined && boundTexture.type !== undefined) {
                            gl.bindTexture(boundTexture.type, null);
                            boundTexture.type = undefined;
                            boundTexture.texture = undefined
                        }
                    }

                    function compressedTexImage2D() {
                        try {
                            gl.compressedTexImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function compressedTexImage3D() {
                        try {
                            gl.compressedTexImage3D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texSubImage2D() {
                        try {
                            gl.texSubImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texSubImage3D() {
                        try {
                            gl.texSubImage3D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function compressedTexSubImage2D() {
                        try {
                            gl.compressedTexSubImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function compressedTexSubImage3D() {
                        try {
                            gl.compressedTexSubImage3D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texStorage2D() {
                        try {
                            gl.texStorage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texStorage3D() {
                        try {
                            gl.texStorage3D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texImage2D() {
                        try {
                            gl.texImage2D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function texImage3D() {
                        try {
                            gl.texImage3D.apply(gl, arguments)
                        } catch (error) {
                            console.error('THREE.WebGLState:', error)
                        }
                    }

                    function scissor(scissor) {
                        if (currentScissor.equals(scissor) === !1) {
                            gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
                            currentScissor.copy(scissor)
                        }
                    }

                    function viewport(viewport) {
                        if (currentViewport.equals(viewport) === !1) {
                            gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
                            currentViewport.copy(viewport)
                        }
                    }

                    function updateUBOMapping(uniformsGroup, program) {
                        let mapping = uboProgramMap.get(program);
                        if (mapping === undefined) {
                            mapping = new WeakMap();
                            uboProgramMap.set(program, mapping)
                        }
                        let blockIndex = mapping.get(uniformsGroup);
                        if (blockIndex === undefined) {
                            blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
                            mapping.set(uniformsGroup, blockIndex)
                        }
                    }

                    function uniformBlockBinding(uniformsGroup, program) {
                        const mapping = uboProgramMap.get(program);
                        const blockIndex = mapping.get(uniformsGroup);
                        if (uboBindings.get(program) !== blockIndex) {
                            gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
                            uboBindings.set(program, blockIndex)
                        }
                    }

                    function reset() {
                        gl.disable(gl.BLEND);
                        gl.disable(gl.CULL_FACE);
                        gl.disable(gl.DEPTH_TEST);
                        gl.disable(gl.POLYGON_OFFSET_FILL);
                        gl.disable(gl.SCISSOR_TEST);
                        gl.disable(gl.STENCIL_TEST);
                        gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                        gl.blendEquation(gl.FUNC_ADD);
                        gl.blendFunc(gl.ONE, gl.ZERO);
                        gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
                        gl.blendColor(0, 0, 0, 0);
                        gl.colorMask(!0, !0, !0, !0);
                        gl.clearColor(0, 0, 0, 0);
                        gl.depthMask(!0);
                        gl.depthFunc(gl.LESS);
                        gl.clearDepth(1);
                        gl.stencilMask(0xffffffff);
                        gl.stencilFunc(gl.ALWAYS, 0, 0xffffffff);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                        gl.clearStencil(0);
                        gl.cullFace(gl.BACK);
                        gl.frontFace(gl.CCW);
                        gl.polygonOffset(0, 0);
                        gl.activeTexture(gl.TEXTURE0);
                        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                        gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
                        gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
                        gl.useProgram(null);
                        gl.lineWidth(1);
                        gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
                        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                        enabledCapabilities = {};
                        currentTextureSlot = null;
                        currentBoundTextures = {};
                        currentBoundFramebuffers = {};
                        currentDrawbuffers = new WeakMap();
                        defaultDrawbuffers = [];
                        currentProgram = null;
                        currentBlendingEnabled = !1;
                        currentBlending = null;
                        currentBlendEquation = null;
                        currentBlendSrc = null;
                        currentBlendDst = null;
                        currentBlendEquationAlpha = null;
                        currentBlendSrcAlpha = null;
                        currentBlendDstAlpha = null;
                        currentBlendColor = new Color(0, 0, 0);
                        currentBlendAlpha = 0;
                        currentPremultipledAlpha = !1;
                        currentFlipSided = null;
                        currentCullFace = null;
                        currentLineWidth = null;
                        currentPolygonOffsetFactor = null;
                        currentPolygonOffsetUnits = null;
                        currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
                        currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
                        colorBuffer.reset();
                        depthBuffer.reset();
                        stencilBuffer.reset()
                    }
                    return {
                        buffers: {
                            color: colorBuffer,
                            depth: depthBuffer,
                            stencil: stencilBuffer
                        },
                        enable: enable,
                        disable: disable,
                        bindFramebuffer: bindFramebuffer,
                        drawBuffers: drawBuffers,
                        useProgram: useProgram,
                        setBlending: setBlending,
                        setMaterial: setMaterial,
                        setFlipSided: setFlipSided,
                        setCullFace: setCullFace,
                        setLineWidth: setLineWidth,
                        setPolygonOffset: setPolygonOffset,
                        setScissorTest: setScissorTest,
                        activeTexture: activeTexture,
                        bindTexture: bindTexture,
                        unbindTexture: unbindTexture,
                        compressedTexImage2D: compressedTexImage2D,
                        compressedTexImage3D: compressedTexImage3D,
                        texImage2D: texImage2D,
                        texImage3D: texImage3D,
                        updateUBOMapping: updateUBOMapping,
                        uniformBlockBinding: uniformBlockBinding,
                        texStorage2D: texStorage2D,
                        texStorage3D: texStorage3D,
                        texSubImage2D: texSubImage2D,
                        texSubImage3D: texSubImage3D,
                        compressedTexSubImage2D: compressedTexSubImage2D,
                        compressedTexSubImage3D: compressedTexSubImage3D,
                        scissor: scissor,
                        viewport: viewport,
                        reset: reset
                    }
                }

                function contain(texture, aspect) {
                    const imageAspect = (texture.image && texture.image.width) ? texture.image.width / texture.image.height : 1;
                    if (imageAspect > aspect) {
                        texture.repeat.x = 1;
                        texture.repeat.y = imageAspect / aspect;
                        texture.offset.x = 0;
                        texture.offset.y = (1 - texture.repeat.y) / 2
                    } else {
                        texture.repeat.x = aspect / imageAspect;
                        texture.repeat.y = 1;
                        texture.offset.x = (1 - texture.repeat.x) / 2;
                        texture.offset.y = 0
                    }
                    return texture
                }

                function cover(texture, aspect) {
                    const imageAspect = (texture.image && texture.image.width) ? texture.image.width / texture.image.height : 1;
                    if (imageAspect > aspect) {
                        texture.repeat.x = aspect / imageAspect;
                        texture.repeat.y = 1;
                        texture.offset.x = (1 - texture.repeat.x) / 2;
                        texture.offset.y = 0
                    } else {
                        texture.repeat.x = 1;
                        texture.repeat.y = imageAspect / aspect;
                        texture.offset.x = 0;
                        texture.offset.y = (1 - texture.repeat.y) / 2
                    }
                    return texture
                }

                function fill(texture) {
                    texture.repeat.x = 1;
                    texture.repeat.y = 1;
                    texture.offset.x = 0;
                    texture.offset.y = 0;
                    return texture
                }

                function getByteLength(width, height, format, type) {
                    const typeByteLength = getTextureTypeByteLength(type);
                    switch (format) {
                        case AlphaFormat:
                            return width * height;
                        case LuminanceFormat:
                            return width * height;
                        case LuminanceAlphaFormat:
                            return width * height * 2;
                        case RedFormat:
                            return ((width * height) / typeByteLength.components) * typeByteLength.byteLength;
                        case RedIntegerFormat:
                            return ((width * height) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGFormat:
                            return ((width * height * 2) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGIntegerFormat:
                            return ((width * height * 2) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGBFormat:
                            return ((width * height * 3) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGBAFormat:
                            return ((width * height * 4) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGBAIntegerFormat:
                            return ((width * height * 4) / typeByteLength.components) * typeByteLength.byteLength;
                        case RGB_S3TC_DXT1_Format:
                        case RGBA_S3TC_DXT1_Format:
                            return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
                        case RGBA_S3TC_DXT3_Format:
                        case RGBA_S3TC_DXT5_Format:
                            return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
                        case RGB_PVRTC_2BPPV1_Format:
                        case RGBA_PVRTC_2BPPV1_Format:
                            return (Math.max(width, 16) * Math.max(height, 8)) / 4;
                        case RGB_PVRTC_4BPPV1_Format:
                        case RGBA_PVRTC_4BPPV1_Format:
                            return (Math.max(width, 8) * Math.max(height, 8)) / 2;
                        case RGB_ETC1_Format:
                        case RGB_ETC2_Format:
                            return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
                        case RGBA_ETC2_EAC_Format:
                            return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
                        case RGBA_ASTC_4x4_Format:
                            return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
                        case RGBA_ASTC_5x4_Format:
                            return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
                        case RGBA_ASTC_5x5_Format:
                            return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
                        case RGBA_ASTC_6x5_Format:
                            return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
                        case RGBA_ASTC_6x6_Format:
                            return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
                        case RGBA_ASTC_8x5_Format:
                            return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
                        case RGBA_ASTC_8x6_Format:
                            return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
                        case RGBA_ASTC_8x8_Format:
                            return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
                        case RGBA_ASTC_10x5_Format:
                            return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
                        case RGBA_ASTC_10x6_Format:
                            return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
                        case RGBA_ASTC_10x8_Format:
                            return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
                        case RGBA_ASTC_10x10_Format:
                            return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
                        case RGBA_ASTC_12x10_Format:
                            return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
                        case RGBA_ASTC_12x12_Format:
                            return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
                        case RGBA_BPTC_Format:
                        case RGB_BPTC_SIGNED_Format:
                        case RGB_BPTC_UNSIGNED_Format:
                            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
                        case RED_RGTC1_Format:
                        case SIGNED_RED_RGTC1_Format:
                            return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
                        case RED_GREEN_RGTC2_Format:
                        case SIGNED_RED_GREEN_RGTC2_Format:
                            return Math.ceil(width / 4) * Math.ceil(height / 4) * 16
                    }
                    throw new Error(`Unable to determine texture byte length for ${format} format.`, )
                }

                function getTextureTypeByteLength(type) {
                    switch (type) {
                        case UnsignedByteType:
                        case ByteType:
                            return {
                                byteLength: 1,
                                components: 1
                            };
                        case UnsignedShortType:
                        case ShortType:
                        case HalfFloatType:
                            return {
                                byteLength: 2,
                                components: 1
                            };
                        case UnsignedShort4444Type:
                        case UnsignedShort5551Type:
                            return {
                                byteLength: 2,
                                components: 4
                            };
                        case UnsignedIntType:
                        case IntType:
                        case FloatType:
                            return {
                                byteLength: 4,
                                components: 1
                            };
                        case UnsignedInt5999Type:
                            return {
                                byteLength: 4,
                                components: 3
                            }
                    }
                    throw new Error(`Unknown texture type ${type}.`)
                }
                const TextureUtils = {
                    contain,
                    cover,
                    fill,
                    getByteLength
                };

                function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
                    const multisampledRTTExt = extensions.has('WEBGL_multisampled_render_to_texture') ? extensions.get('WEBGL_multisampled_render_to_texture') : null;
                    const supportsInvalidateFramebuffer = typeof navigator === 'undefined' ? !1 : /OculusBrowser/g.test(navigator.userAgent);
                    const _imageDimensions = new Vector2();
                    const _videoTextures = new WeakMap();
                    let _canvas;
                    const _sources = new WeakMap();
                    let useOffscreenCanvas = !1;
                    try {
                        useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined' && (new OffscreenCanvas(1, 1).getContext('2d')) !== null
                    } catch (err) {}

                    function createCanvas(width, height) {
                        return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS('canvas')
                    }

                    function resizeImage(image, needsNewCanvas, maxSize) {
                        let scale = 1;
                        const dimensions = getDimensions(image);
                        if (dimensions.width > maxSize || dimensions.height > maxSize) {
                            scale = maxSize / Math.max(dimensions.width, dimensions.height)
                        }
                        if (scale < 1) {
                            if ((typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) || (typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement) || (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) || (typeof VideoFrame !== 'undefined' && image instanceof VideoFrame)) {
                                const width = Math.floor(scale * dimensions.width);
                                const height = Math.floor(scale * dimensions.height);
                                if (_canvas === undefined) _canvas = createCanvas(width, height);
                                const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
                                canvas.width = width;
                                canvas.height = height;
                                const context = canvas.getContext('2d');
                                context.drawImage(image, 0, 0, width, height);
                                console.warn('THREE.WebGLRenderer: Texture has been resized from (' + dimensions.width + 'x' + dimensions.height + ') to (' + width + 'x' + height + ').');
                                return canvas
                            } else {
                                if ('data' in image) {
                                    console.warn('THREE.WebGLRenderer: Image in DataTexture is too big (' + dimensions.width + 'x' + dimensions.height + ').')
                                }
                                return image
                            }
                        }
                        return image
                    }

                    function textureNeedsGenerateMipmaps(texture) {
                        return texture.generateMipmaps && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter
                    }

                    function generateMipmap(target) {
                        _gl.generateMipmap(target)
                    }

                    function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = !1) {
                        if (internalFormatName !== null) {
                            if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
                            console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'')
                        }
                        let internalFormat = glFormat;
                        if (glFormat === _gl.RED) {
                            if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
                            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
                            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8
                        }
                        if (glFormat === _gl.RED_INTEGER) {
                            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
                            if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
                            if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
                            if (glType === _gl.BYTE) internalFormat = _gl.R8I;
                            if (glType === _gl.SHORT) internalFormat = _gl.R16I;
                            if (glType === _gl.INT) internalFormat = _gl.R32I
                        }
                        if (glFormat === _gl.RG) {
                            if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
                            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
                            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8
                        }
                        if (glFormat === _gl.RG_INTEGER) {
                            if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
                            if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
                            if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
                            if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
                            if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
                            if (glType === _gl.INT) internalFormat = _gl.RG32I
                        }
                        if (glFormat === _gl.RGB) {
                            if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5
                        }
                        if (glFormat === _gl.RGBA) {
                            const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
                            if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
                            if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
                            if (glType === _gl.UNSIGNED_BYTE) internalFormat = (transfer === SRGBTransfer) ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
                            if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
                            if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1
                        }
                        if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
                            extensions.get('EXT_color_buffer_float')
                        }
                        return internalFormat
                    }

                    function getInternalDepthFormat(useStencil, depthType) {
                        let glInternalFormat;
                        if (useStencil) {
                            if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
                                glInternalFormat = _gl.DEPTH24_STENCIL8
                            } else if (depthType === FloatType) {
                                glInternalFormat = _gl.DEPTH32F_STENCIL8
                            } else if (depthType === UnsignedShortType) {
                                glInternalFormat = _gl.DEPTH24_STENCIL8;
                                console.warn('DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.')
                            }
                        } else {
                            if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
                                glInternalFormat = _gl.DEPTH_COMPONENT24
                            } else if (depthType === FloatType) {
                                glInternalFormat = _gl.DEPTH_COMPONENT32F
                            } else if (depthType === UnsignedShortType) {
                                glInternalFormat = _gl.DEPTH_COMPONENT16
                            }
                        }
                        return glInternalFormat
                    }

                    function getMipLevels(texture, image) {
                        if (textureNeedsGenerateMipmaps(texture) === !0 || (texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter)) {
                            return Math.log2(Math.max(image.width, image.height)) + 1
                        } else if (texture.mipmaps !== undefined && texture.mipmaps.length > 0) {
                            return texture.mipmaps.length
                        } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
                            return image.mipmaps.length
                        } else {
                            return 1
                        }
                    }

                    function onTextureDispose(event) {
                        const texture = event.target;
                        texture.removeEventListener('dispose', onTextureDispose);
                        deallocateTexture(texture);
                        if (texture.isVideoTexture) {
                            _videoTextures.delete(texture)
                        }
                    }

                    function onRenderTargetDispose(event) {
                        const renderTarget = event.target;
                        renderTarget.removeEventListener('dispose', onRenderTargetDispose);
                        deallocateRenderTarget(renderTarget)
                    }

                    function deallocateTexture(texture) {
                        const textureProperties = properties.get(texture);
                        if (textureProperties.__webglInit === undefined) return;
                        const source = texture.source;
                        const webglTextures = _sources.get(source);
                        if (webglTextures) {
                            const webglTexture = webglTextures[textureProperties.__cacheKey];
                            webglTexture.usedTimes--;
                            if (webglTexture.usedTimes === 0) {
                                deleteTexture(texture)
                            }
                            if (Object.keys(webglTextures).length === 0) {
                                _sources.delete(source)
                            }
                        }
                        properties.remove(texture)
                    }

                    function deleteTexture(texture) {
                        const textureProperties = properties.get(texture);
                        _gl.deleteTexture(textureProperties.__webglTexture);
                        const source = texture.source;
                        const webglTextures = _sources.get(source);
                        delete webglTextures[textureProperties.__cacheKey];
                        info.memory.textures--
                    }

                    function deallocateRenderTarget(renderTarget) {
                        const renderTargetProperties = properties.get(renderTarget);
                        if (renderTarget.depthTexture) {
                            renderTarget.depthTexture.dispose()
                        }
                        if (renderTarget.isWebGLCubeRenderTarget) {
                            for (let i = 0; i < 6; i++) {
                                if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
                                    for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
                                } else {
                                    _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i])
                                }
                                if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])
                            }
                        } else {
                            if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
                                for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
                            } else {
                                _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer)
                            }
                            if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
                            if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
                            if (renderTargetProperties.__webglColorRenderbuffer) {
                                for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
                                    if (renderTargetProperties.__webglColorRenderbuffer[i]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i])
                                }
                            }
                            if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)
                        }
                        const textures = renderTarget.textures;
                        for (let i = 0, il = textures.length; i < il; i++) {
                            const attachmentProperties = properties.get(textures[i]);
                            if (attachmentProperties.__webglTexture) {
                                _gl.deleteTexture(attachmentProperties.__webglTexture);
                                info.memory.textures--
                            }
                            properties.remove(textures[i])
                        }
                        properties.remove(renderTarget)
                    }
                    let textureUnits = 0;

                    function resetTextureUnits() {
                        textureUnits = 0
                    }

                    function allocateTextureUnit() {
                        const textureUnit = textureUnits;
                        if (textureUnit >= capabilities.maxTextures) {
                            console.warn('THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures)
                        }
                        textureUnits += 1;
                        return textureUnit
                    }

                    function getTextureCacheKey(texture) {
                        const array = [];
                        array.push(texture.wrapS);
                        array.push(texture.wrapT);
                        array.push(texture.wrapR || 0);
                        array.push(texture.magFilter);
                        array.push(texture.minFilter);
                        array.push(texture.anisotropy);
                        array.push(texture.internalFormat);
                        array.push(texture.format);
                        array.push(texture.type);
                        array.push(texture.generateMipmaps);
                        array.push(texture.premultiplyAlpha);
                        array.push(texture.flipY);
                        array.push(texture.unpackAlignment);
                        array.push(texture.colorSpace);
                        return array.join()
                    }

                    function setTexture2D(texture, slot) {
                        const textureProperties = properties.get(texture);
                        if (texture.isVideoTexture) updateVideoTexture(texture);
                        if (texture.isRenderTargetTexture === !1 && texture.version > 0 && textureProperties.__version !== texture.version) {
                            const image = texture.image;
                            if (image === null) {
                                console.warn('THREE.WebGLRenderer: Texture marked for update but no image data found.')
                            } else if (image.complete === !1) {
                                console.warn('THREE.WebGLRenderer: Texture marked for update but image is incomplete')
                            } else {
                                uploadTexture(textureProperties, texture, slot);
                                return
                            }
                        }
                        state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
                    }

                    function setTexture2DArray(texture, slot) {
                        const textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadTexture(textureProperties, texture, slot);
                            return
                        }
                        state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
                    }

                    function setTexture3D(texture, slot) {
                        const textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadTexture(textureProperties, texture, slot);
                            return
                        }
                        state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
                    }

                    function setTextureCube(texture, slot) {
                        const textureProperties = properties.get(texture);
                        if (texture.version > 0 && textureProperties.__version !== texture.version) {
                            uploadCubeTexture(textureProperties, texture, slot);
                            return
                        }
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot)
                    }
                    const wrappingToGL = {
                        [RepeatWrapping]: _gl.REPEAT,
                        [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
                        [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
                    };
                    const filterToGL = {
                        [NearestFilter]: _gl.NEAREST,
                        [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
                        [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
                        [LinearFilter]: _gl.LINEAR,
                        [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
                        [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
                    };
                    const compareToGL = {
                        [NeverCompare]: _gl.NEVER,
                        [AlwaysCompare]: _gl.ALWAYS,
                        [LessCompare]: _gl.LESS,
                        [LessEqualCompare]: _gl.LEQUAL,
                        [EqualCompare]: _gl.EQUAL,
                        [GreaterEqualCompare]: _gl.GEQUAL,
                        [GreaterCompare]: _gl.GREATER,
                        [NotEqualCompare]: _gl.NOTEQUAL
                    };

                    function setTextureParameters(textureType, texture) {
                        if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === !1 && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
                            console.warn('THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.')
                        }
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
                        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
                        if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
                            _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR])
                        }
                        _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
                        _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
                        if (texture.compareFunction) {
                            _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
                            _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction])
                        }
                        if (extensions.has('EXT_texture_filter_anisotropic') === !0) {
                            if (texture.magFilter === NearestFilter) return;
                            if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
                            if (texture.type === FloatType && extensions.has('OES_texture_float_linear') === !1) return;
                            if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
                                const extension = extensions.get('EXT_texture_filter_anisotropic');
                                _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
                                properties.get(texture).__currentAnisotropy = texture.anisotropy
                            }
                        }
                    }

                    function initTexture(textureProperties, texture) {
                        let forceUpload = !1;
                        if (textureProperties.__webglInit === undefined) {
                            textureProperties.__webglInit = !0;
                            texture.addEventListener('dispose', onTextureDispose)
                        }
                        const source = texture.source;
                        let webglTextures = _sources.get(source);
                        if (webglTextures === undefined) {
                            webglTextures = {};
                            _sources.set(source, webglTextures)
                        }
                        const textureCacheKey = getTextureCacheKey(texture);
                        if (textureCacheKey !== textureProperties.__cacheKey) {
                            if (webglTextures[textureCacheKey] === undefined) {
                                webglTextures[textureCacheKey] = {
                                    texture: _gl.createTexture(),
                                    usedTimes: 0
                                };
                                info.memory.textures++;
                                forceUpload = !0
                            }
                            webglTextures[textureCacheKey].usedTimes++;
                            const webglTexture = webglTextures[textureProperties.__cacheKey];
                            if (webglTexture !== undefined) {
                                webglTextures[textureProperties.__cacheKey].usedTimes--;
                                if (webglTexture.usedTimes === 0) {
                                    deleteTexture(texture)
                                }
                            }
                            textureProperties.__cacheKey = textureCacheKey;
                            textureProperties.__webglTexture = webglTextures[textureCacheKey].texture
                        }
                        return forceUpload
                    }

                    function uploadTexture(textureProperties, texture, slot) {
                        let textureType = _gl.TEXTURE_2D;
                        if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
                        if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
                        const forceUpload = initTexture(textureProperties, texture);
                        const source = texture.source;
                        state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
                        const sourceProperties = properties.get(source);
                        if (source.version !== sourceProperties.__version || forceUpload === !0) {
                            state.activeTexture(_gl.TEXTURE0 + slot);
                            const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
                            const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
                            const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
                            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
                            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
                            _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
                            let image = resizeImage(texture.image, !1, capabilities.maxTextureSize);
                            image = verifyColorSpace(texture, image);
                            const glFormat = utils.convert(texture.format, texture.colorSpace);
                            const glType = utils.convert(texture.type);
                            let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
                            setTextureParameters(textureType, texture);
                            let mipmap;
                            const mipmaps = texture.mipmaps;
                            const useTexStorage = (texture.isVideoTexture !== !0);
                            const allocateMemory = (sourceProperties.__version === undefined) || (forceUpload === !0);
                            const dataReady = source.dataReady;
                            const levels = getMipLevels(texture, image);
                            if (texture.isDepthTexture) {
                                glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
                                if (allocateMemory) {
                                    if (useTexStorage) {
                                        state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height)
                                    } else {
                                        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null)
                                    }
                                }
                            } else if (texture.isDataTexture) {
                                if (mipmaps.length > 0) {
                                    if (useTexStorage && allocateMemory) {
                                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height)
                                    }
                                    for (let i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (useTexStorage) {
                                            if (dataReady) {
                                                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data)
                                            }
                                        } else {
                                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                                        }
                                    }
                                    texture.generateMipmaps = !1
                                } else {
                                    if (useTexStorage) {
                                        if (allocateMemory) {
                                            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height)
                                        }
                                        if (dataReady) {
                                            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data)
                                        }
                                    } else {
                                        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data)
                                    }
                                }
                            } else if (texture.isCompressedTexture) {
                                if (texture.isCompressedArrayTexture) {
                                    if (useTexStorage && allocateMemory) {
                                        state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth)
                                    }
                                    for (let i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (texture.format !== RGBAFormat) {
                                            if (glFormat !== null) {
                                                if (useTexStorage) {
                                                    if (dataReady) {
                                                        if (texture.layerUpdates.size > 0) {
                                                            const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                                                            for (const layerIndex of texture.layerUpdates) {
                                                                const layerData = mipmap.data.subarray(layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT);
                                                                state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData, 0, 0)
                                                            }
                                                            texture.clearLayerUpdates()
                                                        } else {
                                                            state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0)
                                                        }
                                                    }
                                                } else {
                                                    state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0)
                                                }
                                            } else {
                                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()')
                                            }
                                        } else {
                                            if (useTexStorage) {
                                                if (dataReady) {
                                                    state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data)
                                                }
                                            } else {
                                                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data)
                                            }
                                        }
                                    }
                                } else {
                                    if (useTexStorage && allocateMemory) {
                                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height)
                                    }
                                    for (let i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (texture.format !== RGBAFormat) {
                                            if (glFormat !== null) {
                                                if (useTexStorage) {
                                                    if (dataReady) {
                                                        state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data)
                                                    }
                                                } else {
                                                    state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)
                                                }
                                            } else {
                                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()')
                                            }
                                        } else {
                                            if (useTexStorage) {
                                                if (dataReady) {
                                                    state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data)
                                                }
                                            } else {
                                                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                                            }
                                        }
                                    }
                                }
                            } else if (texture.isDataArrayTexture) {
                                if (useTexStorage) {
                                    if (allocateMemory) {
                                        state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth)
                                    }
                                    if (dataReady) {
                                        if (texture.layerUpdates.size > 0) {
                                            const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
                                            for (const layerIndex of texture.layerUpdates) {
                                                const layerData = image.data.subarray(layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT, (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT);
                                                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData)
                                            }
                                            texture.clearLayerUpdates()
                                        } else {
                                            state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)
                                        }
                                    }
                                } else {
                                    state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
                                }
                            } else if (texture.isData3DTexture) {
                                if (useTexStorage) {
                                    if (allocateMemory) {
                                        state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth)
                                    }
                                    if (dataReady) {
                                        state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data)
                                    }
                                } else {
                                    state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data)
                                }
                            } else if (texture.isFramebufferTexture) {
                                if (allocateMemory) {
                                    if (useTexStorage) {
                                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height)
                                    } else {
                                        let width = image.width,
                                            height = image.height;
                                        for (let i = 0; i < levels; i++) {
                                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
                                            width >>= 1;
                                            height >>= 1
                                        }
                                    }
                                }
                            } else {
                                if (mipmaps.length > 0) {
                                    if (useTexStorage && allocateMemory) {
                                        const dimensions = getDimensions(mipmaps[0]);
                                        state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height)
                                    }
                                    for (let i = 0, il = mipmaps.length; i < il; i++) {
                                        mipmap = mipmaps[i];
                                        if (useTexStorage) {
                                            if (dataReady) {
                                                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap)
                                            }
                                        } else {
                                            state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap)
                                        }
                                    }
                                    texture.generateMipmaps = !1
                                } else {
                                    if (useTexStorage) {
                                        if (allocateMemory) {
                                            const dimensions = getDimensions(image);
                                            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height)
                                        }
                                        if (dataReady) {
                                            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image)
                                        }
                                    } else {
                                        state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image)
                                    }
                                }
                            }
                            if (textureNeedsGenerateMipmaps(texture)) {
                                generateMipmap(textureType)
                            }
                            sourceProperties.__version = source.version;
                            if (texture.onUpdate) texture.onUpdate(texture)
                        }
                        textureProperties.__version = texture.version
                    }

                    function uploadCubeTexture(textureProperties, texture, slot) {
                        if (texture.image.length !== 6) return;
                        const forceUpload = initTexture(textureProperties, texture);
                        const source = texture.source;
                        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
                        const sourceProperties = properties.get(source);
                        if (source.version !== sourceProperties.__version || forceUpload === !0) {
                            state.activeTexture(_gl.TEXTURE0 + slot);
                            const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
                            const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
                            const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
                            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
                            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
                            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
                            _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
                            const isCompressed = (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
                            const isDataTexture = (texture.image[0] && texture.image[0].isDataTexture);
                            const cubeImage = [];
                            for (let i = 0; i < 6; i++) {
                                if (!isCompressed && !isDataTexture) {
                                    cubeImage[i] = resizeImage(texture.image[i], !0, capabilities.maxCubemapSize)
                                } else {
                                    cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i]
                                }
                                cubeImage[i] = verifyColorSpace(texture, cubeImage[i])
                            }
                            const image = cubeImage[0],
                                glFormat = utils.convert(texture.format, texture.colorSpace),
                                glType = utils.convert(texture.type),
                                glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
                            const useTexStorage = (texture.isVideoTexture !== !0);
                            const allocateMemory = (sourceProperties.__version === undefined) || (forceUpload === !0);
                            const dataReady = source.dataReady;
                            let levels = getMipLevels(texture, image);
                            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
                            let mipmaps;
                            if (isCompressed) {
                                if (useTexStorage && allocateMemory) {
                                    state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height)
                                }
                                for (let i = 0; i < 6; i++) {
                                    mipmaps = cubeImage[i].mipmaps;
                                    for (let j = 0; j < mipmaps.length; j++) {
                                        const mipmap = mipmaps[j];
                                        if (texture.format !== RGBAFormat) {
                                            if (glFormat !== null) {
                                                if (useTexStorage) {
                                                    if (dataReady) {
                                                        state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data)
                                                    }
                                                } else {
                                                    state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data)
                                                }
                                            } else {
                                                console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()')
                                            }
                                        } else {
                                            if (useTexStorage) {
                                                if (dataReady) {
                                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data)
                                                }
                                            } else {
                                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data)
                                            }
                                        }
                                    }
                                }
                            } else {
                                mipmaps = texture.mipmaps;
                                if (useTexStorage && allocateMemory) {
                                    if (mipmaps.length > 0) levels++;
                                    const dimensions = getDimensions(cubeImage[0]);
                                    state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height)
                                }
                                for (let i = 0; i < 6; i++) {
                                    if (isDataTexture) {
                                        if (useTexStorage) {
                                            if (dataReady) {
                                                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data)
                                            }
                                        } else {
                                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data)
                                        }
                                        for (let j = 0; j < mipmaps.length; j++) {
                                            const mipmap = mipmaps[j];
                                            const mipmapImage = mipmap.image[i].image;
                                            if (useTexStorage) {
                                                if (dataReady) {
                                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data)
                                                }
                                            } else {
                                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data)
                                            }
                                        }
                                    } else {
                                        if (useTexStorage) {
                                            if (dataReady) {
                                                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i])
                                            }
                                        } else {
                                            state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i])
                                        }
                                        for (let j = 0; j < mipmaps.length; j++) {
                                            const mipmap = mipmaps[j];
                                            if (useTexStorage) {
                                                if (dataReady) {
                                                    state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i])
                                                }
                                            } else {
                                                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i])
                                            }
                                        }
                                    }
                                }
                            }
                            if (textureNeedsGenerateMipmaps(texture)) {
                                generateMipmap(_gl.TEXTURE_CUBE_MAP)
                            }
                            sourceProperties.__version = source.version;
                            if (texture.onUpdate) texture.onUpdate(texture)
                        }
                        textureProperties.__version = texture.version
                    }

                    function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
                        const glFormat = utils.convert(texture.format, texture.colorSpace);
                        const glType = utils.convert(texture.type);
                        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
                        const renderTargetProperties = properties.get(renderTarget);
                        if (!renderTargetProperties.__hasExternalTextures) {
                            const width = Math.max(1, renderTarget.width >> level);
                            const height = Math.max(1, renderTarget.height >> level);
                            if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
                                state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null)
                            } else {
                                state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null)
                            }
                        }
                        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                        if (useMultisampledRTT(renderTarget)) {
                            multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget))
                        } else if (textureTarget === _gl.TEXTURE_2D || (textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z)) {
                            _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level)
                        }
                        state.bindFramebuffer(_gl.FRAMEBUFFER, null)
                    }

                    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
                        if (renderTarget.depthBuffer) {
                            const depthTexture = renderTarget.depthTexture;
                            const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
                            const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
                            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                            const samples = getRenderTargetSamples(renderTarget);
                            const isUseMultisampledRTT = useMultisampledRTT(renderTarget);
                            if (isUseMultisampledRTT) {
                                multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
                            } else if (isMultisample) {
                                _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
                            } else {
                                _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height)
                            }
                            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer)
                        } else {
                            const textures = renderTarget.textures;
                            for (let i = 0; i < textures.length; i++) {
                                const texture = textures[i];
                                const glFormat = utils.convert(texture.format, texture.colorSpace);
                                const glType = utils.convert(texture.type);
                                const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
                                const samples = getRenderTargetSamples(renderTarget);
                                if (isMultisample && useMultisampledRTT(renderTarget) === !1) {
                                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
                                } else if (useMultisampledRTT(renderTarget)) {
                                    multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height)
                                } else {
                                    _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height)
                                }
                            }
                        }
                        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null)
                    }

                    function setupDepthTexture(framebuffer, renderTarget) {
                        const isCube = (renderTarget && renderTarget.isWebGLCubeRenderTarget);
                        if (isCube) throw new Error('Depth Texture with cube render targets is not supported');
                        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                        if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
                            throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture')
                        }
                        if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
                            renderTarget.depthTexture.image.width = renderTarget.width;
                            renderTarget.depthTexture.image.height = renderTarget.height;
                            renderTarget.depthTexture.needsUpdate = !0
                        }
                        setTexture2D(renderTarget.depthTexture, 0);
                        const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
                        const samples = getRenderTargetSamples(renderTarget);
                        if (renderTarget.depthTexture.format === DepthFormat) {
                            if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples)
                            } else {
                                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
                            }
                        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
                            if (useMultisampledRTT(renderTarget)) {
                                multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples)
                            } else {
                                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0)
                            }
                        } else {
                            throw new Error('Unknown depthTexture format')
                        }
                    }

                    function setupDepthRenderbuffer(renderTarget) {
                        const renderTargetProperties = properties.get(renderTarget);
                        const isCube = (renderTarget.isWebGLCubeRenderTarget === !0);
                        if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
                            if (isCube) throw new Error('target.depthTexture not supported in Cube render targets');
                            setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)
                        } else {
                            if (isCube) {
                                renderTargetProperties.__webglDepthbuffer = [];
                                for (let i = 0; i < 6; i++) {
                                    state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
                                    renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
                                    setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, !1)
                                }
                            } else {
                                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                                renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
                                setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, !1)
                            }
                        }
                        state.bindFramebuffer(_gl.FRAMEBUFFER, null)
                    }

                    function rebindTextures(renderTarget, colorTexture, depthTexture) {
                        const renderTargetProperties = properties.get(renderTarget);
                        if (colorTexture !== undefined) {
                            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0)
                        }
                        if (depthTexture !== undefined) {
                            setupDepthRenderbuffer(renderTarget)
                        }
                    }

                    function setupRenderTarget(renderTarget) {
                        const texture = renderTarget.texture;
                        const renderTargetProperties = properties.get(renderTarget);
                        const textureProperties = properties.get(texture);
                        renderTarget.addEventListener('dispose', onRenderTargetDispose);
                        const textures = renderTarget.textures;
                        const isCube = (renderTarget.isWebGLCubeRenderTarget === !0);
                        const isMultipleRenderTargets = (textures.length > 1);
                        if (!isMultipleRenderTargets) {
                            if (textureProperties.__webglTexture === undefined) {
                                textureProperties.__webglTexture = _gl.createTexture()
                            }
                            textureProperties.__version = texture.version;
                            info.memory.textures++
                        }
                        if (isCube) {
                            renderTargetProperties.__webglFramebuffer = [];
                            for (let i = 0; i < 6; i++) {
                                if (texture.mipmaps && texture.mipmaps.length > 0) {
                                    renderTargetProperties.__webglFramebuffer[i] = [];
                                    for (let level = 0; level < texture.mipmaps.length; level++) {
                                        renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer()
                                    }
                                } else {
                                    renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
                                }
                            }
                        } else {
                            if (texture.mipmaps && texture.mipmaps.length > 0) {
                                renderTargetProperties.__webglFramebuffer = [];
                                for (let level = 0; level < texture.mipmaps.length; level++) {
                                    renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer()
                                }
                            } else {
                                renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer()
                            }
                            if (isMultipleRenderTargets) {
                                for (let i = 0, il = textures.length; i < il; i++) {
                                    const attachmentProperties = properties.get(textures[i]);
                                    if (attachmentProperties.__webglTexture === undefined) {
                                        attachmentProperties.__webglTexture = _gl.createTexture();
                                        info.memory.textures++
                                    }
                                }
                            }
                            if ((renderTarget.samples > 0) && useMultisampledRTT(renderTarget) === !1) {
                                renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
                                renderTargetProperties.__webglColorRenderbuffer = [];
                                state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                                for (let i = 0; i < textures.length; i++) {
                                    const texture = textures[i];
                                    renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
                                    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                                    const glFormat = utils.convert(texture.format, texture.colorSpace);
                                    const glType = utils.convert(texture.type);
                                    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, renderTarget.isXRRenderTarget === !0);
                                    const samples = getRenderTargetSamples(renderTarget);
                                    _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
                                    _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i])
                                }
                                _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
                                if (renderTarget.depthBuffer) {
                                    renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
                                    setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, !0)
                                }
                                state.bindFramebuffer(_gl.FRAMEBUFFER, null)
                            }
                        }
                        if (isCube) {
                            state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
                            setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
                            for (let i = 0; i < 6; i++) {
                                if (texture.mipmaps && texture.mipmaps.length > 0) {
                                    for (let level = 0; level < texture.mipmaps.length; level++) {
                                        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level)
                                    }
                                } else {
                                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0)
                                }
                            }
                            if (textureNeedsGenerateMipmaps(texture)) {
                                generateMipmap(_gl.TEXTURE_CUBE_MAP)
                            }
                            state.unbindTexture()
                        } else if (isMultipleRenderTargets) {
                            for (let i = 0, il = textures.length; i < il; i++) {
                                const attachment = textures[i];
                                const attachmentProperties = properties.get(attachment);
                                state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
                                setTextureParameters(_gl.TEXTURE_2D, attachment);
                                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
                                if (textureNeedsGenerateMipmaps(attachment)) {
                                    generateMipmap(_gl.TEXTURE_2D)
                                }
                            }
                            state.unbindTexture()
                        } else {
                            let glTextureType = _gl.TEXTURE_2D;
                            if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
                                glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY
                            }
                            state.bindTexture(glTextureType, textureProperties.__webglTexture);
                            setTextureParameters(glTextureType, texture);
                            if (texture.mipmaps && texture.mipmaps.length > 0) {
                                for (let level = 0; level < texture.mipmaps.length; level++) {
                                    setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level)
                                }
                            } else {
                                setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0)
                            }
                            if (textureNeedsGenerateMipmaps(texture)) {
                                generateMipmap(glTextureType)
                            }
                            state.unbindTexture()
                        }
                        if (renderTarget.depthBuffer) {
                            setupDepthRenderbuffer(renderTarget)
                        }
                    }

                    function updateRenderTargetMipmap(renderTarget) {
                        const textures = renderTarget.textures;
                        for (let i = 0, il = textures.length; i < il; i++) {
                            const texture = textures[i];
                            if (textureNeedsGenerateMipmaps(texture)) {
                                const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
                                const webglTexture = properties.get(texture).__webglTexture;
                                state.bindTexture(target, webglTexture);
                                generateMipmap(target);
                                state.unbindTexture()
                            }
                        }
                    }
                    const invalidationArrayRead = [];
                    const invalidationArrayDraw = [];

                    function updateMultisampleRenderTarget(renderTarget) {
                        if (renderTarget.samples > 0) {
                            if (useMultisampledRTT(renderTarget) === !1) {
                                const textures = renderTarget.textures;
                                const width = renderTarget.width;
                                const height = renderTarget.height;
                                let mask = _gl.COLOR_BUFFER_BIT;
                                const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                                const renderTargetProperties = properties.get(renderTarget);
                                const isMultipleRenderTargets = (textures.length > 1);
                                if (isMultipleRenderTargets) {
                                    for (let i = 0; i < textures.length; i++) {
                                        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
                                        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                                        _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0)
                                    }
                                }
                                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                                for (let i = 0; i < textures.length; i++) {
                                    if (renderTarget.resolveDepthBuffer) {
                                        if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
                                        if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT
                                    }
                                    if (isMultipleRenderTargets) {
                                        _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                                        const webglTexture = properties.get(textures[i]).__webglTexture;
                                        _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0)
                                    }
                                    _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
                                    if (supportsInvalidateFramebuffer === !0) {
                                        invalidationArrayRead.length = 0;
                                        invalidationArrayDraw.length = 0;
                                        invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i);
                                        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === !1) {
                                            invalidationArrayRead.push(depthStyle);
                                            invalidationArrayDraw.push(depthStyle);
                                            _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw)
                                        }
                                        _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead)
                                    }
                                }
                                state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
                                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
                                if (isMultipleRenderTargets) {
                                    for (let i = 0; i < textures.length; i++) {
                                        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
                                        _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
                                        const webglTexture = properties.get(textures[i]).__webglTexture;
                                        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
                                        _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0)
                                    }
                                }
                                state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer)
                            } else {
                                if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === !1 && supportsInvalidateFramebuffer) {
                                    const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
                                    _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle])
                                }
                            }
                        }
                    }

                    function getRenderTargetSamples(renderTarget) {
                        return Math.min(capabilities.maxSamples, renderTarget.samples)
                    }

                    function useMultisampledRTT(renderTarget) {
                        const renderTargetProperties = properties.get(renderTarget);
                        return renderTarget.samples > 0 && extensions.has('WEBGL_multisampled_render_to_texture') === !0 && renderTargetProperties.__useRenderToTexture !== !1
                    }

                    function updateVideoTexture(texture) {
                        const frame = info.render.frame;
                        if (_videoTextures.get(texture) !== frame) {
                            _videoTextures.set(texture, frame);
                            texture.update()
                        }
                    }

                    function verifyColorSpace(texture, image) {
                        const colorSpace = texture.colorSpace;
                        const format = texture.format;
                        const type = texture.type;
                        if (texture.isCompressedTexture === !0 || texture.isVideoTexture === !0) return image;
                        if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
                            if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
                                if (format !== RGBAFormat || type !== UnsignedByteType) {
                                    console.warn('THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.')
                                }
                            } else {
                                console.error('THREE.WebGLTextures: Unsupported texture color space:', colorSpace)
                            }
                        }
                        return image
                    }

                    function getDimensions(image) {
                        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement) {
                            _imageDimensions.width = image.naturalWidth || image.width;
                            _imageDimensions.height = image.naturalHeight || image.height
                        } else if (typeof VideoFrame !== 'undefined' && image instanceof VideoFrame) {
                            _imageDimensions.width = image.displayWidth;
                            _imageDimensions.height = image.displayHeight
                        } else {
                            _imageDimensions.width = image.width;
                            _imageDimensions.height = image.height
                        }
                        return _imageDimensions
                    }
                    this.allocateTextureUnit = allocateTextureUnit;
                    this.resetTextureUnits = resetTextureUnits;
                    this.setTexture2D = setTexture2D;
                    this.setTexture2DArray = setTexture2DArray;
                    this.setTexture3D = setTexture3D;
                    this.setTextureCube = setTextureCube;
                    this.rebindTextures = rebindTextures;
                    this.setupRenderTarget = setupRenderTarget;
                    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
                    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
                    this.setupDepthRenderbuffer = setupDepthRenderbuffer;
                    this.setupFrameBufferTexture = setupFrameBufferTexture;
                    this.useMultisampledRTT = useMultisampledRTT
                }

                function WebGLUtils(gl, extensions) {
                    function convert(p, colorSpace = NoColorSpace) {
                        let extension;
                        const transfer = ColorManagement.getTransfer(colorSpace);
                        if (p === UnsignedByteType) return gl.UNSIGNED_BYTE;
                        if (p === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
                        if (p === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
                        if (p === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
                        if (p === ByteType) return gl.BYTE;
                        if (p === ShortType) return gl.SHORT;
                        if (p === UnsignedShortType) return gl.UNSIGNED_SHORT;
                        if (p === IntType) return gl.INT;
                        if (p === UnsignedIntType) return gl.UNSIGNED_INT;
                        if (p === FloatType) return gl.FLOAT;
                        if (p === HalfFloatType) return gl.HALF_FLOAT;
                        if (p === AlphaFormat) return gl.ALPHA;
                        if (p === RGBFormat) return gl.RGB;
                        if (p === RGBAFormat) return gl.RGBA;
                        if (p === LuminanceFormat) return gl.LUMINANCE;
                        if (p === LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
                        if (p === DepthFormat) return gl.DEPTH_COMPONENT;
                        if (p === DepthStencilFormat) return gl.DEPTH_STENCIL;
                        if (p === RedFormat) return gl.RED;
                        if (p === RedIntegerFormat) return gl.RED_INTEGER;
                        if (p === RGFormat) return gl.RG;
                        if (p === RGIntegerFormat) return gl.RG_INTEGER;
                        if (p === RGBAIntegerFormat) return gl.RGBA_INTEGER;
                        if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
                            if (transfer === SRGBTransfer) {
                                extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
                                if (extension !== null) {
                                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                                } else {
                                    return null
                                }
                            } else {
                                extension = extensions.get('WEBGL_compressed_texture_s3tc');
                                if (extension !== null) {
                                    if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                                    if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                                    if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
                                } else {
                                    return null
                                }
                            }
                        }
                        if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_pvrtc');
                            if (extension !== null) {
                                if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                                if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                                if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                                if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                            } else {
                                return null
                            }
                        }
                        if (p === RGB_ETC1_Format || p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_etc');
                            if (extension !== null) {
                                if (p === RGB_ETC1_Format || p === RGB_ETC2_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
                                if (p === RGBA_ETC2_EAC_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC
                            } else {
                                return null
                            }
                        }
                        if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
                            extension = extensions.get('WEBGL_compressed_texture_astc');
                            if (extension !== null) {
                                if (p === RGBA_ASTC_4x4_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
                                if (p === RGBA_ASTC_5x4_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
                                if (p === RGBA_ASTC_5x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
                                if (p === RGBA_ASTC_6x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
                                if (p === RGBA_ASTC_6x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
                                if (p === RGBA_ASTC_8x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
                                if (p === RGBA_ASTC_8x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
                                if (p === RGBA_ASTC_8x8_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
                                if (p === RGBA_ASTC_10x5_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
                                if (p === RGBA_ASTC_10x6_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
                                if (p === RGBA_ASTC_10x8_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
                                if (p === RGBA_ASTC_10x10_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
                                if (p === RGBA_ASTC_12x10_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
                                if (p === RGBA_ASTC_12x12_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR
                            } else {
                                return null
                            }
                        }
                        if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
                            extension = extensions.get('EXT_texture_compression_bptc');
                            if (extension !== null) {
                                if (p === RGBA_BPTC_Format) return (transfer === SRGBTransfer) ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                                if (p === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                                if (p === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
                            } else {
                                return null
                            }
                        }
                        if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
                            extension = extensions.get('EXT_texture_compression_rgtc');
                            if (extension !== null) {
                                if (p === RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
                                if (p === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                                if (p === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
                                if (p === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
                            } else {
                                return null
                            }
                        }
                        if (p === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
                        return (gl[p] !== undefined) ? gl[p] : null
                    }
                    return {
                        convert: convert
                    }
                }
                class ArrayCamera extends PerspectiveCamera {
                    constructor(array = []) {
                        super();
                        this.isArrayCamera = !0;
                        this.cameras = array
                    }
                }
                class Group extends Object3D {
                    constructor() {
                        super();
                        this.isGroup = !0;
                        this.type = 'Group'
                    }
                }
                const _moveEvent = {
                    type: 'move'
                };
                class WebXRController {
                    constructor() {
                        this._targetRay = null;
                        this._grip = null;
                        this._hand = null
                    }
                    getHandSpace() {
                        if (this._hand === null) {
                            this._hand = new Group();
                            this._hand.matrixAutoUpdate = !1;
                            this._hand.visible = !1;
                            this._hand.joints = {};
                            this._hand.inputState = {
                                pinching: !1
                            }
                        }
                        return this._hand
                    }
                    getTargetRaySpace() {
                        if (this._targetRay === null) {
                            this._targetRay = new Group();
                            this._targetRay.matrixAutoUpdate = !1;
                            this._targetRay.visible = !1;
                            this._targetRay.hasLinearVelocity = !1;
                            this._targetRay.linearVelocity = new Vector3();
                            this._targetRay.hasAngularVelocity = !1;
                            this._targetRay.angularVelocity = new Vector3()
                        }
                        return this._targetRay
                    }
                    getGripSpace() {
                        if (this._grip === null) {
                            this._grip = new Group();
                            this._grip.matrixAutoUpdate = !1;
                            this._grip.visible = !1;
                            this._grip.hasLinearVelocity = !1;
                            this._grip.linearVelocity = new Vector3();
                            this._grip.hasAngularVelocity = !1;
                            this._grip.angularVelocity = new Vector3()
                        }
                        return this._grip
                    }
                    dispatchEvent(event) {
                        if (this._targetRay !== null) {
                            this._targetRay.dispatchEvent(event)
                        }
                        if (this._grip !== null) {
                            this._grip.dispatchEvent(event)
                        }
                        if (this._hand !== null) {
                            this._hand.dispatchEvent(event)
                        }
                        return this
                    }
                    connect(inputSource) {
                        if (inputSource && inputSource.hand) {
                            const hand = this._hand;
                            if (hand) {
                                for (const inputjoint of inputSource.hand.values()) {
                                    this._getHandJoint(hand, inputjoint)
                                }
                            }
                        }
                        this.dispatchEvent({
                            type: 'connected',
                            data: inputSource
                        });
                        return this
                    }
                    disconnect(inputSource) {
                        this.dispatchEvent({
                            type: 'disconnected',
                            data: inputSource
                        });
                        if (this._targetRay !== null) {
                            this._targetRay.visible = !1
                        }
                        if (this._grip !== null) {
                            this._grip.visible = !1
                        }
                        if (this._hand !== null) {
                            this._hand.visible = !1
                        }
                        return this
                    }
                    update(inputSource, frame, referenceSpace) {
                        let inputPose = null;
                        let gripPose = null;
                        let handPose = null;
                        const targetRay = this._targetRay;
                        const grip = this._grip;
                        const hand = this._hand;
                        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
                            if (hand && inputSource.hand) {
                                handPose = !0;
                                for (const inputjoint of inputSource.hand.values()) {
                                    const jointPose = frame.getJointPose(inputjoint, referenceSpace);
                                    const joint = this._getHandJoint(hand, inputjoint);
                                    if (jointPose !== null) {
                                        joint.matrix.fromArray(jointPose.transform.matrix);
                                        joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
                                        joint.matrixWorldNeedsUpdate = !0;
                                        joint.jointRadius = jointPose.radius
                                    }
                                    joint.visible = jointPose !== null
                                }
                                const indexTip = hand.joints['index-finger-tip'];
                                const thumbTip = hand.joints['thumb-tip'];
                                const distance = indexTip.position.distanceTo(thumbTip.position);
                                const distanceToPinch = 0.02;
                                const threshold = 0.005;
                                if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
                                    hand.inputState.pinching = !1;
                                    this.dispatchEvent({
                                        type: 'pinchend',
                                        handedness: inputSource.handedness,
                                        target: this
                                    })
                                } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
                                    hand.inputState.pinching = !0;
                                    this.dispatchEvent({
                                        type: 'pinchstart',
                                        handedness: inputSource.handedness,
                                        target: this
                                    })
                                }
                            } else {
                                if (grip !== null && inputSource.gripSpace) {
                                    gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
                                    if (gripPose !== null) {
                                        grip.matrix.fromArray(gripPose.transform.matrix);
                                        grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
                                        grip.matrixWorldNeedsUpdate = !0;
                                        if (gripPose.linearVelocity) {
                                            grip.hasLinearVelocity = !0;
                                            grip.linearVelocity.copy(gripPose.linearVelocity)
                                        } else {
                                            grip.hasLinearVelocity = !1
                                        }
                                        if (gripPose.angularVelocity) {
                                            grip.hasAngularVelocity = !0;
                                            grip.angularVelocity.copy(gripPose.angularVelocity)
                                        } else {
                                            grip.hasAngularVelocity = !1
                                        }
                                    }
                                }
                            }
                            if (targetRay !== null) {
                                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                                if (inputPose === null && gripPose !== null) {
                                    inputPose = gripPose
                                }
                                if (inputPose !== null) {
                                    targetRay.matrix.fromArray(inputPose.transform.matrix);
                                    targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
                                    targetRay.matrixWorldNeedsUpdate = !0;
                                    if (inputPose.linearVelocity) {
                                        targetRay.hasLinearVelocity = !0;
                                        targetRay.linearVelocity.copy(inputPose.linearVelocity)
                                    } else {
                                        targetRay.hasLinearVelocity = !1
                                    }
                                    if (inputPose.angularVelocity) {
                                        targetRay.hasAngularVelocity = !0;
                                        targetRay.angularVelocity.copy(inputPose.angularVelocity)
                                    } else {
                                        targetRay.hasAngularVelocity = !1
                                    }
                                    this.dispatchEvent(_moveEvent)
                                }
                            }
                        }
                        if (targetRay !== null) {
                            targetRay.visible = (inputPose !== null)
                        }
                        if (grip !== null) {
                            grip.visible = (gripPose !== null)
                        }
                        if (hand !== null) {
                            hand.visible = (handPose !== null)
                        }
                        return this
                    }
                    _getHandJoint(hand, inputjoint) {
                        if (hand.joints[inputjoint.jointName] === undefined) {
                            const joint = new Group();
                            joint.matrixAutoUpdate = !1;
                            joint.visible = !1;
                            hand.joints[inputjoint.jointName] = joint;
                            hand.add(joint)
                        }
                        return hand.joints[inputjoint.jointName]
                    }
                }
                const _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
                const _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
                class WebXRDepthSensing {
                    constructor() {
                        this.texture = null;
                        this.mesh = null;
                        this.depthNear = 0;
                        this.depthFar = 0
                    }
                    init(renderer, depthData, renderState) {
                        if (this.texture === null) {
                            const texture = new Texture();
                            const texProps = renderer.properties.get(texture);
                            texProps.__webglTexture = depthData.texture;
                            if ((depthData.depthNear != renderState.depthNear) || (depthData.depthFar != renderState.depthFar)) {
                                this.depthNear = depthData.depthNear;
                                this.depthFar = depthData.depthFar
                            }
                            this.texture = texture
                        }
                    }
                    getMesh(cameraXR) {
                        if (this.texture !== null) {
                            if (this.mesh === null) {
                                const viewport = cameraXR.cameras[0].viewport;
                                const material = new ShaderMaterial({
                                    vertexShader: _occlusion_vertex,
                                    fragmentShader: _occlusion_fragment,
                                    uniforms: {
                                        depthColor: {
                                            value: this.texture
                                        },
                                        depthWidth: {
                                            value: viewport.z
                                        },
                                        depthHeight: {
                                            value: viewport.w
                                        }
                                    }
                                });
                                this.mesh = new Mesh(new PlaneGeometry(20, 20), material)
                            }
                        }
                        return this.mesh
                    }
                    reset() {
                        this.texture = null;
                        this.mesh = null
                    }
                    getDepthTexture() {
                        return this.texture
                    }
                }
                class WebXRManager extends EventDispatcher {
                    constructor(renderer, gl) {
                        super();
                        const scope = this;
                        let session = null;
                        let framebufferScaleFactor = 1.0;
                        let referenceSpace = null;
                        let referenceSpaceType = 'local-floor';
                        let foveation = 1.0;
                        let customReferenceSpace = null;
                        let pose = null;
                        let glBinding = null;
                        let glProjLayer = null;
                        let glBaseLayer = null;
                        let xrFrame = null;
                        const depthSensing = new WebXRDepthSensing();
                        const attributes = gl.getContextAttributes();
                        let initialRenderTarget = null;
                        let newRenderTarget = null;
                        const controllers = [];
                        const controllerInputSources = [];
                        const currentSize = new Vector2();
                        let currentPixelRatio = null;
                        const cameraL = new PerspectiveCamera();
                        cameraL.layers.enable(1);
                        cameraL.viewport = new Vector4();
                        const cameraR = new PerspectiveCamera();
                        cameraR.layers.enable(2);
                        cameraR.viewport = new Vector4();
                        const cameras = [cameraL, cameraR];
                        const cameraXR = new ArrayCamera();
                        cameraXR.layers.enable(1);
                        cameraXR.layers.enable(2);
                        let _currentDepthNear = null;
                        let _currentDepthFar = null;
                        this.cameraAutoUpdate = !0;
                        this.enabled = !1;
                        this.isPresenting = !1;
                        this.getController = function(index) {
                            let controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller
                            }
                            return controller.getTargetRaySpace()
                        };
                        this.getControllerGrip = function(index) {
                            let controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller
                            }
                            return controller.getGripSpace()
                        };
                        this.getHand = function(index) {
                            let controller = controllers[index];
                            if (controller === undefined) {
                                controller = new WebXRController();
                                controllers[index] = controller
                            }
                            return controller.getHandSpace()
                        };

                        function onSessionEvent(event) {
                            const controllerIndex = controllerInputSources.indexOf(event.inputSource);
                            if (controllerIndex === -1) {
                                return
                            }
                            const controller = controllers[controllerIndex];
                            if (controller !== undefined) {
                                controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
                                controller.dispatchEvent({
                                    type: event.type,
                                    data: event.inputSource
                                })
                            }
                        }

                        function onSessionEnd() {
                            session.removeEventListener('select', onSessionEvent);
                            session.removeEventListener('selectstart', onSessionEvent);
                            session.removeEventListener('selectend', onSessionEvent);
                            session.removeEventListener('squeeze', onSessionEvent);
                            session.removeEventListener('squeezestart', onSessionEvent);
                            session.removeEventListener('squeezeend', onSessionEvent);
                            session.removeEventListener('end', onSessionEnd);
                            session.removeEventListener('inputsourceschange', onInputSourcesChange);
                            for (let i = 0; i < controllers.length; i++) {
                                const inputSource = controllerInputSources[i];
                                if (inputSource === null) continue;
                                controllerInputSources[i] = null;
                                controllers[i].disconnect(inputSource)
                            }
                            _currentDepthNear = null;
                            _currentDepthFar = null;
                            depthSensing.reset();
                            renderer.setRenderTarget(initialRenderTarget);
                            glBaseLayer = null;
                            glProjLayer = null;
                            glBinding = null;
                            session = null;
                            newRenderTarget = null;
                            animation.stop();
                            scope.isPresenting = !1;
                            renderer.setPixelRatio(currentPixelRatio);
                            renderer.setSize(currentSize.width, currentSize.height, !1);
                            scope.dispatchEvent({
                                type: 'sessionend'
                            })
                        }
                        this.setFramebufferScaleFactor = function(value) {
                            framebufferScaleFactor = value;
                            if (scope.isPresenting === !0) {
                                console.warn('THREE.WebXRManager: Cannot change framebuffer scale while presenting.')
                            }
                        };
                        this.setReferenceSpaceType = function(value) {
                            referenceSpaceType = value;
                            if (scope.isPresenting === !0) {
                                console.warn('THREE.WebXRManager: Cannot change reference space type while presenting.')
                            }
                        };
                        this.getReferenceSpace = function() {
                            return customReferenceSpace || referenceSpace
                        };
                        this.setReferenceSpace = function(space) {
                            customReferenceSpace = space
                        };
                        this.getBaseLayer = function() {
                            return glProjLayer !== null ? glProjLayer : glBaseLayer
                        };
                        this.getBinding = function() {
                            return glBinding
                        };
                        this.getFrame = function() {
                            return xrFrame
                        };
                        this.getSession = function() {
                            return session
                        };
                        this.setSession = async function(value) {
                            session = value;
                            if (session !== null) {
                                initialRenderTarget = renderer.getRenderTarget();
                                session.addEventListener('select', onSessionEvent);
                                session.addEventListener('selectstart', onSessionEvent);
                                session.addEventListener('selectend', onSessionEvent);
                                session.addEventListener('squeeze', onSessionEvent);
                                session.addEventListener('squeezestart', onSessionEvent);
                                session.addEventListener('squeezeend', onSessionEvent);
                                session.addEventListener('end', onSessionEnd);
                                session.addEventListener('inputsourceschange', onInputSourcesChange);
                                if (attributes.xrCompatible !== !0) {
                                    await gl.makeXRCompatible()
                                }
                                currentPixelRatio = renderer.getPixelRatio();
                                renderer.getSize(currentSize);
                                if (session.renderState.layers === undefined) {
                                    const layerInit = {
                                        antialias: attributes.antialias,
                                        alpha: !0,
                                        depth: attributes.depth,
                                        stencil: attributes.stencil,
                                        framebufferScaleFactor: framebufferScaleFactor
                                    };
                                    glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                                    session.updateRenderState({
                                        baseLayer: glBaseLayer
                                    });
                                    renderer.setPixelRatio(1);
                                    renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, !1);
                                    newRenderTarget = new WebGLRenderTarget(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, {
                                        format: RGBAFormat,
                                        type: UnsignedByteType,
                                        colorSpace: renderer.outputColorSpace,
                                        stencilBuffer: attributes.stencil
                                    })
                                } else {
                                    let depthFormat = null;
                                    let depthType = null;
                                    let glDepthFormat = null;
                                    if (attributes.depth) {
                                        glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
                                        depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
                                        depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType
                                    }
                                    const projectionlayerInit = {
                                        colorFormat: gl.RGBA8,
                                        depthFormat: glDepthFormat,
                                        scaleFactor: framebufferScaleFactor
                                    };
                                    glBinding = new XRWebGLBinding(session, gl);
                                    glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
                                    session.updateRenderState({
                                        layers: [glProjLayer]
                                    });
                                    renderer.setPixelRatio(1);
                                    renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, !1);
                                    newRenderTarget = new WebGLRenderTarget(glProjLayer.textureWidth, glProjLayer.textureHeight, {
                                        format: RGBAFormat,
                                        type: UnsignedByteType,
                                        depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, undefined, undefined, undefined, undefined, undefined, undefined, depthFormat),
                                        stencilBuffer: attributes.stencil,
                                        colorSpace: renderer.outputColorSpace,
                                        samples: attributes.antialias ? 4 : 0,
                                        resolveDepthBuffer: (glProjLayer.ignoreDepthValues === !1)
                                    })
                                }
                                newRenderTarget.isXRRenderTarget = !0;
                                this.setFoveation(foveation);
                                customReferenceSpace = null;
                                referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
                                animation.setContext(session);
                                animation.start();
                                scope.isPresenting = !0;
                                scope.dispatchEvent({
                                    type: 'sessionstart'
                                })
                            }
                        };
                        this.getEnvironmentBlendMode = function() {
                            if (session !== null) {
                                return session.environmentBlendMode
                            }
                        };
                        this.getDepthTexture = function() {
                            return depthSensing.getDepthTexture()
                        };

                        function onInputSourcesChange(event) {
                            for (let i = 0; i < event.removed.length; i++) {
                                const inputSource = event.removed[i];
                                const index = controllerInputSources.indexOf(inputSource);
                                if (index >= 0) {
                                    controllerInputSources[index] = null;
                                    controllers[index].disconnect(inputSource)
                                }
                            }
                            for (let i = 0; i < event.added.length; i++) {
                                const inputSource = event.added[i];
                                let controllerIndex = controllerInputSources.indexOf(inputSource);
                                if (controllerIndex === -1) {
                                    for (let i = 0; i < controllers.length; i++) {
                                        if (i >= controllerInputSources.length) {
                                            controllerInputSources.push(inputSource);
                                            controllerIndex = i;
                                            break
                                        } else if (controllerInputSources[i] === null) {
                                            controllerInputSources[i] = inputSource;
                                            controllerIndex = i;
                                            break
                                        }
                                    }
                                    if (controllerIndex === -1) break
                                }
                                const controller = controllers[controllerIndex];
                                if (controller) {
                                    controller.connect(inputSource)
                                }
                            }
                        }
                        const cameraLPos = new Vector3();
                        const cameraRPos = new Vector3();

                        function setProjectionFromUnion(camera, cameraL, cameraR) {
                            cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
                            cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
                            const ipd = cameraLPos.distanceTo(cameraRPos);
                            const projL = cameraL.projectionMatrix.elements;
                            const projR = cameraR.projectionMatrix.elements;
                            const near = projL[14] / (projL[10] - 1);
                            const far = projL[14] / (projL[10] + 1);
                            const topFov = (projL[9] + 1) / projL[5];
                            const bottomFov = (projL[9] - 1) / projL[5];
                            const leftFov = (projL[8] - 1) / projL[0];
                            const rightFov = (projR[8] + 1) / projR[0];
                            const left = near * leftFov;
                            const right = near * rightFov;
                            const zOffset = ipd / (-leftFov + rightFov);
                            const xOffset = zOffset * -leftFov;
                            cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
                            camera.translateX(xOffset);
                            camera.translateZ(zOffset);
                            camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
                            camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
                            const near2 = near + zOffset;
                            const far2 = far + zOffset;
                            const left2 = left - xOffset;
                            const right2 = right + (ipd - xOffset);
                            const top2 = topFov * far / far2 * near2;
                            const bottom2 = bottomFov * far / far2 * near2;
                            camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
                            camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert()
                        }

                        function updateCamera(camera, parent) {
                            if (parent === null) {
                                camera.matrixWorld.copy(camera.matrix)
                            } else {
                                camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix)
                            }
                            camera.matrixWorldInverse.copy(camera.matrixWorld).invert()
                        }
                        this.updateCamera = function(camera) {
                            if (session === null) return;
                            if (depthSensing.texture !== null) {
                                camera.near = depthSensing.depthNear;
                                camera.far = depthSensing.depthFar
                            }
                            cameraXR.near = cameraR.near = cameraL.near = camera.near;
                            cameraXR.far = cameraR.far = cameraL.far = camera.far;
                            if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
                                session.updateRenderState({
                                    depthNear: cameraXR.near,
                                    depthFar: cameraXR.far
                                });
                                _currentDepthNear = cameraXR.near;
                                _currentDepthFar = cameraXR.far;
                                cameraL.near = _currentDepthNear;
                                cameraL.far = _currentDepthFar;
                                cameraR.near = _currentDepthNear;
                                cameraR.far = _currentDepthFar;
                                cameraL.updateProjectionMatrix();
                                cameraR.updateProjectionMatrix();
                                camera.updateProjectionMatrix()
                            }
                            const parent = camera.parent;
                            const cameras = cameraXR.cameras;
                            updateCamera(cameraXR, parent);
                            for (let i = 0; i < cameras.length; i++) {
                                updateCamera(cameras[i], parent)
                            }
                            if (cameras.length === 2) {
                                setProjectionFromUnion(cameraXR, cameraL, cameraR)
                            } else {
                                cameraXR.projectionMatrix.copy(cameraL.projectionMatrix)
                            }
                            updateUserCamera(camera, cameraXR, parent)
                        };

                        function updateUserCamera(camera, cameraXR, parent) {
                            if (parent === null) {
                                camera.matrix.copy(cameraXR.matrixWorld)
                            } else {
                                camera.matrix.copy(parent.matrixWorld);
                                camera.matrix.invert();
                                camera.matrix.multiply(cameraXR.matrixWorld)
                            }
                            camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                            camera.updateMatrixWorld(!0);
                            camera.projectionMatrix.copy(cameraXR.projectionMatrix);
                            camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse);
                            if (camera.isPerspectiveCamera) {
                                camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
                                camera.zoom = 1
                            }
                        }
                        this.getCamera = function() {
                            return cameraXR
                        };
                        this.getFoveation = function() {
                            if (glProjLayer === null && glBaseLayer === null) {
                                return undefined
                            }
                            return foveation
                        };
                        this.setFoveation = function(value) {
                            foveation = value;
                            if (glProjLayer !== null) {
                                glProjLayer.fixedFoveation = value
                            }
                            if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== undefined) {
                                glBaseLayer.fixedFoveation = value
                            }
                        };
                        this.hasDepthSensing = function() {
                            return depthSensing.texture !== null
                        };
                        this.getDepthSensingMesh = function() {
                            return depthSensing.getMesh(cameraXR)
                        };
                        let onAnimationFrameCallback = null;

                        function onAnimationFrame(time, frame) {
                            pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
                            xrFrame = frame;
                            if (pose !== null) {
                                const views = pose.views;
                                if (glBaseLayer !== null) {
                                    renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
                                    renderer.setRenderTarget(newRenderTarget)
                                }
                                let cameraXRNeedsUpdate = !1;
                                if (views.length !== cameraXR.cameras.length) {
                                    cameraXR.cameras.length = 0;
                                    cameraXRNeedsUpdate = !0
                                }
                                for (let i = 0; i < views.length; i++) {
                                    const view = views[i];
                                    let viewport = null;
                                    if (glBaseLayer !== null) {
                                        viewport = glBaseLayer.getViewport(view)
                                    } else {
                                        const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
                                        viewport = glSubImage.viewport;
                                        if (i === 0) {
                                            renderer.setRenderTargetTextures(newRenderTarget, glSubImage.colorTexture, glProjLayer.ignoreDepthValues ? undefined : glSubImage.depthStencilTexture);
                                            renderer.setRenderTarget(newRenderTarget)
                                        }
                                    }
                                    let camera = cameras[i];
                                    if (camera === undefined) {
                                        camera = new PerspectiveCamera();
                                        camera.layers.enable(i);
                                        camera.viewport = new Vector4();
                                        cameras[i] = camera
                                    }
                                    camera.matrix.fromArray(view.transform.matrix);
                                    camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
                                    camera.projectionMatrix.fromArray(view.projectionMatrix);
                                    camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
                                    camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
                                    if (i === 0) {
                                        cameraXR.matrix.copy(camera.matrix);
                                        cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale)
                                    }
                                    if (cameraXRNeedsUpdate === !0) {
                                        cameraXR.cameras.push(camera)
                                    }
                                }
                                const enabledFeatures = session.enabledFeatures;
                                if (enabledFeatures && enabledFeatures.includes('depth-sensing')) {
                                    const depthData = glBinding.getDepthInformation(views[0]);
                                    if (depthData && depthData.isValid && depthData.texture) {
                                        depthSensing.init(renderer, depthData, session.renderState)
                                    }
                                }
                            }
                            for (let i = 0; i < controllers.length; i++) {
                                const inputSource = controllerInputSources[i];
                                const controller = controllers[i];
                                if (inputSource !== null && controller !== undefined) {
                                    controller.update(inputSource, frame, customReferenceSpace || referenceSpace)
                                }
                            }
                            if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
                            if (frame.detectedPlanes) {
                                scope.dispatchEvent({
                                    type: 'planesdetected',
                                    data: frame
                                })
                            }
                            xrFrame = null
                        }
                        const animation = new WebGLAnimation();
                        animation.setAnimationLoop(onAnimationFrame);
                        this.setAnimationLoop = function(callback) {
                            onAnimationFrameCallback = callback
                        };
                        this.dispose = function() {}
                    }
                }
                const _e1 = new Euler();
                const _m1 = new Matrix4();

                function WebGLMaterials(renderer, properties) {
                    function refreshTransformUniform(map, uniform) {
                        if (map.matrixAutoUpdate === !0) {
                            map.updateMatrix()
                        }
                        uniform.value.copy(map.matrix)
                    }

                    function refreshFogUniforms(uniforms, fog) {
                        fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
                        if (fog.isFog) {
                            uniforms.fogNear.value = fog.near;
                            uniforms.fogFar.value = fog.far
                        } else if (fog.isFogExp2) {
                            uniforms.fogDensity.value = fog.density
                        }
                    }

                    function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
                        if (material.isMeshBasicMaterial) {
                            refreshUniformsCommon(uniforms, material)
                        } else if (material.isMeshLambertMaterial) {
                            refreshUniformsCommon(uniforms, material)
                        } else if (material.isMeshToonMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsToon(uniforms, material)
                        } else if (material.isMeshPhongMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsPhong(uniforms, material)
                        } else if (material.isMeshStandardMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsStandard(uniforms, material);
                            if (material.isMeshPhysicalMaterial) {
                                refreshUniformsPhysical(uniforms, material, transmissionRenderTarget)
                            }
                        } else if (material.isMeshMatcapMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsMatcap(uniforms, material)
                        } else if (material.isMeshDepthMaterial) {
                            refreshUniformsCommon(uniforms, material)
                        } else if (material.isMeshDistanceMaterial) {
                            refreshUniformsCommon(uniforms, material);
                            refreshUniformsDistance(uniforms, material)
                        } else if (material.isMeshNormalMaterial) {
                            refreshUniformsCommon(uniforms, material)
                        } else if (material.isLineBasicMaterial) {
                            refreshUniformsLine(uniforms, material);
                            if (material.isLineDashedMaterial) {
                                refreshUniformsDash(uniforms, material)
                            }
                        } else if (material.isPointsMaterial) {
                            refreshUniformsPoints(uniforms, material, pixelRatio, height)
                        } else if (material.isSpriteMaterial) {
                            refreshUniformsSprites(uniforms, material)
                        } else if (material.isShadowMaterial) {
                            uniforms.color.value.copy(material.color);
                            uniforms.opacity.value = material.opacity
                        } else if (material.isShaderMaterial) {
                            material.uniformsNeedUpdate = !1
                        }
                    }

                    function refreshUniformsCommon(uniforms, material) {
                        uniforms.opacity.value = material.opacity;
                        if (material.color) {
                            uniforms.diffuse.value.copy(material.color)
                        }
                        if (material.emissive) {
                            uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity)
                        }
                        if (material.map) {
                            uniforms.map.value = material.map;
                            refreshTransformUniform(material.map, uniforms.mapTransform)
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                            refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)
                        }
                        if (material.bumpMap) {
                            uniforms.bumpMap.value = material.bumpMap;
                            refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
                            uniforms.bumpScale.value = material.bumpScale;
                            if (material.side === BackSide) {
                                uniforms.bumpScale.value *= -1
                            }
                        }
                        if (material.normalMap) {
                            uniforms.normalMap.value = material.normalMap;
                            refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
                            uniforms.normalScale.value.copy(material.normalScale);
                            if (material.side === BackSide) {
                                uniforms.normalScale.value.negate()
                            }
                        }
                        if (material.displacementMap) {
                            uniforms.displacementMap.value = material.displacementMap;
                            refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
                            uniforms.displacementScale.value = material.displacementScale;
                            uniforms.displacementBias.value = material.displacementBias
                        }
                        if (material.emissiveMap) {
                            uniforms.emissiveMap.value = material.emissiveMap;
                            refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform)
                        }
                        if (material.specularMap) {
                            uniforms.specularMap.value = material.specularMap;
                            refreshTransformUniform(material.specularMap, uniforms.specularMapTransform)
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest
                        }
                        const materialProperties = properties.get(material);
                        const envMap = materialProperties.envMap;
                        const envMapRotation = materialProperties.envMapRotation;
                        if (envMap) {
                            uniforms.envMap.value = envMap;
                            _e1.copy(envMapRotation);
                            _e1.x *= -1;
                            _e1.y *= -1;
                            _e1.z *= -1;
                            if (envMap.isCubeTexture && envMap.isRenderTargetTexture === !1) {
                                _e1.y *= -1;
                                _e1.z *= -1
                            }
                            uniforms.envMapRotation.value.setFromMatrix4(_m1.makeRotationFromEuler(_e1));
                            uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === !1) ? -1 : 1;
                            uniforms.reflectivity.value = material.reflectivity;
                            uniforms.ior.value = material.ior;
                            uniforms.refractionRatio.value = material.refractionRatio
                        }
                        if (material.lightMap) {
                            uniforms.lightMap.value = material.lightMap;
                            uniforms.lightMapIntensity.value = material.lightMapIntensity;
                            refreshTransformUniform(material.lightMap, uniforms.lightMapTransform)
                        }
                        if (material.aoMap) {
                            uniforms.aoMap.value = material.aoMap;
                            uniforms.aoMapIntensity.value = material.aoMapIntensity;
                            refreshTransformUniform(material.aoMap, uniforms.aoMapTransform)
                        }
                    }

                    function refreshUniformsLine(uniforms, material) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                        if (material.map) {
                            uniforms.map.value = material.map;
                            refreshTransformUniform(material.map, uniforms.mapTransform)
                        }
                    }

                    function refreshUniformsDash(uniforms, material) {
                        uniforms.dashSize.value = material.dashSize;
                        uniforms.totalSize.value = material.dashSize + material.gapSize;
                        uniforms.scale.value = material.scale
                    }

                    function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                        uniforms.size.value = material.size * pixelRatio;
                        uniforms.scale.value = height * 0.5;
                        if (material.map) {
                            uniforms.map.value = material.map;
                            refreshTransformUniform(material.map, uniforms.uvTransform)
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                            refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest
                        }
                    }

                    function refreshUniformsSprites(uniforms, material) {
                        uniforms.diffuse.value.copy(material.color);
                        uniforms.opacity.value = material.opacity;
                        uniforms.rotation.value = material.rotation;
                        if (material.map) {
                            uniforms.map.value = material.map;
                            refreshTransformUniform(material.map, uniforms.mapTransform)
                        }
                        if (material.alphaMap) {
                            uniforms.alphaMap.value = material.alphaMap;
                            refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform)
                        }
                        if (material.alphaTest > 0) {
                            uniforms.alphaTest.value = material.alphaTest
                        }
                    }

                    function refreshUniformsPhong(uniforms, material) {
                        uniforms.specular.value.copy(material.specular);
                        uniforms.shininess.value = Math.max(material.shininess, 1e-4)
                    }

                    function refreshUniformsToon(uniforms, material) {
                        if (material.gradientMap) {
                            uniforms.gradientMap.value = material.gradientMap
                        }
                    }

                    function refreshUniformsStandard(uniforms, material) {
                        uniforms.metalness.value = material.metalness;
                        if (material.metalnessMap) {
                            uniforms.metalnessMap.value = material.metalnessMap;
                            refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform)
                        }
                        uniforms.roughness.value = material.roughness;
                        if (material.roughnessMap) {
                            uniforms.roughnessMap.value = material.roughnessMap;
                            refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform)
                        }
                        if (material.envMap) {
                            uniforms.envMapIntensity.value = material.envMapIntensity
                        }
                    }

                    function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
                        uniforms.ior.value = material.ior;
                        if (material.sheen > 0) {
                            uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
                            uniforms.sheenRoughness.value = material.sheenRoughness;
                            if (material.sheenColorMap) {
                                uniforms.sheenColorMap.value = material.sheenColorMap;
                                refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform)
                            }
                            if (material.sheenRoughnessMap) {
                                uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
                                refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform)
                            }
                        }
                        if (material.clearcoat > 0) {
                            uniforms.clearcoat.value = material.clearcoat;
                            uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
                            if (material.clearcoatMap) {
                                uniforms.clearcoatMap.value = material.clearcoatMap;
                                refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform)
                            }
                            if (material.clearcoatRoughnessMap) {
                                uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
                                refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform)
                            }
                            if (material.clearcoatNormalMap) {
                                uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
                                refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
                                uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
                                if (material.side === BackSide) {
                                    uniforms.clearcoatNormalScale.value.negate()
                                }
                            }
                        }
                        if (material.dispersion > 0) {
                            uniforms.dispersion.value = material.dispersion
                        }
                        if (material.iridescence > 0) {
                            uniforms.iridescence.value = material.iridescence;
                            uniforms.iridescenceIOR.value = material.iridescenceIOR;
                            uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
                            uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
                            if (material.iridescenceMap) {
                                uniforms.iridescenceMap.value = material.iridescenceMap;
                                refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform)
                            }
                            if (material.iridescenceThicknessMap) {
                                uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
                                refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform)
                            }
                        }
                        if (material.transmission > 0) {
                            uniforms.transmission.value = material.transmission;
                            uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
                            uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
                            if (material.transmissionMap) {
                                uniforms.transmissionMap.value = material.transmissionMap;
                                refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform)
                            }
                            uniforms.thickness.value = material.thickness;
                            if (material.thicknessMap) {
                                uniforms.thicknessMap.value = material.thicknessMap;
                                refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform)
                            }
                            uniforms.attenuationDistance.value = material.attenuationDistance;
                            uniforms.attenuationColor.value.copy(material.attenuationColor)
                        }
                        if (material.anisotropy > 0) {
                            uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
                            if (material.anisotropyMap) {
                                uniforms.anisotropyMap.value = material.anisotropyMap;
                                refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform)
                            }
                        }
                        uniforms.specularIntensity.value = material.specularIntensity;
                        uniforms.specularColor.value.copy(material.specularColor);
                        if (material.specularColorMap) {
                            uniforms.specularColorMap.value = material.specularColorMap;
                            refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform)
                        }
                        if (material.specularIntensityMap) {
                            uniforms.specularIntensityMap.value = material.specularIntensityMap;
                            refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform)
                        }
                    }

                    function refreshUniformsMatcap(uniforms, material) {
                        if (material.matcap) {
                            uniforms.matcap.value = material.matcap
                        }
                    }

                    function refreshUniformsDistance(uniforms, material) {
                        const light = properties.get(material).light;
                        uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
                        uniforms.nearDistance.value = light.shadow.camera.near;
                        uniforms.farDistance.value = light.shadow.camera.far
                    }
                    return {
                        refreshFogUniforms: refreshFogUniforms,
                        refreshMaterialUniforms: refreshMaterialUniforms
                    }
                }

                function WebGLUniformsGroups(gl, info, capabilities, state) {
                    let buffers = {};
                    let updateList = {};
                    let allocatedBindingPoints = [];
                    const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);

                    function bind(uniformsGroup, program) {
                        const webglProgram = program.program;
                        state.uniformBlockBinding(uniformsGroup, webglProgram)
                    }

                    function update(uniformsGroup, program) {
                        let buffer = buffers[uniformsGroup.id];
                        if (buffer === undefined) {
                            prepareUniformsGroup(uniformsGroup);
                            buffer = createBuffer(uniformsGroup);
                            buffers[uniformsGroup.id] = buffer;
                            uniformsGroup.addEventListener('dispose', onUniformsGroupsDispose)
                        }
                        const webglProgram = program.program;
                        state.updateUBOMapping(uniformsGroup, webglProgram);
                        const frame = info.render.frame;
                        if (updateList[uniformsGroup.id] !== frame) {
                            updateBufferData(uniformsGroup);
                            updateList[uniformsGroup.id] = frame
                        }
                    }

                    function createBuffer(uniformsGroup) {
                        const bindingPointIndex = allocateBindingPointIndex();
                        uniformsGroup.__bindingPointIndex = bindingPointIndex;
                        const buffer = gl.createBuffer();
                        const size = uniformsGroup.__size;
                        const usage = uniformsGroup.usage;
                        gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
                        gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
                        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                        gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
                        return buffer
                    }

                    function allocateBindingPointIndex() {
                        for (let i = 0; i < maxBindingPoints; i++) {
                            if (allocatedBindingPoints.indexOf(i) === -1) {
                                allocatedBindingPoints.push(i);
                                return i
                            }
                        }
                        console.error('THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.');
                        return 0
                    }

                    function updateBufferData(uniformsGroup) {
                        const buffer = buffers[uniformsGroup.id];
                        const uniforms = uniformsGroup.uniforms;
                        const cache = uniformsGroup.__cache;
                        gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
                        for (let i = 0, il = uniforms.length; i < il; i++) {
                            const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
                            for (let j = 0, jl = uniformArray.length; j < jl; j++) {
                                const uniform = uniformArray[j];
                                if (hasUniformChanged(uniform, i, j, cache) === !0) {
                                    const offset = uniform.__offset;
                                    const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
                                    let arrayOffset = 0;
                                    for (let k = 0; k < values.length; k++) {
                                        const value = values[k];
                                        const info = getUniformSize(value);
                                        if (typeof value === 'number' || typeof value === 'boolean') {
                                            uniform.__data[0] = value;
                                            gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data)
                                        } else if (value.isMatrix3) {
                                            uniform.__data[0] = value.elements[0];
                                            uniform.__data[1] = value.elements[1];
                                            uniform.__data[2] = value.elements[2];
                                            uniform.__data[3] = 0;
                                            uniform.__data[4] = value.elements[3];
                                            uniform.__data[5] = value.elements[4];
                                            uniform.__data[6] = value.elements[5];
                                            uniform.__data[7] = 0;
                                            uniform.__data[8] = value.elements[6];
                                            uniform.__data[9] = value.elements[7];
                                            uniform.__data[10] = value.elements[8];
                                            uniform.__data[11] = 0
                                        } else {
                                            value.toArray(uniform.__data, arrayOffset);
                                            arrayOffset += info.storage / Float32Array.BYTES_PER_ELEMENT
                                        }
                                    }
                                    gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data)
                                }
                            }
                        }
                        gl.bindBuffer(gl.UNIFORM_BUFFER, null)
                    }

                    function hasUniformChanged(uniform, index, indexArray, cache) {
                        const value = uniform.value;
                        const indexString = index + '_' + indexArray;
                        if (cache[indexString] === undefined) {
                            if (typeof value === 'number' || typeof value === 'boolean') {
                                cache[indexString] = value
                            } else {
                                cache[indexString] = value.clone()
                            }
                            return !0
                        } else {
                            const cachedObject = cache[indexString];
                            if (typeof value === 'number' || typeof value === 'boolean') {
                                if (cachedObject !== value) {
                                    cache[indexString] = value;
                                    return !0
                                }
                            } else {
                                if (cachedObject.equals(value) === !1) {
                                    cachedObject.copy(value);
                                    return !0
                                }
                            }
                        }
                        return !1
                    }

                    function prepareUniformsGroup(uniformsGroup) {
                        const uniforms = uniformsGroup.uniforms;
                        let offset = 0;
                        const chunkSize = 16;
                        for (let i = 0, l = uniforms.length; i < l; i++) {
                            const uniformArray = Array.isArray(uniforms[i]) ? uniforms[i] : [uniforms[i]];
                            for (let j = 0, jl = uniformArray.length; j < jl; j++) {
                                const uniform = uniformArray[j];
                                const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
                                for (let k = 0, kl = values.length; k < kl; k++) {
                                    const value = values[k];
                                    const info = getUniformSize(value);
                                    const chunkOffset = offset % chunkSize;
                                    const chunkPadding = chunkOffset % info.boundary;
                                    const chunkStart = chunkOffset + chunkPadding;
                                    offset += chunkPadding;
                                    if (chunkStart !== 0 && (chunkSize - chunkStart) < info.storage) {
                                        offset += (chunkSize - chunkStart)
                                    }
                                    uniform.__data = new Float32Array(info.storage / Float32Array.BYTES_PER_ELEMENT);
                                    uniform.__offset = offset;
                                    offset += info.storage
                                }
                            }
                        }
                        const chunkOffset = offset % chunkSize;
                        if (chunkOffset > 0) offset += (chunkSize - chunkOffset);
                        uniformsGroup.__size = offset;
                        uniformsGroup.__cache = {};
                        return this
                    }

                    function getUniformSize(value) {
                        const info = {
                            boundary: 0,
                            storage: 0
                        };
                        if (typeof value === 'number' || typeof value === 'boolean') {
                            info.boundary = 4;
                            info.storage = 4
                        } else if (value.isVector2) {
                            info.boundary = 8;
                            info.storage = 8
                        } else if (value.isVector3 || value.isColor) {
                            info.boundary = 16;
                            info.storage = 12
                        } else if (value.isVector4) {
                            info.boundary = 16;
                            info.storage = 16
                        } else if (value.isMatrix3) {
                            info.boundary = 48;
                            info.storage = 48
                        } else if (value.isMatrix4) {
                            info.boundary = 64;
                            info.storage = 64
                        } else if (value.isTexture) {
                            console.warn('THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.')
                        } else {
                            console.warn('THREE.WebGLRenderer: Unsupported uniform value type.', value)
                        }
                        return info
                    }

                    function onUniformsGroupsDispose(event) {
                        const uniformsGroup = event.target;
                        uniformsGroup.removeEventListener('dispose', onUniformsGroupsDispose);
                        const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
                        allocatedBindingPoints.splice(index, 1);
                        gl.deleteBuffer(buffers[uniformsGroup.id]);
                        delete buffers[uniformsGroup.id];
                        delete updateList[uniformsGroup.id]
                    }

                    function dispose() {
                        for (const id in buffers) {
                            gl.deleteBuffer(buffers[id])
                        }
                        allocatedBindingPoints = [];
                        buffers = {};
                        updateList = {}
                    }
                    return {
                        bind: bind,
                        update: update,
                        dispose: dispose
                    }
                }
                class WebGLRenderer {
                    constructor(parameters = {}) {
                        const {
                            canvas = createCanvasElement(), context = null, depth = !0, stencil = !1, alpha = !1, antialias = !1, premultipliedAlpha = !0, preserveDrawingBuffer = !1, powerPreference = 'default', failIfMajorPerformanceCaveat = !1,
                        } = parameters;
                        this.isWebGLRenderer = !0;
                        let _alpha;
                        if (context !== null) {
                            if (typeof WebGLRenderingContext !== 'undefined' && context instanceof WebGLRenderingContext) {
                                throw new Error('THREE.WebGLRenderer: WebGL 1 is not supported since r163.')
                            }
                            _alpha = context.getContextAttributes().alpha
                        } else {
                            _alpha = alpha
                        }
                        const uintClearColor = new Uint32Array(4);
                        const intClearColor = new Int32Array(4);
                        let currentRenderList = null;
                        let currentRenderState = null;
                        const renderListStack = [];
                        const renderStateStack = [];
                        this.domElement = canvas;
                        this.debug = {
                            checkShaderErrors: !0,
                            onShaderError: null
                        };
                        this.autoClear = !0;
                        this.autoClearColor = !0;
                        this.autoClearDepth = !0;
                        this.autoClearStencil = !0;
                        this.sortObjects = !0;
                        this.clippingPlanes = [];
                        this.localClippingEnabled = !1;
                        this._outputColorSpace = SRGBColorSpace;
                        this.toneMapping = NoToneMapping;
                        this.toneMappingExposure = 1.0;
                        const _this = this;
                        let _isContextLost = !1;
                        let _currentActiveCubeFace = 0;
                        let _currentActiveMipmapLevel = 0;
                        let _currentRenderTarget = null;
                        let _currentMaterialId = -1;
                        let _currentCamera = null;
                        const _currentViewport = new Vector4();
                        const _currentScissor = new Vector4();
                        let _currentScissorTest = null;
                        const _currentClearColor = new Color(0x000000);
                        let _currentClearAlpha = 0;
                        let _width = canvas.width;
                        let _height = canvas.height;
                        let _pixelRatio = 1;
                        let _opaqueSort = null;
                        let _transparentSort = null;
                        const _viewport = new Vector4(0, 0, _width, _height);
                        const _scissor = new Vector4(0, 0, _width, _height);
                        let _scissorTest = !1;
                        const _frustum = new Frustum();
                        let _clippingEnabled = !1;
                        let _localClippingEnabled = !1;
                        const _projScreenMatrix = new Matrix4();
                        const _vector3 = new Vector3();
                        const _vector4 = new Vector4();
                        const _emptyScene = {
                            background: null,
                            fog: null,
                            environment: null,
                            overrideMaterial: null,
                            isScene: !0
                        };
                        let _renderBackground = !1;

                        function getTargetPixelRatio() {
                            return _currentRenderTarget === null ? _pixelRatio : 1
                        }
                        let _gl = context;

                        function getContext(contextName, contextAttributes) {
                            return canvas.getContext(contextName, contextAttributes)
                        }
                        try {
                            const contextAttributes = {
                                alpha: !0,
                                depth,
                                stencil,
                                antialias,
                                premultipliedAlpha,
                                preserveDrawingBuffer,
                                powerPreference,
                                failIfMajorPerformanceCaveat,
                            };
                            if ('setAttribute' in canvas) canvas.setAttribute('data-engine', `three.js r${REVISION}`);
                            canvas.addEventListener('webglcontextlost', onContextLost, !1);
                            canvas.addEventListener('webglcontextrestored', onContextRestore, !1);
                            canvas.addEventListener('webglcontextcreationerror', onContextCreationError, !1);
                            if (_gl === null) {
                                const contextName = 'webgl2';
                                _gl = getContext(contextName, contextAttributes);
                                if (_gl === null) {
                                    if (getContext(contextName)) {
                                        throw new Error('Error creating WebGL context with your selected attributes.')
                                    } else {
                                        throw new Error('Error creating WebGL context.')
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('THREE.WebGLRenderer: ' + error.message);
                            throw error
                        }
                        let extensions, capabilities, state, info;
                        let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
                        let programCache, materials, renderLists, renderStates, clipping, shadowMap;
                        let background, morphtargets, bufferRenderer, indexedBufferRenderer;
                        let utils, bindingStates, uniformsGroups;

                        function initGLContext() {
                            extensions = new WebGLExtensions(_gl);
                            extensions.init();
                            utils = new WebGLUtils(_gl, extensions);
                            capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
                            state = new WebGLState(_gl);
                            info = new WebGLInfo(_gl);
                            properties = new WebGLProperties();
                            textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
                            cubemaps = new WebGLCubeMaps(_this);
                            cubeuvmaps = new WebGLCubeUVMaps(_this);
                            attributes = new WebGLAttributes(_gl);
                            bindingStates = new WebGLBindingStates(_gl, attributes);
                            geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
                            objects = new WebGLObjects(_gl, geometries, attributes, info);
                            morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
                            clipping = new WebGLClipping(properties);
                            programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
                            materials = new WebGLMaterials(_this, properties);
                            renderLists = new WebGLRenderLists();
                            renderStates = new WebGLRenderStates(extensions);
                            background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
                            shadowMap = new WebGLShadowMap(_this, objects, capabilities);
                            uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
                            bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
                            indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
                            info.programs = programCache.programs;
                            _this.capabilities = capabilities;
                            _this.extensions = extensions;
                            _this.properties = properties;
                            _this.renderLists = renderLists;
                            _this.shadowMap = shadowMap;
                            _this.state = state;
                            _this.info = info
                        }
                        initGLContext();
                        const xr = new WebXRManager(_this, _gl);
                        this.xr = xr;
                        this.getContext = function() {
                            return _gl
                        };
                        this.getContextAttributes = function() {
                            return _gl.getContextAttributes()
                        };
                        this.forceContextLoss = function() {
                            const extension = extensions.get('WEBGL_lose_context');
                            if (extension) extension.loseContext()
                        };
                        this.forceContextRestore = function() {
                            const extension = extensions.get('WEBGL_lose_context');
                            if (extension) extension.restoreContext()
                        };
                        this.getPixelRatio = function() {
                            return _pixelRatio
                        };
                        this.setPixelRatio = function(value) {
                            if (value === undefined) return;
                            _pixelRatio = value;
                            this.setSize(_width, _height, !1)
                        };
                        this.getSize = function(target) {
                            return target.set(_width, _height)
                        };
                        this.setSize = function(width, height, updateStyle = !0) {
                            if (xr.isPresenting) {
                                console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');
                                return
                            }
                            _width = width;
                            _height = height;
                            canvas.width = Math.floor(width * _pixelRatio);
                            canvas.height = Math.floor(height * _pixelRatio);
                            if (updateStyle === !0) {
                                canvas.style.width = width + 'px';
                                canvas.style.height = height + 'px'
                            }
                            this.setViewport(0, 0, width, height)
                        };
                        this.getDrawingBufferSize = function(target) {
                            return target.set(_width * _pixelRatio, _height * _pixelRatio).floor()
                        };
                        this.setDrawingBufferSize = function(width, height, pixelRatio) {
                            _width = width;
                            _height = height;
                            _pixelRatio = pixelRatio;
                            canvas.width = Math.floor(width * pixelRatio);
                            canvas.height = Math.floor(height * pixelRatio);
                            this.setViewport(0, 0, width, height)
                        };
                        this.getCurrentViewport = function(target) {
                            return target.copy(_currentViewport)
                        };
                        this.getViewport = function(target) {
                            return target.copy(_viewport)
                        };
                        this.setViewport = function(x, y, width, height) {
                            if (x.isVector4) {
                                _viewport.set(x.x, x.y, x.z, x.w)
                            } else {
                                _viewport.set(x, y, width, height)
                            }
                            state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round())
                        };
                        this.getScissor = function(target) {
                            return target.copy(_scissor)
                        };
                        this.setScissor = function(x, y, width, height) {
                            if (x.isVector4) {
                                _scissor.set(x.x, x.y, x.z, x.w)
                            } else {
                                _scissor.set(x, y, width, height)
                            }
                            state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round())
                        };
                        this.getScissorTest = function() {
                            return _scissorTest
                        };
                        this.setScissorTest = function(boolean) {
                            state.setScissorTest(_scissorTest = boolean)
                        };
                        this.setOpaqueSort = function(method) {
                            _opaqueSort = method
                        };
                        this.setTransparentSort = function(method) {
                            _transparentSort = method
                        };
                        this.getClearColor = function(target) {
                            return target.copy(background.getClearColor())
                        };
                        this.setClearColor = function() {
                            background.setClearColor.apply(background, arguments)
                        };
                        this.getClearAlpha = function() {
                            return background.getClearAlpha()
                        };
                        this.setClearAlpha = function() {
                            background.setClearAlpha.apply(background, arguments)
                        };
                        this.clear = function(color = !0, depth = !0, stencil = !0) {
                            let bits = 0;
                            if (color) {
                                let isIntegerFormat = !1;
                                if (_currentRenderTarget !== null) {
                                    const targetFormat = _currentRenderTarget.texture.format;
                                    isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat
                                }
                                if (isIntegerFormat) {
                                    const targetType = _currentRenderTarget.texture.type;
                                    const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
                                    const clearColor = background.getClearColor();
                                    const a = background.getClearAlpha();
                                    const r = clearColor.r;
                                    const g = clearColor.g;
                                    const b = clearColor.b;
                                    if (isUnsignedType) {
                                        uintClearColor[0] = r;
                                        uintClearColor[1] = g;
                                        uintClearColor[2] = b;
                                        uintClearColor[3] = a;
                                        _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor)
                                    } else {
                                        intClearColor[0] = r;
                                        intClearColor[1] = g;
                                        intClearColor[2] = b;
                                        intClearColor[3] = a;
                                        _gl.clearBufferiv(_gl.COLOR, 0, intClearColor)
                                    }
                                } else {
                                    bits |= _gl.COLOR_BUFFER_BIT
                                }
                            }
                            if (depth) bits |= _gl.DEPTH_BUFFER_BIT;
                            if (stencil) {
                                bits |= _gl.STENCIL_BUFFER_BIT;
                                this.state.buffers.stencil.setMask(0xffffffff)
                            }
                            _gl.clear(bits)
                        };
                        this.clearColor = function() {
                            this.clear(!0, !1, !1)
                        };
                        this.clearDepth = function() {
                            this.clear(!1, !0, !1)
                        };
                        this.clearStencil = function() {
                            this.clear(!1, !1, !0)
                        };
                        this.dispose = function() {
                            canvas.removeEventListener('webglcontextlost', onContextLost, !1);
                            canvas.removeEventListener('webglcontextrestored', onContextRestore, !1);
                            canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, !1);
                            renderLists.dispose();
                            renderStates.dispose();
                            properties.dispose();
                            cubemaps.dispose();
                            cubeuvmaps.dispose();
                            objects.dispose();
                            bindingStates.dispose();
                            uniformsGroups.dispose();
                            programCache.dispose();
                            xr.dispose();
                            xr.removeEventListener('sessionstart', onXRSessionStart);
                            xr.removeEventListener('sessionend', onXRSessionEnd);
                            animation.stop()
                        };

                        function onContextLost(event) {
                            event.preventDefault();
                            console.log('THREE.WebGLRenderer: Context Lost.');
                            _isContextLost = !0
                        }

                        function onContextRestore() {
                            console.log('THREE.WebGLRenderer: Context Restored.');
                            _isContextLost = !1;
                            const infoAutoReset = info.autoReset;
                            const shadowMapEnabled = shadowMap.enabled;
                            const shadowMapAutoUpdate = shadowMap.autoUpdate;
                            const shadowMapNeedsUpdate = shadowMap.needsUpdate;
                            const shadowMapType = shadowMap.type;
                            initGLContext();
                            info.autoReset = infoAutoReset;
                            shadowMap.enabled = shadowMapEnabled;
                            shadowMap.autoUpdate = shadowMapAutoUpdate;
                            shadowMap.needsUpdate = shadowMapNeedsUpdate;
                            shadowMap.type = shadowMapType
                        }

                        function onContextCreationError(event) {
                            console.error('THREE.WebGLRenderer: A WebGL context could not be created. Reason: ', event.statusMessage)
                        }

                        function onMaterialDispose(event) {
                            const material = event.target;
                            material.removeEventListener('dispose', onMaterialDispose);
                            deallocateMaterial(material)
                        }

                        function deallocateMaterial(material) {
                            releaseMaterialProgramReferences(material);
                            properties.remove(material)
                        }

                        function releaseMaterialProgramReferences(material) {
                            const programs = properties.get(material).programs;
                            if (programs !== undefined) {
                                programs.forEach(function(program) {
                                    programCache.releaseProgram(program)
                                });
                                if (material.isShaderMaterial) {
                                    programCache.releaseShaderCache(material)
                                }
                            }
                        }
                        this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
                            if (scene === null) scene = _emptyScene;
                            const frontFaceCW = (object.isMesh && object.matrixWorld.determinant() < 0);
                            const program = setProgram(camera, scene, geometry, material, object);
                            state.setMaterial(material, frontFaceCW);
                            let index = geometry.index;
                            let rangeFactor = 1;
                            if (material.wireframe === !0) {
                                index = geometries.getWireframeAttribute(geometry);
                                if (index === undefined) return;
                                rangeFactor = 2
                            }
                            const drawRange = geometry.drawRange;
                            const position = geometry.attributes.position;
                            let drawStart = drawRange.start * rangeFactor;
                            let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
                            if (group !== null) {
                                drawStart = Math.max(drawStart, group.start * rangeFactor);
                                drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor)
                            }
                            if (index !== null) {
                                drawStart = Math.max(drawStart, 0);
                                drawEnd = Math.min(drawEnd, index.count)
                            } else if (position !== undefined && position !== null) {
                                drawStart = Math.max(drawStart, 0);
                                drawEnd = Math.min(drawEnd, position.count)
                            }
                            const drawCount = drawEnd - drawStart;
                            if (drawCount < 0 || drawCount === Infinity) return;
                            bindingStates.setup(object, material, program, geometry, index);
                            let attribute;
                            let renderer = bufferRenderer;
                            if (index !== null) {
                                attribute = attributes.get(index);
                                renderer = indexedBufferRenderer;
                                renderer.setIndex(attribute)
                            }
                            if (object.isMesh) {
                                if (material.wireframe === !0) {
                                    state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
                                    renderer.setMode(_gl.LINES)
                                } else {
                                    renderer.setMode(_gl.TRIANGLES)
                                }
                            } else if (object.isLine) {
                                let lineWidth = material.linewidth;
                                if (lineWidth === undefined) lineWidth = 1;
                                state.setLineWidth(lineWidth * getTargetPixelRatio());
                                if (object.isLineSegments) {
                                    renderer.setMode(_gl.LINES)
                                } else if (object.isLineLoop) {
                                    renderer.setMode(_gl.LINE_LOOP)
                                } else {
                                    renderer.setMode(_gl.LINE_STRIP)
                                }
                            } else if (object.isPoints) {
                                renderer.setMode(_gl.POINTS)
                            } else if (object.isSprite) {
                                renderer.setMode(_gl.TRIANGLES)
                            }
                            if (object.isBatchedMesh) {
                                if (object._multiDrawInstances !== null) {
                                    renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances)
                                } else {
                                    if (!extensions.get('WEBGL_multi_draw')) {
                                        const starts = object._multiDrawStarts;
                                        const counts = object._multiDrawCounts;
                                        const drawCount = object._multiDrawCount;
                                        const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
                                        const uniforms = properties.get(material).currentProgram.getUniforms();
                                        for (let i = 0; i < drawCount; i++) {
                                            uniforms.setValue(_gl, '_gl_DrawID', i);
                                            renderer.render(starts[i] / bytesPerElement, counts[i])
                                        }
                                    } else {
                                        renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount)
                                    }
                                }
                            } else if (object.isInstancedMesh) {
                                renderer.renderInstances(drawStart, drawCount, object.count)
                            } else if (geometry.isInstancedBufferGeometry) {
                                const maxInstanceCount = geometry._maxInstanceCount !== undefined ? geometry._maxInstanceCount : Infinity;
                                const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
                                renderer.renderInstances(drawStart, drawCount, instanceCount)
                            } else {
                                renderer.render(drawStart, drawCount)
                            }
                        };

                        function prepareMaterial(material, scene, object) {
                            if (material.transparent === !0 && material.side === DoubleSide && material.forceSinglePass === !1) {
                                material.side = BackSide;
                                material.needsUpdate = !0;
                                getProgram(material, scene, object);
                                material.side = FrontSide;
                                material.needsUpdate = !0;
                                getProgram(material, scene, object);
                                material.side = DoubleSide
                            } else {
                                getProgram(material, scene, object)
                            }
                        }
                        this.compile = function(scene, camera, targetScene = null) {
                            if (targetScene === null) targetScene = scene;
                            currentRenderState = renderStates.get(targetScene);
                            currentRenderState.init(camera);
                            renderStateStack.push(currentRenderState);
                            targetScene.traverseVisible(function(object) {
                                if (object.isLight && object.layers.test(camera.layers)) {
                                    currentRenderState.pushLight(object);
                                    if (object.castShadow) {
                                        currentRenderState.pushShadow(object)
                                    }
                                }
                            });
                            if (scene !== targetScene) {
                                scene.traverseVisible(function(object) {
                                    if (object.isLight && object.layers.test(camera.layers)) {
                                        currentRenderState.pushLight(object);
                                        if (object.castShadow) {
                                            currentRenderState.pushShadow(object)
                                        }
                                    }
                                })
                            }
                            currentRenderState.setupLights();
                            const materials = new Set();
                            scene.traverse(function(object) {
                                const material = object.material;
                                if (material) {
                                    if (Array.isArray(material)) {
                                        for (let i = 0; i < material.length; i++) {
                                            const material2 = material[i];
                                            prepareMaterial(material2, targetScene, object);
                                            materials.add(material2)
                                        }
                                    } else {
                                        prepareMaterial(material, targetScene, object);
                                        materials.add(material)
                                    }
                                }
                            });
                            renderStateStack.pop();
                            currentRenderState = null;
                            return materials
                        };
                        this.compileAsync = function(scene, camera, targetScene = null) {
                            const materials = this.compile(scene, camera, targetScene);
                            return new Promise((resolve) => {
                                function checkMaterialsReady() {
                                    materials.forEach(function(material) {
                                        const materialProperties = properties.get(material);
                                        const program = materialProperties.currentProgram;
                                        if (program.isReady()) {
                                            materials.delete(material)
                                        }
                                    });
                                    if (materials.size === 0) {
                                        resolve(scene);
                                        return
                                    }
                                    setTimeout(checkMaterialsReady, 10)
                                }
                                if (extensions.get('KHR_parallel_shader_compile') !== null) {
                                    checkMaterialsReady()
                                } else {
                                    setTimeout(checkMaterialsReady, 10)
                                }
                            })
                        };
                        let onAnimationFrameCallback = null;

                        function onAnimationFrame(time) {
                            if (onAnimationFrameCallback) onAnimationFrameCallback(time)
                        }

                        function onXRSessionStart() {
                            animation.stop()
                        }

                        function onXRSessionEnd() {
                            animation.start()
                        }
                        const animation = new WebGLAnimation();
                        animation.setAnimationLoop(onAnimationFrame);
                        if (typeof self !== 'undefined') animation.setContext(self);
                        this.setAnimationLoop = function(callback) {
                            onAnimationFrameCallback = callback;
                            xr.setAnimationLoop(callback);
                            (callback === null) ? animation.stop(): animation.start()
                        };
                        xr.addEventListener('sessionstart', onXRSessionStart);
                        xr.addEventListener('sessionend', onXRSessionEnd);
                        this.render = function(scene, camera) {
                            if (camera !== undefined && camera.isCamera !== !0) {
                                console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');
                                return
                            }
                            if (_isContextLost === !0) return;
                            if (scene.matrixWorldAutoUpdate === !0) scene.updateMatrixWorld();
                            if (camera.parent === null && camera.matrixWorldAutoUpdate === !0) camera.updateMatrixWorld();
                            if (xr.enabled === !0 && xr.isPresenting === !0) {
                                if (xr.cameraAutoUpdate === !0) xr.updateCamera(camera);
                                camera = xr.getCamera()
                            }
                            if (scene.isScene === !0) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
                            currentRenderState = renderStates.get(scene, renderStateStack.length);
                            currentRenderState.init(camera);
                            renderStateStack.push(currentRenderState);
                            _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                            _frustum.setFromProjectionMatrix(_projScreenMatrix);
                            _localClippingEnabled = this.localClippingEnabled;
                            _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
                            currentRenderList = renderLists.get(scene, renderListStack.length);
                            currentRenderList.init();
                            renderListStack.push(currentRenderList);
                            if (xr.enabled === !0 && xr.isPresenting === !0) {
                                const depthSensingMesh = _this.xr.getDepthSensingMesh();
                                if (depthSensingMesh !== null) {
                                    projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects)
                                }
                            }
                            projectObject(scene, camera, 0, _this.sortObjects);
                            currentRenderList.finish();
                            if (_this.sortObjects === !0) {
                                currentRenderList.sort(_opaqueSort, _transparentSort)
                            }
                            _renderBackground = xr.enabled === !1 || xr.isPresenting === !1 || xr.hasDepthSensing() === !1;
                            if (_renderBackground) {
                                background.addToRenderList(currentRenderList, scene)
                            }
                            this.info.render.frame++;
                            if (_clippingEnabled === !0) clipping.beginShadows();
                            const shadowsArray = currentRenderState.state.shadowsArray;
                            shadowMap.render(shadowsArray, scene, camera);
                            if (_clippingEnabled === !0) clipping.endShadows();
                            if (this.info.autoReset === !0) this.info.reset();
                            const opaqueObjects = currentRenderList.opaque;
                            const transmissiveObjects = currentRenderList.transmissive;
                            currentRenderState.setupLights();
                            if (camera.isArrayCamera) {
                                const cameras = camera.cameras;
                                if (transmissiveObjects.length > 0) {
                                    for (let i = 0, l = cameras.length; i < l; i++) {
                                        const camera2 = cameras[i];
                                        renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2)
                                    }
                                }
                                if (_renderBackground) background.render(scene);
                                for (let i = 0, l = cameras.length; i < l; i++) {
                                    const camera2 = cameras[i];
                                    renderScene(currentRenderList, scene, camera2, camera2.viewport)
                                }
                            } else {
                                if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
                                if (_renderBackground) background.render(scene);
                                renderScene(currentRenderList, scene, camera)
                            }
                            if (_currentRenderTarget !== null) {
                                textures.updateMultisampleRenderTarget(_currentRenderTarget);
                                textures.updateRenderTargetMipmap(_currentRenderTarget)
                            }
                            if (scene.isScene === !0) scene.onAfterRender(_this, scene, camera);
                            bindingStates.resetDefaultState();
                            _currentMaterialId = -1;
                            _currentCamera = null;
                            renderStateStack.pop();
                            if (renderStateStack.length > 0) {
                                currentRenderState = renderStateStack[renderStateStack.length - 1];
                                if (_clippingEnabled === !0) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera)
                            } else {
                                currentRenderState = null
                            }
                            renderListStack.pop();
                            if (renderListStack.length > 0) {
                                currentRenderList = renderListStack[renderListStack.length - 1]
                            } else {
                                currentRenderList = null
                            }
                        };

                        function projectObject(object, camera, groupOrder, sortObjects) {
                            if (object.visible === !1) return;
                            const visible = object.layers.test(camera.layers);
                            if (visible) {
                                if (object.isGroup) {
                                    groupOrder = object.renderOrder
                                } else if (object.isLOD) {
                                    if (object.autoUpdate === !0) object.update(camera)
                                } else if (object.isLight) {
                                    currentRenderState.pushLight(object);
                                    if (object.castShadow) {
                                        currentRenderState.pushShadow(object)
                                    }
                                } else if (object.isSprite) {
                                    if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
                                        if (sortObjects) {
                                            _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix)
                                        }
                                        const geometry = objects.update(object);
                                        const material = object.material;
                                        if (material.visible) {
                                            currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null)
                                        }
                                    }
                                } else if (object.isMesh || object.isLine || object.isPoints) {
                                    if (!object.frustumCulled || _frustum.intersectsObject(object)) {
                                        const geometry = objects.update(object);
                                        const material = object.material;
                                        if (sortObjects) {
                                            if (object.boundingSphere !== undefined) {
                                                if (object.boundingSphere === null) object.computeBoundingSphere();
                                                _vector4.copy(object.boundingSphere.center)
                                            } else {
                                                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                                                _vector4.copy(geometry.boundingSphere.center)
                                            }
                                            _vector4
                                                .applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix)
                                        }
                                        if (Array.isArray(material)) {
                                            const groups = geometry.groups;
                                            for (let i = 0, l = groups.length; i < l; i++) {
                                                const group = groups[i];
                                                const groupMaterial = material[group.materialIndex];
                                                if (groupMaterial && groupMaterial.visible) {
                                                    currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group)
                                                }
                                            }
                                        } else if (material.visible) {
                                            currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null)
                                        }
                                    }
                                }
                            }
                            const children = object.children;
                            for (let i = 0, l = children.length; i < l; i++) {
                                projectObject(children[i], camera, groupOrder, sortObjects)
                            }
                        }

                        function renderScene(currentRenderList, scene, camera, viewport) {
                            const opaqueObjects = currentRenderList.opaque;
                            const transmissiveObjects = currentRenderList.transmissive;
                            const transparentObjects = currentRenderList.transparent;
                            currentRenderState.setupLightsView(camera);
                            if (_clippingEnabled === !0) clipping.setGlobalState(_this.clippingPlanes, camera);
                            if (viewport) state.viewport(_currentViewport.copy(viewport));
                            if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
                            if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
                            if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
                            state.buffers.depth.setTest(!0);
                            state.buffers.depth.setMask(!0);
                            state.buffers.color.setMask(!0);
                            state.setPolygonOffset(!1)
                        }

                        function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
                            const overrideMaterial = scene.isScene === !0 ? scene.overrideMaterial : null;
                            if (overrideMaterial !== null) {
                                return
                            }
                            if (currentRenderState.state.transmissionRenderTarget[camera.id] === undefined) {
                                currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
                                    generateMipmaps: !0,
                                    type: (extensions.has('EXT_color_buffer_half_float') || extensions.has('EXT_color_buffer_float')) ? HalfFloatType : UnsignedByteType,
                                    minFilter: LinearMipmapLinearFilter,
                                    samples: 4,
                                    stencilBuffer: stencil,
                                    resolveDepthBuffer: !1,
                                    resolveStencilBuffer: !1,
                                    colorSpace: ColorManagement.workingColorSpace,
                                })
                            }
                            const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
                            const activeViewport = camera.viewport || _currentViewport;
                            transmissionRenderTarget.setSize(activeViewport.z, activeViewport.w);
                            const currentRenderTarget = _this.getRenderTarget();
                            _this.setRenderTarget(transmissionRenderTarget);
                            _this.getClearColor(_currentClearColor);
                            _currentClearAlpha = _this.getClearAlpha();
                            if (_currentClearAlpha < 1) _this.setClearColor(0xffffff, 0.5);
                            _this.clear();
                            if (_renderBackground) background.render(scene);
                            const currentToneMapping = _this.toneMapping;
                            _this.toneMapping = NoToneMapping;
                            const currentCameraViewport = camera.viewport;
                            if (camera.viewport !== undefined) camera.viewport = undefined;
                            currentRenderState.setupLightsView(camera);
                            if (_clippingEnabled === !0) clipping.setGlobalState(_this.clippingPlanes, camera);
                            renderObjects(opaqueObjects, scene, camera);
                            textures.updateMultisampleRenderTarget(transmissionRenderTarget);
                            textures.updateRenderTargetMipmap(transmissionRenderTarget);
                            if (extensions.has('WEBGL_multisampled_render_to_texture') === !1) {
                                let renderTargetNeedsUpdate = !1;
                                for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
                                    const renderItem = transmissiveObjects[i];
                                    const object = renderItem.object;
                                    const geometry = renderItem.geometry;
                                    const material = renderItem.material;
                                    const group = renderItem.group;
                                    if (material.side === DoubleSide && object.layers.test(camera.layers)) {
                                        const currentSide = material.side;
                                        material.side = BackSide;
                                        material.needsUpdate = !0;
                                        renderObject(object, scene, camera, geometry, material, group);
                                        material.side = currentSide;
                                        material.needsUpdate = !0;
                                        renderTargetNeedsUpdate = !0
                                    }
                                }
                                if (renderTargetNeedsUpdate === !0) {
                                    textures.updateMultisampleRenderTarget(transmissionRenderTarget);
                                    textures.updateRenderTargetMipmap(transmissionRenderTarget)
                                }
                            }
                            _this.setRenderTarget(currentRenderTarget);
                            _this.setClearColor(_currentClearColor, _currentClearAlpha);
                            if (currentCameraViewport !== undefined) camera.viewport = currentCameraViewport;
                            _this.toneMapping = currentToneMapping
                        }

                        function renderObjects(renderList, scene, camera) {
                            const overrideMaterial = scene.isScene === !0 ? scene.overrideMaterial : null;
                            for (let i = 0, l = renderList.length; i < l; i++) {
                                const renderItem = renderList[i];
                                const object = renderItem.object;
                                const geometry = renderItem.geometry;
                                const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
                                const group = renderItem.group;
                                if (object.layers.test(camera.layers)) {
                                    renderObject(object, scene, camera, geometry, material, group)
                                }
                            }
                        }

                        function renderObject(object, scene, camera, geometry, material, group) {
                            object.onBeforeRender(_this, scene, camera, geometry, material, group);
                            object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
                            object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
                            if (material.transparent === !0 && material.side === DoubleSide && material.forceSinglePass === !1) {
                                material.side = BackSide;
                                material.needsUpdate = !0;
                                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                                material.side = FrontSide;
                                material.needsUpdate = !0;
                                _this.renderBufferDirect(camera, scene, geometry, material, object, group);
                                material.side = DoubleSide
                            } else {
                                _this.renderBufferDirect(camera, scene, geometry, material, object, group)
                            }
                            object.onAfterRender(_this, scene, camera, geometry, material, group)
                        }

                        function getProgram(material, scene, object) {
                            if (scene.isScene !== !0) scene = _emptyScene;
                            const materialProperties = properties.get(material);
                            const lights = currentRenderState.state.lights;
                            const shadowsArray = currentRenderState.state.shadowsArray;
                            const lightsStateVersion = lights.state.version;
                            const parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
                            const programCacheKey = programCache.getProgramCacheKey(parameters);
                            let programs = materialProperties.programs;
                            materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
                            materialProperties.fog = scene.fog;
                            materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
                            materialProperties.envMapRotation = (materialProperties.environment !== null && material.envMap === null) ? scene.environmentRotation : material.envMapRotation;
                            if (programs === undefined) {
                                material.addEventListener('dispose', onMaterialDispose);
                                programs = new Map();
                                materialProperties.programs = programs
                            }
                            let program = programs.get(programCacheKey);
                            if (program !== undefined) {
                                if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
                                    updateCommonMaterialProperties(material, parameters);
                                    return program
                                }
                            } else {
                                parameters.uniforms = programCache.getUniforms(material);
                                material.onBeforeCompile(parameters, _this);
                                program = programCache.acquireProgram(parameters, programCacheKey);
                                programs.set(programCacheKey, program);
                                materialProperties.uniforms = parameters.uniforms
                            }
                            const uniforms = materialProperties.uniforms;
                            if ((!material.isShaderMaterial && !material.isRawShaderMaterial) || material.clipping === !0) {
                                uniforms.clippingPlanes = clipping.uniform
                            }
                            updateCommonMaterialProperties(material, parameters);
                            materialProperties.needsLights = materialNeedsLights(material);
                            materialProperties.lightsStateVersion = lightsStateVersion;
                            if (materialProperties.needsLights) {
                                uniforms.ambientLightColor.value = lights.state.ambient;
                                uniforms.lightProbe.value = lights.state.probe;
                                uniforms.directionalLights.value = lights.state.directional;
                                uniforms.directionalLightShadows.value = lights.state.directionalShadow;
                                uniforms.spotLights.value = lights.state.spot;
                                uniforms.spotLightShadows.value = lights.state.spotShadow;
                                uniforms.rectAreaLights.value = lights.state.rectArea;
                                uniforms.ltc_1.value = lights.state.rectAreaLTC1;
                                uniforms.ltc_2.value = lights.state.rectAreaLTC2;
                                uniforms.pointLights.value = lights.state.point;
                                uniforms.pointLightShadows.value = lights.state.pointShadow;
                                uniforms.hemisphereLights.value = lights.state.hemi;
                                uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
                                uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
                                uniforms.spotShadowMap.value = lights.state.spotShadowMap;
                                uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
                                uniforms.spotLightMap.value = lights.state.spotLightMap;
                                uniforms.pointShadowMap.value = lights.state.pointShadowMap;
                                uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix
                            }
                            materialProperties.currentProgram = program;
                            materialProperties.uniformsList = null;
                            return program
                        }

                        function getUniformList(materialProperties) {
                            if (materialProperties.uniformsList === null) {
                                const progUniforms = materialProperties.currentProgram.getUniforms();
                                materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms)
                            }
                            return materialProperties.uniformsList
                        }

                        function updateCommonMaterialProperties(material, parameters) {
                            const materialProperties = properties.get(material);
                            materialProperties.outputColorSpace = parameters.outputColorSpace;
                            materialProperties.batching = parameters.batching;
                            materialProperties.batchingColor = parameters.batchingColor;
                            materialProperties.instancing = parameters.instancing;
                            materialProperties.instancingColor = parameters.instancingColor;
                            materialProperties.instancingMorph = parameters.instancingMorph;
                            materialProperties.skinning = parameters.skinning;
                            materialProperties.morphTargets = parameters.morphTargets;
                            materialProperties.morphNormals = parameters.morphNormals;
                            materialProperties.morphColors = parameters.morphColors;
                            materialProperties.morphTargetsCount = parameters.morphTargetsCount;
                            materialProperties.numClippingPlanes = parameters.numClippingPlanes;
                            materialProperties.numIntersection = parameters.numClipIntersection;
                            materialProperties.vertexAlphas = parameters.vertexAlphas;
                            materialProperties.vertexTangents = parameters.vertexTangents;
                            materialProperties.toneMapping = parameters.toneMapping
                        }

                        function setProgram(camera, scene, geometry, material, object) {
                            if (scene.isScene !== !0) scene = _emptyScene;
                            textures.resetTextureUnits();
                            const fog = scene.fog;
                            const environment = material.isMeshStandardMaterial ? scene.environment : null;
                            const colorSpace = (_currentRenderTarget === null) ? _this.outputColorSpace : (_currentRenderTarget.isXRRenderTarget === !0 ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace);
                            const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
                            const vertexAlphas = material.vertexColors === !0 && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
                            const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
                            const morphTargets = !!geometry.morphAttributes.position;
                            const morphNormals = !!geometry.morphAttributes.normal;
                            const morphColors = !!geometry.morphAttributes.color;
                            let toneMapping = NoToneMapping;
                            if (material.toneMapped) {
                                if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === !0) {
                                    toneMapping = _this.toneMapping
                                }
                            }
                            const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
                            const morphTargetsCount = (morphAttribute !== undefined) ? morphAttribute.length : 0;
                            const materialProperties = properties.get(material);
                            const lights = currentRenderState.state.lights;
                            if (_clippingEnabled === !0) {
                                if (_localClippingEnabled === !0 || camera !== _currentCamera) {
                                    const useCache = camera === _currentCamera && material.id === _currentMaterialId;
                                    clipping.setState(material, camera, useCache)
                                }
                            }
                            let needsProgramChange = !1;
                            if (material.version === materialProperties.__version) {
                                if (materialProperties.needsLights && (materialProperties.lightsStateVersion !== lights.state.version)) {
                                    needsProgramChange = !0
                                } else if (materialProperties.outputColorSpace !== colorSpace) {
                                    needsProgramChange = !0
                                } else if (object.isBatchedMesh && materialProperties.batching === !1) {
                                    needsProgramChange = !0
                                } else if (!object.isBatchedMesh && materialProperties.batching === !0) {
                                    needsProgramChange = !0
                                } else if (object.isBatchedMesh && materialProperties.batchingColor === !0 && object.colorTexture === null) {
                                    needsProgramChange = !0
                                } else if (object.isBatchedMesh && materialProperties.batchingColor === !1 && object.colorTexture !== null) {
                                    needsProgramChange = !0
                                } else if (object.isInstancedMesh && materialProperties.instancing === !1) {
                                    needsProgramChange = !0
                                } else if (!object.isInstancedMesh && materialProperties.instancing === !0) {
                                    needsProgramChange = !0
                                } else if (object.isSkinnedMesh && materialProperties.skinning === !1) {
                                    needsProgramChange = !0
                                } else if (!object.isSkinnedMesh && materialProperties.skinning === !0) {
                                    needsProgramChange = !0
                                } else if (object.isInstancedMesh && materialProperties.instancingColor === !0 && object.instanceColor === null) {
                                    needsProgramChange = !0
                                } else if (object.isInstancedMesh && materialProperties.instancingColor === !1 && object.instanceColor !== null) {
                                    needsProgramChange = !0
                                } else if (object.isInstancedMesh && materialProperties.instancingMorph === !0 && object.morphTexture === null) {
                                    needsProgramChange = !0
                                } else if (object.isInstancedMesh && materialProperties.instancingMorph === !1 && object.morphTexture !== null) {
                                    needsProgramChange = !0
                                } else if (materialProperties.envMap !== envMap) {
                                    needsProgramChange = !0
                                } else if (material.fog === !0 && materialProperties.fog !== fog) {
                                    needsProgramChange = !0
                                } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
                                    needsProgramChange = !0
                                } else if (materialProperties.vertexAlphas !== vertexAlphas) {
                                    needsProgramChange = !0
                                } else if (materialProperties.vertexTangents !== vertexTangents) {
                                    needsProgramChange = !0
                                } else if (materialProperties.morphTargets !== morphTargets) {
                                    needsProgramChange = !0
                                } else if (materialProperties.morphNormals !== morphNormals) {
                                    needsProgramChange = !0
                                } else if (materialProperties.morphColors !== morphColors) {
                                    needsProgramChange = !0
                                } else if (materialProperties.toneMapping !== toneMapping) {
                                    needsProgramChange = !0
                                } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
                                    needsProgramChange = !0
                                }
                            } else {
                                needsProgramChange = !0;
                                materialProperties.__version = material.version
                            }
                            let program = materialProperties.currentProgram;
                            if (needsProgramChange === !0) {
                                program = getProgram(material, scene, object)
                            }
                            let refreshProgram = !1;
                            let refreshMaterial = !1;
                            let refreshLights = !1;
                            const p_uniforms = program.getUniforms(),
                                m_uniforms = materialProperties.uniforms;
                            if (state.useProgram(program.program)) {
                                refreshProgram = !0;
                                refreshMaterial = !0;
                                refreshLights = !0
                            }
                            if (material.id !== _currentMaterialId) {
                                _currentMaterialId = material.id;
                                refreshMaterial = !0
                            }
                            if (refreshProgram || _currentCamera !== camera) {
                                p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix);
                                p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse);
                                const uCamPos = p_uniforms.map.cameraPosition;
                                if (uCamPos !== undefined) {
                                    uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld))
                                }
                                if (capabilities.logarithmicDepthBuffer) {
                                    p_uniforms.setValue(_gl, 'logDepthBufFC', 2.0 / (Math.log(camera.far + 1.0) / Math.LN2))
                                }
                                if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
                                    p_uniforms.setValue(_gl, 'isOrthographic', camera.isOrthographicCamera === !0)
                                }
                                if (_currentCamera !== camera) {
                                    _currentCamera = camera;
                                    refreshMaterial = !0;
                                    refreshLights = !0
                                }
                            }
                            if (object.isSkinnedMesh) {
                                p_uniforms.setOptional(_gl, object, 'bindMatrix');
                                p_uniforms.setOptional(_gl, object, 'bindMatrixInverse');
                                const skeleton = object.skeleton;
                                if (skeleton) {
                                    if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
                                    p_uniforms.setValue(_gl, 'boneTexture', skeleton.boneTexture, textures)
                                }
                            }
                            if (object.isBatchedMesh) {
                                p_uniforms.setOptional(_gl, object, 'batchingTexture');
                                p_uniforms.setValue(_gl, 'batchingTexture', object._matricesTexture, textures);
                                p_uniforms.setOptional(_gl, object, 'batchingIdTexture');
                                p_uniforms.setValue(_gl, 'batchingIdTexture', object._indirectTexture, textures);
                                p_uniforms.setOptional(_gl, object, 'batchingColorTexture');
                                if (object._colorsTexture !== null) {
                                    p_uniforms.setValue(_gl, 'batchingColorTexture', object._colorsTexture, textures)
                                }
                            }
                            const morphAttributes = geometry.morphAttributes;
                            if (morphAttributes.position !== undefined || morphAttributes.normal !== undefined || (morphAttributes.color !== undefined)) {
                                morphtargets.update(object, geometry, program)
                            }
                            if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
                                materialProperties.receiveShadow = object.receiveShadow;
                                p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow)
                            }
                            if (material.isMeshGouraudMaterial && material.envMap !== null) {
                                m_uniforms.envMap.value = envMap;
                                m_uniforms.flipEnvMap.value = (envMap.isCubeTexture && envMap.isRenderTargetTexture === !1) ? -1 : 1
                            }
                            if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
                                m_uniforms.envMapIntensity.value = scene.environmentIntensity
                            }
                            if (refreshMaterial) {
                                p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure);
                                if (materialProperties.needsLights) {
                                    markUniformsLightsNeedsUpdate(m_uniforms, refreshLights)
                                }
                                if (fog && material.fog === !0) {
                                    materials.refreshFogUniforms(m_uniforms, fog)
                                }
                                materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
                                WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures)
                            }
                            if (material.isShaderMaterial && material.uniformsNeedUpdate === !0) {
                                WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
                                material.uniformsNeedUpdate = !1
                            }
                            if (material.isSpriteMaterial) {
                                p_uniforms.setValue(_gl, 'center', object.center)
                            }
                            p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix);
                            p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix);
                            p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld);
                            if (material.isShaderMaterial || material.isRawShaderMaterial) {
                                const groups = material.uniformsGroups;
                                for (let i = 0, l = groups.length; i < l; i++) {
                                    const group = groups[i];
                                    uniformsGroups.update(group, program);
                                    uniformsGroups.bind(group, program)
                                }
                            }
                            return program
                        }

                        function markUniformsLightsNeedsUpdate(uniforms, value) {
                            uniforms.ambientLightColor.needsUpdate = value;
                            uniforms.lightProbe.needsUpdate = value;
                            uniforms.directionalLights.needsUpdate = value;
                            uniforms.directionalLightShadows.needsUpdate = value;
                            uniforms.pointLights.needsUpdate = value;
                            uniforms.pointLightShadows.needsUpdate = value;
                            uniforms.spotLights.needsUpdate = value;
                            uniforms.spotLightShadows.needsUpdate = value;
                            uniforms.rectAreaLights.needsUpdate = value;
                            uniforms.hemisphereLights.needsUpdate = value
                        }

                        function materialNeedsLights(material) {
                            return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || (material.isShaderMaterial && material.lights === !0)
                        }
                        this.getActiveCubeFace = function() {
                            return _currentActiveCubeFace
                        };
                        this.getActiveMipmapLevel = function() {
                            return _currentActiveMipmapLevel
                        };
                        this.getRenderTarget = function() {
                            return _currentRenderTarget
                        };
                        this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
                            properties.get(renderTarget.texture).__webglTexture = colorTexture;
                            properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
                            const renderTargetProperties = properties.get(renderTarget);
                            renderTargetProperties.__hasExternalTextures = !0;
                            renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === undefined;
                            if (!renderTargetProperties.__autoAllocateDepthBuffer) {
                                if (extensions.has('WEBGL_multisampled_render_to_texture') === !0) {
                                    console.warn('THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided');
                                    renderTargetProperties.__useRenderToTexture = !1
                                }
                            }
                        };
                        this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
                            const renderTargetProperties = properties.get(renderTarget);
                            renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
                            renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === undefined
                        };
                        this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
                            _currentRenderTarget = renderTarget;
                            _currentActiveCubeFace = activeCubeFace;
                            _currentActiveMipmapLevel = activeMipmapLevel;
                            let useDefaultFramebuffer = !0;
                            let framebuffer = null;
                            let isCube = !1;
                            let isRenderTarget3D = !1;
                            if (renderTarget) {
                                const renderTargetProperties = properties.get(renderTarget);
                                if (renderTargetProperties.__useDefaultFramebuffer !== undefined) {
                                    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
                                    useDefaultFramebuffer = !1
                                } else if (renderTargetProperties.__webglFramebuffer === undefined) {
                                    textures.setupRenderTarget(renderTarget)
                                } else if (renderTargetProperties.__hasExternalTextures) {
                                    textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture)
                                }
                                const texture = renderTarget.texture;
                                if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                                    isRenderTarget3D = !0
                                }
                                const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
                                if (renderTarget.isWebGLCubeRenderTarget) {
                                    if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
                                        framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel]
                                    } else {
                                        framebuffer = __webglFramebuffer[activeCubeFace]
                                    }
                                    isCube = !0
                                } else if ((renderTarget.samples > 0) && textures.useMultisampledRTT(renderTarget) === !1) {
                                    framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer
                                } else {
                                    if (Array.isArray(__webglFramebuffer)) {
                                        framebuffer = __webglFramebuffer[activeMipmapLevel]
                                    } else {
                                        framebuffer = __webglFramebuffer
                                    }
                                }
                                _currentViewport.copy(renderTarget.viewport);
                                _currentScissor.copy(renderTarget.scissor);
                                _currentScissorTest = renderTarget.scissorTest
                            } else {
                                _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
                                _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
                                _currentScissorTest = _scissorTest
                            }
                            const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                            if (framebufferBound && useDefaultFramebuffer) {
                                state.drawBuffers(renderTarget, framebuffer)
                            }
                            state.viewport(_currentViewport);
                            state.scissor(_currentScissor);
                            state.setScissorTest(_currentScissorTest);
                            if (isCube) {
                                const textureProperties = properties.get(renderTarget.texture);
                                _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel)
                            } else if (isRenderTarget3D) {
                                const textureProperties = properties.get(renderTarget.texture);
                                const layer = activeCubeFace || 0;
                                _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer)
                            }
                            _currentMaterialId = -1
                        };
                        this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                                console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');
                                return
                            }
                            let framebuffer = properties.get(renderTarget).__webglFramebuffer;
                            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                                framebuffer = framebuffer[activeCubeFaceIndex]
                            }
                            if (framebuffer) {
                                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                                try {
                                    const texture = renderTarget.texture;
                                    const textureFormat = texture.format;
                                    const textureType = texture.type;
                                    if (!capabilities.textureFormatReadable(textureFormat)) {
                                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');
                                        return
                                    }
                                    if (!capabilities.textureTypeReadable(textureType)) {
                                        console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');
                                        return
                                    }
                                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                                        _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer)
                                    }
                                } finally {
                                    const framebuffer = (_currentRenderTarget !== null) ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                                    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)
                                }
                            }
                        };
                        this.readRenderTargetPixelsAsync = async function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
                            if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
                                throw new Error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.')
                            }
                            let framebuffer = properties.get(renderTarget).__webglFramebuffer;
                            if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
                                framebuffer = framebuffer[activeCubeFaceIndex]
                            }
                            if (framebuffer) {
                                state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
                                try {
                                    const texture = renderTarget.texture;
                                    const textureFormat = texture.format;
                                    const textureType = texture.type;
                                    if (!capabilities.textureFormatReadable(textureFormat)) {
                                        throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.')
                                    }
                                    if (!capabilities.textureTypeReadable(textureType)) {
                                        throw new Error('THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.')
                                    }
                                    if ((x >= 0 && x <= (renderTarget.width - width)) && (y >= 0 && y <= (renderTarget.height - height))) {
                                        const glBuffer = _gl.createBuffer();
                                        _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                                        _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
                                        _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
                                        _gl.flush();
                                        const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
                                        await probeAsync(_gl, sync, 4);
                                        try {
                                            _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
                                            _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer)
                                        } finally {
                                            _gl.deleteBuffer(glBuffer);
                                            _gl.deleteSync(sync)
                                        }
                                        return buffer
                                    }
                                } finally {
                                    const framebuffer = (_currentRenderTarget !== null) ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
                                    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer)
                                }
                            }
                        };
                        this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
                            if (texture.isTexture !== !0) {
                                warnOnce('WebGLRenderer: copyFramebufferToTexture function signature has changed.');
                                position = arguments[0] || null;
                                texture = arguments[1]
                            }
                            const levelScale = Math.pow(2, -level);
                            const width = Math.floor(texture.image.width * levelScale);
                            const height = Math.floor(texture.image.height * levelScale);
                            const x = position !== null ? position.x : 0;
                            const y = position !== null ? position.y : 0;
                            textures.setTexture2D(texture, 0);
                            _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x, y, width, height);
                            state.unbindTexture()
                        };
                        this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
                            if (srcTexture.isTexture !== !0) {
                                warnOnce('WebGLRenderer: copyTextureToTexture function signature has changed.');
                                dstPosition = arguments[0] || null;
                                srcTexture = arguments[1];
                                dstTexture = arguments[2];
                                level = arguments[3] || 0;
                                srcRegion = null
                            }
                            let width, height, minX, minY;
                            let dstX, dstY;
                            if (srcRegion !== null) {
                                width = srcRegion.max.x - srcRegion.min.x;
                                height = srcRegion.max.y - srcRegion.min.y;
                                minX = srcRegion.min.x;
                                minY = srcRegion.min.y
                            } else {
                                width = srcTexture.image.width;
                                height = srcTexture.image.height;
                                minX = 0;
                                minY = 0
                            }
                            if (dstPosition !== null) {
                                dstX = dstPosition.x;
                                dstY = dstPosition.y
                            } else {
                                dstX = 0;
                                dstY = 0
                            }
                            const glFormat = utils.convert(dstTexture.format);
                            const glType = utils.convert(dstTexture.type);
                            textures.setTexture2D(dstTexture, 0);
                            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
                            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
                            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
                            const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
                            const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
                            const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
                            const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
                            const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
                            const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
                            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
                            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
                            if (srcTexture.isDataTexture) {
                                _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data)
                            } else {
                                if (srcTexture.isCompressedTexture) {
                                    _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data)
                                } else {
                                    _gl.texSubImage2D(_gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image)
                                }
                            }
                            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
                            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
                            if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(_gl.TEXTURE_2D);
                            state.unbindTexture()
                        };
                        this.copyTextureToTexture3D = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0) {
                            if (srcTexture.isTexture !== !0) {
                                warnOnce('WebGLRenderer: copyTextureToTexture3D function signature has changed.');
                                srcRegion = arguments[0] || null;
                                dstPosition = arguments[1] || null;
                                srcTexture = arguments[2];
                                dstTexture = arguments[3];
                                level = arguments[4] || 0
                            }
                            let width, height, depth, minX, minY, minZ;
                            let dstX, dstY, dstZ;
                            const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
                            if (srcRegion !== null) {
                                width = srcRegion.max.x - srcRegion.min.x;
                                height = srcRegion.max.y - srcRegion.min.y;
                                depth = srcRegion.max.z - srcRegion.min.z;
                                minX = srcRegion.min.x;
                                minY = srcRegion.min.y;
                                minZ = srcRegion.min.z
                            } else {
                                width = image.width;
                                height = image.height;
                                depth = image.depth;
                                minX = 0;
                                minY = 0;
                                minZ = 0
                            }
                            if (dstPosition !== null) {
                                dstX = dstPosition.x;
                                dstY = dstPosition.y;
                                dstZ = dstPosition.z
                            } else {
                                dstX = 0;
                                dstY = 0;
                                dstZ = 0
                            }
                            const glFormat = utils.convert(dstTexture.format);
                            const glType = utils.convert(dstTexture.type);
                            let glTarget;
                            if (dstTexture.isData3DTexture) {
                                textures.setTexture3D(dstTexture, 0);
                                glTarget = _gl.TEXTURE_3D
                            } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
                                textures.setTexture2DArray(dstTexture, 0);
                                glTarget = _gl.TEXTURE_2D_ARRAY
                            } else {
                                console.warn('THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.');
                                return
                            }
                            _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
                            _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
                            _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
                            const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
                            const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
                            const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
                            const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
                            const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
                            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
                            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
                            if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
                                _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image.data)
                            } else {
                                if (dstTexture.isCompressedArrayTexture) {
                                    _gl.compressedTexSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, image.data)
                                } else {
                                    _gl.texSubImage3D(glTarget, level, dstX, dstY, dstZ, width, height, depth, glFormat, glType, image)
                                }
                            }
                            _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
                            _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
                            _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
                            if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget);
                            state.unbindTexture()
                        };
                        this.initRenderTarget = function(target) {
                            if (properties.get(target).__webglFramebuffer === undefined) {
                                textures.setupRenderTarget(target)
                            }
                        };
                        this.initTexture = function(texture) {
                            if (texture.isCubeTexture) {
                                textures.setTextureCube(texture, 0)
                            } else if (texture.isData3DTexture) {
                                textures.setTexture3D(texture, 0)
                            } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
                                textures.setTexture2DArray(texture, 0)
                            } else {
                                textures.setTexture2D(texture, 0)
                            }
                            state.unbindTexture()
                        };
                        this.resetState = function() {
                            _currentActiveCubeFace = 0;
                            _currentActiveMipmapLevel = 0;
                            _currentRenderTarget = null;
                            state.reset();
                            bindingStates.reset()
                        };
                        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                                detail: this
                            }))
                        }
                    }
                    get coordinateSystem() {
                        return WebGLCoordinateSystem
                    }
                    get outputColorSpace() {
                        return this._outputColorSpace
                    }
                    set outputColorSpace(colorSpace) {
                        this._outputColorSpace = colorSpace;
                        const gl = this.getContext();
                        gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? 'display-p3' : 'srgb';
                        gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? 'display-p3' : 'srgb'
                    }
                }
                class FogExp2 {
                    constructor(color, density = 0.00025) {
                        this.isFogExp2 = !0;
                        this.name = '';
                        this.color = new Color(color);
                        this.density = density
                    }
                    clone() {
                        return new FogExp2(this.color, this.density)
                    }
                    toJSON() {
                        return {
                            type: 'FogExp2',
                            name: this.name,
                            color: this.color.getHex(),
                            density: this.density
                        }
                    }
                }
                class Fog {
                    constructor(color, near = 1, far = 1000) {
                        this.isFog = !0;
                        this.name = '';
                        this.color = new Color(color);
                        this.near = near;
                        this.far = far
                    }
                    clone() {
                        return new Fog(this.color, this.near, this.far)
                    }
                    toJSON() {
                        return {
                            type: 'Fog',
                            name: this.name,
                            color: this.color.getHex(),
                            near: this.near,
                            far: this.far
                        }
                    }
                }
                class Scene extends Object3D {
                    constructor() {
                        super();
                        this.isScene = !0;
                        this.type = 'Scene';
                        this.background = null;
                        this.environment = null;
                        this.fog = null;
                        this.backgroundBlurriness = 0;
                        this.backgroundIntensity = 1;
                        this.backgroundRotation = new Euler();
                        this.environmentIntensity = 1;
                        this.environmentRotation = new Euler();
                        this.overrideMaterial = null;
                        if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                            __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
                                detail: this
                            }))
                        }
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        if (source.background !== null) this.background = source.background.clone();
                        if (source.environment !== null) this.environment = source.environment.clone();
                        if (source.fog !== null) this.fog = source.fog.clone();
                        this.backgroundBlurriness = source.backgroundBlurriness;
                        this.backgroundIntensity = source.backgroundIntensity;
                        this.backgroundRotation.copy(source.backgroundRotation);
                        this.environmentIntensity = source.environmentIntensity;
                        this.environmentRotation.copy(source.environmentRotation);
                        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
                        this.matrixAutoUpdate = source.matrixAutoUpdate;
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        if (this.fog !== null) data.object.fog = this.fog.toJSON();
                        if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
                        if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
                        data.object.backgroundRotation = this.backgroundRotation.toArray();
                        if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
                        data.object.environmentRotation = this.environmentRotation.toArray();
                        return data
                    }
                }
                class InterleavedBuffer {
                    constructor(array, stride) {
                        this.isInterleavedBuffer = !0;
                        this.array = array;
                        this.stride = stride;
                        this.count = array !== undefined ? array.length / stride : 0;
                        this.usage = StaticDrawUsage;
                        this._updateRange = {
                            offset: 0,
                            count: -1
                        };
                        this.updateRanges = [];
                        this.version = 0;
                        this.uuid = generateUUID()
                    }
                    onUploadCallback() {}
                    set needsUpdate(value) {
                        if (value === !0) this.version++
                    }
                    get updateRange() {
                        warnOnce('THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead.');
                        return this._updateRange
                    }
                    setUsage(value) {
                        this.usage = value;
                        return this
                    }
                    addUpdateRange(start, count) {
                        this.updateRanges.push({
                            start,
                            count
                        })
                    }
                    clearUpdateRanges() {
                        this.updateRanges.length = 0
                    }
                    copy(source) {
                        this.array = new source.array.constructor(source.array);
                        this.count = source.count;
                        this.stride = source.stride;
                        this.usage = source.usage;
                        return this
                    }
                    copyAt(index1, attribute, index2) {
                        index1 *= this.stride;
                        index2 *= attribute.stride;
                        for (let i = 0, l = this.stride; i < l; i++) {
                            this.array[index1 + i] = attribute.array[index2 + i]
                        }
                        return this
                    }
                    set(value, offset = 0) {
                        this.array.set(value, offset);
                        return this
                    }
                    clone(data) {
                        if (data.arrayBuffers === undefined) {
                            data.arrayBuffers = {}
                        }
                        if (this.array.buffer._uuid === undefined) {
                            this.array.buffer._uuid = generateUUID()
                        }
                        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                            data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer
                        }
                        const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
                        const ib = new this.constructor(array, this.stride);
                        ib.setUsage(this.usage);
                        return ib
                    }
                    onUpload(callback) {
                        this.onUploadCallback = callback;
                        return this
                    }
                    toJSON(data) {
                        if (data.arrayBuffers === undefined) {
                            data.arrayBuffers = {}
                        }
                        if (this.array.buffer._uuid === undefined) {
                            this.array.buffer._uuid = generateUUID()
                        }
                        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
                            data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))
                        }
                        return {
                            uuid: this.uuid,
                            buffer: this.array.buffer._uuid,
                            type: this.array.constructor.name,
                            stride: this.stride
                        }
                    }
                }
                const _vector$6 = new Vector3();
                class InterleavedBufferAttribute {
                    constructor(interleavedBuffer, itemSize, offset, normalized = !1) {
                        this.isInterleavedBufferAttribute = !0;
                        this.name = '';
                        this.data = interleavedBuffer;
                        this.itemSize = itemSize;
                        this.offset = offset;
                        this.normalized = normalized
                    }
                    get count() {
                        return this.data.count
                    }
                    get array() {
                        return this.data.array
                    }
                    set needsUpdate(value) {
                        this.data.needsUpdate = value
                    }
                    applyMatrix4(m) {
                        for (let i = 0, l = this.data.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.applyMatrix4(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)
                        }
                        return this
                    }
                    applyNormalMatrix(m) {
                        for (let i = 0, l = this.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.applyNormalMatrix(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)
                        }
                        return this
                    }
                    transformDirection(m) {
                        for (let i = 0, l = this.count; i < l; i++) {
                            _vector$6.fromBufferAttribute(this, i);
                            _vector$6.transformDirection(m);
                            this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z)
                        }
                        return this
                    }
                    getComponent(index, component) {
                        let value = this.array[index * this.data.stride + this.offset + component];
                        if (this.normalized) value = denormalize(value, this.array);
                        return value
                    }
                    setComponent(index, component, value) {
                        if (this.normalized) value = normalize(value, this.array);
                        this.data.array[index * this.data.stride + this.offset + component] = value;
                        return this
                    }
                    setX(index, x) {
                        if (this.normalized) x = normalize(x, this.array);
                        this.data.array[index * this.data.stride + this.offset] = x;
                        return this
                    }
                    setY(index, y) {
                        if (this.normalized) y = normalize(y, this.array);
                        this.data.array[index * this.data.stride + this.offset + 1] = y;
                        return this
                    }
                    setZ(index, z) {
                        if (this.normalized) z = normalize(z, this.array);
                        this.data.array[index * this.data.stride + this.offset + 2] = z;
                        return this
                    }
                    setW(index, w) {
                        if (this.normalized) w = normalize(w, this.array);
                        this.data.array[index * this.data.stride + this.offset + 3] = w;
                        return this
                    }
                    getX(index) {
                        let x = this.data.array[index * this.data.stride + this.offset];
                        if (this.normalized) x = denormalize(x, this.array);
                        return x
                    }
                    getY(index) {
                        let y = this.data.array[index * this.data.stride + this.offset + 1];
                        if (this.normalized) y = denormalize(y, this.array);
                        return y
                    }
                    getZ(index) {
                        let z = this.data.array[index * this.data.stride + this.offset + 2];
                        if (this.normalized) z = denormalize(z, this.array);
                        return z
                    }
                    getW(index) {
                        let w = this.data.array[index * this.data.stride + this.offset + 3];
                        if (this.normalized) w = denormalize(w, this.array);
                        return w
                    }
                    setXY(index, x, y) {
                        index = index * this.data.stride + this.offset;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array)
                        }
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        return this
                    }
                    setXYZ(index, x, y, z) {
                        index = index * this.data.stride + this.offset;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array)
                        }
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        this.data.array[index + 2] = z;
                        return this
                    }
                    setXYZW(index, x, y, z, w) {
                        index = index * this.data.stride + this.offset;
                        if (this.normalized) {
                            x = normalize(x, this.array);
                            y = normalize(y, this.array);
                            z = normalize(z, this.array);
                            w = normalize(w, this.array)
                        }
                        this.data.array[index + 0] = x;
                        this.data.array[index + 1] = y;
                        this.data.array[index + 2] = z;
                        this.data.array[index + 3] = w;
                        return this
                    }
                    clone(data) {
                        if (data === undefined) {
                            console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
                            const array = [];
                            for (let i = 0; i < this.count; i++) {
                                const index = i * this.data.stride + this.offset;
                                for (let j = 0; j < this.itemSize; j++) {
                                    array.push(this.data.array[index + j])
                                }
                            }
                            return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized)
                        } else {
                            if (data.interleavedBuffers === undefined) {
                                data.interleavedBuffers = {}
                            }
                            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                                data.interleavedBuffers[this.data.uuid] = this.data.clone(data)
                            }
                            return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
                        }
                    }
                    toJSON(data) {
                        if (data === undefined) {
                            console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
                            const array = [];
                            for (let i = 0; i < this.count; i++) {
                                const index = i * this.data.stride + this.offset;
                                for (let j = 0; j < this.itemSize; j++) {
                                    array.push(this.data.array[index + j])
                                }
                            }
                            return {
                                itemSize: this.itemSize,
                                type: this.array.constructor.name,
                                array: array,
                                normalized: this.normalized
                            }
                        } else {
                            if (data.interleavedBuffers === undefined) {
                                data.interleavedBuffers = {}
                            }
                            if (data.interleavedBuffers[this.data.uuid] === undefined) {
                                data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)
                            }
                            return {
                                isInterleavedBufferAttribute: !0,
                                itemSize: this.itemSize,
                                data: this.data.uuid,
                                offset: this.offset,
                                normalized: this.normalized
                            }
                        }
                    }
                }
                class SpriteMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isSpriteMaterial = !0;
                        this.type = 'SpriteMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.alphaMap = null;
                        this.rotation = 0;
                        this.sizeAttenuation = !0;
                        this.transparent = !0;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.rotation = source.rotation;
                        this.sizeAttenuation = source.sizeAttenuation;
                        this.fog = source.fog;
                        return this
                    }
                }
                let _geometry;
                const _intersectPoint = new Vector3();
                const _worldScale = new Vector3();
                const _mvPosition = new Vector3();
                const _alignedPosition = new Vector2();
                const _rotatedPosition = new Vector2();
                const _viewWorldMatrix = new Matrix4();
                const _vA = new Vector3();
                const _vB = new Vector3();
                const _vC = new Vector3();
                const _uvA = new Vector2();
                const _uvB = new Vector2();
                const _uvC = new Vector2();
                class Sprite extends Object3D {
                    constructor(material = new SpriteMaterial()) {
                        super();
                        this.isSprite = !0;
                        this.type = 'Sprite';
                        if (_geometry === undefined) {
                            _geometry = new BufferGeometry();
                            const float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
                            const interleavedBuffer = new InterleavedBuffer(float32Array, 5);
                            _geometry.setIndex([0, 1, 2, 0, 2, 3]);
                            _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, !1));
                            _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, !1))
                        }
                        this.geometry = _geometry;
                        this.material = material;
                        this.center = new Vector2(0.5, 0.5)
                    }
                    raycast(raycaster, intersects) {
                        if (raycaster.camera === null) {
                            console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.')
                        }
                        _worldScale.setFromMatrixScale(this.matrixWorld);
                        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
                        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
                        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
                        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1) {
                            _worldScale.multiplyScalar(-_mvPosition.z)
                        }
                        const rotation = this.material.rotation;
                        let sin, cos;
                        if (rotation !== 0) {
                            cos = Math.cos(rotation);
                            sin = Math.sin(rotation)
                        }
                        const center = this.center;
                        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                        _uvA.set(0, 0);
                        _uvB.set(1, 0);
                        _uvC.set(1, 1);
                        let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, !1, _intersectPoint);
                        if (intersect === null) {
                            transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
                            _uvB.set(0, 1);
                            intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, !1, _intersectPoint);
                            if (intersect === null) {
                                return
                            }
                        }
                        const distance = raycaster.ray.origin.distanceTo(_intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            point: _intersectPoint.clone(),
                            uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
                            face: null,
                            object: this
                        })
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        if (source.center !== undefined) this.center.copy(source.center);
                        this.material = source.material;
                        return this
                    }
                }

                function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
                    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
                    if (sin !== undefined) {
                        _rotatedPosition.x = (cos * _alignedPosition.x) - (sin * _alignedPosition.y);
                        _rotatedPosition.y = (sin * _alignedPosition.x) + (cos * _alignedPosition.y)
                    } else {
                        _rotatedPosition.copy(_alignedPosition)
                    }
                    vertexPosition.copy(mvPosition);
                    vertexPosition.x += _rotatedPosition.x;
                    vertexPosition.y += _rotatedPosition.y;
                    vertexPosition.applyMatrix4(_viewWorldMatrix)
                }
                const _v1$2 = new Vector3();
                const _v2$1 = new Vector3();
                class LOD extends Object3D {
                    constructor() {
                        super();
                        this._currentLevel = 0;
                        this.type = 'LOD';
                        Object.defineProperties(this, {
                            levels: {
                                enumerable: !0,
                                value: []
                            },
                            isLOD: {
                                value: !0,
                            }
                        });
                        this.autoUpdate = !0
                    }
                    copy(source) {
                        super.copy(source, !1);
                        const levels = source.levels;
                        for (let i = 0, l = levels.length; i < l; i++) {
                            const level = levels[i];
                            this.addLevel(level.object.clone(), level.distance, level.hysteresis)
                        }
                        this.autoUpdate = source.autoUpdate;
                        return this
                    }
                    addLevel(object, distance = 0, hysteresis = 0) {
                        distance = Math.abs(distance);
                        const levels = this.levels;
                        let l;
                        for (l = 0; l < levels.length; l++) {
                            if (distance < levels[l].distance) {
                                break
                            }
                        }
                        levels.splice(l, 0, {
                            distance: distance,
                            hysteresis: hysteresis,
                            object: object
                        });
                        this.add(object);
                        return this
                    }
                    getCurrentLevel() {
                        return this._currentLevel
                    }
                    getObjectForDistance(distance) {
                        const levels = this.levels;
                        if (levels.length > 0) {
                            let i, l;
                            for (i = 1, l = levels.length; i < l; i++) {
                                let levelDistance = levels[i].distance;
                                if (levels[i].object.visible) {
                                    levelDistance -= levelDistance * levels[i].hysteresis
                                }
                                if (distance < levelDistance) {
                                    break
                                }
                            }
                            return levels[i - 1].object
                        }
                        return null
                    }
                    raycast(raycaster, intersects) {
                        const levels = this.levels;
                        if (levels.length > 0) {
                            _v1$2.setFromMatrixPosition(this.matrixWorld);
                            const distance = raycaster.ray.origin.distanceTo(_v1$2);
                            this.getObjectForDistance(distance).raycast(raycaster, intersects)
                        }
                    }
                    update(camera) {
                        const levels = this.levels;
                        if (levels.length > 1) {
                            _v1$2.setFromMatrixPosition(camera.matrixWorld);
                            _v2$1.setFromMatrixPosition(this.matrixWorld);
                            const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
                            levels[0].object.visible = !0;
                            let i, l;
                            for (i = 1, l = levels.length; i < l; i++) {
                                let levelDistance = levels[i].distance;
                                if (levels[i].object.visible) {
                                    levelDistance -= levelDistance * levels[i].hysteresis
                                }
                                if (distance >= levelDistance) {
                                    levels[i - 1].object.visible = !1;
                                    levels[i].object.visible = !0
                                } else {
                                    break
                                }
                            }
                            this._currentLevel = i - 1;
                            for (; i < l; i++) {
                                levels[i].object.visible = !1
                            }
                        }
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        if (this.autoUpdate === !1) data.object.autoUpdate = !1;
                        data.object.levels = [];
                        const levels = this.levels;
                        for (let i = 0, l = levels.length; i < l; i++) {
                            const level = levels[i];
                            data.object.levels.push({
                                object: level.object.uuid,
                                distance: level.distance,
                                hysteresis: level.hysteresis
                            })
                        }
                        return data
                    }
                }
                const _basePosition = new Vector3();
                const _skinIndex = new Vector4();
                const _skinWeight = new Vector4();
                const _vector3 = new Vector3();
                const _matrix4 = new Matrix4();
                const _vertex = new Vector3();
                const _sphere$4 = new Sphere();
                const _inverseMatrix$2 = new Matrix4();
                const _ray$2 = new Ray();
                class SkinnedMesh extends Mesh {
                    constructor(geometry, material) {
                        super(geometry, material);
                        this.isSkinnedMesh = !0;
                        this.type = 'SkinnedMesh';
                        this.bindMode = AttachedBindMode;
                        this.bindMatrix = new Matrix4();
                        this.bindMatrixInverse = new Matrix4();
                        this.boundingBox = null;
                        this.boundingSphere = null
                    }
                    computeBoundingBox() {
                        const geometry = this.geometry;
                        if (this.boundingBox === null) {
                            this.boundingBox = new Box3()
                        }
                        this.boundingBox.makeEmpty();
                        const positionAttribute = geometry.getAttribute('position');
                        for (let i = 0; i < positionAttribute.count; i++) {
                            this.getVertexPosition(i, _vertex);
                            this.boundingBox.expandByPoint(_vertex)
                        }
                    }
                    computeBoundingSphere() {
                        const geometry = this.geometry;
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere()
                        }
                        this.boundingSphere.makeEmpty();
                        const positionAttribute = geometry.getAttribute('position');
                        for (let i = 0; i < positionAttribute.count; i++) {
                            this.getVertexPosition(i, _vertex);
                            this.boundingSphere.expandByPoint(_vertex)
                        }
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.bindMode = source.bindMode;
                        this.bindMatrix.copy(source.bindMatrix);
                        this.bindMatrixInverse.copy(source.bindMatrixInverse);
                        this.skeleton = source.skeleton;
                        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
                        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
                        return this
                    }
                    raycast(raycaster, intersects) {
                        const material = this.material;
                        const matrixWorld = this.matrixWorld;
                        if (material === undefined) return;
                        if (this.boundingSphere === null) this.computeBoundingSphere();
                        _sphere$4.copy(this.boundingSphere);
                        _sphere$4.applyMatrix4(matrixWorld);
                        if (raycaster.ray.intersectsSphere(_sphere$4) === !1) return;
                        _inverseMatrix$2.copy(matrixWorld).invert();
                        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
                        if (this.boundingBox !== null) {
                            if (_ray$2.intersectsBox(this.boundingBox) === !1) return
                        }
                        this._computeIntersections(raycaster, intersects, _ray$2)
                    }
                    getVertexPosition(index, target) {
                        super.getVertexPosition(index, target);
                        this.applyBoneTransform(index, target);
                        return target
                    }
                    bind(skeleton, bindMatrix) {
                        this.skeleton = skeleton;
                        if (bindMatrix === undefined) {
                            this.updateMatrixWorld(!0);
                            this.skeleton.calculateInverses();
                            bindMatrix = this.matrixWorld
                        }
                        this.bindMatrix.copy(bindMatrix);
                        this.bindMatrixInverse.copy(bindMatrix).invert()
                    }
                    pose() {
                        this.skeleton.pose()
                    }
                    normalizeSkinWeights() {
                        const vector = new Vector4();
                        const skinWeight = this.geometry.attributes.skinWeight;
                        for (let i = 0, l = skinWeight.count; i < l; i++) {
                            vector.fromBufferAttribute(skinWeight, i);
                            const scale = 1.0 / vector.manhattanLength();
                            if (scale !== Infinity) {
                                vector.multiplyScalar(scale)
                            } else {
                                vector.set(1, 0, 0, 0)
                            }
                            skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w)
                        }
                    }
                    updateMatrixWorld(force) {
                        super.updateMatrixWorld(force);
                        if (this.bindMode === AttachedBindMode) {
                            this.bindMatrixInverse.copy(this.matrixWorld).invert()
                        } else if (this.bindMode === DetachedBindMode) {
                            this.bindMatrixInverse.copy(this.bindMatrix).invert()
                        } else {
                            console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode)
                        }
                    }
                    applyBoneTransform(index, vector) {
                        const skeleton = this.skeleton;
                        const geometry = this.geometry;
                        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
                        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
                        _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
                        vector.set(0, 0, 0);
                        for (let i = 0; i < 4; i++) {
                            const weight = _skinWeight.getComponent(i);
                            if (weight !== 0) {
                                const boneIndex = _skinIndex.getComponent(i);
                                _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
                                vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight)
                            }
                        }
                        return vector.applyMatrix4(this.bindMatrixInverse)
                    }
                }
                class Bone extends Object3D {
                    constructor() {
                        super();
                        this.isBone = !0;
                        this.type = 'Bone'
                    }
                }
                class DataTexture extends Texture {
                    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
                        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
                        this.isDataTexture = !0;
                        this.image = {
                            data: data,
                            width: width,
                            height: height
                        };
                        this.generateMipmaps = !1;
                        this.flipY = !1;
                        this.unpackAlignment = 1
                    }
                }
                const _offsetMatrix = new Matrix4();
                const _identityMatrix$1 = new Matrix4();
                class Skeleton {
                    constructor(bones = [], boneInverses = []) {
                        this.uuid = generateUUID();
                        this.bones = bones.slice(0);
                        this.boneInverses = boneInverses;
                        this.boneMatrices = null;
                        this.boneTexture = null;
                        this.init()
                    }
                    init() {
                        const bones = this.bones;
                        const boneInverses = this.boneInverses;
                        this.boneMatrices = new Float32Array(bones.length * 16);
                        if (boneInverses.length === 0) {
                            this.calculateInverses()
                        } else {
                            if (bones.length !== boneInverses.length) {
                                console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
                                this.boneInverses = [];
                                for (let i = 0, il = this.bones.length; i < il; i++) {
                                    this.boneInverses.push(new Matrix4())
                                }
                            }
                        }
                    }
                    calculateInverses() {
                        this.boneInverses.length = 0;
                        for (let i = 0, il = this.bones.length; i < il; i++) {
                            const inverse = new Matrix4();
                            if (this.bones[i]) {
                                inverse.copy(this.bones[i].matrixWorld).invert()
                            }
                            this.boneInverses.push(inverse)
                        }
                    }
                    pose() {
                        for (let i = 0, il = this.bones.length; i < il; i++) {
                            const bone = this.bones[i];
                            if (bone) {
                                bone.matrixWorld.copy(this.boneInverses[i]).invert()
                            }
                        }
                        for (let i = 0, il = this.bones.length; i < il; i++) {
                            const bone = this.bones[i];
                            if (bone) {
                                if (bone.parent && bone.parent.isBone) {
                                    bone.matrix.copy(bone.parent.matrixWorld).invert();
                                    bone.matrix.multiply(bone.matrixWorld)
                                } else {
                                    bone.matrix.copy(bone.matrixWorld)
                                }
                                bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)
                            }
                        }
                    }
                    update() {
                        const bones = this.bones;
                        const boneInverses = this.boneInverses;
                        const boneMatrices = this.boneMatrices;
                        const boneTexture = this.boneTexture;
                        for (let i = 0, il = bones.length; i < il; i++) {
                            const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix$1;
                            _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
                            _offsetMatrix.toArray(boneMatrices, i * 16)
                        }
                        if (boneTexture !== null) {
                            boneTexture.needsUpdate = !0
                        }
                    }
                    clone() {
                        return new Skeleton(this.bones, this.boneInverses)
                    }
                    computeBoneTexture() {
                        let size = Math.sqrt(this.bones.length * 4);
                        size = Math.ceil(size / 4) * 4;
                        size = Math.max(size, 4);
                        const boneMatrices = new Float32Array(size * size * 4);
                        boneMatrices.set(this.boneMatrices);
                        const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
                        boneTexture.needsUpdate = !0;
                        this.boneMatrices = boneMatrices;
                        this.boneTexture = boneTexture;
                        return this
                    }
                    getBoneByName(name) {
                        for (let i = 0, il = this.bones.length; i < il; i++) {
                            const bone = this.bones[i];
                            if (bone.name === name) {
                                return bone
                            }
                        }
                        return undefined
                    }
                    dispose() {
                        if (this.boneTexture !== null) {
                            this.boneTexture.dispose();
                            this.boneTexture = null
                        }
                    }
                    fromJSON(json, bones) {
                        this.uuid = json.uuid;
                        for (let i = 0, l = json.bones.length; i < l; i++) {
                            const uuid = json.bones[i];
                            let bone = bones[uuid];
                            if (bone === undefined) {
                                console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
                                bone = new Bone()
                            }
                            this.bones.push(bone);
                            this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]))
                        }
                        this.init();
                        return this
                    }
                    toJSON() {
                        const data = {
                            metadata: {
                                version: 4.6,
                                type: 'Skeleton',
                                generator: 'Skeleton.toJSON'
                            },
                            bones: [],
                            boneInverses: []
                        };
                        data.uuid = this.uuid;
                        const bones = this.bones;
                        const boneInverses = this.boneInverses;
                        for (let i = 0, l = bones.length; i < l; i++) {
                            const bone = bones[i];
                            data.bones.push(bone.uuid);
                            const boneInverse = boneInverses[i];
                            data.boneInverses.push(boneInverse.toArray())
                        }
                        return data
                    }
                }
                class InstancedBufferAttribute extends BufferAttribute {
                    constructor(array, itemSize, normalized, meshPerAttribute = 1) {
                        super(array, itemSize, normalized);
                        this.isInstancedBufferAttribute = !0;
                        this.meshPerAttribute = meshPerAttribute
                    }
                    copy(source) {
                        super.copy(source);
                        this.meshPerAttribute = source.meshPerAttribute;
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.meshPerAttribute = this.meshPerAttribute;
                        data.isInstancedBufferAttribute = !0;
                        return data
                    }
                }
                const _instanceLocalMatrix = new Matrix4();
                const _instanceWorldMatrix = new Matrix4();
                const _instanceIntersects = [];
                const _box3 = new Box3();
                const _identity = new Matrix4();
                const _mesh$1 = new Mesh();
                const _sphere$3 = new Sphere();
                class InstancedMesh extends Mesh {
                    constructor(geometry, material, count) {
                        super(geometry, material);
                        this.isInstancedMesh = !0;
                        this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
                        this.instanceColor = null;
                        this.morphTexture = null;
                        this.count = count;
                        this.boundingBox = null;
                        this.boundingSphere = null;
                        for (let i = 0; i < count; i++) {
                            this.setMatrixAt(i, _identity)
                        }
                    }
                    computeBoundingBox() {
                        const geometry = this.geometry;
                        const count = this.count;
                        if (this.boundingBox === null) {
                            this.boundingBox = new Box3()
                        }
                        if (geometry.boundingBox === null) {
                            geometry.computeBoundingBox()
                        }
                        this.boundingBox.makeEmpty();
                        for (let i = 0; i < count; i++) {
                            this.getMatrixAt(i, _instanceLocalMatrix);
                            _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
                            this.boundingBox.union(_box3)
                        }
                    }
                    computeBoundingSphere() {
                        const geometry = this.geometry;
                        const count = this.count;
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere()
                        }
                        if (geometry.boundingSphere === null) {
                            geometry.computeBoundingSphere()
                        }
                        this.boundingSphere.makeEmpty();
                        for (let i = 0; i < count; i++) {
                            this.getMatrixAt(i, _instanceLocalMatrix);
                            _sphere$3.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
                            this.boundingSphere.union(_sphere$3)
                        }
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.instanceMatrix.copy(source.instanceMatrix);
                        if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
                        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
                        this.count = source.count;
                        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
                        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
                        return this
                    }
                    getColorAt(index, color) {
                        color.fromArray(this.instanceColor.array, index * 3)
                    }
                    getMatrixAt(index, matrix) {
                        matrix.fromArray(this.instanceMatrix.array, index * 16)
                    }
                    getMorphAt(index, object) {
                        const objectInfluences = object.morphTargetInfluences;
                        const array = this.morphTexture.source.data.data;
                        const len = objectInfluences.length + 1;
                        const dataIndex = index * len + 1;
                        for (let i = 0; i < objectInfluences.length; i++) {
                            objectInfluences[i] = array[dataIndex + i]
                        }
                    }
                    raycast(raycaster, intersects) {
                        const matrixWorld = this.matrixWorld;
                        const raycastTimes = this.count;
                        _mesh$1.geometry = this.geometry;
                        _mesh$1.material = this.material;
                        if (_mesh$1.material === undefined) return;
                        if (this.boundingSphere === null) this.computeBoundingSphere();
                        _sphere$3.copy(this.boundingSphere);
                        _sphere$3.applyMatrix4(matrixWorld);
                        if (raycaster.ray.intersectsSphere(_sphere$3) === !1) return;
                        for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
                            this.getMatrixAt(instanceId, _instanceLocalMatrix);
                            _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
                            _mesh$1.matrixWorld = _instanceWorldMatrix;
                            _mesh$1.raycast(raycaster, _instanceIntersects);
                            for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
                                const intersect = _instanceIntersects[i];
                                intersect.instanceId = instanceId;
                                intersect.object = this;
                                intersects.push(intersect)
                            }
                            _instanceIntersects.length = 0
                        }
                    }
                    setColorAt(index, color) {
                        if (this.instanceColor === null) {
                            this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)
                        }
                        color.toArray(this.instanceColor.array, index * 3)
                    }
                    setMatrixAt(index, matrix) {
                        matrix.toArray(this.instanceMatrix.array, index * 16)
                    }
                    setMorphAt(index, object) {
                        const objectInfluences = object.morphTargetInfluences;
                        const len = objectInfluences.length + 1;
                        if (this.morphTexture === null) {
                            this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType)
                        }
                        const array = this.morphTexture.source.data.data;
                        let morphInfluencesSum = 0;
                        for (let i = 0; i < objectInfluences.length; i++) {
                            morphInfluencesSum += objectInfluences[i]
                        }
                        const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
                        const dataIndex = len * index;
                        array[dataIndex] = morphBaseInfluence;
                        array.set(objectInfluences, dataIndex + 1)
                    }
                    updateMorphTargets() {}
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                        if (this.morphTexture !== null) {
                            this.morphTexture.dispose();
                            this.morphTexture = null
                        }
                        return this
                    }
                }

                function sortOpaque(a, b) {
                    return a.z - b.z
                }

                function sortTransparent(a, b) {
                    return b.z - a.z
                }
                class MultiDrawRenderList {
                    constructor() {
                        this.index = 0;
                        this.pool = [];
                        this.list = []
                    }
                    push(drawRange, z, index) {
                        const pool = this.pool;
                        const list = this.list;
                        if (this.index >= pool.length) {
                            pool.push({
                                start: -1,
                                count: -1,
                                z: -1,
                                index: -1,
                            })
                        }
                        const item = pool[this.index];
                        list.push(item);
                        this.index++;
                        item.start = drawRange.start;
                        item.count = drawRange.count;
                        item.z = z;
                        item.index = index
                    }
                    reset() {
                        this.list.length = 0;
                        this.index = 0
                    }
                }
                const _matrix$1 = new Matrix4();
                const _invMatrixWorld = new Matrix4();
                const _identityMatrix = new Matrix4();
                const _whiteColor = new Color(1, 1, 1);
                const _projScreenMatrix$2 = new Matrix4();
                const _frustum = new Frustum();
                const _box$1 = new Box3();
                const _sphere$2 = new Sphere();
                const _vector$5 = new Vector3();
                const _forward = new Vector3();
                const _temp = new Vector3();
                const _renderList = new MultiDrawRenderList();
                const _mesh = new Mesh();
                const _batchIntersects = [];

                function copyAttributeData(src, target, targetOffset = 0) {
                    const itemSize = target.itemSize;
                    if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
                        const vertexCount = src.count;
                        for (let i = 0; i < vertexCount; i++) {
                            for (let c = 0; c < itemSize; c++) {
                                target.setComponent(i + targetOffset, c, src.getComponent(i, c))
                            }
                        }
                    } else {
                        target.array.set(src.array, targetOffset * itemSize)
                    }
                    target.needsUpdate = !0
                }
                class BatchedMesh extends Mesh {
                    get maxInstanceCount() {
                        return this._maxInstanceCount
                    }
                    constructor(maxInstanceCount, maxVertexCount, maxIndexCount = maxVertexCount * 2, material) {
                        super(new BufferGeometry(), material);
                        this.isBatchedMesh = !0;
                        this.perObjectFrustumCulled = !0;
                        this.sortObjects = !0;
                        this.boundingBox = null;
                        this.boundingSphere = null;
                        this.customSort = null;
                        this._drawInfo = [];
                        this._drawRanges = [];
                        this._reservedRanges = [];
                        this._bounds = [];
                        this._maxInstanceCount = maxInstanceCount;
                        this._maxVertexCount = maxVertexCount;
                        this._maxIndexCount = maxIndexCount;
                        this._geometryInitialized = !1;
                        this._geometryCount = 0;
                        this._multiDrawCounts = new Int32Array(maxInstanceCount);
                        this._multiDrawStarts = new Int32Array(maxInstanceCount);
                        this._multiDrawCount = 0;
                        this._multiDrawInstances = null;
                        this._visibilityChanged = !0;
                        this._matricesTexture = null;
                        this._indirectTexture = null;
                        this._colorsTexture = null;
                        this._initMatricesTexture();
                        this._initIndirectTexture()
                    }
                    _initMatricesTexture() {
                        let size = Math.sqrt(this._maxInstanceCount * 4);
                        size = Math.ceil(size / 4) * 4;
                        size = Math.max(size, 4);
                        const matricesArray = new Float32Array(size * size * 4);
                        const matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
                        this._matricesTexture = matricesTexture
                    }
                    _initIndirectTexture() {
                        let size = Math.sqrt(this._maxInstanceCount);
                        size = Math.ceil(size);
                        const indirectArray = new Uint32Array(size * size);
                        const indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
                        this._indirectTexture = indirectTexture
                    }
                    _initColorsTexture() {
                        let size = Math.sqrt(this._maxIndexCount);
                        size = Math.ceil(size);
                        const colorsArray = new Float32Array(size * size * 4).fill(1);
                        const colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
                        colorsTexture.colorSpace = ColorManagement.workingColorSpace;
                        this._colorsTexture = colorsTexture
                    }
                    _initializeGeometry(reference) {
                        const geometry = this.geometry;
                        const maxVertexCount = this._maxVertexCount;
                        const maxIndexCount = this._maxIndexCount;
                        if (this._geometryInitialized === !1) {
                            for (const attributeName in reference.attributes) {
                                const srcAttribute = reference.getAttribute(attributeName);
                                const {
                                    array,
                                    itemSize,
                                    normalized
                                } = srcAttribute;
                                const dstArray = new array.constructor(maxVertexCount * itemSize);
                                const dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
                                geometry.setAttribute(attributeName, dstAttribute)
                            }
                            if (reference.getIndex() !== null) {
                                const indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
                                geometry.setIndex(new BufferAttribute(indexArray, 1))
                            }
                            this._geometryInitialized = !0
                        }
                    }
                    _validateGeometry(geometry) {
                        const batchGeometry = this.geometry;
                        if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
                            throw new Error('BatchedMesh: All geometries must consistently have "index".')
                        }
                        for (const attributeName in batchGeometry.attributes) {
                            if (!geometry.hasAttribute(attributeName)) {
                                throw new Error(`BatchedMesh: Added geometry missing "${ attributeName }". All geometries must have consistent attributes.`)
                            }
                            const srcAttribute = geometry.getAttribute(attributeName);
                            const dstAttribute = batchGeometry.getAttribute(attributeName);
                            if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
                                throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.')
                            }
                        }
                    }
                    setCustomSort(func) {
                        this.customSort = func;
                        return this
                    }
                    computeBoundingBox() {
                        if (this.boundingBox === null) {
                            this.boundingBox = new Box3()
                        }
                        const geometryCount = this._geometryCount;
                        const boundingBox = this.boundingBox;
                        const drawInfo = this._drawInfo;
                        boundingBox.makeEmpty();
                        for (let i = 0; i < geometryCount; i++) {
                            if (drawInfo[i].active === !1) continue;
                            const geometryId = drawInfo[i].geometryIndex;
                            this.getMatrixAt(i, _matrix$1);
                            this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
                            boundingBox.union(_box$1)
                        }
                    }
                    computeBoundingSphere() {
                        if (this.boundingSphere === null) {
                            this.boundingSphere = new Sphere()
                        }
                        const boundingSphere = this.boundingSphere;
                        const drawInfo = this._drawInfo;
                        boundingSphere.makeEmpty();
                        for (let i = 0, l = drawInfo.length; i < l; i++) {
                            if (drawInfo[i].active === !1) continue;
                            const geometryId = drawInfo[i].geometryIndex;
                            this.getMatrixAt(i, _matrix$1);
                            this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                            boundingSphere.union(_sphere$2)
                        }
                    }
                    addInstance(geometryId) {
                        if (this._drawInfo.length >= this._maxInstanceCount) {
                            throw new Error('BatchedMesh: Maximum item count reached.')
                        }
                        this._drawInfo.push({
                            visible: !0,
                            active: !0,
                            geometryIndex: geometryId,
                        });
                        const drawId = this._drawInfo.length - 1;
                        const matricesTexture = this._matricesTexture;
                        const matricesArray = matricesTexture.image.data;
                        _identityMatrix.toArray(matricesArray, drawId * 16);
                        matricesTexture.needsUpdate = !0;
                        const colorsTexture = this._colorsTexture;
                        if (colorsTexture) {
                            _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
                            colorsTexture.needsUpdate = !0
                        }
                        return drawId
                    }
                    addGeometry(geometry, vertexCount = -1, indexCount = -1) {
                        this._initializeGeometry(geometry);
                        this._validateGeometry(geometry);
                        if (this._drawInfo.length >= this._maxInstanceCount) {
                            throw new Error('BatchedMesh: Maximum item count reached.')
                        }
                        const reservedRange = {
                            vertexStart: -1,
                            vertexCount: -1,
                            indexStart: -1,
                            indexCount: -1,
                        };
                        let lastRange = null;
                        const reservedRanges = this._reservedRanges;
                        const drawRanges = this._drawRanges;
                        const bounds = this._bounds;
                        if (this._geometryCount !== 0) {
                            lastRange = reservedRanges[reservedRanges.length - 1]
                        }
                        if (vertexCount === -1) {
                            reservedRange.vertexCount = geometry.getAttribute('position').count
                        } else {
                            reservedRange.vertexCount = vertexCount
                        }
                        if (lastRange === null) {
                            reservedRange.vertexStart = 0
                        } else {
                            reservedRange.vertexStart = lastRange.vertexStart + lastRange.vertexCount
                        }
                        const index = geometry.getIndex();
                        const hasIndex = index !== null;
                        if (hasIndex) {
                            if (indexCount === -1) {
                                reservedRange.indexCount = index.count
                            } else {
                                reservedRange.indexCount = indexCount
                            }
                            if (lastRange === null) {
                                reservedRange.indexStart = 0
                            } else {
                                reservedRange.indexStart = lastRange.indexStart + lastRange.indexCount
                            }
                        }
                        if (reservedRange.indexStart !== -1 && reservedRange.indexStart + reservedRange.indexCount > this._maxIndexCount || reservedRange.vertexStart + reservedRange.vertexCount > this._maxVertexCount) {
                            throw new Error('BatchedMesh: Reserved space request exceeds the maximum buffer size.')
                        }
                        const geometryId = this._geometryCount;
                        this._geometryCount++;
                        reservedRanges.push(reservedRange);
                        drawRanges.push({
                            start: hasIndex ? reservedRange.indexStart : reservedRange.vertexStart,
                            count: -1
                        });
                        bounds.push({
                            boxInitialized: !1,
                            box: new Box3(),
                            sphereInitialized: !1,
                            sphere: new Sphere()
                        });
                        this.setGeometryAt(geometryId, geometry);
                        return geometryId
                    }
                    setGeometryAt(geometryId, geometry) {
                        if (geometryId >= this._geometryCount) {
                            throw new Error('BatchedMesh: Maximum geometry count reached.')
                        }
                        this._validateGeometry(geometry);
                        const batchGeometry = this.geometry;
                        const hasIndex = batchGeometry.getIndex() !== null;
                        const dstIndex = batchGeometry.getIndex();
                        const srcIndex = geometry.getIndex();
                        const reservedRange = this._reservedRanges[geometryId];
                        if (hasIndex && srcIndex.count > reservedRange.indexCount || geometry.attributes.position.count > reservedRange.vertexCount) {
                            throw new Error('BatchedMesh: Reserved space not large enough for provided geometry.')
                        }
                        const vertexStart = reservedRange.vertexStart;
                        const vertexCount = reservedRange.vertexCount;
                        for (const attributeName in batchGeometry.attributes) {
                            const srcAttribute = geometry.getAttribute(attributeName);
                            const dstAttribute = batchGeometry.getAttribute(attributeName);
                            copyAttributeData(srcAttribute, dstAttribute, vertexStart);
                            const itemSize = srcAttribute.itemSize;
                            for (let i = srcAttribute.count, l = vertexCount; i < l; i++) {
                                const index = vertexStart + i;
                                for (let c = 0; c < itemSize; c++) {
                                    dstAttribute.setComponent(index, c, 0)
                                }
                            }
                            dstAttribute.needsUpdate = !0;
                            dstAttribute.addUpdateRange(vertexStart * itemSize, vertexCount * itemSize)
                        }
                        if (hasIndex) {
                            const indexStart = reservedRange.indexStart;
                            for (let i = 0; i < srcIndex.count; i++) {
                                dstIndex.setX(indexStart + i, vertexStart + srcIndex.getX(i))
                            }
                            for (let i = srcIndex.count, l = reservedRange.indexCount; i < l; i++) {
                                dstIndex.setX(indexStart + i, vertexStart)
                            }
                            dstIndex.needsUpdate = !0;
                            dstIndex.addUpdateRange(indexStart, reservedRange.indexCount)
                        }
                        const bound = this._bounds[geometryId];
                        if (geometry.boundingBox !== null) {
                            bound.box.copy(geometry.boundingBox);
                            bound.boxInitialized = !0
                        } else {
                            bound.boxInitialized = !1
                        }
                        if (geometry.boundingSphere !== null) {
                            bound.sphere.copy(geometry.boundingSphere);
                            bound.sphereInitialized = !0
                        } else {
                            bound.sphereInitialized = !1
                        }
                        const drawRange = this._drawRanges[geometryId];
                        const posAttr = geometry.getAttribute('position');
                        drawRange.count = hasIndex ? srcIndex.count : posAttr.count;
                        this._visibilityChanged = !0;
                        return geometryId
                    }
                    getBoundingBoxAt(geometryId, target) {
                        if (geometryId >= this._geometryCount) {
                            return null
                        }
                        const bound = this._bounds[geometryId];
                        const box = bound.box;
                        const geometry = this.geometry;
                        if (bound.boxInitialized === !1) {
                            box.makeEmpty();
                            const index = geometry.index;
                            const position = geometry.attributes.position;
                            const drawRange = this._drawRanges[geometryId];
                            for (let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                                let iv = i;
                                if (index) {
                                    iv = index.getX(iv)
                                }
                                box.expandByPoint(_vector$5.fromBufferAttribute(position, iv))
                            }
                            bound.boxInitialized = !0
                        }
                        target.copy(box);
                        return target
                    }
                    getBoundingSphereAt(geometryId, target) {
                        if (geometryId >= this._geometryCount) {
                            return null
                        }
                        const bound = this._bounds[geometryId];
                        const sphere = bound.sphere;
                        const geometry = this.geometry;
                        if (bound.sphereInitialized === !1) {
                            sphere.makeEmpty();
                            this.getBoundingBoxAt(geometryId, _box$1);
                            _box$1.getCenter(sphere.center);
                            const index = geometry.index;
                            const position = geometry.attributes.position;
                            const drawRange = this._drawRanges[geometryId];
                            let maxRadiusSq = 0;
                            for (let i = drawRange.start, l = drawRange.start + drawRange.count; i < l; i++) {
                                let iv = i;
                                if (index) {
                                    iv = index.getX(iv)
                                }
                                _vector$5.fromBufferAttribute(position, iv);
                                maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5))
                            }
                            sphere.radius = Math.sqrt(maxRadiusSq);
                            bound.sphereInitialized = !0
                        }
                        target.copy(sphere);
                        return target
                    }
                    setMatrixAt(instanceId, matrix) {
                        const drawInfo = this._drawInfo;
                        const matricesTexture = this._matricesTexture;
                        const matricesArray = this._matricesTexture.image.data;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1) {
                            return this
                        }
                        matrix.toArray(matricesArray, instanceId * 16);
                        matricesTexture.needsUpdate = !0;
                        return this
                    }
                    getMatrixAt(instanceId, matrix) {
                        const drawInfo = this._drawInfo;
                        const matricesArray = this._matricesTexture.image.data;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1) {
                            return null
                        }
                        return matrix.fromArray(matricesArray, instanceId * 16)
                    }
                    setColorAt(instanceId, color) {
                        if (this._colorsTexture === null) {
                            this._initColorsTexture()
                        }
                        const colorsTexture = this._colorsTexture;
                        const colorsArray = this._colorsTexture.image.data;
                        const drawInfo = this._drawInfo;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1) {
                            return this
                        }
                        color.toArray(colorsArray, instanceId * 4);
                        colorsTexture.needsUpdate = !0;
                        return this
                    }
                    getColorAt(instanceId, color) {
                        const colorsArray = this._colorsTexture.image.data;
                        const drawInfo = this._drawInfo;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1) {
                            return null
                        }
                        return color.fromArray(colorsArray, instanceId * 4)
                    }
                    setVisibleAt(instanceId, value) {
                        const drawInfo = this._drawInfo;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1 || drawInfo[instanceId].visible === value) {
                            return this
                        }
                        drawInfo[instanceId].visible = value;
                        this._visibilityChanged = !0;
                        return this
                    }
                    getVisibleAt(instanceId) {
                        const drawInfo = this._drawInfo;
                        if (instanceId >= drawInfo.length || drawInfo[instanceId].active === !1) {
                            return !1
                        }
                        return drawInfo[instanceId].visible
                    }
                    raycast(raycaster, intersects) {
                        const drawInfo = this._drawInfo;
                        const drawRanges = this._drawRanges;
                        const matrixWorld = this.matrixWorld;
                        const batchGeometry = this.geometry;
                        _mesh.material = this.material;
                        _mesh.geometry.index = batchGeometry.index;
                        _mesh.geometry.attributes = batchGeometry.attributes;
                        if (_mesh.geometry.boundingBox === null) {
                            _mesh.geometry.boundingBox = new Box3()
                        }
                        if (_mesh.geometry.boundingSphere === null) {
                            _mesh.geometry.boundingSphere = new Sphere()
                        }
                        for (let i = 0, l = drawInfo.length; i < l; i++) {
                            if (!drawInfo[i].visible || !drawInfo[i].active) {
                                continue
                            }
                            const geometryId = drawInfo[i].geometryIndex;
                            const drawRange = drawRanges[geometryId];
                            _mesh.geometry.setDrawRange(drawRange.start, drawRange.count);
                            this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
                            this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
                            this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
                            _mesh.raycast(raycaster, _batchIntersects);
                            for (let j = 0, l = _batchIntersects.length; j < l; j++) {
                                const intersect = _batchIntersects[j];
                                intersect.object = this;
                                intersect.batchId = i;
                                intersects.push(intersect)
                            }
                            _batchIntersects.length = 0
                        }
                        _mesh.material = null;
                        _mesh.geometry.index = null;
                        _mesh.geometry.attributes = {};
                        _mesh.geometry.setDrawRange(0, Infinity)
                    }
                    copy(source) {
                        super.copy(source);
                        this.geometry = source.geometry.clone();
                        this.perObjectFrustumCulled = source.perObjectFrustumCulled;
                        this.sortObjects = source.sortObjects;
                        this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
                        this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
                        this._drawRanges = source._drawRanges.map(range => ({ ...range
                        }));
                        this._reservedRanges = source._reservedRanges.map(range => ({ ...range
                        }));
                        this._drawInfo = source._drawInfo.map(inf => ({ ...inf
                        }));
                        this._bounds = source._bounds.map(bound => ({
                            boxInitialized: bound.boxInitialized,
                            box: bound.box.clone(),
                            sphereInitialized: bound.sphereInitialized,
                            sphere: bound.sphere.clone()
                        }));
                        this._maxInstanceCount = source._maxInstanceCount;
                        this._maxVertexCount = source._maxVertexCount;
                        this._maxIndexCount = source._maxIndexCount;
                        this._geometryInitialized = source._geometryInitialized;
                        this._geometryCount = source._geometryCount;
                        this._multiDrawCounts = source._multiDrawCounts.slice();
                        this._multiDrawStarts = source._multiDrawStarts.slice();
                        this._matricesTexture = source._matricesTexture.clone();
                        this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
                        if (this._colorsTexture !== null) {
                            this._colorsTexture = source._colorsTexture.clone();
                            this._colorsTexture.image.data = this._colorsTexture.image.data.slice()
                        }
                        return this
                    }
                    dispose() {
                        this.geometry.dispose();
                        this._matricesTexture.dispose();
                        this._matricesTexture = null;
                        this._indirectTexture.dispose();
                        this._indirectTexture = null;
                        if (this._colorsTexture !== null) {
                            this._colorsTexture.dispose();
                            this._colorsTexture = null
                        }
                        return this
                    }
                    onBeforeRender(renderer, scene, camera, geometry, material) {
                        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
                            return
                        }
                        const index = geometry.getIndex();
                        const bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
                        const drawInfo = this._drawInfo;
                        const multiDrawStarts = this._multiDrawStarts;
                        const multiDrawCounts = this._multiDrawCounts;
                        const drawRanges = this._drawRanges;
                        const perObjectFrustumCulled = this.perObjectFrustumCulled;
                        const indirectTexture = this._indirectTexture;
                        const indirectArray = indirectTexture.image.data;
                        if (perObjectFrustumCulled) {
                            _projScreenMatrix$2
                                .multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
                            _frustum.setFromProjectionMatrix(_projScreenMatrix$2, renderer.coordinateSystem)
                        }
                        let count = 0;
                        if (this.sortObjects) {
                            _invMatrixWorld.copy(this.matrixWorld).invert();
                            _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_invMatrixWorld);
                            _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_invMatrixWorld);
                            for (let i = 0, l = drawInfo.length; i < l; i++) {
                                if (drawInfo[i].visible && drawInfo[i].active) {
                                    const geometryId = drawInfo[i].geometryIndex;
                                    this.getMatrixAt(i, _matrix$1);
                                    this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                                    let culled = !1;
                                    if (perObjectFrustumCulled) {
                                        culled = !_frustum.intersectsSphere(_sphere$2)
                                    }
                                    if (!culled) {
                                        const z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
                                        _renderList.push(drawRanges[geometryId], z, i)
                                    }
                                }
                            }
                            const list = _renderList.list;
                            const customSort = this.customSort;
                            if (customSort === null) {
                                list.sort(material.transparent ? sortTransparent : sortOpaque)
                            } else {
                                customSort.call(this, list, camera)
                            }
                            for (let i = 0, l = list.length; i < l; i++) {
                                const item = list[i];
                                multiDrawStarts[count] = item.start * bytesPerElement;
                                multiDrawCounts[count] = item.count;
                                indirectArray[count] = item.index;
                                count++
                            }
                            _renderList.reset()
                        } else {
                            for (let i = 0, l = drawInfo.length; i < l; i++) {
                                if (drawInfo[i].visible && drawInfo[i].active) {
                                    const geometryId = drawInfo[i].geometryIndex;
                                    let culled = !1;
                                    if (perObjectFrustumCulled) {
                                        this.getMatrixAt(i, _matrix$1);
                                        this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
                                        culled = !_frustum.intersectsSphere(_sphere$2)
                                    }
                                    if (!culled) {
                                        const range = drawRanges[geometryId];
                                        multiDrawStarts[count] = range.start * bytesPerElement;
                                        multiDrawCounts[count] = range.count;
                                        indirectArray[count] = i;
                                        count++
                                    }
                                }
                            }
                        }
                        indirectTexture.needsUpdate = !0;
                        this._multiDrawCount = count;
                        this._visibilityChanged = !1
                    }
                    onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial) {
                        this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial)
                    }
                }
                class LineBasicMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isLineBasicMaterial = !0;
                        this.type = 'LineBasicMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.linewidth = 1;
                        this.linecap = 'round';
                        this.linejoin = 'round';
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.linewidth = source.linewidth;
                        this.linecap = source.linecap;
                        this.linejoin = source.linejoin;
                        this.fog = source.fog;
                        return this
                    }
                }
                const _vStart = new Vector3();
                const _vEnd = new Vector3();
                const _inverseMatrix$1 = new Matrix4();
                const _ray$1 = new Ray();
                const _sphere$1 = new Sphere();
                const _intersectPointOnRay = new Vector3();
                const _intersectPointOnSegment = new Vector3();
                class Line extends Object3D {
                    constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
                        super();
                        this.isLine = !0;
                        this.type = 'Line';
                        this.geometry = geometry;
                        this.material = material;
                        this.updateMorphTargets()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
                        this.geometry = source.geometry;
                        return this
                    }
                    computeLineDistances() {
                        const geometry = this.geometry;
                        if (geometry.index === null) {
                            const positionAttribute = geometry.attributes.position;
                            const lineDistances = [0];
                            for (let i = 1, l = positionAttribute.count; i < l; i++) {
                                _vStart.fromBufferAttribute(positionAttribute, i - 1);
                                _vEnd.fromBufferAttribute(positionAttribute, i);
                                lineDistances[i] = lineDistances[i - 1];
                                lineDistances[i] += _vStart.distanceTo(_vEnd)
                            }
                            geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1))
                        } else {
                            console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.')
                        }
                        return this
                    }
                    raycast(raycaster, intersects) {
                        const geometry = this.geometry;
                        const matrixWorld = this.matrixWorld;
                        const threshold = raycaster.params.Line.threshold;
                        const drawRange = geometry.drawRange;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        _sphere$1.copy(geometry.boundingSphere);
                        _sphere$1.applyMatrix4(matrixWorld);
                        _sphere$1.radius += threshold;
                        if (raycaster.ray.intersectsSphere(_sphere$1) === !1) return;
                        _inverseMatrix$1.copy(matrixWorld).invert();
                        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
                        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                        const localThresholdSq = localThreshold * localThreshold;
                        const step = this.isLineSegments ? 2 : 1;
                        const index = geometry.index;
                        const attributes = geometry.attributes;
                        const positionAttribute = attributes.position;
                        if (index !== null) {
                            const start = Math.max(0, drawRange.start);
                            const end = Math.min(index.count, (drawRange.start + drawRange.count));
                            for (let i = start, l = end - 1; i < l; i += step) {
                                const a = index.getX(i);
                                const b = index.getX(i + 1);
                                const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
                                if (intersect) {
                                    intersects.push(intersect)
                                }
                            }
                            if (this.isLineLoop) {
                                const a = index.getX(end - 1);
                                const b = index.getX(start);
                                const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
                                if (intersect) {
                                    intersects.push(intersect)
                                }
                            }
                        } else {
                            const start = Math.max(0, drawRange.start);
                            const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                            for (let i = start, l = end - 1; i < l; i += step) {
                                const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i, i + 1);
                                if (intersect) {
                                    intersects.push(intersect)
                                }
                            }
                            if (this.isLineLoop) {
                                const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start);
                                if (intersect) {
                                    intersects.push(intersect)
                                }
                            }
                        }
                    }
                    updateMorphTargets() {
                        const geometry = this.geometry;
                        const morphAttributes = geometry.morphAttributes;
                        const keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            const morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    const name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m
                                }
                            }
                        }
                    }
                }

                function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
                    const positionAttribute = object.geometry.attributes.position;
                    _vStart.fromBufferAttribute(positionAttribute, a);
                    _vEnd.fromBufferAttribute(positionAttribute, b);
                    const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
                    if (distSq > thresholdSq) return;
                    _intersectPointOnRay.applyMatrix4(object.matrixWorld);
                    const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
                    if (distance < raycaster.near || distance > raycaster.far) return;
                    return {
                        distance: distance,
                        point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
                        index: a,
                        face: null,
                        faceIndex: null,
                        object: object
                    }
                }
                const _start = new Vector3();
                const _end = new Vector3();
                class LineSegments extends Line {
                    constructor(geometry, material) {
                        super(geometry, material);
                        this.isLineSegments = !0;
                        this.type = 'LineSegments'
                    }
                    computeLineDistances() {
                        const geometry = this.geometry;
                        if (geometry.index === null) {
                            const positionAttribute = geometry.attributes.position;
                            const lineDistances = [];
                            for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
                                _start.fromBufferAttribute(positionAttribute, i);
                                _end.fromBufferAttribute(positionAttribute, i + 1);
                                lineDistances[i] = (i === 0) ? 0 : lineDistances[i - 1];
                                lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end)
                            }
                            geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1))
                        } else {
                            console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.')
                        }
                        return this
                    }
                }
                class LineLoop extends Line {
                    constructor(geometry, material) {
                        super(geometry, material);
                        this.isLineLoop = !0;
                        this.type = 'LineLoop'
                    }
                }
                class PointsMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isPointsMaterial = !0;
                        this.type = 'PointsMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.alphaMap = null;
                        this.size = 1;
                        this.sizeAttenuation = !0;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.alphaMap = source.alphaMap;
                        this.size = source.size;
                        this.sizeAttenuation = source.sizeAttenuation;
                        this.fog = source.fog;
                        return this
                    }
                }
                const _inverseMatrix = new Matrix4();
                const _ray = new Ray();
                const _sphere = new Sphere();
                const _position$2 = new Vector3();
                class Points extends Object3D {
                    constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
                        super();
                        this.isPoints = !0;
                        this.type = 'Points';
                        this.geometry = geometry;
                        this.material = material;
                        this.updateMorphTargets()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
                        this.geometry = source.geometry;
                        return this
                    }
                    raycast(raycaster, intersects) {
                        const geometry = this.geometry;
                        const matrixWorld = this.matrixWorld;
                        const threshold = raycaster.params.Points.threshold;
                        const drawRange = geometry.drawRange;
                        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                        _sphere.copy(geometry.boundingSphere);
                        _sphere.applyMatrix4(matrixWorld);
                        _sphere.radius += threshold;
                        if (raycaster.ray.intersectsSphere(_sphere) === !1) return;
                        _inverseMatrix.copy(matrixWorld).invert();
                        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
                        const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
                        const localThresholdSq = localThreshold * localThreshold;
                        const index = geometry.index;
                        const attributes = geometry.attributes;
                        const positionAttribute = attributes.position;
                        if (index !== null) {
                            const start = Math.max(0, drawRange.start);
                            const end = Math.min(index.count, (drawRange.start + drawRange.count));
                            for (let i = start, il = end; i < il; i++) {
                                const a = index.getX(i);
                                _position$2.fromBufferAttribute(positionAttribute, a);
                                testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this)
                            }
                        } else {
                            const start = Math.max(0, drawRange.start);
                            const end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                            for (let i = start, l = end; i < l; i++) {
                                _position$2.fromBufferAttribute(positionAttribute, i);
                                testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this)
                            }
                        }
                    }
                    updateMorphTargets() {
                        const geometry = this.geometry;
                        const morphAttributes = geometry.morphAttributes;
                        const keys = Object.keys(morphAttributes);
                        if (keys.length > 0) {
                            const morphAttribute = morphAttributes[keys[0]];
                            if (morphAttribute !== undefined) {
                                this.morphTargetInfluences = [];
                                this.morphTargetDictionary = {};
                                for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
                                    const name = morphAttribute[m].name || String(m);
                                    this.morphTargetInfluences.push(0);
                                    this.morphTargetDictionary[name] = m
                                }
                            }
                        }
                    }
                }

                function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
                    const rayPointDistanceSq = _ray.distanceSqToPoint(point);
                    if (rayPointDistanceSq < localThresholdSq) {
                        const intersectPoint = new Vector3();
                        _ray.closestPointToPoint(point, intersectPoint);
                        intersectPoint.applyMatrix4(matrixWorld);
                        const distance = raycaster.ray.origin.distanceTo(intersectPoint);
                        if (distance < raycaster.near || distance > raycaster.far) return;
                        intersects.push({
                            distance: distance,
                            distanceToRay: Math.sqrt(rayPointDistanceSq),
                            point: intersectPoint,
                            index: index,
                            face: null,
                            object: object
                        })
                    }
                }
                class VideoTexture extends Texture {
                    constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                        super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                        this.isVideoTexture = !0;
                        this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
                        this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
                        this.generateMipmaps = !1;
                        const scope = this;

                        function updateVideo() {
                            scope.needsUpdate = !0;
                            video.requestVideoFrameCallback(updateVideo)
                        }
                        if ('requestVideoFrameCallback' in video) {
                            video.requestVideoFrameCallback(updateVideo)
                        }
                    }
                    clone() {
                        return new this.constructor(this.image).copy(this)
                    }
                    update() {
                        const video = this.image;
                        const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
                        if (hasVideoFrameCallback === !1 && video.readyState >= video.HAVE_CURRENT_DATA) {
                            this.needsUpdate = !0
                        }
                    }
                }
                class FramebufferTexture extends Texture {
                    constructor(width, height) {
                        super({
                            width,
                            height
                        });
                        this.isFramebufferTexture = !0;
                        this.magFilter = NearestFilter;
                        this.minFilter = NearestFilter;
                        this.generateMipmaps = !1;
                        this.needsUpdate = !0
                    }
                }
                class CompressedTexture extends Texture {
                    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
                        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
                        this.isCompressedTexture = !0;
                        this.image = {
                            width: width,
                            height: height
                        };
                        this.mipmaps = mipmaps;
                        this.flipY = !1;
                        this.generateMipmaps = !1
                    }
                }
                class CompressedArrayTexture extends CompressedTexture {
                    constructor(mipmaps, width, height, depth, format, type) {
                        super(mipmaps, width, height, format, type);
                        this.isCompressedArrayTexture = !0;
                        this.image.depth = depth;
                        this.wrapR = ClampToEdgeWrapping;
                        this.layerUpdates = new Set()
                    }
                    addLayerUpdate(layerIndex) {
                        this.layerUpdates.add(layerIndex)
                    }
                    clearLayerUpdates() {
                        this.layerUpdates.clear()
                    }
                }
                class CompressedCubeTexture extends CompressedTexture {
                    constructor(images, format, type) {
                        super(undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping);
                        this.isCompressedCubeTexture = !0;
                        this.isCubeTexture = !0;
                        this.image = images
                    }
                }
                class CanvasTexture extends Texture {
                    constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
                        super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
                        this.isCanvasTexture = !0;
                        this.needsUpdate = !0
                    }
                }
                class Curve {
                    constructor() {
                        this.type = 'Curve';
                        this.arcLengthDivisions = 200
                    }
                    getPoint() {
                        console.warn('THREE.Curve: .getPoint() not implemented.');
                        return null
                    }
                    getPointAt(u, optionalTarget) {
                        const t = this.getUtoTmapping(u);
                        return this.getPoint(t, optionalTarget)
                    }
                    getPoints(divisions = 5) {
                        const points = [];
                        for (let d = 0; d <= divisions; d++) {
                            points.push(this.getPoint(d / divisions))
                        }
                        return points
                    }
                    getSpacedPoints(divisions = 5) {
                        const points = [];
                        for (let d = 0; d <= divisions; d++) {
                            points.push(this.getPointAt(d / divisions))
                        }
                        return points
                    }
                    getLength() {
                        const lengths = this.getLengths();
                        return lengths[lengths.length - 1]
                    }
                    getLengths(divisions = this.arcLengthDivisions) {
                        if (this.cacheArcLengths && (this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate) {
                            return this.cacheArcLengths
                        }
                        this.needsUpdate = !1;
                        const cache = [];
                        let current, last = this.getPoint(0);
                        let sum = 0;
                        cache.push(0);
                        for (let p = 1; p <= divisions; p++) {
                            current = this.getPoint(p / divisions);
                            sum += current.distanceTo(last);
                            cache.push(sum);
                            last = current
                        }
                        this.cacheArcLengths = cache;
                        return cache
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0;
                        this.getLengths()
                    }
                    getUtoTmapping(u, distance) {
                        const arcLengths = this.getLengths();
                        let i = 0;
                        const il = arcLengths.length;
                        let targetArcLength;
                        if (distance) {
                            targetArcLength = distance
                        } else {
                            targetArcLength = u * arcLengths[il - 1]
                        }
                        let low = 0,
                            high = il - 1,
                            comparison;
                        while (low <= high) {
                            i = Math.floor(low + (high - low) / 2);
                            comparison = arcLengths[i] - targetArcLength;
                            if (comparison < 0) {
                                low = i + 1
                            } else if (comparison > 0) {
                                high = i - 1
                            } else {
                                high = i;
                                break
                            }
                        }
                        i = high;
                        if (arcLengths[i] === targetArcLength) {
                            return i / (il - 1)
                        }
                        const lengthBefore = arcLengths[i];
                        const lengthAfter = arcLengths[i + 1];
                        const segmentLength = lengthAfter - lengthBefore;
                        const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
                        const t = (i + segmentFraction) / (il - 1);
                        return t
                    }
                    getTangent(t, optionalTarget) {
                        const delta = 0.0001;
                        let t1 = t - delta;
                        let t2 = t + delta;
                        if (t1 < 0) t1 = 0;
                        if (t2 > 1) t2 = 1;
                        const pt1 = this.getPoint(t1);
                        const pt2 = this.getPoint(t2);
                        const tangent = optionalTarget || ((pt1.isVector2) ? new Vector2() : new Vector3());
                        tangent.copy(pt2).sub(pt1).normalize();
                        return tangent
                    }
                    getTangentAt(u, optionalTarget) {
                        const t = this.getUtoTmapping(u);
                        return this.getTangent(t, optionalTarget)
                    }
                    computeFrenetFrames(segments, closed) {
                        const normal = new Vector3();
                        const tangents = [];
                        const normals = [];
                        const binormals = [];
                        const vec = new Vector3();
                        const mat = new Matrix4();
                        for (let i = 0; i <= segments; i++) {
                            const u = i / segments;
                            tangents[i] = this.getTangentAt(u, new Vector3())
                        }
                        normals[0] = new Vector3();
                        binormals[0] = new Vector3();
                        let min = Number.MAX_VALUE;
                        const tx = Math.abs(tangents[0].x);
                        const ty = Math.abs(tangents[0].y);
                        const tz = Math.abs(tangents[0].z);
                        if (tx <= min) {
                            min = tx;
                            normal.set(1, 0, 0)
                        }
                        if (ty <= min) {
                            min = ty;
                            normal.set(0, 1, 0)
                        }
                        if (tz <= min) {
                            normal.set(0, 0, 1)
                        }
                        vec.crossVectors(tangents[0], normal).normalize();
                        normals[0].crossVectors(tangents[0], vec);
                        binormals[0].crossVectors(tangents[0], normals[0]);
                        for (let i = 1; i <= segments; i++) {
                            normals[i] = normals[i - 1].clone();
                            binormals[i] = binormals[i - 1].clone();
                            vec.crossVectors(tangents[i - 1], tangents[i]);
                            if (vec.length() > Number.EPSILON) {
                                vec.normalize();
                                const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
                                normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))
                            }
                            binormals[i].crossVectors(tangents[i], normals[i])
                        }
                        if (closed === !0) {
                            let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
                            theta /= segments;
                            if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
                                theta = -theta
                            }
                            for (let i = 1; i <= segments; i++) {
                                normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
                                binormals[i].crossVectors(tangents[i], normals[i])
                            }
                        }
                        return {
                            tangents: tangents,
                            normals: normals,
                            binormals: binormals
                        }
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(source) {
                        this.arcLengthDivisions = source.arcLengthDivisions;
                        return this
                    }
                    toJSON() {
                        const data = {
                            metadata: {
                                version: 4.6,
                                type: 'Curve',
                                generator: 'Curve.toJSON'
                            }
                        };
                        data.arcLengthDivisions = this.arcLengthDivisions;
                        data.type = this.type;
                        return data
                    }
                    fromJSON(json) {
                        this.arcLengthDivisions = json.arcLengthDivisions;
                        return this
                    }
                }
                class EllipseCurve extends Curve {
                    constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = !1, aRotation = 0) {
                        super();
                        this.isEllipseCurve = !0;
                        this.type = 'EllipseCurve';
                        this.aX = aX;
                        this.aY = aY;
                        this.xRadius = xRadius;
                        this.yRadius = yRadius;
                        this.aStartAngle = aStartAngle;
                        this.aEndAngle = aEndAngle;
                        this.aClockwise = aClockwise;
                        this.aRotation = aRotation
                    }
                    getPoint(t, optionalTarget = new Vector2()) {
                        const point = optionalTarget;
                        const twoPi = Math.PI * 2;
                        let deltaAngle = this.aEndAngle - this.aStartAngle;
                        const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
                        while (deltaAngle < 0) deltaAngle += twoPi;
                        while (deltaAngle > twoPi) deltaAngle -= twoPi;
                        if (deltaAngle < Number.EPSILON) {
                            if (samePoints) {
                                deltaAngle = 0
                            } else {
                                deltaAngle = twoPi
                            }
                        }
                        if (this.aClockwise === !0 && !samePoints) {
                            if (deltaAngle === twoPi) {
                                deltaAngle = -twoPi
                            } else {
                                deltaAngle = deltaAngle - twoPi
                            }
                        }
                        const angle = this.aStartAngle + t * deltaAngle;
                        let x = this.aX + this.xRadius * Math.cos(angle);
                        let y = this.aY + this.yRadius * Math.sin(angle);
                        if (this.aRotation !== 0) {
                            const cos = Math.cos(this.aRotation);
                            const sin = Math.sin(this.aRotation);
                            const tx = x - this.aX;
                            const ty = y - this.aY;
                            x = tx * cos - ty * sin + this.aX;
                            y = tx * sin + ty * cos + this.aY
                        }
                        return point.set(x, y)
                    }
                    copy(source) {
                        super.copy(source);
                        this.aX = source.aX;
                        this.aY = source.aY;
                        this.xRadius = source.xRadius;
                        this.yRadius = source.yRadius;
                        this.aStartAngle = source.aStartAngle;
                        this.aEndAngle = source.aEndAngle;
                        this.aClockwise = source.aClockwise;
                        this.aRotation = source.aRotation;
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.aX = this.aX;
                        data.aY = this.aY;
                        data.xRadius = this.xRadius;
                        data.yRadius = this.yRadius;
                        data.aStartAngle = this.aStartAngle;
                        data.aEndAngle = this.aEndAngle;
                        data.aClockwise = this.aClockwise;
                        data.aRotation = this.aRotation;
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.aX = json.aX;
                        this.aY = json.aY;
                        this.xRadius = json.xRadius;
                        this.yRadius = json.yRadius;
                        this.aStartAngle = json.aStartAngle;
                        this.aEndAngle = json.aEndAngle;
                        this.aClockwise = json.aClockwise;
                        this.aRotation = json.aRotation;
                        return this
                    }
                }
                class ArcCurve extends EllipseCurve {
                    constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
                        this.isArcCurve = !0;
                        this.type = 'ArcCurve'
                    }
                }

                function CubicPoly() {
                    let c0 = 0,
                        c1 = 0,
                        c2 = 0,
                        c3 = 0;

                    function init(x0, x1, t0, t1) {
                        c0 = x0;
                        c1 = t0;
                        c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
                        c3 = 2 * x0 - 2 * x1 + t0 + t1
                    }
                    return {
                        initCatmullRom: function(x0, x1, x2, x3, tension) {
                            init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))
                        },
                        initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
                            let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
                            let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
                            t1 *= dt1;
                            t2 *= dt1;
                            init(x1, x2, t1, t2)
                        },
                        calc: function(t) {
                            const t2 = t * t;
                            const t3 = t2 * t;
                            return c0 + c1 * t + c2 * t2 + c3 * t3
                        }
                    }
                }
                const tmp = new Vector3();
                const px = new CubicPoly();
                const py = new CubicPoly();
                const pz = new CubicPoly();
                class CatmullRomCurve3 extends Curve {
                    constructor(points = [], closed = !1, curveType = 'centripetal', tension = 0.5) {
                        super();
                        this.isCatmullRomCurve3 = !0;
                        this.type = 'CatmullRomCurve3';
                        this.points = points;
                        this.closed = closed;
                        this.curveType = curveType;
                        this.tension = tension
                    }
                    getPoint(t, optionalTarget = new Vector3()) {
                        const point = optionalTarget;
                        const points = this.points;
                        const l = points.length;
                        const p = (l - (this.closed ? 0 : 1)) * t;
                        let intPoint = Math.floor(p);
                        let weight = p - intPoint;
                        if (this.closed) {
                            intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l
                        } else if (weight === 0 && intPoint === l - 1) {
                            intPoint = l - 2;
                            weight = 1
                        }
                        let p0, p3;
                        if (this.closed || intPoint > 0) {
                            p0 = points[(intPoint - 1) % l]
                        } else {
                            tmp.subVectors(points[0], points[1]).add(points[0]);
                            p0 = tmp
                        }
                        const p1 = points[intPoint % l];
                        const p2 = points[(intPoint + 1) % l];
                        if (this.closed || intPoint + 2 < l) {
                            p3 = points[(intPoint + 2) % l]
                        } else {
                            tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
                            p3 = tmp
                        }
                        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
                            const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
                            let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
                            let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
                            let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
                            if (dt1 < 1e-4) dt1 = 1.0;
                            if (dt0 < 1e-4) dt0 = dt1;
                            if (dt2 < 1e-4) dt2 = dt1;
                            px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
                            py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
                            pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2)
                        } else if (this.curveType === 'catmullrom') {
                            px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
                            py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
                            pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension)
                        }
                        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.points = [];
                        for (let i = 0, l = source.points.length; i < l; i++) {
                            const point = source.points[i];
                            this.points.push(point.clone())
                        }
                        this.closed = source.closed;
                        this.curveType = source.curveType;
                        this.tension = source.tension;
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.points = [];
                        for (let i = 0, l = this.points.length; i < l; i++) {
                            const point = this.points[i];
                            data.points.push(point.toArray())
                        }
                        data.closed = this.closed;
                        data.curveType = this.curveType;
                        data.tension = this.tension;
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.points = [];
                        for (let i = 0, l = json.points.length; i < l; i++) {
                            const point = json.points[i];
                            this.points.push(new Vector3().fromArray(point))
                        }
                        this.closed = json.closed;
                        this.curveType = json.curveType;
                        this.tension = json.tension;
                        return this
                    }
                }

                function CatmullRom(t, p0, p1, p2, p3) {
                    const v0 = (p2 - p0) * 0.5;
                    const v1 = (p3 - p1) * 0.5;
                    const t2 = t * t;
                    const t3 = t * t2;
                    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1
                }

                function QuadraticBezierP0(t, p) {
                    const k = 1 - t;
                    return k * k * p
                }

                function QuadraticBezierP1(t, p) {
                    return 2 * (1 - t) * t * p
                }

                function QuadraticBezierP2(t, p) {
                    return t * t * p
                }

                function QuadraticBezier(t, p0, p1, p2) {
                    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2)
                }

                function CubicBezierP0(t, p) {
                    const k = 1 - t;
                    return k * k * k * p
                }

                function CubicBezierP1(t, p) {
                    const k = 1 - t;
                    return 3 * k * k * t * p
                }

                function CubicBezierP2(t, p) {
                    return 3 * (1 - t) * t * t * p
                }

                function CubicBezierP3(t, p) {
                    return t * t * t * p
                }

                function CubicBezier(t, p0, p1, p2, p3) {
                    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3)
                }
                class CubicBezierCurve extends Curve {
                    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {
                        super();
                        this.isCubicBezierCurve = !0;
                        this.type = 'CubicBezierCurve';
                        this.v0 = v0;
                        this.v1 = v1;
                        this.v2 = v2;
                        this.v3 = v3
                    }
                    getPoint(t, optionalTarget = new Vector2()) {
                        const point = optionalTarget;
                        const v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2,
                            v3 = this.v3;
                        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        this.v3.copy(source.v3);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        data.v3 = this.v3.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        this.v3.fromArray(json.v3);
                        return this
                    }
                }
                class CubicBezierCurve3 extends Curve {
                    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {
                        super();
                        this.isCubicBezierCurve3 = !0;
                        this.type = 'CubicBezierCurve3';
                        this.v0 = v0;
                        this.v1 = v1;
                        this.v2 = v2;
                        this.v3 = v3
                    }
                    getPoint(t, optionalTarget = new Vector3()) {
                        const point = optionalTarget;
                        const v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2,
                            v3 = this.v3;
                        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        this.v3.copy(source.v3);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        data.v3 = this.v3.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        this.v3.fromArray(json.v3);
                        return this
                    }
                }
                class LineCurve extends Curve {
                    constructor(v1 = new Vector2(), v2 = new Vector2()) {
                        super();
                        this.isLineCurve = !0;
                        this.type = 'LineCurve';
                        this.v1 = v1;
                        this.v2 = v2
                    }
                    getPoint(t, optionalTarget = new Vector2()) {
                        const point = optionalTarget;
                        if (t === 1) {
                            point.copy(this.v2)
                        } else {
                            point.copy(this.v2).sub(this.v1);
                            point.multiplyScalar(t).add(this.v1)
                        }
                        return point
                    }
                    getPointAt(u, optionalTarget) {
                        return this.getPoint(u, optionalTarget)
                    }
                    getTangent(t, optionalTarget = new Vector2()) {
                        return optionalTarget.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(u, optionalTarget) {
                        return this.getTangent(u, optionalTarget)
                    }
                    copy(source) {
                        super.copy(source);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this
                    }
                }
                class LineCurve3 extends Curve {
                    constructor(v1 = new Vector3(), v2 = new Vector3()) {
                        super();
                        this.isLineCurve3 = !0;
                        this.type = 'LineCurve3';
                        this.v1 = v1;
                        this.v2 = v2
                    }
                    getPoint(t, optionalTarget = new Vector3()) {
                        const point = optionalTarget;
                        if (t === 1) {
                            point.copy(this.v2)
                        } else {
                            point.copy(this.v2).sub(this.v1);
                            point.multiplyScalar(t).add(this.v1)
                        }
                        return point
                    }
                    getPointAt(u, optionalTarget) {
                        return this.getPoint(u, optionalTarget)
                    }
                    getTangent(t, optionalTarget = new Vector3()) {
                        return optionalTarget.subVectors(this.v2, this.v1).normalize()
                    }
                    getTangentAt(u, optionalTarget) {
                        return this.getTangent(u, optionalTarget)
                    }
                    copy(source) {
                        super.copy(source);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this
                    }
                }
                class QuadraticBezierCurve extends Curve {
                    constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
                        super();
                        this.isQuadraticBezierCurve = !0;
                        this.type = 'QuadraticBezierCurve';
                        this.v0 = v0;
                        this.v1 = v1;
                        this.v2 = v2
                    }
                    getPoint(t, optionalTarget = new Vector2()) {
                        const point = optionalTarget;
                        const v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2;
                        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this
                    }
                }
                class QuadraticBezierCurve3 extends Curve {
                    constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
                        super();
                        this.isQuadraticBezierCurve3 = !0;
                        this.type = 'QuadraticBezierCurve3';
                        this.v0 = v0;
                        this.v1 = v1;
                        this.v2 = v2
                    }
                    getPoint(t, optionalTarget = new Vector3()) {
                        const point = optionalTarget;
                        const v0 = this.v0,
                            v1 = this.v1,
                            v2 = this.v2;
                        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.v0.copy(source.v0);
                        this.v1.copy(source.v1);
                        this.v2.copy(source.v2);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.v0 = this.v0.toArray();
                        data.v1 = this.v1.toArray();
                        data.v2 = this.v2.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.v0.fromArray(json.v0);
                        this.v1.fromArray(json.v1);
                        this.v2.fromArray(json.v2);
                        return this
                    }
                }
                class SplineCurve extends Curve {
                    constructor(points = []) {
                        super();
                        this.isSplineCurve = !0;
                        this.type = 'SplineCurve';
                        this.points = points
                    }
                    getPoint(t, optionalTarget = new Vector2()) {
                        const point = optionalTarget;
                        const points = this.points;
                        const p = (points.length - 1) * t;
                        const intPoint = Math.floor(p);
                        const weight = p - intPoint;
                        const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
                        const p1 = points[intPoint];
                        const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
                        const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
                        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
                        return point
                    }
                    copy(source) {
                        super.copy(source);
                        this.points = [];
                        for (let i = 0, l = source.points.length; i < l; i++) {
                            const point = source.points[i];
                            this.points.push(point.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.points = [];
                        for (let i = 0, l = this.points.length; i < l; i++) {
                            const point = this.points[i];
                            data.points.push(point.toArray())
                        }
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.points = [];
                        for (let i = 0, l = json.points.length; i < l; i++) {
                            const point = json.points[i];
                            this.points.push(new Vector2().fromArray(point))
                        }
                        return this
                    }
                }
                var Curves = Object.freeze({
                    __proto__: null,
                    ArcCurve: ArcCurve,
                    CatmullRomCurve3: CatmullRomCurve3,
                    CubicBezierCurve: CubicBezierCurve,
                    CubicBezierCurve3: CubicBezierCurve3,
                    EllipseCurve: EllipseCurve,
                    LineCurve: LineCurve,
                    LineCurve3: LineCurve3,
                    QuadraticBezierCurve: QuadraticBezierCurve,
                    QuadraticBezierCurve3: QuadraticBezierCurve3,
                    SplineCurve: SplineCurve
                });
                class CurvePath extends Curve {
                    constructor() {
                        super();
                        this.type = 'CurvePath';
                        this.curves = [];
                        this.autoClose = !1
                    }
                    add(curve) {
                        this.curves.push(curve)
                    }
                    closePath() {
                        const startPoint = this.curves[0].getPoint(0);
                        const endPoint = this.curves[this.curves.length - 1].getPoint(1);
                        if (!startPoint.equals(endPoint)) {
                            const lineType = (startPoint.isVector2 === !0) ? 'LineCurve' : 'LineCurve3';
                            this.curves.push(new Curves[lineType](endPoint, startPoint))
                        }
                        return this
                    }
                    getPoint(t, optionalTarget) {
                        const d = t * this.getLength();
                        const curveLengths = this.getCurveLengths();
                        let i = 0;
                        while (i < curveLengths.length) {
                            if (curveLengths[i] >= d) {
                                const diff = curveLengths[i] - d;
                                const curve = this.curves[i];
                                const segmentLength = curve.getLength();
                                const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
                                return curve.getPointAt(u, optionalTarget)
                            }
                            i++
                        }
                        return null
                    }
                    getLength() {
                        const lens = this.getCurveLengths();
                        return lens[lens.length - 1]
                    }
                    updateArcLengths() {
                        this.needsUpdate = !0;
                        this.cacheLengths = null;
                        this.getCurveLengths()
                    }
                    getCurveLengths() {
                        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
                            return this.cacheLengths
                        }
                        const lengths = [];
                        let sums = 0;
                        for (let i = 0, l = this.curves.length; i < l; i++) {
                            sums += this.curves[i].getLength();
                            lengths.push(sums)
                        }
                        this.cacheLengths = lengths;
                        return lengths
                    }
                    getSpacedPoints(divisions = 40) {
                        const points = [];
                        for (let i = 0; i <= divisions; i++) {
                            points.push(this.getPoint(i / divisions))
                        }
                        if (this.autoClose) {
                            points.push(points[0])
                        }
                        return points
                    }
                    getPoints(divisions = 12) {
                        const points = [];
                        let last;
                        for (let i = 0, curves = this.curves; i < curves.length; i++) {
                            const curve = curves[i];
                            const resolution = curve.isEllipseCurve ? divisions * 2 : (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
                            const pts = curve.getPoints(resolution);
                            for (let j = 0; j < pts.length; j++) {
                                const point = pts[j];
                                if (last && last.equals(point)) continue;
                                points.push(point);
                                last = point
                            }
                        }
                        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
                            points.push(points[0])
                        }
                        return points
                    }
                    copy(source) {
                        super.copy(source);
                        this.curves = [];
                        for (let i = 0, l = source.curves.length; i < l; i++) {
                            const curve = source.curves[i];
                            this.curves.push(curve.clone())
                        }
                        this.autoClose = source.autoClose;
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.autoClose = this.autoClose;
                        data.curves = [];
                        for (let i = 0, l = this.curves.length; i < l; i++) {
                            const curve = this.curves[i];
                            data.curves.push(curve.toJSON())
                        }
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.autoClose = json.autoClose;
                        this.curves = [];
                        for (let i = 0, l = json.curves.length; i < l; i++) {
                            const curve = json.curves[i];
                            this.curves.push(new Curves[curve.type]().fromJSON(curve))
                        }
                        return this
                    }
                }
                class Path extends CurvePath {
                    constructor(points) {
                        super();
                        this.type = 'Path';
                        this.currentPoint = new Vector2();
                        if (points) {
                            this.setFromPoints(points)
                        }
                    }
                    setFromPoints(points) {
                        this.moveTo(points[0].x, points[0].y);
                        for (let i = 1, l = points.length; i < l; i++) {
                            this.lineTo(points[i].x, points[i].y)
                        }
                        return this
                    }
                    moveTo(x, y) {
                        this.currentPoint.set(x, y);
                        return this
                    }
                    lineTo(x, y) {
                        const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
                        this.curves.push(curve);
                        this.currentPoint.set(x, y);
                        return this
                    }
                    quadraticCurveTo(aCPx, aCPy, aX, aY) {
                        const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
                        this.curves.push(curve);
                        this.currentPoint.set(aX, aY);
                        return this
                    }
                    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                        const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
                        this.curves.push(curve);
                        this.currentPoint.set(aX, aY);
                        return this
                    }
                    splineThru(pts) {
                        const npts = [this.currentPoint.clone()].concat(pts);
                        const curve = new SplineCurve(npts);
                        this.curves.push(curve);
                        this.currentPoint.copy(pts[pts.length - 1]);
                        return this
                    }
                    arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        const x0 = this.currentPoint.x;
                        const y0 = this.currentPoint.y;
                        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
                        return this
                    }
                    absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
                        return this
                    }
                    ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                        const x0 = this.currentPoint.x;
                        const y0 = this.currentPoint.y;
                        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                        return this
                    }
                    absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
                        const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
                        if (this.curves.length > 0) {
                            const firstPoint = curve.getPoint(0);
                            if (!firstPoint.equals(this.currentPoint)) {
                                this.lineTo(firstPoint.x, firstPoint.y)
                            }
                        }
                        this.curves.push(curve);
                        const lastPoint = curve.getPoint(1);
                        this.currentPoint.copy(lastPoint);
                        return this
                    }
                    copy(source) {
                        super.copy(source);
                        this.currentPoint.copy(source.currentPoint);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.currentPoint = this.currentPoint.toArray();
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.currentPoint.fromArray(json.currentPoint);
                        return this
                    }
                }
                class LatheGeometry extends BufferGeometry {
                    constructor(points = [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
                        super();
                        this.type = 'LatheGeometry';
                        this.parameters = {
                            points: points,
                            segments: segments,
                            phiStart: phiStart,
                            phiLength: phiLength
                        };
                        segments = Math.floor(segments);
                        phiLength = clamp(phiLength, 0, Math.PI * 2);
                        const indices = [];
                        const vertices = [];
                        const uvs = [];
                        const initNormals = [];
                        const normals = [];
                        const inverseSegments = 1.0 / segments;
                        const vertex = new Vector3();
                        const uv = new Vector2();
                        const normal = new Vector3();
                        const curNormal = new Vector3();
                        const prevNormal = new Vector3();
                        let dx = 0;
                        let dy = 0;
                        for (let j = 0; j <= (points.length - 1); j++) {
                            switch (j) {
                                case 0:
                                    dx = points[j + 1].x - points[j].x;
                                    dy = points[j + 1].y - points[j].y;
                                    normal.x = dy * 1.0;
                                    normal.y = -dx;
                                    normal.z = dy * 0.0;
                                    prevNormal.copy(normal);
                                    normal.normalize();
                                    initNormals.push(normal.x, normal.y, normal.z);
                                    break;
                                case (points.length - 1):
                                    initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
                                    break;
                                default:
                                    dx = points[j + 1].x - points[j].x;
                                    dy = points[j + 1].y - points[j].y;
                                    normal.x = dy * 1.0;
                                    normal.y = -dx;
                                    normal.z = dy * 0.0;
                                    curNormal.copy(normal);
                                    normal.x += prevNormal.x;
                                    normal.y += prevNormal.y;
                                    normal.z += prevNormal.z;
                                    normal.normalize();
                                    initNormals.push(normal.x, normal.y, normal.z);
                                    prevNormal.copy(curNormal)
                            }
                        }
                        for (let i = 0; i <= segments; i++) {
                            const phi = phiStart + i * inverseSegments * phiLength;
                            const sin = Math.sin(phi);
                            const cos = Math.cos(phi);
                            for (let j = 0; j <= (points.length - 1); j++) {
                                vertex.x = points[j].x * sin;
                                vertex.y = points[j].y;
                                vertex.z = points[j].x * cos;
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                uv.x = i / segments;
                                uv.y = j / (points.length - 1);
                                uvs.push(uv.x, uv.y);
                                const x = initNormals[3 * j + 0] * sin;
                                const y = initNormals[3 * j + 1];
                                const z = initNormals[3 * j + 0] * cos;
                                normals.push(x, y, z)
                            }
                        }
                        for (let i = 0; i < segments; i++) {
                            for (let j = 0; j < (points.length - 1); j++) {
                                const base = j + i * points.length;
                                const a = base;
                                const b = base + points.length;
                                const c = base + points.length + 1;
                                const d = base + 1;
                                indices.push(a, b, d);
                                indices.push(c, d, b)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength)
                    }
                }
                class CapsuleGeometry extends LatheGeometry {
                    constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
                        const path = new Path();
                        path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
                        path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
                        super(path.getPoints(capSegments), radialSegments);
                        this.type = 'CapsuleGeometry';
                        this.parameters = {
                            radius: radius,
                            length: length,
                            capSegments: capSegments,
                            radialSegments: radialSegments,
                        }
                    }
                    static fromJSON(data) {
                        return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments)
                    }
                }
                class CircleGeometry extends BufferGeometry {
                    constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
                        super();
                        this.type = 'CircleGeometry';
                        this.parameters = {
                            radius: radius,
                            segments: segments,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        segments = Math.max(3, segments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        const vertex = new Vector3();
                        const uv = new Vector2();
                        vertices.push(0, 0, 0);
                        normals.push(0, 0, 1);
                        uvs.push(0.5, 0.5);
                        for (let s = 0, i = 3; s <= segments; s++, i += 3) {
                            const segment = thetaStart + s / segments * thetaLength;
                            vertex.x = radius * Math.cos(segment);
                            vertex.y = radius * Math.sin(segment);
                            vertices.push(vertex.x, vertex.y, vertex.z);
                            normals.push(0, 0, 1);
                            uv.x = (vertices[i] / radius + 1) / 2;
                            uv.y = (vertices[i + 1] / radius + 1) / 2;
                            uvs.push(uv.x, uv.y)
                        }
                        for (let i = 1; i <= segments; i++) {
                            indices.push(i, i + 1, 0)
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength)
                    }
                }
                class CylinderGeometry extends BufferGeometry {
                    constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = !1, thetaStart = 0, thetaLength = Math.PI * 2) {
                        super();
                        this.type = 'CylinderGeometry';
                        this.parameters = {
                            radiusTop: radiusTop,
                            radiusBottom: radiusBottom,
                            height: height,
                            radialSegments: radialSegments,
                            heightSegments: heightSegments,
                            openEnded: openEnded,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        const scope = this;
                        radialSegments = Math.floor(radialSegments);
                        heightSegments = Math.floor(heightSegments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        let index = 0;
                        const indexArray = [];
                        const halfHeight = height / 2;
                        let groupStart = 0;
                        generateTorso();
                        if (openEnded === !1) {
                            if (radiusTop > 0) generateCap(!0);
                            if (radiusBottom > 0) generateCap(!1)
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function generateTorso() {
                            const normal = new Vector3();
                            const vertex = new Vector3();
                            let groupCount = 0;
                            const slope = (radiusBottom - radiusTop) / height;
                            for (let y = 0; y <= heightSegments; y++) {
                                const indexRow = [];
                                const v = y / heightSegments;
                                const radius = v * (radiusBottom - radiusTop) + radiusTop;
                                for (let x = 0; x <= radialSegments; x++) {
                                    const u = x / radialSegments;
                                    const theta = u * thetaLength + thetaStart;
                                    const sinTheta = Math.sin(theta);
                                    const cosTheta = Math.cos(theta);
                                    vertex.x = radius * sinTheta;
                                    vertex.y = -v * height + halfHeight;
                                    vertex.z = radius * cosTheta;
                                    vertices.push(vertex.x, vertex.y, vertex.z);
                                    normal.set(sinTheta, slope, cosTheta).normalize();
                                    normals.push(normal.x, normal.y, normal.z);
                                    uvs.push(u, 1 - v);
                                    indexRow.push(index++)
                                }
                                indexArray.push(indexRow)
                            }
                            for (let x = 0; x < radialSegments; x++) {
                                for (let y = 0; y < heightSegments; y++) {
                                    const a = indexArray[y][x];
                                    const b = indexArray[y + 1][x];
                                    const c = indexArray[y + 1][x + 1];
                                    const d = indexArray[y][x + 1];
                                    indices.push(a, b, d);
                                    indices.push(b, c, d);
                                    groupCount += 6
                                }
                            }
                            scope.addGroup(groupStart, groupCount, 0);
                            groupStart += groupCount
                        }

                        function generateCap(top) {
                            const centerIndexStart = index;
                            const uv = new Vector2();
                            const vertex = new Vector3();
                            let groupCount = 0;
                            const radius = (top === !0) ? radiusTop : radiusBottom;
                            const sign = (top === !0) ? 1 : -1;
                            for (let x = 1; x <= radialSegments; x++) {
                                vertices.push(0, halfHeight * sign, 0);
                                normals.push(0, sign, 0);
                                uvs.push(0.5, 0.5);
                                index++
                            }
                            const centerIndexEnd = index;
                            for (let x = 0; x <= radialSegments; x++) {
                                const u = x / radialSegments;
                                const theta = u * thetaLength + thetaStart;
                                const cosTheta = Math.cos(theta);
                                const sinTheta = Math.sin(theta);
                                vertex.x = radius * sinTheta;
                                vertex.y = halfHeight * sign;
                                vertex.z = radius * cosTheta;
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                normals.push(0, sign, 0);
                                uv.x = (cosTheta * 0.5) + 0.5;
                                uv.y = (sinTheta * 0.5 * sign) + 0.5;
                                uvs.push(uv.x, uv.y);
                                index++
                            }
                            for (let x = 0; x < radialSegments; x++) {
                                const c = centerIndexStart + x;
                                const i = centerIndexEnd + x;
                                if (top === !0) {
                                    indices.push(i, i + 1, c)
                                } else {
                                    indices.push(i + 1, i, c)
                                }
                                groupCount += 3
                            }
                            scope.addGroup(groupStart, groupCount, top === !0 ? 1 : 2);
                            groupStart += groupCount
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength)
                    }
                }
                class ConeGeometry extends CylinderGeometry {
                    constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = !1, thetaStart = 0, thetaLength = Math.PI * 2) {
                        super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
                        this.type = 'ConeGeometry';
                        this.parameters = {
                            radius: radius,
                            height: height,
                            radialSegments: radialSegments,
                            heightSegments: heightSegments,
                            openEnded: openEnded,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        }
                    }
                    static fromJSON(data) {
                        return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength)
                    }
                }
                class PolyhedronGeometry extends BufferGeometry {
                    constructor(vertices = [], indices = [], radius = 1, detail = 0) {
                        super();
                        this.type = 'PolyhedronGeometry';
                        this.parameters = {
                            vertices: vertices,
                            indices: indices,
                            radius: radius,
                            detail: detail
                        };
                        const vertexBuffer = [];
                        const uvBuffer = [];
                        subdivide(detail);
                        applyRadius(radius);
                        generateUVs();
                        this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
                        if (detail === 0) {
                            this.computeVertexNormals()
                        } else {
                            this.normalizeNormals()
                        }

                        function subdivide(detail) {
                            const a = new Vector3();
                            const b = new Vector3();
                            const c = new Vector3();
                            for (let i = 0; i < indices.length; i += 3) {
                                getVertexByIndex(indices[i + 0], a);
                                getVertexByIndex(indices[i + 1], b);
                                getVertexByIndex(indices[i + 2], c);
                                subdivideFace(a, b, c, detail)
                            }
                        }

                        function subdivideFace(a, b, c, detail) {
                            const cols = detail + 1;
                            const v = [];
                            for (let i = 0; i <= cols; i++) {
                                v[i] = [];
                                const aj = a.clone().lerp(c, i / cols);
                                const bj = b.clone().lerp(c, i / cols);
                                const rows = cols - i;
                                for (let j = 0; j <= rows; j++) {
                                    if (j === 0 && i === cols) {
                                        v[i][j] = aj
                                    } else {
                                        v[i][j] = aj.clone().lerp(bj, j / rows)
                                    }
                                }
                            }
                            for (let i = 0; i < cols; i++) {
                                for (let j = 0; j < 2 * (cols - i) - 1; j++) {
                                    const k = Math.floor(j / 2);
                                    if (j % 2 === 0) {
                                        pushVertex(v[i][k + 1]);
                                        pushVertex(v[i + 1][k]);
                                        pushVertex(v[i][k])
                                    } else {
                                        pushVertex(v[i][k + 1]);
                                        pushVertex(v[i + 1][k + 1]);
                                        pushVertex(v[i + 1][k])
                                    }
                                }
                            }
                        }

                        function applyRadius(radius) {
                            const vertex = new Vector3();
                            for (let i = 0; i < vertexBuffer.length; i += 3) {
                                vertex.x = vertexBuffer[i + 0];
                                vertex.y = vertexBuffer[i + 1];
                                vertex.z = vertexBuffer[i + 2];
                                vertex.normalize().multiplyScalar(radius);
                                vertexBuffer[i + 0] = vertex.x;
                                vertexBuffer[i + 1] = vertex.y;
                                vertexBuffer[i + 2] = vertex.z
                            }
                        }

                        function generateUVs() {
                            const vertex = new Vector3();
                            for (let i = 0; i < vertexBuffer.length; i += 3) {
                                vertex.x = vertexBuffer[i + 0];
                                vertex.y = vertexBuffer[i + 1];
                                vertex.z = vertexBuffer[i + 2];
                                const u = azimuth(vertex) / 2 / Math.PI + 0.5;
                                const v = inclination(vertex) / Math.PI + 0.5;
                                uvBuffer.push(u, 1 - v)
                            }
                            correctUVs();
                            correctSeam()
                        }

                        function correctSeam() {
                            for (let i = 0; i < uvBuffer.length; i += 6) {
                                const x0 = uvBuffer[i + 0];
                                const x1 = uvBuffer[i + 2];
                                const x2 = uvBuffer[i + 4];
                                const max = Math.max(x0, x1, x2);
                                const min = Math.min(x0, x1, x2);
                                if (max > 0.9 && min < 0.1) {
                                    if (x0 < 0.2) uvBuffer[i + 0] += 1;
                                    if (x1 < 0.2) uvBuffer[i + 2] += 1;
                                    if (x2 < 0.2) uvBuffer[i + 4] += 1
                                }
                            }
                        }

                        function pushVertex(vertex) {
                            vertexBuffer.push(vertex.x, vertex.y, vertex.z)
                        }

                        function getVertexByIndex(index, vertex) {
                            const stride = index * 3;
                            vertex.x = vertices[stride + 0];
                            vertex.y = vertices[stride + 1];
                            vertex.z = vertices[stride + 2]
                        }

                        function correctUVs() {
                            const a = new Vector3();
                            const b = new Vector3();
                            const c = new Vector3();
                            const centroid = new Vector3();
                            const uvA = new Vector2();
                            const uvB = new Vector2();
                            const uvC = new Vector2();
                            for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
                                a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
                                b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
                                c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
                                uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
                                uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
                                uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
                                centroid.copy(a).add(b).add(c).divideScalar(3);
                                const azi = azimuth(centroid);
                                correctUV(uvA, j + 0, a, azi);
                                correctUV(uvB, j + 2, b, azi);
                                correctUV(uvC, j + 4, c, azi)
                            }
                        }

                        function correctUV(uv, stride, vector, azimuth) {
                            if ((azimuth < 0) && (uv.x === 1)) {
                                uvBuffer[stride] = uv.x - 1
                            }
                            if ((vector.x === 0) && (vector.z === 0)) {
                                uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5
                            }
                        }

                        function azimuth(vector) {
                            return Math.atan2(vector.z, -vector.x)
                        }

                        function inclination(vector) {
                            return Math.atan2(-vector.y, Math.sqrt((vector.x * vector.x) + (vector.z * vector.z)))
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details)
                    }
                }
                class DodecahedronGeometry extends PolyhedronGeometry {
                    constructor(radius = 1, detail = 0) {
                        const t = (1 + Math.sqrt(5)) / 2;
                        const r = 1 / t;
                        const vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
                        const indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
                        super(vertices, indices, radius, detail);
                        this.type = 'DodecahedronGeometry';
                        this.parameters = {
                            radius: radius,
                            detail: detail
                        }
                    }
                    static fromJSON(data) {
                        return new DodecahedronGeometry(data.radius, data.detail)
                    }
                }
                const _v0 = new Vector3();
                const _v1$1 = new Vector3();
                const _normal = new Vector3();
                const _triangle = new Triangle();
                class EdgesGeometry extends BufferGeometry {
                    constructor(geometry = null, thresholdAngle = 1) {
                        super();
                        this.type = 'EdgesGeometry';
                        this.parameters = {
                            geometry: geometry,
                            thresholdAngle: thresholdAngle
                        };
                        if (geometry !== null) {
                            const precisionPoints = 4;
                            const precision = Math.pow(10, precisionPoints);
                            const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
                            const indexAttr = geometry.getIndex();
                            const positionAttr = geometry.getAttribute('position');
                            const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
                            const indexArr = [0, 0, 0];
                            const vertKeys = ['a', 'b', 'c'];
                            const hashes = new Array(3);
                            const edgeData = {};
                            const vertices = [];
                            for (let i = 0; i < indexCount; i += 3) {
                                if (indexAttr) {
                                    indexArr[0] = indexAttr.getX(i);
                                    indexArr[1] = indexAttr.getX(i + 1);
                                    indexArr[2] = indexAttr.getX(i + 2)
                                } else {
                                    indexArr[0] = i;
                                    indexArr[1] = i + 1;
                                    indexArr[2] = i + 2
                                }
                                const {
                                    a,
                                    b,
                                    c
                                } = _triangle;
                                a.fromBufferAttribute(positionAttr, indexArr[0]);
                                b.fromBufferAttribute(positionAttr, indexArr[1]);
                                c.fromBufferAttribute(positionAttr, indexArr[2]);
                                _triangle.getNormal(_normal);
                                hashes[0] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
                                hashes[1] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
                                hashes[2] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;
                                if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                                    continue
                                }
                                for (let j = 0; j < 3; j++) {
                                    const jNext = (j + 1) % 3;
                                    const vecHash0 = hashes[j];
                                    const vecHash1 = hashes[jNext];
                                    const v0 = _triangle[vertKeys[j]];
                                    const v1 = _triangle[vertKeys[jNext]];
                                    const hash = `${ vecHash0 }_${ vecHash1 }`;
                                    const reverseHash = `${ vecHash1 }_${ vecHash0 }`;
                                    if (reverseHash in edgeData && edgeData[reverseHash]) {
                                        if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                                            vertices.push(v0.x, v0.y, v0.z);
                                            vertices.push(v1.x, v1.y, v1.z)
                                        }
                                        edgeData[reverseHash] = null
                                    } else if (!(hash in edgeData)) {
                                        edgeData[hash] = {
                                            index0: indexArr[j],
                                            index1: indexArr[jNext],
                                            normal: _normal.clone(),
                                        }
                                    }
                                }
                            }
                            for (const key in edgeData) {
                                if (edgeData[key]) {
                                    const {
                                        index0,
                                        index1
                                    } = edgeData[key];
                                    _v0.fromBufferAttribute(positionAttr, index0);
                                    _v1$1.fromBufferAttribute(positionAttr, index1);
                                    vertices.push(_v0.x, _v0.y, _v0.z);
                                    vertices.push(_v1$1.x, _v1$1.y, _v1$1.z)
                                }
                            }
                            this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                }
                class Shape extends Path {
                    constructor(points) {
                        super(points);
                        this.uuid = generateUUID();
                        this.type = 'Shape';
                        this.holes = []
                    }
                    getPointsHoles(divisions) {
                        const holesPts = [];
                        for (let i = 0, l = this.holes.length; i < l; i++) {
                            holesPts[i] = this.holes[i].getPoints(divisions)
                        }
                        return holesPts
                    }
                    extractPoints(divisions) {
                        return {
                            shape: this.getPoints(divisions),
                            holes: this.getPointsHoles(divisions)
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.holes = [];
                        for (let i = 0, l = source.holes.length; i < l; i++) {
                            const hole = source.holes[i];
                            this.holes.push(hole.clone())
                        }
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.uuid = this.uuid;
                        data.holes = [];
                        for (let i = 0, l = this.holes.length; i < l; i++) {
                            const hole = this.holes[i];
                            data.holes.push(hole.toJSON())
                        }
                        return data
                    }
                    fromJSON(json) {
                        super.fromJSON(json);
                        this.uuid = json.uuid;
                        this.holes = [];
                        for (let i = 0, l = json.holes.length; i < l; i++) {
                            const hole = json.holes[i];
                            this.holes.push(new Path().fromJSON(hole))
                        }
                        return this
                    }
                }
                const Earcut = {
                    triangulate: function(data, holeIndices, dim = 2) {
                        const hasHoles = holeIndices && holeIndices.length;
                        const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
                        let outerNode = linkedList(data, 0, outerLen, dim, !0);
                        const triangles = [];
                        if (!outerNode || outerNode.next === outerNode.prev) return triangles;
                        let minX, minY, maxX, maxY, x, y, invSize;
                        if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
                        if (data.length > 80 * dim) {
                            minX = maxX = data[0];
                            minY = maxY = data[1];
                            for (let i = dim; i < outerLen; i += dim) {
                                x = data[i];
                                y = data[i + 1];
                                if (x < minX) minX = x;
                                if (y < minY) minY = y;
                                if (x > maxX) maxX = x;
                                if (y > maxY) maxY = y
                            }
                            invSize = Math.max(maxX - minX, maxY - minY);
                            invSize = invSize !== 0 ? 32767 / invSize : 0
                        }
                        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
                        return triangles
                    }
                };

                function linkedList(data, start, end, dim, clockwise) {
                    let i, last;
                    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
                        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
                    } else {
                        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
                    }
                    if (last && equals(last, last.next)) {
                        removeNode(last);
                        last = last.next
                    }
                    return last
                }

                function filterPoints(start, end) {
                    if (!start) return start;
                    if (!end) end = start;
                    let p = start,
                        again;
                    do {
                        again = !1;
                        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                            removeNode(p);
                            p = end = p.prev;
                            if (p === p.next) break;
                            again = !0
                        } else {
                            p = p.next
                        }
                    } while (again || p !== end);
                    return end
                }

                function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
                    if (!ear) return;
                    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
                    let stop = ear,
                        prev, next;
                    while (ear.prev !== ear.next) {
                        prev = ear.prev;
                        next = ear.next;
                        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
                            triangles.push(prev.i / dim | 0);
                            triangles.push(ear.i / dim | 0);
                            triangles.push(next.i / dim | 0);
                            removeNode(ear);
                            ear = next.next;
                            stop = next.next;
                            continue
                        }
                        ear = next;
                        if (ear === stop) {
                            if (!pass) {
                                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1)
                            } else if (pass === 1) {
                                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
                                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2)
                            } else if (pass === 2) {
                                splitEarcut(ear, triangles, dim, minX, minY, invSize)
                            }
                            break
                        }
                    }
                }

                function isEar(ear) {
                    const a = ear.prev,
                        b = ear,
                        c = ear.next;
                    if (area(a, b, c) >= 0) return !1;
                    const ax = a.x,
                        bx = b.x,
                        cx = c.x,
                        ay = a.y,
                        by = b.y,
                        cy = c.y;
                    const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
                        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
                        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
                        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);
                    let p = c.next;
                    while (p !== a) {
                        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                        p = p.next
                    }
                    return !0
                }

                function isEarHashed(ear, minX, minY, invSize) {
                    const a = ear.prev,
                        b = ear,
                        c = ear.next;
                    if (area(a, b, c) >= 0) return !1;
                    const ax = a.x,
                        bx = b.x,
                        cx = c.x,
                        ay = a.y,
                        by = b.y,
                        cy = c.y;
                    const x0 = ax < bx ? (ax < cx ? ax : cx) : (bx < cx ? bx : cx),
                        y0 = ay < by ? (ay < cy ? ay : cy) : (by < cy ? by : cy),
                        x1 = ax > bx ? (ax > cx ? ax : cx) : (bx > cx ? bx : cx),
                        y1 = ay > by ? (ay > cy ? ay : cy) : (by > cy ? by : cy);
                    const minZ = zOrder(x0, y0, minX, minY, invSize),
                        maxZ = zOrder(x1, y1, minX, minY, invSize);
                    let p = ear.prevZ,
                        n = ear.nextZ;
                    while (p && p.z >= minZ && n && n.z <= maxZ) {
                        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ;
                        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return !1;
                        n = n.nextZ
                    }
                    while (p && p.z >= minZ) {
                        if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    while (n && n.z <= maxZ) {
                        if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return !1;
                        n = n.nextZ
                    }
                    return !0
                }

                function cureLocalIntersections(start, triangles, dim) {
                    let p = start;
                    do {
                        const a = p.prev,
                            b = p.next.next;
                        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                            triangles.push(a.i / dim | 0);
                            triangles.push(p.i / dim | 0);
                            triangles.push(b.i / dim | 0);
                            removeNode(p);
                            removeNode(p.next);
                            p = start = b
                        }
                        p = p.next
                    } while (p !== start);
                    return filterPoints(p)
                }

                function splitEarcut(start, triangles, dim, minX, minY, invSize) {
                    let a = start;
                    do {
                        let b = a.next.next;
                        while (b !== a.prev) {
                            if (a.i !== b.i && isValidDiagonal(a, b)) {
                                let c = splitPolygon(a, b);
                                a = filterPoints(a, a.next);
                                c = filterPoints(c, c.next);
                                earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
                                earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
                                return
                            }
                            b = b.next
                        }
                        a = a.next
                    } while (a !== start);
                }

                function eliminateHoles(data, holeIndices, outerNode, dim) {
                    const queue = [];
                    let i, len, start, end, list;
                    for (i = 0, len = holeIndices.length; i < len; i++) {
                        start = holeIndices[i] * dim;
                        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
                        list = linkedList(data, start, end, dim, !1);
                        if (list === list.next) list.steiner = !0;
                        queue.push(getLeftmost(list))
                    }
                    queue.sort(compareX);
                    for (i = 0; i < queue.length; i++) {
                        outerNode = eliminateHole(queue[i], outerNode)
                    }
                    return outerNode
                }

                function compareX(a, b) {
                    return a.x - b.x
                }

                function eliminateHole(hole, outerNode) {
                    const bridge = findHoleBridge(hole, outerNode);
                    if (!bridge) {
                        return outerNode
                    }
                    const bridgeReverse = splitPolygon(bridge, hole);
                    filterPoints(bridgeReverse, bridgeReverse.next);
                    return filterPoints(bridge, bridge.next)
                }

                function findHoleBridge(hole, outerNode) {
                    let p = outerNode,
                        qx = -Infinity,
                        m;
                    const hx = hole.x,
                        hy = hole.y;
                    do {
                        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                            const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                            if (x <= hx && x > qx) {
                                qx = x;
                                m = p.x < p.next.x ? p : p.next;
                                if (x === hx) return m
                            }
                        }
                        p = p.next
                    } while (p !== outerNode);
                    if (!m) return null;
                    const stop = m,
                        mx = m.x,
                        my = m.y;
                    let tanMin = Infinity,
                        tan;
                    p = m;
                    do {
                        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                            tan = Math.abs(hy - p.y) / (hx - p.x);
                            if (locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {
                                m = p;
                                tanMin = tan
                            }
                        }
                        p = p.next
                    } while (p !== stop);
                    return m
                }

                function sectorContainsSector(m, p) {
                    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0
                }

                function indexCurve(start, minX, minY, invSize) {
                    let p = start;
                    do {
                        if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
                        p.prevZ = p.prev;
                        p.nextZ = p.next;
                        p = p.next
                    } while (p !== start);
                    p.prevZ.nextZ = null;
                    p.prevZ = null;
                    sortLinked(p)
                }

                function sortLinked(list) {
                    let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
                    do {
                        p = list;
                        list = null;
                        tail = null;
                        numMerges = 0;
                        while (p) {
                            numMerges++;
                            q = p;
                            pSize = 0;
                            for (i = 0; i < inSize; i++) {
                                pSize++;
                                q = q.nextZ;
                                if (!q) break
                            }
                            qSize = inSize;
                            while (pSize > 0 || (qSize > 0 && q)) {
                                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                                    e = p;
                                    p = p.nextZ;
                                    pSize--
                                } else {
                                    e = q;
                                    q = q.nextZ;
                                    qSize--
                                }
                                if (tail) tail.nextZ = e;
                                else list = e;
                                e.prevZ = tail;
                                tail = e
                            }
                            p = q
                        }
                        tail.nextZ = null;
                        inSize *= 2
                    } while (numMerges > 1);
                    return list
                }

                function zOrder(x, y, minX, minY, invSize) {
                    x = (x - minX) * invSize | 0;
                    y = (y - minY) * invSize | 0;
                    x = (x | (x << 8)) & 0x00FF00FF;
                    x = (x | (x << 4)) & 0x0F0F0F0F;
                    x = (x | (x << 2)) & 0x33333333;
                    x = (x | (x << 1)) & 0x55555555;
                    y = (y | (y << 8)) & 0x00FF00FF;
                    y = (y | (y << 4)) & 0x0F0F0F0F;
                    y = (y | (y << 2)) & 0x33333333;
                    y = (y | (y << 1)) & 0x55555555;
                    return x | (y << 1)
                }

                function getLeftmost(start) {
                    let p = start,
                        leftmost = start;
                    do {
                        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
                        p = p.next
                    } while (p !== start);
                    return leftmost
                }

                function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
                    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py)
                }

                function isValidDiagonal(a, b) {
                    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0)
                }

                function area(p, q, r) {
                    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y)
                }

                function equals(p1, p2) {
                    return p1.x === p2.x && p1.y === p2.y
                }

                function intersects(p1, q1, p2, q2) {
                    const o1 = sign(area(p1, q1, p2));
                    const o2 = sign(area(p1, q1, q2));
                    const o3 = sign(area(p2, q2, p1));
                    const o4 = sign(area(p2, q2, q1));
                    if (o1 !== o2 && o3 !== o4) return !0;
                    if (o1 === 0 && onSegment(p1, p2, q1)) return !0;
                    if (o2 === 0 && onSegment(p1, q2, q1)) return !0;
                    if (o3 === 0 && onSegment(p2, p1, q2)) return !0;
                    if (o4 === 0 && onSegment(p2, q1, q2)) return !0;
                    return !1
                }

                function onSegment(p, q, r) {
                    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y)
                }

                function sign(num) {
                    return num > 0 ? 1 : num < 0 ? -1 : 0
                }

                function intersectsPolygon(a, b) {
                    let p = a;
                    do {
                        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return !0;
                        p = p.next
                    } while (p !== a);
                    return !1
                }

                function locallyInside(a, b) {
                    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
                }

                function middleInside(a, b) {
                    let p = a,
                        inside = !1;
                    const px = (a.x + b.x) / 2,
                        py = (a.y + b.y) / 2;
                    do {
                        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
                            inside = !inside;
                        p = p.next
                    } while (p !== a);
                    return inside
                }

                function splitPolygon(a, b) {
                    const a2 = new Node(a.i, a.x, a.y),
                        b2 = new Node(b.i, b.x, b.y),
                        an = a.next,
                        bp = b.prev;
                    a.next = b;
                    b.prev = a;
                    a2.next = an;
                    an.prev = a2;
                    b2.next = a2;
                    a2.prev = b2;
                    bp.next = b2;
                    b2.prev = bp;
                    return b2
                }

                function insertNode(i, x, y, last) {
                    const p = new Node(i, x, y);
                    if (!last) {
                        p.prev = p;
                        p.next = p
                    } else {
                        p.next = last.next;
                        p.prev = last;
                        last.next.prev = p;
                        last.next = p
                    }
                    return p
                }

                function removeNode(p) {
                    p.next.prev = p.prev;
                    p.prev.next = p.next;
                    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
                    if (p.nextZ) p.nextZ.prevZ = p.prevZ
                }

                function Node(i, x, y) {
                    this.i = i;
                    this.x = x;
                    this.y = y;
                    this.prev = null;
                    this.next = null;
                    this.z = 0;
                    this.prevZ = null;
                    this.nextZ = null;
                    this.steiner = !1
                }

                function signedArea(data, start, end, dim) {
                    let sum = 0;
                    for (let i = start, j = end - dim; i < end; i += dim) {
                        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
                        j = i
                    }
                    return sum
                }
                class ShapeUtils {
                    static area(contour) {
                        const n = contour.length;
                        let a = 0.0;
                        for (let p = n - 1, q = 0; q < n; p = q++) {
                            a += contour[p].x * contour[q].y - contour[q].x * contour[p].y
                        }
                        return a * 0.5
                    }
                    static isClockWise(pts) {
                        return ShapeUtils.area(pts) < 0
                    }
                    static triangulateShape(contour, holes) {
                        const vertices = [];
                        const holeIndices = [];
                        const faces = [];
                        removeDupEndPts(contour);
                        addContour(vertices, contour);
                        let holeIndex = contour.length;
                        holes.forEach(removeDupEndPts);
                        for (let i = 0; i < holes.length; i++) {
                            holeIndices.push(holeIndex);
                            holeIndex += holes[i].length;
                            addContour(vertices, holes[i])
                        }
                        const triangles = Earcut.triangulate(vertices, holeIndices);
                        for (let i = 0; i < triangles.length; i += 3) {
                            faces.push(triangles.slice(i, i + 3))
                        }
                        return faces
                    }
                }

                function removeDupEndPts(points) {
                    const l = points.length;
                    if (l > 2 && points[l - 1].equals(points[0])) {
                        points.pop()
                    }
                }

                function addContour(vertices, contour) {
                    for (let i = 0; i < contour.length; i++) {
                        vertices.push(contour[i].x);
                        vertices.push(contour[i].y)
                    }
                }
                class ExtrudeGeometry extends BufferGeometry {
                    constructor(shapes = new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), options = {}) {
                        super();
                        this.type = 'ExtrudeGeometry';
                        this.parameters = {
                            shapes: shapes,
                            options: options
                        };
                        shapes = Array.isArray(shapes) ? shapes : [shapes];
                        const scope = this;
                        const verticesArray = [];
                        const uvArray = [];
                        for (let i = 0, l = shapes.length; i < l; i++) {
                            const shape = shapes[i];
                            addShape(shape)
                        }
                        this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
                        this.computeVertexNormals();

                        function addShape(shape) {
                            const placeholder = [];
                            const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
                            const steps = options.steps !== undefined ? options.steps : 1;
                            const depth = options.depth !== undefined ? options.depth : 1;
                            let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : !0;
                            let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
                            let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
                            let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
                            let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
                            const extrudePath = options.extrudePath;
                            const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
                            let extrudePts, extrudeByPath = !1;
                            let splineTube, binormal, normal, position2;
                            if (extrudePath) {
                                extrudePts = extrudePath.getSpacedPoints(steps);
                                extrudeByPath = !0;
                                bevelEnabled = !1;
                                splineTube = extrudePath.computeFrenetFrames(steps, !1);
                                binormal = new Vector3();
                                normal = new Vector3();
                                position2 = new Vector3()
                            }
                            if (!bevelEnabled) {
                                bevelSegments = 0;
                                bevelThickness = 0;
                                bevelSize = 0;
                                bevelOffset = 0
                            }
                            const shapePoints = shape.extractPoints(curveSegments);
                            let vertices = shapePoints.shape;
                            const holes = shapePoints.holes;
                            const reverse = !ShapeUtils.isClockWise(vertices);
                            if (reverse) {
                                vertices = vertices.reverse();
                                for (let h = 0, hl = holes.length; h < hl; h++) {
                                    const ahole = holes[h];
                                    if (ShapeUtils.isClockWise(ahole)) {
                                        holes[h] = ahole.reverse()
                                    }
                                }
                            }
                            const faces = ShapeUtils.triangulateShape(vertices, holes);
                            const contour = vertices;
                            for (let h = 0, hl = holes.length; h < hl; h++) {
                                const ahole = holes[h];
                                vertices = vertices.concat(ahole)
                            }

                            function scalePt2(pt, vec, size) {
                                if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
                                return pt.clone().addScaledVector(vec, size)
                            }
                            const vlen = vertices.length,
                                flen = faces.length;

                            function getBevelVec(inPt, inPrev, inNext) {
                                let v_trans_x, v_trans_y, shrink_by;
                                const v_prev_x = inPt.x - inPrev.x,
                                    v_prev_y = inPt.y - inPrev.y;
                                const v_next_x = inNext.x - inPt.x,
                                    v_next_y = inNext.y - inPt.y;
                                const v_prev_lensq = (v_prev_x * v_prev_x + v_prev_y * v_prev_y);
                                const collinear0 = (v_prev_x * v_next_y - v_prev_y * v_next_x);
                                if (Math.abs(collinear0) > Number.EPSILON) {
                                    const v_prev_len = Math.sqrt(v_prev_lensq);
                                    const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
                                    const ptPrevShift_x = (inPrev.x - v_prev_y / v_prev_len);
                                    const ptPrevShift_y = (inPrev.y + v_prev_x / v_prev_len);
                                    const ptNextShift_x = (inNext.x - v_next_y / v_next_len);
                                    const ptNextShift_y = (inNext.y + v_next_x / v_next_len);
                                    const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
                                    v_trans_x = (ptPrevShift_x + v_prev_x * sf - inPt.x);
                                    v_trans_y = (ptPrevShift_y + v_prev_y * sf - inPt.y);
                                    const v_trans_lensq = (v_trans_x * v_trans_x + v_trans_y * v_trans_y);
                                    if (v_trans_lensq <= 2) {
                                        return new Vector2(v_trans_x, v_trans_y)
                                    } else {
                                        shrink_by = Math.sqrt(v_trans_lensq / 2)
                                    }
                                } else {
                                    let direction_eq = !1;
                                    if (v_prev_x > Number.EPSILON) {
                                        if (v_next_x > Number.EPSILON) {
                                            direction_eq = !0
                                        }
                                    } else {
                                        if (v_prev_x < -Number.EPSILON) {
                                            if (v_next_x < -Number.EPSILON) {
                                                direction_eq = !0
                                            }
                                        } else {
                                            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                                                direction_eq = !0
                                            }
                                        }
                                    }
                                    if (direction_eq) {
                                        v_trans_x = -v_prev_y;
                                        v_trans_y = v_prev_x;
                                        shrink_by = Math.sqrt(v_prev_lensq)
                                    } else {
                                        v_trans_x = v_prev_x;
                                        v_trans_y = v_prev_y;
                                        shrink_by = Math.sqrt(v_prev_lensq / 2)
                                    }
                                }
                                return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by)
                            }
                            const contourMovements = [];
                            for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                                if (j === il) j = 0;
                                if (k === il) k = 0;
                                contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k])
                            }
                            const holesMovements = [];
                            let oneHoleMovements, verticesMovements = contourMovements.concat();
                            for (let h = 0, hl = holes.length; h < hl; h++) {
                                const ahole = holes[h];
                                oneHoleMovements = [];
                                for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
                                    if (j === il) j = 0;
                                    if (k === il) k = 0;
                                    oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k])
                                }
                                holesMovements.push(oneHoleMovements);
                                verticesMovements = verticesMovements.concat(oneHoleMovements)
                            }
                            for (let b = 0; b < bevelSegments; b++) {
                                const t = b / bevelSegments;
                                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                                for (let i = 0, il = contour.length; i < il; i++) {
                                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                                    v(vert.x, vert.y, -z)
                                }
                                for (let h = 0, hl = holes.length; h < hl; h++) {
                                    const ahole = holes[h];
                                    oneHoleMovements = holesMovements[h];
                                    for (let i = 0, il = ahole.length; i < il; i++) {
                                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                                        v(vert.x, vert.y, -z)
                                    }
                                }
                            }
                            const bs = bevelSize + bevelOffset;
                            for (let i = 0; i < vlen; i++) {
                                const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                                if (!extrudeByPath) {
                                    v(vert.x, vert.y, 0)
                                } else {
                                    normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
                                    binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
                                    position2.copy(extrudePts[0]).add(normal).add(binormal);
                                    v(position2.x, position2.y, position2.z)
                                }
                            }
                            for (let s = 1; s <= steps; s++) {
                                for (let i = 0; i < vlen; i++) {
                                    const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
                                    if (!extrudeByPath) {
                                        v(vert.x, vert.y, depth / steps * s)
                                    } else {
                                        normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
                                        binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
                                        position2.copy(extrudePts[s]).add(normal).add(binormal);
                                        v(position2.x, position2.y, position2.z)
                                    }
                                }
                            }
                            for (let b = bevelSegments - 1; b >= 0; b--) {
                                const t = b / bevelSegments;
                                const z = bevelThickness * Math.cos(t * Math.PI / 2);
                                const bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
                                for (let i = 0, il = contour.length; i < il; i++) {
                                    const vert = scalePt2(contour[i], contourMovements[i], bs);
                                    v(vert.x, vert.y, depth + z)
                                }
                                for (let h = 0, hl = holes.length; h < hl; h++) {
                                    const ahole = holes[h];
                                    oneHoleMovements = holesMovements[h];
                                    for (let i = 0, il = ahole.length; i < il; i++) {
                                        const vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
                                        if (!extrudeByPath) {
                                            v(vert.x, vert.y, depth + z)
                                        } else {
                                            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z)
                                        }
                                    }
                                }
                            }
                            buildLidFaces();
                            buildSideFaces();

                            function buildLidFaces() {
                                const start = verticesArray.length / 3;
                                if (bevelEnabled) {
                                    let layer = 0;
                                    let offset = vlen * layer;
                                    for (let i = 0; i < flen; i++) {
                                        const face = faces[i];
                                        f3(face[2] + offset, face[1] + offset, face[0] + offset)
                                    }
                                    layer = steps + bevelSegments * 2;
                                    offset = vlen * layer;
                                    for (let i = 0; i < flen; i++) {
                                        const face = faces[i];
                                        f3(face[0] + offset, face[1] + offset, face[2] + offset)
                                    }
                                } else {
                                    for (let i = 0; i < flen; i++) {
                                        const face = faces[i];
                                        f3(face[2], face[1], face[0])
                                    }
                                    for (let i = 0; i < flen; i++) {
                                        const face = faces[i];
                                        f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps)
                                    }
                                }
                                scope.addGroup(start, verticesArray.length / 3 - start, 0)
                            }

                            function buildSideFaces() {
                                const start = verticesArray.length / 3;
                                let layeroffset = 0;
                                sidewalls(contour, layeroffset);
                                layeroffset += contour.length;
                                for (let h = 0, hl = holes.length; h < hl; h++) {
                                    const ahole = holes[h];
                                    sidewalls(ahole, layeroffset);
                                    layeroffset += ahole.length
                                }
                                scope.addGroup(start, verticesArray.length / 3 - start, 1)
                            }

                            function sidewalls(contour, layeroffset) {
                                let i = contour.length;
                                while (--i >= 0) {
                                    const j = i;
                                    let k = i - 1;
                                    if (k < 0) k = contour.length - 1;
                                    for (let s = 0, sl = (steps + bevelSegments * 2); s < sl; s++) {
                                        const slen1 = vlen * s;
                                        const slen2 = vlen * (s + 1);
                                        const a = layeroffset + j + slen1,
                                            b = layeroffset + k + slen1,
                                            c = layeroffset + k + slen2,
                                            d = layeroffset + j + slen2;
                                        f4(a, b, c, d)
                                    }
                                }
                            }

                            function v(x, y, z) {
                                placeholder.push(x);
                                placeholder.push(y);
                                placeholder.push(z)
                            }

                            function f3(a, b, c) {
                                addVertex(a);
                                addVertex(b);
                                addVertex(c);
                                const nextIndex = verticesArray.length / 3;
                                const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                                addUV(uvs[0]);
                                addUV(uvs[1]);
                                addUV(uvs[2])
                            }

                            function f4(a, b, c, d) {
                                addVertex(a);
                                addVertex(b);
                                addVertex(d);
                                addVertex(b);
                                addVertex(c);
                                addVertex(d);
                                const nextIndex = verticesArray.length / 3;
                                const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
                                addUV(uvs[0]);
                                addUV(uvs[1]);
                                addUV(uvs[3]);
                                addUV(uvs[1]);
                                addUV(uvs[2]);
                                addUV(uvs[3])
                            }

                            function addVertex(index) {
                                verticesArray.push(placeholder[index * 3 + 0]);
                                verticesArray.push(placeholder[index * 3 + 1]);
                                verticesArray.push(placeholder[index * 3 + 2])
                            }

                            function addUV(vector2) {
                                uvArray.push(vector2.x);
                                uvArray.push(vector2.y)
                            }
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        const shapes = this.parameters.shapes;
                        const options = this.parameters.options;
                        return toJSON$1(shapes, options, data)
                    }
                    static fromJSON(data, shapes) {
                        const geometryShapes = [];
                        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                            const shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape)
                        }
                        const extrudePath = data.options.extrudePath;
                        if (extrudePath !== undefined) {
                            data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath)
                        }
                        return new ExtrudeGeometry(geometryShapes, data.options)
                    }
                }
                const WorldUVGenerator = {
                    generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
                        const a_x = vertices[indexA * 3];
                        const a_y = vertices[indexA * 3 + 1];
                        const b_x = vertices[indexB * 3];
                        const b_y = vertices[indexB * 3 + 1];
                        const c_x = vertices[indexC * 3];
                        const c_y = vertices[indexC * 3 + 1];
                        return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)]
                    },
                    generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
                        const a_x = vertices[indexA * 3];
                        const a_y = vertices[indexA * 3 + 1];
                        const a_z = vertices[indexA * 3 + 2];
                        const b_x = vertices[indexB * 3];
                        const b_y = vertices[indexB * 3 + 1];
                        const b_z = vertices[indexB * 3 + 2];
                        const c_x = vertices[indexC * 3];
                        const c_y = vertices[indexC * 3 + 1];
                        const c_z = vertices[indexC * 3 + 2];
                        const d_x = vertices[indexD * 3];
                        const d_y = vertices[indexD * 3 + 1];
                        const d_z = vertices[indexD * 3 + 2];
                        if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
                            return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)]
                        } else {
                            return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)]
                        }
                    }
                };

                function toJSON$1(shapes, options, data) {
                    data.shapes = [];
                    if (Array.isArray(shapes)) {
                        for (let i = 0, l = shapes.length; i < l; i++) {
                            const shape = shapes[i];
                            data.shapes.push(shape.uuid)
                        }
                    } else {
                        data.shapes.push(shapes.uuid)
                    }
                    data.options = Object.assign({}, options);
                    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
                    return data
                }
                class IcosahedronGeometry extends PolyhedronGeometry {
                    constructor(radius = 1, detail = 0) {
                        const t = (1 + Math.sqrt(5)) / 2;
                        const vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
                        const indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
                        super(vertices, indices, radius, detail);
                        this.type = 'IcosahedronGeometry';
                        this.parameters = {
                            radius: radius,
                            detail: detail
                        }
                    }
                    static fromJSON(data) {
                        return new IcosahedronGeometry(data.radius, data.detail)
                    }
                }
                class OctahedronGeometry extends PolyhedronGeometry {
                    constructor(radius = 1, detail = 0) {
                        const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
                        const indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
                        super(vertices, indices, radius, detail);
                        this.type = 'OctahedronGeometry';
                        this.parameters = {
                            radius: radius,
                            detail: detail
                        }
                    }
                    static fromJSON(data) {
                        return new OctahedronGeometry(data.radius, data.detail)
                    }
                }
                class RingGeometry extends BufferGeometry {
                    constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
                        super();
                        this.type = 'RingGeometry';
                        this.parameters = {
                            innerRadius: innerRadius,
                            outerRadius: outerRadius,
                            thetaSegments: thetaSegments,
                            phiSegments: phiSegments,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        thetaSegments = Math.max(3, thetaSegments);
                        phiSegments = Math.max(1, phiSegments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        let radius = innerRadius;
                        const radiusStep = ((outerRadius - innerRadius) / phiSegments);
                        const vertex = new Vector3();
                        const uv = new Vector2();
                        for (let j = 0; j <= phiSegments; j++) {
                            for (let i = 0; i <= thetaSegments; i++) {
                                const segment = thetaStart + i / thetaSegments * thetaLength;
                                vertex.x = radius * Math.cos(segment);
                                vertex.y = radius * Math.sin(segment);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                normals.push(0, 0, 1);
                                uv.x = (vertex.x / outerRadius + 1) / 2;
                                uv.y = (vertex.y / outerRadius + 1) / 2;
                                uvs.push(uv.x, uv.y)
                            }
                            radius += radiusStep
                        }
                        for (let j = 0; j < phiSegments; j++) {
                            const thetaSegmentLevel = j * (thetaSegments + 1);
                            for (let i = 0; i < thetaSegments; i++) {
                                const segment = i + thetaSegmentLevel;
                                const a = segment;
                                const b = segment + thetaSegments + 1;
                                const c = segment + thetaSegments + 2;
                                const d = segment + 1;
                                indices.push(a, b, d);
                                indices.push(b, c, d)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength)
                    }
                }
                class ShapeGeometry extends BufferGeometry {
                    constructor(shapes = new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]), curveSegments = 12) {
                        super();
                        this.type = 'ShapeGeometry';
                        this.parameters = {
                            shapes: shapes,
                            curveSegments: curveSegments
                        };
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        let groupStart = 0;
                        let groupCount = 0;
                        if (Array.isArray(shapes) === !1) {
                            addShape(shapes)
                        } else {
                            for (let i = 0; i < shapes.length; i++) {
                                addShape(shapes[i]);
                                this.addGroup(groupStart, groupCount, i);
                                groupStart += groupCount;
                                groupCount = 0
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function addShape(shape) {
                            const indexOffset = vertices.length / 3;
                            const points = shape.extractPoints(curveSegments);
                            let shapeVertices = points.shape;
                            const shapeHoles = points.holes;
                            if (ShapeUtils.isClockWise(shapeVertices) === !1) {
                                shapeVertices = shapeVertices.reverse()
                            }
                            for (let i = 0, l = shapeHoles.length; i < l; i++) {
                                const shapeHole = shapeHoles[i];
                                if (ShapeUtils.isClockWise(shapeHole) === !0) {
                                    shapeHoles[i] = shapeHole.reverse()
                                }
                            }
                            const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
                            for (let i = 0, l = shapeHoles.length; i < l; i++) {
                                const shapeHole = shapeHoles[i];
                                shapeVertices = shapeVertices.concat(shapeHole)
                            }
                            for (let i = 0, l = shapeVertices.length; i < l; i++) {
                                const vertex = shapeVertices[i];
                                vertices.push(vertex.x, vertex.y, 0);
                                normals.push(0, 0, 1);
                                uvs.push(vertex.x, vertex.y)
                            }
                            for (let i = 0, l = faces.length; i < l; i++) {
                                const face = faces[i];
                                const a = face[0] + indexOffset;
                                const b = face[1] + indexOffset;
                                const c = face[2] + indexOffset;
                                indices.push(a, b, c);
                                groupCount += 3
                            }
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        const shapes = this.parameters.shapes;
                        return toJSON(shapes, data)
                    }
                    static fromJSON(data, shapes) {
                        const geometryShapes = [];
                        for (let j = 0, jl = data.shapes.length; j < jl; j++) {
                            const shape = shapes[data.shapes[j]];
                            geometryShapes.push(shape)
                        }
                        return new ShapeGeometry(geometryShapes, data.curveSegments)
                    }
                }

                function toJSON(shapes, data) {
                    data.shapes = [];
                    if (Array.isArray(shapes)) {
                        for (let i = 0, l = shapes.length; i < l; i++) {
                            const shape = shapes[i];
                            data.shapes.push(shape.uuid)
                        }
                    } else {
                        data.shapes.push(shapes.uuid)
                    }
                    return data
                }
                class SphereGeometry extends BufferGeometry {
                    constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
                        super();
                        this.type = 'SphereGeometry';
                        this.parameters = {
                            radius: radius,
                            widthSegments: widthSegments,
                            heightSegments: heightSegments,
                            phiStart: phiStart,
                            phiLength: phiLength,
                            thetaStart: thetaStart,
                            thetaLength: thetaLength
                        };
                        widthSegments = Math.max(3, Math.floor(widthSegments));
                        heightSegments = Math.max(2, Math.floor(heightSegments));
                        const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
                        let index = 0;
                        const grid = [];
                        const vertex = new Vector3();
                        const normal = new Vector3();
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        for (let iy = 0; iy <= heightSegments; iy++) {
                            const verticesRow = [];
                            const v = iy / heightSegments;
                            let uOffset = 0;
                            if (iy === 0 && thetaStart === 0) {
                                uOffset = 0.5 / widthSegments
                            } else if (iy === heightSegments && thetaEnd === Math.PI) {
                                uOffset = -0.5 / widthSegments
                            }
                            for (let ix = 0; ix <= widthSegments; ix++) {
                                const u = ix / widthSegments;
                                vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                                vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
                                vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                normal.copy(vertex).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                uvs.push(u + uOffset, 1 - v);
                                verticesRow.push(index++)
                            }
                            grid.push(verticesRow)
                        }
                        for (let iy = 0; iy < heightSegments; iy++) {
                            for (let ix = 0; ix < widthSegments; ix++) {
                                const a = grid[iy][ix + 1];
                                const b = grid[iy][ix];
                                const c = grid[iy + 1][ix];
                                const d = grid[iy + 1][ix + 1];
                                if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
                                if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength)
                    }
                }
                class TetrahedronGeometry extends PolyhedronGeometry {
                    constructor(radius = 1, detail = 0) {
                        const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
                        const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
                        super(vertices, indices, radius, detail);
                        this.type = 'TetrahedronGeometry';
                        this.parameters = {
                            radius: radius,
                            detail: detail
                        }
                    }
                    static fromJSON(data) {
                        return new TetrahedronGeometry(data.radius, data.detail)
                    }
                }
                class TorusGeometry extends BufferGeometry {
                    constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
                        super();
                        this.type = 'TorusGeometry';
                        this.parameters = {
                            radius: radius,
                            tube: tube,
                            radialSegments: radialSegments,
                            tubularSegments: tubularSegments,
                            arc: arc
                        };
                        radialSegments = Math.floor(radialSegments);
                        tubularSegments = Math.floor(tubularSegments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        const center = new Vector3();
                        const vertex = new Vector3();
                        const normal = new Vector3();
                        for (let j = 0; j <= radialSegments; j++) {
                            for (let i = 0; i <= tubularSegments; i++) {
                                const u = i / tubularSegments * arc;
                                const v = j / radialSegments * Math.PI * 2;
                                vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
                                vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
                                vertex.z = tube * Math.sin(v);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                center.x = radius * Math.cos(u);
                                center.y = radius * Math.sin(u);
                                normal.subVectors(vertex, center).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                uvs.push(i / tubularSegments);
                                uvs.push(j / radialSegments)
                            }
                        }
                        for (let j = 1; j <= radialSegments; j++) {
                            for (let i = 1; i <= tubularSegments; i++) {
                                const a = (tubularSegments + 1) * j + i - 1;
                                const b = (tubularSegments + 1) * (j - 1) + i - 1;
                                const c = (tubularSegments + 1) * (j - 1) + i;
                                const d = (tubularSegments + 1) * j + i;
                                indices.push(a, b, d);
                                indices.push(b, c, d)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc)
                    }
                }
                class TorusKnotGeometry extends BufferGeometry {
                    constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
                        super();
                        this.type = 'TorusKnotGeometry';
                        this.parameters = {
                            radius: radius,
                            tube: tube,
                            tubularSegments: tubularSegments,
                            radialSegments: radialSegments,
                            p: p,
                            q: q
                        };
                        tubularSegments = Math.floor(tubularSegments);
                        radialSegments = Math.floor(radialSegments);
                        const indices = [];
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        const vertex = new Vector3();
                        const normal = new Vector3();
                        const P1 = new Vector3();
                        const P2 = new Vector3();
                        const B = new Vector3();
                        const T = new Vector3();
                        const N = new Vector3();
                        for (let i = 0; i <= tubularSegments; ++i) {
                            const u = i / tubularSegments * p * Math.PI * 2;
                            calculatePositionOnCurve(u, p, q, radius, P1);
                            calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
                            T.subVectors(P2, P1);
                            N.addVectors(P2, P1);
                            B.crossVectors(T, N);
                            N.crossVectors(B, T);
                            B.normalize();
                            N.normalize();
                            for (let j = 0; j <= radialSegments; ++j) {
                                const v = j / radialSegments * Math.PI * 2;
                                const cx = -tube * Math.cos(v);
                                const cy = tube * Math.sin(v);
                                vertex.x = P1.x + (cx * N.x + cy * B.x);
                                vertex.y = P1.y + (cx * N.y + cy * B.y);
                                vertex.z = P1.z + (cx * N.z + cy * B.z);
                                vertices.push(vertex.x, vertex.y, vertex.z);
                                normal.subVectors(vertex, P1).normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                uvs.push(i / tubularSegments);
                                uvs.push(j / radialSegments)
                            }
                        }
                        for (let j = 1; j <= tubularSegments; j++) {
                            for (let i = 1; i <= radialSegments; i++) {
                                const a = (radialSegments + 1) * (j - 1) + (i - 1);
                                const b = (radialSegments + 1) * j + (i - 1);
                                const c = (radialSegments + 1) * j + i;
                                const d = (radialSegments + 1) * (j - 1) + i;
                                indices.push(a, b, d);
                                indices.push(b, c, d)
                            }
                        }
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function calculatePositionOnCurve(u, p, q, radius, position) {
                            const cu = Math.cos(u);
                            const su = Math.sin(u);
                            const quOverP = q / p * u;
                            const cs = Math.cos(quOverP);
                            position.x = radius * (2 + cs) * 0.5 * cu;
                            position.y = radius * (2 + cs) * su * 0.5;
                            position.z = radius * Math.sin(quOverP) * 0.5
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    static fromJSON(data) {
                        return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q)
                    }
                }
                class TubeGeometry extends BufferGeometry {
                    constructor(path = new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = !1) {
                        super();
                        this.type = 'TubeGeometry';
                        this.parameters = {
                            path: path,
                            tubularSegments: tubularSegments,
                            radius: radius,
                            radialSegments: radialSegments,
                            closed: closed
                        };
                        const frames = path.computeFrenetFrames(tubularSegments, closed);
                        this.tangents = frames.tangents;
                        this.normals = frames.normals;
                        this.binormals = frames.binormals;
                        const vertex = new Vector3();
                        const normal = new Vector3();
                        const uv = new Vector2();
                        let P = new Vector3();
                        const vertices = [];
                        const normals = [];
                        const uvs = [];
                        const indices = [];
                        generateBufferData();
                        this.setIndex(indices);
                        this.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        this.setAttribute('normal', new Float32BufferAttribute(normals, 3));
                        this.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

                        function generateBufferData() {
                            for (let i = 0; i < tubularSegments; i++) {
                                generateSegment(i)
                            }
                            generateSegment((closed === !1) ? tubularSegments : 0);
                            generateUVs();
                            generateIndices()
                        }

                        function generateSegment(i) {
                            P = path.getPointAt(i / tubularSegments, P);
                            const N = frames.normals[i];
                            const B = frames.binormals[i];
                            for (let j = 0; j <= radialSegments; j++) {
                                const v = j / radialSegments * Math.PI * 2;
                                const sin = Math.sin(v);
                                const cos = -Math.cos(v);
                                normal.x = (cos * N.x + sin * B.x);
                                normal.y = (cos * N.y + sin * B.y);
                                normal.z = (cos * N.z + sin * B.z);
                                normal.normalize();
                                normals.push(normal.x, normal.y, normal.z);
                                vertex.x = P.x + radius * normal.x;
                                vertex.y = P.y + radius * normal.y;
                                vertex.z = P.z + radius * normal.z;
                                vertices.push(vertex.x, vertex.y, vertex.z)
                            }
                        }

                        function generateIndices() {
                            for (let j = 1; j <= tubularSegments; j++) {
                                for (let i = 1; i <= radialSegments; i++) {
                                    const a = (radialSegments + 1) * (j - 1) + (i - 1);
                                    const b = (radialSegments + 1) * j + (i - 1);
                                    const c = (radialSegments + 1) * j + i;
                                    const d = (radialSegments + 1) * (j - 1) + i;
                                    indices.push(a, b, d);
                                    indices.push(b, c, d)
                                }
                            }
                        }

                        function generateUVs() {
                            for (let i = 0; i <= tubularSegments; i++) {
                                for (let j = 0; j <= radialSegments; j++) {
                                    uv.x = i / tubularSegments;
                                    uv.y = j / radialSegments;
                                    uvs.push(uv.x, uv.y)
                                }
                            }
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.path = this.parameters.path.toJSON();
                        return data
                    }
                    static fromJSON(data) {
                        return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed)
                    }
                }
                class WireframeGeometry extends BufferGeometry {
                    constructor(geometry = null) {
                        super();
                        this.type = 'WireframeGeometry';
                        this.parameters = {
                            geometry: geometry
                        };
                        if (geometry !== null) {
                            const vertices = [];
                            const edges = new Set();
                            const start = new Vector3();
                            const end = new Vector3();
                            if (geometry.index !== null) {
                                const position = geometry.attributes.position;
                                const indices = geometry.index;
                                let groups = geometry.groups;
                                if (groups.length === 0) {
                                    groups = [{
                                        start: 0,
                                        count: indices.count,
                                        materialIndex: 0
                                    }]
                                }
                                for (let o = 0, ol = groups.length; o < ol; ++o) {
                                    const group = groups[o];
                                    const groupStart = group.start;
                                    const groupCount = group.count;
                                    for (let i = groupStart, l = (groupStart + groupCount); i < l; i += 3) {
                                        for (let j = 0; j < 3; j++) {
                                            const index1 = indices.getX(i + j);
                                            const index2 = indices.getX(i + (j + 1) % 3);
                                            start.fromBufferAttribute(position, index1);
                                            end.fromBufferAttribute(position, index2);
                                            if (isUniqueEdge(start, end, edges) === !0) {
                                                vertices.push(start.x, start.y, start.z);
                                                vertices.push(end.x, end.y, end.z)
                                            }
                                        }
                                    }
                                }
                            } else {
                                const position = geometry.attributes.position;
                                for (let i = 0, l = (position.count / 3); i < l; i++) {
                                    for (let j = 0; j < 3; j++) {
                                        const index1 = 3 * i + j;
                                        const index2 = 3 * i + ((j + 1) % 3);
                                        start.fromBufferAttribute(position, index1);
                                        end.fromBufferAttribute(position, index2);
                                        if (isUniqueEdge(start, end, edges) === !0) {
                                            vertices.push(start.x, start.y, start.z);
                                            vertices.push(end.x, end.y, end.z)
                                        }
                                    }
                                }
                            }
                            this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
                        }
                    }
                    copy(source) {
                        super.copy(source);
                        this.parameters = Object.assign({}, source.parameters);
                        return this
                    }
                }

                function isUniqueEdge(start, end, edges) {
                    const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
                    const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
                    if (edges.has(hash1) === !0 || edges.has(hash2) === !0) {
                        return !1
                    } else {
                        edges.add(hash1);
                        edges.add(hash2);
                        return !0
                    }
                }
                var Geometries = Object.freeze({
                    __proto__: null,
                    BoxGeometry: BoxGeometry,
                    CapsuleGeometry: CapsuleGeometry,
                    CircleGeometry: CircleGeometry,
                    ConeGeometry: ConeGeometry,
                    CylinderGeometry: CylinderGeometry,
                    DodecahedronGeometry: DodecahedronGeometry,
                    EdgesGeometry: EdgesGeometry,
                    ExtrudeGeometry: ExtrudeGeometry,
                    IcosahedronGeometry: IcosahedronGeometry,
                    LatheGeometry: LatheGeometry,
                    OctahedronGeometry: OctahedronGeometry,
                    PlaneGeometry: PlaneGeometry,
                    PolyhedronGeometry: PolyhedronGeometry,
                    RingGeometry: RingGeometry,
                    ShapeGeometry: ShapeGeometry,
                    SphereGeometry: SphereGeometry,
                    TetrahedronGeometry: TetrahedronGeometry,
                    TorusGeometry: TorusGeometry,
                    TorusKnotGeometry: TorusKnotGeometry,
                    TubeGeometry: TubeGeometry,
                    WireframeGeometry: WireframeGeometry
                });
                class ShadowMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isShadowMaterial = !0;
                        this.type = 'ShadowMaterial';
                        this.color = new Color(0x000000);
                        this.transparent = !0;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.fog = source.fog;
                        return this
                    }
                }
                class RawShaderMaterial extends ShaderMaterial {
                    constructor(parameters) {
                        super(parameters);
                        this.isRawShaderMaterial = !0;
                        this.type = 'RawShaderMaterial'
                    }
                }
                class MeshStandardMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshStandardMaterial = !0;
                        this.defines = {
                            'STANDARD': ''
                        };
                        this.type = 'MeshStandardMaterial';
                        this.color = new Color(0xffffff);
                        this.roughness = 1.0;
                        this.metalness = 0.0;
                        this.map = null;
                        this.lightMap = null;
                        this.lightMapIntensity = 1.0;
                        this.aoMap = null;
                        this.aoMapIntensity = 1.0;
                        this.emissive = new Color(0x000000);
                        this.emissiveIntensity = 1.0;
                        this.emissiveMap = null;
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.roughnessMap = null;
                        this.metalnessMap = null;
                        this.alphaMap = null;
                        this.envMap = null;
                        this.envMapRotation = new Euler();
                        this.envMapIntensity = 1.0;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.wireframeLinecap = 'round';
                        this.wireframeLinejoin = 'round';
                        this.flatShading = !1;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.defines = {
                            'STANDARD': ''
                        };
                        this.color.copy(source.color);
                        this.roughness = source.roughness;
                        this.metalness = source.metalness;
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.roughnessMap = source.roughnessMap;
                        this.metalnessMap = source.metalnessMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.envMapRotation.copy(source.envMapRotation);
                        this.envMapIntensity = source.envMapIntensity;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.flatShading = source.flatShading;
                        this.fog = source.fog;
                        return this
                    }
                }
                class MeshPhysicalMaterial extends MeshStandardMaterial {
                    constructor(parameters) {
                        super();
                        this.isMeshPhysicalMaterial = !0;
                        this.defines = {
                            'STANDARD': '',
                            'PHYSICAL': ''
                        };
                        this.type = 'MeshPhysicalMaterial';
                        this.anisotropyRotation = 0;
                        this.anisotropyMap = null;
                        this.clearcoatMap = null;
                        this.clearcoatRoughness = 0.0;
                        this.clearcoatRoughnessMap = null;
                        this.clearcoatNormalScale = new Vector2(1, 1);
                        this.clearcoatNormalMap = null;
                        this.ior = 1.5;
                        Object.defineProperty(this, 'reflectivity', {
                            get: function() {
                                return (clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1))
                            },
                            set: function(reflectivity) {
                                this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity)
                            }
                        });
                        this.iridescenceMap = null;
                        this.iridescenceIOR = 1.3;
                        this.iridescenceThicknessRange = [100, 400];
                        this.iridescenceThicknessMap = null;
                        this.sheenColor = new Color(0x000000);
                        this.sheenColorMap = null;
                        this.sheenRoughness = 1.0;
                        this.sheenRoughnessMap = null;
                        this.transmissionMap = null;
                        this.thickness = 0;
                        this.thicknessMap = null;
                        this.attenuationDistance = Infinity;
                        this.attenuationColor = new Color(1, 1, 1);
                        this.specularIntensity = 1.0;
                        this.specularIntensityMap = null;
                        this.specularColor = new Color(1, 1, 1);
                        this.specularColorMap = null;
                        this._anisotropy = 0;
                        this._clearcoat = 0;
                        this._dispersion = 0;
                        this._iridescence = 0;
                        this._sheen = 0.0;
                        this._transmission = 0;
                        this.setValues(parameters)
                    }
                    get anisotropy() {
                        return this._anisotropy
                    }
                    set anisotropy(value) {
                        if (this._anisotropy > 0 !== value > 0) {
                            this.version++
                        }
                        this._anisotropy = value
                    }
                    get clearcoat() {
                        return this._clearcoat
                    }
                    set clearcoat(value) {
                        if (this._clearcoat > 0 !== value > 0) {
                            this.version++
                        }
                        this._clearcoat = value
                    }
                    get iridescence() {
                        return this._iridescence
                    }
                    set iridescence(value) {
                        if (this._iridescence > 0 !== value > 0) {
                            this.version++
                        }
                        this._iridescence = value
                    }
                    get dispersion() {
                        return this._dispersion
                    }
                    set dispersion(value) {
                        if (this._dispersion > 0 !== value > 0) {
                            this.version++
                        }
                        this._dispersion = value
                    }
                    get sheen() {
                        return this._sheen
                    }
                    set sheen(value) {
                        if (this._sheen > 0 !== value > 0) {
                            this.version++
                        }
                        this._sheen = value
                    }
                    get transmission() {
                        return this._transmission
                    }
                    set transmission(value) {
                        if (this._transmission > 0 !== value > 0) {
                            this.version++
                        }
                        this._transmission = value
                    }
                    copy(source) {
                        super.copy(source);
                        this.defines = {
                            'STANDARD': '',
                            'PHYSICAL': ''
                        };
                        this.anisotropy = source.anisotropy;
                        this.anisotropyRotation = source.anisotropyRotation;
                        this.anisotropyMap = source.anisotropyMap;
                        this.clearcoat = source.clearcoat;
                        this.clearcoatMap = source.clearcoatMap;
                        this.clearcoatRoughness = source.clearcoatRoughness;
                        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
                        this.clearcoatNormalMap = source.clearcoatNormalMap;
                        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
                        this.dispersion = source.dispersion;
                        this.ior = source.ior;
                        this.iridescence = source.iridescence;
                        this.iridescenceMap = source.iridescenceMap;
                        this.iridescenceIOR = source.iridescenceIOR;
                        this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
                        this.iridescenceThicknessMap = source.iridescenceThicknessMap;
                        this.sheen = source.sheen;
                        this.sheenColor.copy(source.sheenColor);
                        this.sheenColorMap = source.sheenColorMap;
                        this.sheenRoughness = source.sheenRoughness;
                        this.sheenRoughnessMap = source.sheenRoughnessMap;
                        this.transmission = source.transmission;
                        this.transmissionMap = source.transmissionMap;
                        this.thickness = source.thickness;
                        this.thicknessMap = source.thicknessMap;
                        this.attenuationDistance = source.attenuationDistance;
                        this.attenuationColor.copy(source.attenuationColor);
                        this.specularIntensity = source.specularIntensity;
                        this.specularIntensityMap = source.specularIntensityMap;
                        this.specularColor.copy(source.specularColor);
                        this.specularColorMap = source.specularColorMap;
                        return this
                    }
                }
                class MeshPhongMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshPhongMaterial = !0;
                        this.type = 'MeshPhongMaterial';
                        this.color = new Color(0xffffff);
                        this.specular = new Color(0x111111);
                        this.shininess = 30;
                        this.map = null;
                        this.lightMap = null;
                        this.lightMapIntensity = 1.0;
                        this.aoMap = null;
                        this.aoMapIntensity = 1.0;
                        this.emissive = new Color(0x000000);
                        this.emissiveIntensity = 1.0;
                        this.emissiveMap = null;
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.specularMap = null;
                        this.alphaMap = null;
                        this.envMap = null;
                        this.envMapRotation = new Euler();
                        this.combine = MultiplyOperation;
                        this.reflectivity = 1;
                        this.refractionRatio = 0.98;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.wireframeLinecap = 'round';
                        this.wireframeLinejoin = 'round';
                        this.flatShading = !1;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.specular.copy(source.specular);
                        this.shininess = source.shininess;
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.envMapRotation.copy(source.envMapRotation);
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.flatShading = source.flatShading;
                        this.fog = source.fog;
                        return this
                    }
                }
                class MeshToonMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshToonMaterial = !0;
                        this.defines = {
                            'TOON': ''
                        };
                        this.type = 'MeshToonMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.gradientMap = null;
                        this.lightMap = null;
                        this.lightMapIntensity = 1.0;
                        this.aoMap = null;
                        this.aoMapIntensity = 1.0;
                        this.emissive = new Color(0x000000);
                        this.emissiveIntensity = 1.0;
                        this.emissiveMap = null;
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.alphaMap = null;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.wireframeLinecap = 'round';
                        this.wireframeLinejoin = 'round';
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.gradientMap = source.gradientMap;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.alphaMap = source.alphaMap;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.fog = source.fog;
                        return this
                    }
                }
                class MeshNormalMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshNormalMaterial = !0;
                        this.type = 'MeshNormalMaterial';
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.flatShading = !1;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.flatShading = source.flatShading;
                        return this
                    }
                }
                class MeshLambertMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshLambertMaterial = !0;
                        this.type = 'MeshLambertMaterial';
                        this.color = new Color(0xffffff);
                        this.map = null;
                        this.lightMap = null;
                        this.lightMapIntensity = 1.0;
                        this.aoMap = null;
                        this.aoMapIntensity = 1.0;
                        this.emissive = new Color(0x000000);
                        this.emissiveIntensity = 1.0;
                        this.emissiveMap = null;
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.specularMap = null;
                        this.alphaMap = null;
                        this.envMap = null;
                        this.envMapRotation = new Euler();
                        this.combine = MultiplyOperation;
                        this.reflectivity = 1;
                        this.refractionRatio = 0.98;
                        this.wireframe = !1;
                        this.wireframeLinewidth = 1;
                        this.wireframeLinecap = 'round';
                        this.wireframeLinejoin = 'round';
                        this.flatShading = !1;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.color.copy(source.color);
                        this.map = source.map;
                        this.lightMap = source.lightMap;
                        this.lightMapIntensity = source.lightMapIntensity;
                        this.aoMap = source.aoMap;
                        this.aoMapIntensity = source.aoMapIntensity;
                        this.emissive.copy(source.emissive);
                        this.emissiveMap = source.emissiveMap;
                        this.emissiveIntensity = source.emissiveIntensity;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.specularMap = source.specularMap;
                        this.alphaMap = source.alphaMap;
                        this.envMap = source.envMap;
                        this.envMapRotation.copy(source.envMapRotation);
                        this.combine = source.combine;
                        this.reflectivity = source.reflectivity;
                        this.refractionRatio = source.refractionRatio;
                        this.wireframe = source.wireframe;
                        this.wireframeLinewidth = source.wireframeLinewidth;
                        this.wireframeLinecap = source.wireframeLinecap;
                        this.wireframeLinejoin = source.wireframeLinejoin;
                        this.flatShading = source.flatShading;
                        this.fog = source.fog;
                        return this
                    }
                }
                class MeshMatcapMaterial extends Material {
                    constructor(parameters) {
                        super();
                        this.isMeshMatcapMaterial = !0;
                        this.defines = {
                            'MATCAP': ''
                        };
                        this.type = 'MeshMatcapMaterial';
                        this.color = new Color(0xffffff);
                        this.matcap = null;
                        this.map = null;
                        this.bumpMap = null;
                        this.bumpScale = 1;
                        this.normalMap = null;
                        this.normalMapType = TangentSpaceNormalMap;
                        this.normalScale = new Vector2(1, 1);
                        this.displacementMap = null;
                        this.displacementScale = 1;
                        this.displacementBias = 0;
                        this.alphaMap = null;
                        this.flatShading = !1;
                        this.fog = !0;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.defines = {
                            'MATCAP': ''
                        };
                        this.color.copy(source.color);
                        this.matcap = source.matcap;
                        this.map = source.map;
                        this.bumpMap = source.bumpMap;
                        this.bumpScale = source.bumpScale;
                        this.normalMap = source.normalMap;
                        this.normalMapType = source.normalMapType;
                        this.normalScale.copy(source.normalScale);
                        this.displacementMap = source.displacementMap;
                        this.displacementScale = source.displacementScale;
                        this.displacementBias = source.displacementBias;
                        this.alphaMap = source.alphaMap;
                        this.flatShading = source.flatShading;
                        this.fog = source.fog;
                        return this
                    }
                }
                class LineDashedMaterial extends LineBasicMaterial {
                    constructor(parameters) {
                        super();
                        this.isLineDashedMaterial = !0;
                        this.type = 'LineDashedMaterial';
                        this.scale = 1;
                        this.dashSize = 3;
                        this.gapSize = 1;
                        this.setValues(parameters)
                    }
                    copy(source) {
                        super.copy(source);
                        this.scale = source.scale;
                        this.dashSize = source.dashSize;
                        this.gapSize = source.gapSize;
                        return this
                    }
                }

                function convertArray(array, type, forceClone) {
                    if (!array || !forceClone && array.constructor === type) return array;
                    if (typeof type.BYTES_PER_ELEMENT === 'number') {
                        return new type(array)
                    }
                    return Array.prototype.slice.call(array)
                }

                function isTypedArray(object) {
                    return ArrayBuffer.isView(object) && !(object instanceof DataView)
                }

                function getKeyframeOrder(times) {
                    function compareTime(i, j) {
                        return times[i] - times[j]
                    }
                    const n = times.length;
                    const result = new Array(n);
                    for (let i = 0; i !== n; ++i) result[i] = i;
                    result.sort(compareTime);
                    return result
                }

                function sortedArray(values, stride, order) {
                    const nValues = values.length;
                    const result = new values.constructor(nValues);
                    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
                        const srcOffset = order[i] * stride;
                        for (let j = 0; j !== stride; ++j) {
                            result[dstOffset++] = values[srcOffset + j]
                        }
                    }
                    return result
                }

                function flattenJSON(jsonKeys, times, values, valuePropertyName) {
                    let i = 1,
                        key = jsonKeys[0];
                    while (key !== undefined && key[valuePropertyName] === undefined) {
                        key = jsonKeys[i++]
                    }
                    if (key === undefined) return;
                    let value = key[valuePropertyName];
                    if (value === undefined) return;
                    if (Array.isArray(value)) {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push.apply(values, value)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined);
                    } else if (value.toArray !== undefined) {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                value.toArray(values, values.length)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined);
                    } else {
                        do {
                            value = key[valuePropertyName];
                            if (value !== undefined) {
                                times.push(key.time);
                                values.push(value)
                            }
                            key = jsonKeys[i++]
                        } while (key !== undefined);
                    }
                }

                function subclip(sourceClip, name, startFrame, endFrame, fps = 30) {
                    const clip = sourceClip.clone();
                    clip.name = name;
                    const tracks = [];
                    for (let i = 0; i < clip.tracks.length; ++i) {
                        const track = clip.tracks[i];
                        const valueSize = track.getValueSize();
                        const times = [];
                        const values = [];
                        for (let j = 0; j < track.times.length; ++j) {
                            const frame = track.times[j] * fps;
                            if (frame < startFrame || frame >= endFrame) continue;
                            times.push(track.times[j]);
                            for (let k = 0; k < valueSize; ++k) {
                                values.push(track.values[j * valueSize + k])
                            }
                        }
                        if (times.length === 0) continue;
                        track.times = convertArray(times, track.times.constructor);
                        track.values = convertArray(values, track.values.constructor);
                        tracks.push(track)
                    }
                    clip.tracks = tracks;
                    let minStartTime = Infinity;
                    for (let i = 0; i < clip.tracks.length; ++i) {
                        if (minStartTime > clip.tracks[i].times[0]) {
                            minStartTime = clip.tracks[i].times[0]
                        }
                    }
                    for (let i = 0; i < clip.tracks.length; ++i) {
                        clip.tracks[i].shift(-1 * minStartTime)
                    }
                    clip.resetDuration();
                    return clip
                }

                function makeClipAdditive(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {
                    if (fps <= 0) fps = 30;
                    const numTracks = referenceClip.tracks.length;
                    const referenceTime = referenceFrame / fps;
                    for (let i = 0; i < numTracks; ++i) {
                        const referenceTrack = referenceClip.tracks[i];
                        const referenceTrackType = referenceTrack.ValueTypeName;
                        if (referenceTrackType === 'bool' || referenceTrackType === 'string') continue;
                        const targetTrack = targetClip.tracks.find(function(track) {
                            return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType
                        });
                        if (targetTrack === undefined) continue;
                        let referenceOffset = 0;
                        const referenceValueSize = referenceTrack.getValueSize();
                        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                            referenceOffset = referenceValueSize / 3
                        }
                        let targetOffset = 0;
                        const targetValueSize = targetTrack.getValueSize();
                        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
                            targetOffset = targetValueSize / 3
                        }
                        const lastIndex = referenceTrack.times.length - 1;
                        let referenceValue;
                        if (referenceTime <= referenceTrack.times[0]) {
                            const startIndex = referenceOffset;
                            const endIndex = referenceValueSize - referenceOffset;
                            referenceValue = referenceTrack.values.slice(startIndex, endIndex)
                        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
                            const startIndex = lastIndex * referenceValueSize + referenceOffset;
                            const endIndex = startIndex + referenceValueSize - referenceOffset;
                            referenceValue = referenceTrack.values.slice(startIndex, endIndex)
                        } else {
                            const interpolant = referenceTrack.createInterpolant();
                            const startIndex = referenceOffset;
                            const endIndex = referenceValueSize - referenceOffset;
                            interpolant.evaluate(referenceTime);
                            referenceValue = interpolant.resultBuffer.slice(startIndex, endIndex)
                        }
                        if (referenceTrackType === 'quaternion') {
                            const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
                            referenceQuat.toArray(referenceValue)
                        }
                        const numTimes = targetTrack.times.length;
                        for (let j = 0; j < numTimes; ++j) {
                            const valueStart = j * targetValueSize + targetOffset;
                            if (referenceTrackType === 'quaternion') {
                                Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart)
                            } else {
                                const valueEnd = targetValueSize - targetOffset * 2;
                                for (let k = 0; k < valueEnd; ++k) {
                                    targetTrack.values[valueStart + k] -= referenceValue[k]
                                }
                            }
                        }
                    }
                    targetClip.blendMode = AdditiveAnimationBlendMode;
                    return targetClip
                }
                const AnimationUtils = {
                    convertArray: convertArray,
                    isTypedArray: isTypedArray,
                    getKeyframeOrder: getKeyframeOrder,
                    sortedArray: sortedArray,
                    flattenJSON: flattenJSON,
                    subclip: subclip,
                    makeClipAdditive: makeClipAdditive
                };
                class Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        this.parameterPositions = parameterPositions;
                        this._cachedIndex = 0;
                        this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
                        this.sampleValues = sampleValues;
                        this.valueSize = sampleSize;
                        this.settings = null;
                        this.DefaultSettings_ = {}
                    }
                    evaluate(t) {
                        const pp = this.parameterPositions;
                        let i1 = this._cachedIndex,
                            t1 = pp[i1],
                            t0 = pp[i1 - 1];
                        validate_interval: {
                            seek: {
                                let right;linear_scan: {
                                    forward_scan: if (!(t < t1)) {
                                        for (let giveUpAt = i1 + 2;;) {
                                            if (t1 === undefined) {
                                                if (t < t0) break forward_scan;
                                                i1 = pp.length;
                                                this._cachedIndex = i1;
                                                return this.copySampleValue_(i1 - 1)
                                            }
                                            if (i1 === giveUpAt) break;
                                            t0 = t1;
                                            t1 = pp[++i1];
                                            if (t < t1) {
                                                break seek
                                            }
                                        }
                                        right = pp.length;
                                        break linear_scan
                                    }
                                    if (!(t >= t0)) {
                                        const t1global = pp[1];
                                        if (t < t1global) {
                                            i1 = 2;
                                            t0 = t1global
                                        }
                                        for (let giveUpAt = i1 - 2;;) {
                                            if (t0 === undefined) {
                                                this._cachedIndex = 0;
                                                return this.copySampleValue_(0)
                                            }
                                            if (i1 === giveUpAt) break;
                                            t1 = t0;
                                            t0 = pp[--i1 - 1];
                                            if (t >= t0) {
                                                break seek
                                            }
                                        }
                                        right = i1;
                                        i1 = 0;
                                        break linear_scan
                                    }
                                    break validate_interval
                                }
                                while (i1 < right) {
                                    const mid = (i1 + right) >>> 1;
                                    if (t < pp[mid]) {
                                        right = mid
                                    } else {
                                        i1 = mid + 1
                                    }
                                }
                                t1 = pp[i1];t0 = pp[i1 - 1];
                                if (t0 === undefined) {
                                    this._cachedIndex = 0;
                                    return this.copySampleValue_(0)
                                }
                                if (t1 === undefined) {
                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.copySampleValue_(i1 - 1)
                                }
                            }
                            this._cachedIndex = i1;this.intervalChanged_(i1, t0, t1)
                        }
                        return this.interpolate_(i1, t0, t, t1)
                    }
                    getSettings_() {
                        return this.settings || this.DefaultSettings_
                    }
                    copySampleValue_(index) {
                        const result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            offset = index * stride;
                        for (let i = 0; i !== stride; ++i) {
                            result[i] = values[offset + i]
                        }
                        return result
                    }
                    interpolate_() {
                        throw new Error('call to abstract method')
                    }
                    intervalChanged_() {}
                }
                class CubicInterpolant extends Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        super(parameterPositions, sampleValues, sampleSize, resultBuffer);
                        this._weightPrev = -0;
                        this._offsetPrev = -0;
                        this._weightNext = -0;
                        this._offsetNext = -0;
                        this.DefaultSettings_ = {
                            endingStart: ZeroCurvatureEnding,
                            endingEnd: ZeroCurvatureEnding
                        }
                    }
                    intervalChanged_(i1, t0, t1) {
                        const pp = this.parameterPositions;
                        let iPrev = i1 - 2,
                            iNext = i1 + 1,
                            tPrev = pp[iPrev],
                            tNext = pp[iNext];
                        if (tPrev === undefined) {
                            switch (this.getSettings_().endingStart) {
                                case ZeroSlopeEnding:
                                    iPrev = i1;
                                    tPrev = 2 * t0 - t1;
                                    break;
                                case WrapAroundEnding:
                                    iPrev = pp.length - 2;
                                    tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
                                    break;
                                default:
                                    iPrev = i1;
                                    tPrev = t1
                            }
                        }
                        if (tNext === undefined) {
                            switch (this.getSettings_().endingEnd) {
                                case ZeroSlopeEnding:
                                    iNext = i1;
                                    tNext = 2 * t1 - t0;
                                    break;
                                case WrapAroundEnding:
                                    iNext = 1;
                                    tNext = t1 + pp[1] - pp[0];
                                    break;
                                default:
                                    iNext = i1 - 1;
                                    tNext = t0
                            }
                        }
                        const halfDt = (t1 - t0) * 0.5,
                            stride = this.valueSize;
                        this._weightPrev = halfDt / (t0 - tPrev);
                        this._weightNext = halfDt / (tNext - t1);
                        this._offsetPrev = iPrev * stride;
                        this._offsetNext = iNext * stride
                    }
                    interpolate_(i1, t0, t, t1) {
                        const result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            o1 = i1 * stride,
                            o0 = o1 - stride,
                            oP = this._offsetPrev,
                            oN = this._offsetNext,
                            wP = this._weightPrev,
                            wN = this._weightNext,
                            p = (t - t0) / (t1 - t0),
                            pp = p * p,
                            ppp = pp * p;
                        const sP = -wP * ppp + 2 * wP * pp - wP * p;
                        const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
                        const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
                        const sN = wN * ppp - wN * pp;
                        for (let i = 0; i !== stride; ++i) {
                            result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i]
                        }
                        return result
                    }
                }
                class LinearInterpolant extends Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        super(parameterPositions, sampleValues, sampleSize, resultBuffer)
                    }
                    interpolate_(i1, t0, t, t1) {
                        const result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            offset1 = i1 * stride,
                            offset0 = offset1 - stride,
                            weight1 = (t - t0) / (t1 - t0),
                            weight0 = 1 - weight1;
                        for (let i = 0; i !== stride; ++i) {
                            result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1
                        }
                        return result
                    }
                }
                class DiscreteInterpolant extends Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        super(parameterPositions, sampleValues, sampleSize, resultBuffer)
                    }
                    interpolate_(i1) {
                        return this.copySampleValue_(i1 - 1)
                    }
                }
                class KeyframeTrack {
                    constructor(name, times, values, interpolation) {
                        if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
                        if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
                        this.name = name;
                        this.times = convertArray(times, this.TimeBufferType);
                        this.values = convertArray(values, this.ValueBufferType);
                        this.setInterpolation(interpolation || this.DefaultInterpolation)
                    }
                    static toJSON(track) {
                        const trackType = track.constructor;
                        let json;
                        if (trackType.toJSON !== this.toJSON) {
                            json = trackType.toJSON(track)
                        } else {
                            json = {
                                'name': track.name,
                                'times': convertArray(track.times, Array),
                                'values': convertArray(track.values, Array)
                            };
                            const interpolation = track.getInterpolation();
                            if (interpolation !== track.DefaultInterpolation) {
                                json.interpolation = interpolation
                            }
                        }
                        json.type = track.ValueTypeName;
                        return json
                    }
                    InterpolantFactoryMethodDiscrete(result) {
                        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result)
                    }
                    InterpolantFactoryMethodLinear(result) {
                        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result)
                    }
                    InterpolantFactoryMethodSmooth(result) {
                        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result)
                    }
                    setInterpolation(interpolation) {
                        let factoryMethod;
                        switch (interpolation) {
                            case InterpolateDiscrete:
                                factoryMethod = this.InterpolantFactoryMethodDiscrete;
                                break;
                            case InterpolateLinear:
                                factoryMethod = this.InterpolantFactoryMethodLinear;
                                break;
                            case InterpolateSmooth:
                                factoryMethod = this.InterpolantFactoryMethodSmooth;
                                break
                        }
                        if (factoryMethod === undefined) {
                            const message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
                            if (this.createInterpolant === undefined) {
                                if (interpolation !== this.DefaultInterpolation) {
                                    this.setInterpolation(this.DefaultInterpolation)
                                } else {
                                    throw new Error(message)
                                }
                            }
                            console.warn('THREE.KeyframeTrack:', message);
                            return this
                        }
                        this.createInterpolant = factoryMethod;
                        return this
                    }
                    getInterpolation() {
                        switch (this.createInterpolant) {
                            case this.InterpolantFactoryMethodDiscrete:
                                return InterpolateDiscrete;
                            case this.InterpolantFactoryMethodLinear:
                                return InterpolateLinear;
                            case this.InterpolantFactoryMethodSmooth:
                                return InterpolateSmooth
                        }
                    }
                    getValueSize() {
                        return this.values.length / this.times.length
                    }
                    shift(timeOffset) {
                        if (timeOffset !== 0.0) {
                            const times = this.times;
                            for (let i = 0, n = times.length; i !== n; ++i) {
                                times[i] += timeOffset
                            }
                        }
                        return this
                    }
                    scale(timeScale) {
                        if (timeScale !== 1.0) {
                            const times = this.times;
                            for (let i = 0, n = times.length; i !== n; ++i) {
                                times[i] *= timeScale
                            }
                        }
                        return this
                    }
                    trim(startTime, endTime) {
                        const times = this.times,
                            nKeys = times.length;
                        let from = 0,
                            to = nKeys - 1;
                        while (from !== nKeys && times[from] < startTime) {
                            ++from
                        }
                        while (to !== -1 && times[to] > endTime) {
                            --to
                        }
                        ++to;
                        if (from !== 0 || to !== nKeys) {
                            if (from >= to) {
                                to = Math.max(to, 1);
                                from = to - 1
                            }
                            const stride = this.getValueSize();
                            this.times = times.slice(from, to);
                            this.values = this.values.slice(from * stride, to * stride)
                        }
                        return this
                    }
                    validate() {
                        let valid = !0;
                        const valueSize = this.getValueSize();
                        if (valueSize - Math.floor(valueSize) !== 0) {
                            console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
                            valid = !1
                        }
                        const times = this.times,
                            values = this.values,
                            nKeys = times.length;
                        if (nKeys === 0) {
                            console.error('THREE.KeyframeTrack: Track is empty.', this);
                            valid = !1
                        }
                        let prevTime = null;
                        for (let i = 0; i !== nKeys; i++) {
                            const currTime = times[i];
                            if (typeof currTime === 'number' && isNaN(currTime)) {
                                console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
                                valid = !1;
                                break
                            }
                            if (prevTime !== null && prevTime > currTime) {
                                console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
                                valid = !1;
                                break
                            }
                            prevTime = currTime
                        }
                        if (values !== undefined) {
                            if (isTypedArray(values)) {
                                for (let i = 0, n = values.length; i !== n; ++i) {
                                    const value = values[i];
                                    if (isNaN(value)) {
                                        console.error('THREE.KeyframeTrack: Value is not a valid number.', this, i, value);
                                        valid = !1;
                                        break
                                    }
                                }
                            }
                        }
                        return valid
                    }
                    optimize() {
                        const times = this.times.slice(),
                            values = this.values.slice(),
                            stride = this.getValueSize(),
                            smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
                            lastIndex = times.length - 1;
                        let writeIndex = 1;
                        for (let i = 1; i < lastIndex; ++i) {
                            let keep = !1;
                            const time = times[i];
                            const timeNext = times[i + 1];
                            if (time !== timeNext && (i !== 1 || time !== times[0])) {
                                if (!smoothInterpolation) {
                                    const offset = i * stride,
                                        offsetP = offset - stride,
                                        offsetN = offset + stride;
                                    for (let j = 0; j !== stride; ++j) {
                                        const value = values[offset + j];
                                        if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                                            keep = !0;
                                            break
                                        }
                                    }
                                } else {
                                    keep = !0
                                }
                            }
                            if (keep) {
                                if (i !== writeIndex) {
                                    times[writeIndex] = times[i];
                                    const readOffset = i * stride,
                                        writeOffset = writeIndex * stride;
                                    for (let j = 0; j !== stride; ++j) {
                                        values[writeOffset + j] = values[readOffset + j]
                                    }
                                }
                                ++writeIndex
                            }
                        }
                        if (lastIndex > 0) {
                            times[writeIndex] = times[lastIndex];
                            for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
                                values[writeOffset + j] = values[readOffset + j]
                            }
                            ++writeIndex
                        }
                        if (writeIndex !== times.length) {
                            this.times = times.slice(0, writeIndex);
                            this.values = values.slice(0, writeIndex * stride)
                        } else {
                            this.times = times;
                            this.values = values
                        }
                        return this
                    }
                    clone() {
                        const times = this.times.slice();
                        const values = this.values.slice();
                        const TypedKeyframeTrack = this.constructor;
                        const track = new TypedKeyframeTrack(this.name, times, values);
                        track.createInterpolant = this.createInterpolant;
                        return track
                    }
                }
                KeyframeTrack.prototype.TimeBufferType = Float32Array;
                KeyframeTrack.prototype.ValueBufferType = Float32Array;
                KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
                class BooleanKeyframeTrack extends KeyframeTrack {
                    constructor(name, times, values) {
                        super(name, times, values)
                    }
                }
                BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
                BooleanKeyframeTrack.prototype.ValueBufferType = Array;
                BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
                BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
                BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                class ColorKeyframeTrack extends KeyframeTrack {}
                ColorKeyframeTrack.prototype.ValueTypeName = 'color';
                class NumberKeyframeTrack extends KeyframeTrack {}
                NumberKeyframeTrack.prototype.ValueTypeName = 'number';
                class QuaternionLinearInterpolant extends Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        super(parameterPositions, sampleValues, sampleSize, resultBuffer)
                    }
                    interpolate_(i1, t0, t, t1) {
                        const result = this.resultBuffer,
                            values = this.sampleValues,
                            stride = this.valueSize,
                            alpha = (t - t0) / (t1 - t0);
                        let offset = i1 * stride;
                        for (let end = offset + stride; offset !== end; offset += 4) {
                            Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha)
                        }
                        return result
                    }
                }
                class QuaternionKeyframeTrack extends KeyframeTrack {
                    InterpolantFactoryMethodLinear(result) {
                        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result)
                    }
                }
                QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
                QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                class StringKeyframeTrack extends KeyframeTrack {
                    constructor(name, times, values) {
                        super(name, times, values)
                    }
                }
                StringKeyframeTrack.prototype.ValueTypeName = 'string';
                StringKeyframeTrack.prototype.ValueBufferType = Array;
                StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
                StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
                StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;
                class VectorKeyframeTrack extends KeyframeTrack {}
                VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
                class AnimationClip {
                    constructor(name = '', duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
                        this.name = name;
                        this.tracks = tracks;
                        this.duration = duration;
                        this.blendMode = blendMode;
                        this.uuid = generateUUID();
                        if (this.duration < 0) {
                            this.resetDuration()
                        }
                    }
                    static parse(json) {
                        const tracks = [],
                            jsonTracks = json.tracks,
                            frameTime = 1.0 / (json.fps || 1.0);
                        for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
                            tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime))
                        }
                        const clip = new this(json.name, json.duration, tracks, json.blendMode);
                        clip.uuid = json.uuid;
                        return clip
                    }
                    static toJSON(clip) {
                        const tracks = [],
                            clipTracks = clip.tracks;
                        const json = {
                            'name': clip.name,
                            'duration': clip.duration,
                            'tracks': tracks,
                            'uuid': clip.uuid,
                            'blendMode': clip.blendMode
                        };
                        for (let i = 0, n = clipTracks.length; i !== n; ++i) {
                            tracks.push(KeyframeTrack.toJSON(clipTracks[i]))
                        }
                        return json
                    }
                    static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
                        const numMorphTargets = morphTargetSequence.length;
                        const tracks = [];
                        for (let i = 0; i < numMorphTargets; i++) {
                            let times = [];
                            let values = [];
                            times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
                            values.push(0, 1, 0);
                            const order = getKeyframeOrder(times);
                            times = sortedArray(times, 1, order);
                            values = sortedArray(values, 1, order);
                            if (!noLoop && times[0] === 0) {
                                times.push(numMorphTargets);
                                values.push(values[0])
                            }
                            tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps))
                        }
                        return new this(name, -1, tracks)
                    }
                    static findByName(objectOrClipArray, name) {
                        let clipArray = objectOrClipArray;
                        if (!Array.isArray(objectOrClipArray)) {
                            const o = objectOrClipArray;
                            clipArray = o.geometry && o.geometry.animations || o.animations
                        }
                        for (let i = 0; i < clipArray.length; i++) {
                            if (clipArray[i].name === name) {
                                return clipArray[i]
                            }
                        }
                        return null
                    }
                    static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
                        const animationToMorphTargets = {};
                        const pattern = /^([\w-]*?)([\d]+)$/;
                        for (let i = 0, il = morphTargets.length; i < il; i++) {
                            const morphTarget = morphTargets[i];
                            const parts = morphTarget.name.match(pattern);
                            if (parts && parts.length > 1) {
                                const name = parts[1];
                                let animationMorphTargets = animationToMorphTargets[name];
                                if (!animationMorphTargets) {
                                    animationToMorphTargets[name] = animationMorphTargets = []
                                }
                                animationMorphTargets.push(morphTarget)
                            }
                        }
                        const clips = [];
                        for (const name in animationToMorphTargets) {
                            clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop))
                        }
                        return clips
                    }
                    static parseAnimation(animation, bones) {
                        if (!animation) {
                            console.error('THREE.AnimationClip: No animation in JSONLoader data.');
                            return null
                        }
                        const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
                            if (animationKeys.length !== 0) {
                                const times = [];
                                const values = [];
                                flattenJSON(animationKeys, times, values, propertyName);
                                if (times.length !== 0) {
                                    destTracks.push(new trackType(trackName, times, values))
                                }
                            }
                        };
                        const tracks = [];
                        const clipName = animation.name || 'default';
                        const fps = animation.fps || 30;
                        const blendMode = animation.blendMode;
                        let duration = animation.length || -1;
                        const hierarchyTracks = animation.hierarchy || [];
                        for (let h = 0; h < hierarchyTracks.length; h++) {
                            const animationKeys = hierarchyTracks[h].keys;
                            if (!animationKeys || animationKeys.length === 0) continue;
                            if (animationKeys[0].morphTargets) {
                                const morphTargetNames = {};
                                let k;
                                for (k = 0; k < animationKeys.length; k++) {
                                    if (animationKeys[k].morphTargets) {
                                        for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
                                            morphTargetNames[animationKeys[k].morphTargets[m]] = -1
                                        }
                                    }
                                }
                                for (const morphTargetName in morphTargetNames) {
                                    const times = [];
                                    const values = [];
                                    for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
                                        const animationKey = animationKeys[k];
                                        times.push(animationKey.time);
                                        values.push((animationKey.morphTarget === morphTargetName) ? 1 : 0)
                                    }
                                    tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values))
                                }
                                duration = morphTargetNames.length * fps
                            } else {
                                const boneName = '.bones[' + bones[h].name + ']';
                                addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
                                addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
                                addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks)
                            }
                        }
                        if (tracks.length === 0) {
                            return null
                        }
                        const clip = new this(clipName, duration, tracks, blendMode);
                        return clip
                    }
                    resetDuration() {
                        const tracks = this.tracks;
                        let duration = 0;
                        for (let i = 0, n = tracks.length; i !== n; ++i) {
                            const track = this.tracks[i];
                            duration = Math.max(duration, track.times[track.times.length - 1])
                        }
                        this.duration = duration;
                        return this
                    }
                    trim() {
                        for (let i = 0; i < this.tracks.length; i++) {
                            this.tracks[i].trim(0, this.duration)
                        }
                        return this
                    }
                    validate() {
                        let valid = !0;
                        for (let i = 0; i < this.tracks.length; i++) {
                            valid = valid && this.tracks[i].validate()
                        }
                        return valid
                    }
                    optimize() {
                        for (let i = 0; i < this.tracks.length; i++) {
                            this.tracks[i].optimize()
                        }
                        return this
                    }
                    clone() {
                        const tracks = [];
                        for (let i = 0; i < this.tracks.length; i++) {
                            tracks.push(this.tracks[i].clone())
                        }
                        return new this.constructor(this.name, this.duration, tracks, this.blendMode)
                    }
                    toJSON() {
                        return this.constructor.toJSON(this)
                    }
                }

                function getTrackTypeForValueTypeName(typeName) {
                    switch (typeName.toLowerCase()) {
                        case 'scalar':
                        case 'double':
                        case 'float':
                        case 'number':
                        case 'integer':
                            return NumberKeyframeTrack;
                        case 'vector':
                        case 'vector2':
                        case 'vector3':
                        case 'vector4':
                            return VectorKeyframeTrack;
                        case 'color':
                            return ColorKeyframeTrack;
                        case 'quaternion':
                            return QuaternionKeyframeTrack;
                        case 'bool':
                        case 'boolean':
                            return BooleanKeyframeTrack;
                        case 'string':
                            return StringKeyframeTrack
                    }
                    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName)
                }

                function parseKeyframeTrack(json) {
                    if (json.type === undefined) {
                        throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
                    }
                    const trackType = getTrackTypeForValueTypeName(json.type);
                    if (json.times === undefined) {
                        const times = [],
                            values = [];
                        flattenJSON(json.keys, times, values, 'value');
                        json.times = times;
                        json.values = values
                    }
                    if (trackType.parse !== undefined) {
                        return trackType.parse(json)
                    } else {
                        return new trackType(json.name, json.times, json.values, json.interpolation)
                    }
                }
                const Cache = {
                    enabled: !1,
                    files: {},
                    add: function(key, file) {
                        if (this.enabled === !1) return;
                        this.files[key] = file
                    },
                    get: function(key) {
                        if (this.enabled === !1) return;
                        return this.files[key]
                    },
                    remove: function(key) {
                        delete this.files[key]
                    },
                    clear: function() {
                        this.files = {}
                    }
                };
                class LoadingManager {
                    constructor(onLoad, onProgress, onError) {
                        const scope = this;
                        let isLoading = !1;
                        let itemsLoaded = 0;
                        let itemsTotal = 0;
                        let urlModifier = undefined;
                        const handlers = [];
                        this.onStart = undefined;
                        this.onLoad = onLoad;
                        this.onProgress = onProgress;
                        this.onError = onError;
                        this.itemStart = function(url) {
                            itemsTotal++;
                            if (isLoading === !1) {
                                if (scope.onStart !== undefined) {
                                    scope.onStart(url, itemsLoaded, itemsTotal)
                                }
                            }
                            isLoading = !0
                        };
                        this.itemEnd = function(url) {
                            itemsLoaded++;
                            if (scope.onProgress !== undefined) {
                                scope.onProgress(url, itemsLoaded, itemsTotal)
                            }
                            if (itemsLoaded === itemsTotal) {
                                isLoading = !1;
                                if (scope.onLoad !== undefined) {
                                    scope.onLoad()
                                }
                            }
                        };
                        this.itemError = function(url) {
                            if (scope.onError !== undefined) {
                                scope.onError(url)
                            }
                        };
                        this.resolveURL = function(url) {
                            if (urlModifier) {
                                return urlModifier(url)
                            }
                            return url
                        };
                        this.setURLModifier = function(transform) {
                            urlModifier = transform;
                            return this
                        };
                        this.addHandler = function(regex, loader) {
                            handlers.push(regex, loader);
                            return this
                        };
                        this.removeHandler = function(regex) {
                            const index = handlers.indexOf(regex);
                            if (index !== -1) {
                                handlers.splice(index, 2)
                            }
                            return this
                        };
                        this.getHandler = function(file) {
                            for (let i = 0, l = handlers.length; i < l; i += 2) {
                                const regex = handlers[i];
                                const loader = handlers[i + 1];
                                if (regex.global) regex.lastIndex = 0;
                                if (regex.test(file)) {
                                    return loader
                                }
                            }
                            return null
                        }
                    }
                }
                const DefaultLoadingManager = new LoadingManager();
                class Loader {
                    constructor(manager) {
                        this.manager = (manager !== undefined) ? manager : DefaultLoadingManager;
                        this.crossOrigin = 'anonymous';
                        this.withCredentials = !1;
                        this.path = '';
                        this.resourcePath = '';
                        this.requestHeader = {}
                    }
                    load() {}
                    loadAsync(url, onProgress) {
                        const scope = this;
                        return new Promise(function(resolve, reject) {
                            scope.load(url, resolve, onProgress, reject)
                        })
                    }
                    parse() {}
                    setCrossOrigin(crossOrigin) {
                        this.crossOrigin = crossOrigin;
                        return this
                    }
                    setWithCredentials(value) {
                        this.withCredentials = value;
                        return this
                    }
                    setPath(path) {
                        this.path = path;
                        return this
                    }
                    setResourcePath(resourcePath) {
                        this.resourcePath = resourcePath;
                        return this
                    }
                    setRequestHeader(requestHeader) {
                        this.requestHeader = requestHeader;
                        return this
                    }
                }
                Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
                const loading = {};
                class HttpError extends Error {
                    constructor(message, response) {
                        super(message);
                        this.response = response
                    }
                }
                class FileLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        if (url === undefined) url = '';
                        if (this.path !== undefined) url = this.path + url;
                        url = this.manager.resolveURL(url);
                        const cached = Cache.get(url);
                        if (cached !== undefined) {
                            this.manager.itemStart(url);
                            setTimeout(() => {
                                if (onLoad) onLoad(cached);
                                this.manager.itemEnd(url)
                            }, 0);
                            return cached
                        }
                        if (loading[url] !== undefined) {
                            loading[url].push({
                                onLoad: onLoad,
                                onProgress: onProgress,
                                onError: onError
                            });
                            return
                        }
                        loading[url] = [];
                        loading[url].push({
                            onLoad: onLoad,
                            onProgress: onProgress,
                            onError: onError,
                        });
                        const req = new Request(url, {
                            headers: new Headers(this.requestHeader),
                            credentials: this.withCredentials ? 'include' : 'same-origin',
                        });
                        const mimeType = this.mimeType;
                        const responseType = this.responseType;
                        fetch(req).then(response => {
                            if (response.status === 200 || response.status === 0) {
                                if (response.status === 0) {
                                    console.warn('THREE.FileLoader: HTTP Status 0 received.')
                                }
                                if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
                                    return response
                                }
                                const callbacks = loading[url];
                                const reader = response.body.getReader();
                                const contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');
                                const total = contentLength ? parseInt(contentLength) : 0;
                                const lengthComputable = total !== 0;
                                let loaded = 0;
                                const stream = new ReadableStream({
                                    start(controller) {
                                        readData();

                                        function readData() {
                                            reader.read().then(({
                                                done,
                                                value
                                            }) => {
                                                if (done) {
                                                    controller.close()
                                                } else {
                                                    loaded += value.byteLength;
                                                    const event = new ProgressEvent('progress', {
                                                        lengthComputable,
                                                        loaded,
                                                        total
                                                    });
                                                    for (let i = 0, il = callbacks.length; i < il; i++) {
                                                        const callback = callbacks[i];
                                                        if (callback.onProgress) callback.onProgress(event)
                                                    }
                                                    controller.enqueue(value);
                                                    readData()
                                                }
                                            }, (e) => {
                                                controller.error(e)
                                            })
                                        }
                                    }
                                });
                                return new Response(stream)
                            } else {
                                throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response)
                            }
                        }).then(response => {
                            switch (responseType) {
                                case 'arraybuffer':
                                    return response.arrayBuffer();
                                case 'blob':
                                    return response.blob();
                                case 'document':
                                    return response.text().then(text => {
                                        const parser = new DOMParser();
                                        return parser.parseFromString(text, mimeType)
                                    });
                                case 'json':
                                    return response.json();
                                default:
                                    if (mimeType === undefined) {
                                        return response.text()
                                    } else {
                                        const re = /charset="?([^;"\s]*)"?/i;
                                        const exec = re.exec(mimeType);
                                        const label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                                        const decoder = new TextDecoder(label);
                                        return response.arrayBuffer().then(ab => decoder.decode(ab))
                                    }
                            }
                        }).then(data => {
                            Cache.add(url, data);
                            const callbacks = loading[url];
                            delete loading[url];
                            for (let i = 0, il = callbacks.length; i < il; i++) {
                                const callback = callbacks[i];
                                if (callback.onLoad) callback.onLoad(data)
                            }
                        }).catch(err => {
                            const callbacks = loading[url];
                            if (callbacks === undefined) {
                                this.manager.itemError(url);
                                throw err
                            }
                            delete loading[url];
                            for (let i = 0, il = callbacks.length; i < il; i++) {
                                const callback = callbacks[i];
                                if (callback.onError) callback.onError(err)
                            }
                            this.manager.itemError(url)
                        }).finally(() => {
                            this.manager.itemEnd(url)
                        });
                        this.manager.itemStart(url)
                    }
                    setResponseType(value) {
                        this.responseType = value;
                        return this
                    }
                    setMimeType(value) {
                        this.mimeType = value;
                        return this
                    }
                }
                class AnimationLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)))
                            } catch (e) {
                                if (onError) {
                                    onError(e)
                                } else {
                                    console.error(e)
                                }
                                scope.manager.itemError(url)
                            }
                        }, onProgress, onError)
                    }
                    parse(json) {
                        const animations = [];
                        for (let i = 0; i < json.length; i++) {
                            const clip = AnimationClip.parse(json[i]);
                            animations.push(clip)
                        }
                        return animations
                    }
                }
                class CompressedTextureLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const images = [];
                        const texture = new CompressedTexture();
                        const loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        let loaded = 0;

                        function loadTexture(i) {
                            loader.load(url[i], function(buffer) {
                                const texDatas = scope.parse(buffer, !0);
                                images[i] = {
                                    width: texDatas.width,
                                    height: texDatas.height,
                                    format: texDatas.format,
                                    mipmaps: texDatas.mipmaps
                                };
                                loaded += 1;
                                if (loaded === 6) {
                                    if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
                                    texture.image = images;
                                    texture.format = texDatas.format;
                                    texture.needsUpdate = !0;
                                    if (onLoad) onLoad(texture)
                                }
                            }, onProgress, onError)
                        }
                        if (Array.isArray(url)) {
                            for (let i = 0, il = url.length; i < il; ++i) {
                                loadTexture(i)
                            }
                        } else {
                            loader.load(url, function(buffer) {
                                const texDatas = scope.parse(buffer, !0);
                                if (texDatas.isCubemap) {
                                    const faces = texDatas.mipmaps.length / texDatas.mipmapCount;
                                    for (let f = 0; f < faces; f++) {
                                        images[f] = {
                                            mipmaps: []
                                        };
                                        for (let i = 0; i < texDatas.mipmapCount; i++) {
                                            images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
                                            images[f].format = texDatas.format;
                                            images[f].width = texDatas.width;
                                            images[f].height = texDatas.height
                                        }
                                    }
                                    texture.image = images
                                } else {
                                    texture.image.width = texDatas.width;
                                    texture.image.height = texDatas.height;
                                    texture.mipmaps = texDatas.mipmaps
                                }
                                if (texDatas.mipmapCount === 1) {
                                    texture.minFilter = LinearFilter
                                }
                                texture.format = texDatas.format;
                                texture.needsUpdate = !0;
                                if (onLoad) onLoad(texture)
                            }, onProgress, onError)
                        }
                        return texture
                    }
                }
                class ImageLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        if (this.path !== undefined) url = this.path + url;
                        url = this.manager.resolveURL(url);
                        const scope = this;
                        const cached = Cache.get(url);
                        if (cached !== undefined) {
                            scope.manager.itemStart(url);
                            setTimeout(function() {
                                if (onLoad) onLoad(cached);
                                scope.manager.itemEnd(url)
                            }, 0);
                            return cached
                        }
                        const image = createElementNS('img');

                        function onImageLoad() {
                            removeEventListeners();
                            Cache.add(url, this);
                            if (onLoad) onLoad(this);
                            scope.manager.itemEnd(url)
                        }

                        function onImageError(event) {
                            removeEventListeners();
                            if (onError) onError(event);
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url)
                        }

                        function removeEventListeners() {
                            image.removeEventListener('load', onImageLoad, !1);
                            image.removeEventListener('error', onImageError, !1)
                        }
                        image.addEventListener('load', onImageLoad, !1);
                        image.addEventListener('error', onImageError, !1);
                        if (url.slice(0, 5) !== 'data:') {
                            if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin
                        }
                        scope.manager.itemStart(url);
                        image.src = url;
                        return image
                    }
                }
                class CubeTextureLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(urls, onLoad, onProgress, onError) {
                        const texture = new CubeTexture();
                        texture.colorSpace = SRGBColorSpace;
                        const loader = new ImageLoader(this.manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        loader.setPath(this.path);
                        let loaded = 0;

                        function loadTexture(i) {
                            loader.load(urls[i], function(image) {
                                texture.images[i] = image;
                                loaded++;
                                if (loaded === 6) {
                                    texture.needsUpdate = !0;
                                    if (onLoad) onLoad(texture)
                                }
                            }, undefined, onError)
                        }
                        for (let i = 0; i < urls.length; ++i) {
                            loadTexture(i)
                        }
                        return texture
                    }
                }
                class DataTextureLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const texture = new DataTexture();
                        const loader = new FileLoader(this.manager);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setPath(this.path);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(buffer) {
                            let texData;
                            try {
                                texData = scope.parse(buffer)
                            } catch (error) {
                                if (onError !== undefined) {
                                    onError(error)
                                } else {
                                    console.error(error);
                                    return
                                }
                            }
                            if (texData.image !== undefined) {
                                texture.image = texData.image
                            } else if (texData.data !== undefined) {
                                texture.image.width = texData.width;
                                texture.image.height = texData.height;
                                texture.image.data = texData.data
                            }
                            texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
                            texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
                            texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
                            texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
                            texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
                            if (texData.colorSpace !== undefined) {
                                texture.colorSpace = texData.colorSpace
                            }
                            if (texData.flipY !== undefined) {
                                texture.flipY = texData.flipY
                            }
                            if (texData.format !== undefined) {
                                texture.format = texData.format
                            }
                            if (texData.type !== undefined) {
                                texture.type = texData.type
                            }
                            if (texData.mipmaps !== undefined) {
                                texture.mipmaps = texData.mipmaps;
                                texture.minFilter = LinearMipmapLinearFilter
                            }
                            if (texData.mipmapCount === 1) {
                                texture.minFilter = LinearFilter
                            }
                            if (texData.generateMipmaps !== undefined) {
                                texture.generateMipmaps = texData.generateMipmaps
                            }
                            texture.needsUpdate = !0;
                            if (onLoad) onLoad(texture, texData)
                        }, onProgress, onError);
                        return texture
                    }
                }
                class TextureLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const texture = new Texture();
                        const loader = new ImageLoader(this.manager);
                        loader.setCrossOrigin(this.crossOrigin);
                        loader.setPath(this.path);
                        loader.load(url, function(image) {
                            texture.image = image;
                            texture.needsUpdate = !0;
                            if (onLoad !== undefined) {
                                onLoad(texture)
                            }
                        }, onProgress, onError);
                        return texture
                    }
                }
                class Light extends Object3D {
                    constructor(color, intensity = 1) {
                        super();
                        this.isLight = !0;
                        this.type = 'Light';
                        this.color = new Color(color);
                        this.intensity = intensity
                    }
                    dispose() {}
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.color.copy(source.color);
                        this.intensity = source.intensity;
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.object.color = this.color.getHex();
                        data.object.intensity = this.intensity;
                        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
                        if (this.distance !== undefined) data.object.distance = this.distance;
                        if (this.angle !== undefined) data.object.angle = this.angle;
                        if (this.decay !== undefined) data.object.decay = this.decay;
                        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
                        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
                        if (this.target !== undefined) data.object.target = this.target.uuid;
                        return data
                    }
                }
                class HemisphereLight extends Light {
                    constructor(skyColor, groundColor, intensity) {
                        super(skyColor, intensity);
                        this.isHemisphereLight = !0;
                        this.type = 'HemisphereLight';
                        this.position.copy(Object3D.DEFAULT_UP);
                        this.updateMatrix();
                        this.groundColor = new Color(groundColor)
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.groundColor.copy(source.groundColor);
                        return this
                    }
                }
                const _projScreenMatrix$1 = new Matrix4();
                const _lightPositionWorld$1 = new Vector3();
                const _lookTarget$1 = new Vector3();
                class LightShadow {
                    constructor(camera) {
                        this.camera = camera;
                        this.intensity = 1;
                        this.bias = 0;
                        this.normalBias = 0;
                        this.radius = 1;
                        this.blurSamples = 8;
                        this.mapSize = new Vector2(512, 512);
                        this.map = null;
                        this.mapPass = null;
                        this.matrix = new Matrix4();
                        this.autoUpdate = !0;
                        this.needsUpdate = !1;
                        this._frustum = new Frustum();
                        this._frameExtents = new Vector2(1, 1);
                        this._viewportCount = 1;
                        this._viewports = [new Vector4(0, 0, 1, 1)]
                    }
                    getViewportCount() {
                        return this._viewportCount
                    }
                    getFrustum() {
                        return this._frustum
                    }
                    updateMatrices(light) {
                        const shadowCamera = this.camera;
                        const shadowMatrix = this.matrix;
                        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
                        shadowCamera.position.copy(_lightPositionWorld$1);
                        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
                        shadowCamera.lookAt(_lookTarget$1);
                        shadowCamera.updateMatrixWorld();
                        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
                        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
                        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
                        shadowMatrix.multiply(_projScreenMatrix$1)
                    }
                    getViewport(viewportIndex) {
                        return this._viewports[viewportIndex]
                    }
                    getFrameExtents() {
                        return this._frameExtents
                    }
                    dispose() {
                        if (this.map) {
                            this.map.dispose()
                        }
                        if (this.mapPass) {
                            this.mapPass.dispose()
                        }
                    }
                    copy(source) {
                        this.camera = source.camera.clone();
                        this.intensity = source.intensity;
                        this.bias = source.bias;
                        this.radius = source.radius;
                        this.mapSize.copy(source.mapSize);
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    toJSON() {
                        const object = {};
                        if (this.intensity !== 1) object.intensity = this.intensity;
                        if (this.bias !== 0) object.bias = this.bias;
                        if (this.normalBias !== 0) object.normalBias = this.normalBias;
                        if (this.radius !== 1) object.radius = this.radius;
                        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
                        object.camera = this.camera.toJSON(!1).object;
                        delete object.camera.matrix;
                        return object
                    }
                }
                class SpotLightShadow extends LightShadow {
                    constructor() {
                        super(new PerspectiveCamera(50, 1, 0.5, 500));
                        this.isSpotLightShadow = !0;
                        this.focus = 1
                    }
                    updateMatrices(light) {
                        const camera = this.camera;
                        const fov = RAD2DEG * 2 * light.angle * this.focus;
                        const aspect = this.mapSize.width / this.mapSize.height;
                        const far = light.distance || camera.far;
                        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
                            camera.fov = fov;
                            camera.aspect = aspect;
                            camera.far = far;
                            camera.updateProjectionMatrix()
                        }
                        super.updateMatrices(light)
                    }
                    copy(source) {
                        super.copy(source);
                        this.focus = source.focus;
                        return this
                    }
                }
                class SpotLight extends Light {
                    constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
                        super(color, intensity);
                        this.isSpotLight = !0;
                        this.type = 'SpotLight';
                        this.position.copy(Object3D.DEFAULT_UP);
                        this.updateMatrix();
                        this.target = new Object3D();
                        this.distance = distance;
                        this.angle = angle;
                        this.penumbra = penumbra;
                        this.decay = decay;
                        this.map = null;
                        this.shadow = new SpotLightShadow()
                    }
                    get power() {
                        return this.intensity * Math.PI
                    }
                    set power(power) {
                        this.intensity = power / Math.PI
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.distance = source.distance;
                        this.angle = source.angle;
                        this.penumbra = source.penumbra;
                        this.decay = source.decay;
                        this.target = source.target.clone();
                        this.shadow = source.shadow.clone();
                        return this
                    }
                }
                const _projScreenMatrix = new Matrix4();
                const _lightPositionWorld = new Vector3();
                const _lookTarget = new Vector3();
                class PointLightShadow extends LightShadow {
                    constructor() {
                        super(new PerspectiveCamera(90, 1, 0.5, 500));
                        this.isPointLightShadow = !0;
                        this._frameExtents = new Vector2(4, 2);
                        this._viewportCount = 6;
                        this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)];
                        this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
                        this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)]
                    }
                    updateMatrices(light, viewportIndex = 0) {
                        const camera = this.camera;
                        const shadowMatrix = this.matrix;
                        const far = light.distance || camera.far;
                        if (far !== camera.far) {
                            camera.far = far;
                            camera.updateProjectionMatrix()
                        }
                        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
                        camera.position.copy(_lightPositionWorld);
                        _lookTarget.copy(camera.position);
                        _lookTarget.add(this._cubeDirections[viewportIndex]);
                        camera.up.copy(this._cubeUps[viewportIndex]);
                        camera.lookAt(_lookTarget);
                        camera.updateMatrixWorld();
                        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
                        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                        this._frustum.setFromProjectionMatrix(_projScreenMatrix)
                    }
                }
                class PointLight extends Light {
                    constructor(color, intensity, distance = 0, decay = 2) {
                        super(color, intensity);
                        this.isPointLight = !0;
                        this.type = 'PointLight';
                        this.distance = distance;
                        this.decay = decay;
                        this.shadow = new PointLightShadow()
                    }
                    get power() {
                        return this.intensity * 4 * Math.PI
                    }
                    set power(power) {
                        this.intensity = power / (4 * Math.PI)
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.distance = source.distance;
                        this.decay = source.decay;
                        this.shadow = source.shadow.clone();
                        return this
                    }
                }
                class DirectionalLightShadow extends LightShadow {
                    constructor() {
                        super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
                        this.isDirectionalLightShadow = !0
                    }
                }
                class DirectionalLight extends Light {
                    constructor(color, intensity) {
                        super(color, intensity);
                        this.isDirectionalLight = !0;
                        this.type = 'DirectionalLight';
                        this.position.copy(Object3D.DEFAULT_UP);
                        this.updateMatrix();
                        this.target = new Object3D();
                        this.shadow = new DirectionalLightShadow()
                    }
                    dispose() {
                        this.shadow.dispose()
                    }
                    copy(source) {
                        super.copy(source);
                        this.target = source.target.clone();
                        this.shadow = source.shadow.clone();
                        return this
                    }
                }
                class AmbientLight extends Light {
                    constructor(color, intensity) {
                        super(color, intensity);
                        this.isAmbientLight = !0;
                        this.type = 'AmbientLight'
                    }
                }
                class RectAreaLight extends Light {
                    constructor(color, intensity, width = 10, height = 10) {
                        super(color, intensity);
                        this.isRectAreaLight = !0;
                        this.type = 'RectAreaLight';
                        this.width = width;
                        this.height = height
                    }
                    get power() {
                        return this.intensity * this.width * this.height * Math.PI
                    }
                    set power(power) {
                        this.intensity = power / (this.width * this.height * Math.PI)
                    }
                    copy(source) {
                        super.copy(source);
                        this.width = source.width;
                        this.height = source.height;
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.object.width = this.width;
                        data.object.height = this.height;
                        return data
                    }
                }
                class SphericalHarmonics3 {
                    constructor() {
                        this.isSphericalHarmonics3 = !0;
                        this.coefficients = [];
                        for (let i = 0; i < 9; i++) {
                            this.coefficients.push(new Vector3())
                        }
                    }
                    set(coefficients) {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].copy(coefficients[i])
                        }
                        return this
                    }
                    zero() {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].set(0, 0, 0)
                        }
                        return this
                    }
                    getAt(normal, target) {
                        const x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        const coeff = this.coefficients;
                        target.copy(coeff[0]).multiplyScalar(0.282095);
                        target.addScaledVector(coeff[1], 0.488603 * y);
                        target.addScaledVector(coeff[2], 0.488603 * z);
                        target.addScaledVector(coeff[3], 0.488603 * x);
                        target.addScaledVector(coeff[4], 1.092548 * (x * y));
                        target.addScaledVector(coeff[5], 1.092548 * (y * z));
                        target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
                        target.addScaledVector(coeff[7], 1.092548 * (x * z));
                        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
                        return target
                    }
                    getIrradianceAt(normal, target) {
                        const x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        const coeff = this.coefficients;
                        target.copy(coeff[0]).multiplyScalar(0.886227);
                        target.addScaledVector(coeff[1], 2.0 * 0.511664 * y);
                        target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
                        target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);
                        target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y);
                        target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
                        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);
                        target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
                        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));
                        return target
                    }
                    add(sh) {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].add(sh.coefficients[i])
                        }
                        return this
                    }
                    addScaledSH(sh, s) {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].addScaledVector(sh.coefficients[i], s)
                        }
                        return this
                    }
                    scale(s) {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].multiplyScalar(s)
                        }
                        return this
                    }
                    lerp(sh, alpha) {
                        for (let i = 0; i < 9; i++) {
                            this.coefficients[i].lerp(sh.coefficients[i], alpha)
                        }
                        return this
                    }
                    equals(sh) {
                        for (let i = 0; i < 9; i++) {
                            if (!this.coefficients[i].equals(sh.coefficients[i])) {
                                return !1
                            }
                        }
                        return !0
                    }
                    copy(sh) {
                        return this.set(sh.coefficients)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    fromArray(array, offset = 0) {
                        const coefficients = this.coefficients;
                        for (let i = 0; i < 9; i++) {
                            coefficients[i].fromArray(array, offset + (i * 3))
                        }
                        return this
                    }
                    toArray(array = [], offset = 0) {
                        const coefficients = this.coefficients;
                        for (let i = 0; i < 9; i++) {
                            coefficients[i].toArray(array, offset + (i * 3))
                        }
                        return array
                    }
                    static getBasisAt(normal, shBasis) {
                        const x = normal.x,
                            y = normal.y,
                            z = normal.z;
                        shBasis[0] = 0.282095;
                        shBasis[1] = 0.488603 * y;
                        shBasis[2] = 0.488603 * z;
                        shBasis[3] = 0.488603 * x;
                        shBasis[4] = 1.092548 * x * y;
                        shBasis[5] = 1.092548 * y * z;
                        shBasis[6] = 0.315392 * (3 * z * z - 1);
                        shBasis[7] = 1.092548 * x * z;
                        shBasis[8] = 0.546274 * (x * x - y * y)
                    }
                }
                class LightProbe extends Light {
                    constructor(sh = new SphericalHarmonics3(), intensity = 1) {
                        super(undefined, intensity);
                        this.isLightProbe = !0;
                        this.sh = sh
                    }
                    copy(source) {
                        super.copy(source);
                        this.sh.copy(source.sh);
                        return this
                    }
                    fromJSON(json) {
                        this.intensity = json.intensity;
                        this.sh.fromArray(json.sh);
                        return this
                    }
                    toJSON(meta) {
                        const data = super.toJSON(meta);
                        data.object.sh = this.sh.toArray();
                        return data
                    }
                }
                class MaterialLoader extends Loader {
                    constructor(manager) {
                        super(manager);
                        this.textures = {}
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const loader = new FileLoader(scope.manager);
                        loader.setPath(scope.path);
                        loader.setRequestHeader(scope.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)))
                            } catch (e) {
                                if (onError) {
                                    onError(e)
                                } else {
                                    console.error(e)
                                }
                                scope.manager.itemError(url)
                            }
                        }, onProgress, onError)
                    }
                    parse(json) {
                        const textures = this.textures;

                        function getTexture(name) {
                            if (textures[name] === undefined) {
                                console.warn('THREE.MaterialLoader: Undefined texture', name)
                            }
                            return textures[name]
                        }
                        const material = MaterialLoader.createMaterialFromType(json.type);
                        if (json.uuid !== undefined) material.uuid = json.uuid;
                        if (json.name !== undefined) material.name = json.name;
                        if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
                        if (json.roughness !== undefined) material.roughness = json.roughness;
                        if (json.metalness !== undefined) material.metalness = json.metalness;
                        if (json.sheen !== undefined) material.sheen = json.sheen;
                        if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
                        if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
                        if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
                        if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
                        if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
                        if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
                        if (json.shininess !== undefined) material.shininess = json.shininess;
                        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
                        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
                        if (json.dispersion !== undefined) material.dispersion = json.dispersion;
                        if (json.iridescence !== undefined) material.iridescence = json.iridescence;
                        if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
                        if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
                        if (json.transmission !== undefined) material.transmission = json.transmission;
                        if (json.thickness !== undefined) material.thickness = json.thickness;
                        if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
                        if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
                        if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;
                        if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;
                        if (json.fog !== undefined) material.fog = json.fog;
                        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
                        if (json.blending !== undefined) material.blending = json.blending;
                        if (json.combine !== undefined) material.combine = json.combine;
                        if (json.side !== undefined) material.side = json.side;
                        if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
                        if (json.opacity !== undefined) material.opacity = json.opacity;
                        if (json.transparent !== undefined) material.transparent = json.transparent;
                        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
                        if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;
                        if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;
                        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
                        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
                        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
                        if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;
                        if (json.blendDst !== undefined) material.blendDst = json.blendDst;
                        if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;
                        if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;
                        if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;
                        if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;
                        if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);
                        if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;
                        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
                        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
                        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
                        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
                        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
                        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
                        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
                        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
                        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
                        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
                        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
                        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
                        if (json.rotation !== undefined) material.rotation = json.rotation;
                        if (json.linewidth !== undefined) material.linewidth = json.linewidth;
                        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
                        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
                        if (json.scale !== undefined) material.scale = json.scale;
                        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
                        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
                        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
                        if (json.dithering !== undefined) material.dithering = json.dithering;
                        if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
                        if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
                        if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
                        if (json.visible !== undefined) material.visible = json.visible;
                        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
                        if (json.userData !== undefined) material.userData = json.userData;
                        if (json.vertexColors !== undefined) {
                            if (typeof json.vertexColors === 'number') {
                                material.vertexColors = (json.vertexColors > 0) ? !0 : !1
                            } else {
                                material.vertexColors = json.vertexColors
                            }
                        }
                        if (json.uniforms !== undefined) {
                            for (const name in json.uniforms) {
                                const uniform = json.uniforms[name];
                                material.uniforms[name] = {};
                                switch (uniform.type) {
                                    case 't':
                                        material.uniforms[name].value = getTexture(uniform.value);
                                        break;
                                    case 'c':
                                        material.uniforms[name].value = new Color().setHex(uniform.value);
                                        break;
                                    case 'v2':
                                        material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                                        break;
                                    case 'v3':
                                        material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                                        break;
                                    case 'v4':
                                        material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                                        break;
                                    case 'm3':
                                        material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                                        break;
                                    case 'm4':
                                        material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                                        break;
                                    default:
                                        material.uniforms[name].value = uniform.value
                                }
                            }
                        }
                        if (json.defines !== undefined) material.defines = json.defines;
                        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
                        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
                        if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
                        if (json.extensions !== undefined) {
                            for (const key in json.extensions) {
                                material.extensions[key] = json.extensions[key]
                            }
                        }
                        if (json.lights !== undefined) material.lights = json.lights;
                        if (json.clipping !== undefined) material.clipping = json.clipping;
                        if (json.size !== undefined) material.size = json.size;
                        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
                        if (json.map !== undefined) material.map = getTexture(json.map);
                        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
                        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
                        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
                        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
                        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
                        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
                        if (json.normalScale !== undefined) {
                            let normalScale = json.normalScale;
                            if (Array.isArray(normalScale) === !1) {
                                normalScale = [normalScale, normalScale]
                            }
                            material.normalScale = new Vector2().fromArray(normalScale)
                        }
                        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
                        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
                        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
                        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
                        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
                        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
                        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
                        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
                        if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
                        if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
                        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
                        if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);
                        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
                        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
                        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
                        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
                        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
                        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
                        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
                        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
                        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
                        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
                        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
                        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
                        if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
                        if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
                        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
                        if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
                        if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);
                        if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
                        if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
                        return material
                    }
                    setTextures(value) {
                        this.textures = value;
                        return this
                    }
                    static createMaterialFromType(type) {
                        const materialLib = {
                            ShadowMaterial,
                            SpriteMaterial,
                            RawShaderMaterial,
                            ShaderMaterial,
                            PointsMaterial,
                            MeshPhysicalMaterial,
                            MeshStandardMaterial,
                            MeshPhongMaterial,
                            MeshToonMaterial,
                            MeshNormalMaterial,
                            MeshLambertMaterial,
                            MeshDepthMaterial,
                            MeshDistanceMaterial,
                            MeshBasicMaterial,
                            MeshMatcapMaterial,
                            LineDashedMaterial,
                            LineBasicMaterial,
                            Material
                        };
                        return new materialLib[type]()
                    }
                }
                class LoaderUtils {
                    static decodeText(array) {
                        console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.');
                        if (typeof TextDecoder !== 'undefined') {
                            return new TextDecoder().decode(array)
                        }
                        let s = '';
                        for (let i = 0, il = array.length; i < il; i++) {
                            s += String.fromCharCode(array[i])
                        }
                        try {
                            return decodeURIComponent(escape(s))
                        } catch (e) {
                            return s
                        }
                    }
                    static extractUrlBase(url) {
                        const index = url.lastIndexOf('/');
                        if (index === -1) return './';
                        return url.slice(0, index + 1)
                    }
                    static resolveURL(url, path) {
                        if (typeof url !== 'string' || url === '') return '';
                        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
                            path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1')
                        }
                        if (/^(https?:)?\/\//i.test(url)) return url;
                        if (/^data:.*,.*$/i.test(url)) return url;
                        if (/^blob:.*$/i.test(url)) return url;
                        return path + url
                    }
                }
                class InstancedBufferGeometry extends BufferGeometry {
                    constructor() {
                        super();
                        this.isInstancedBufferGeometry = !0;
                        this.type = 'InstancedBufferGeometry';
                        this.instanceCount = Infinity
                    }
                    copy(source) {
                        super.copy(source);
                        this.instanceCount = source.instanceCount;
                        return this
                    }
                    toJSON() {
                        const data = super.toJSON();
                        data.instanceCount = this.instanceCount;
                        data.isInstancedBufferGeometry = !0;
                        return data
                    }
                }
                class BufferGeometryLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const loader = new FileLoader(scope.manager);
                        loader.setPath(scope.path);
                        loader.setRequestHeader(scope.requestHeader);
                        loader.setWithCredentials(scope.withCredentials);
                        loader.load(url, function(text) {
                            try {
                                onLoad(scope.parse(JSON.parse(text)))
                            } catch (e) {
                                if (onError) {
                                    onError(e)
                                } else {
                                    console.error(e)
                                }
                                scope.manager.itemError(url)
                            }
                        }, onProgress, onError)
                    }
                    parse(json) {
                        const interleavedBufferMap = {};
                        const arrayBufferMap = {};

                        function getInterleavedBuffer(json, uuid) {
                            if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
                            const interleavedBuffers = json.interleavedBuffers;
                            const interleavedBuffer = interleavedBuffers[uuid];
                            const buffer = getArrayBuffer(json, interleavedBuffer.buffer);
                            const array = getTypedArray(interleavedBuffer.type, buffer);
                            const ib = new InterleavedBuffer(array, interleavedBuffer.stride);
                            ib.uuid = interleavedBuffer.uuid;
                            interleavedBufferMap[uuid] = ib;
                            return ib
                        }

                        function getArrayBuffer(json, uuid) {
                            if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
                            const arrayBuffers = json.arrayBuffers;
                            const arrayBuffer = arrayBuffers[uuid];
                            const ab = new Uint32Array(arrayBuffer).buffer;
                            arrayBufferMap[uuid] = ab;
                            return ab
                        }
                        const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
                        const index = json.data.index;
                        if (index !== undefined) {
                            const typedArray = getTypedArray(index.type, index.array);
                            geometry.setIndex(new BufferAttribute(typedArray, 1))
                        }
                        const attributes = json.data.attributes;
                        for (const key in attributes) {
                            const attribute = attributes[key];
                            let bufferAttribute;
                            if (attribute.isInterleavedBufferAttribute) {
                                const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                                bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized)
                            } else {
                                const typedArray = getTypedArray(attribute.type, attribute.array);
                                const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
                                bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized)
                            }
                            if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                            if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
                            geometry.setAttribute(key, bufferAttribute)
                        }
                        const morphAttributes = json.data.morphAttributes;
                        if (morphAttributes) {
                            for (const key in morphAttributes) {
                                const attributeArray = morphAttributes[key];
                                const array = [];
                                for (let i = 0, il = attributeArray.length; i < il; i++) {
                                    const attribute = attributeArray[i];
                                    let bufferAttribute;
                                    if (attribute.isInterleavedBufferAttribute) {
                                        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
                                        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized)
                                    } else {
                                        const typedArray = getTypedArray(attribute.type, attribute.array);
                                        bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized)
                                    }
                                    if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
                                    array.push(bufferAttribute)
                                }
                                geometry.morphAttributes[key] = array
                            }
                        }
                        const morphTargetsRelative = json.data.morphTargetsRelative;
                        if (morphTargetsRelative) {
                            geometry.morphTargetsRelative = !0
                        }
                        const groups = json.data.groups || json.data.drawcalls || json.data.offsets;
                        if (groups !== undefined) {
                            for (let i = 0, n = groups.length; i !== n; ++i) {
                                const group = groups[i];
                                geometry.addGroup(group.start, group.count, group.materialIndex)
                            }
                        }
                        const boundingSphere = json.data.boundingSphere;
                        if (boundingSphere !== undefined) {
                            const center = new Vector3();
                            if (boundingSphere.center !== undefined) {
                                center.fromArray(boundingSphere.center)
                            }
                            geometry.boundingSphere = new Sphere(center, boundingSphere.radius)
                        }
                        if (json.name) geometry.name = json.name;
                        if (json.userData) geometry.userData = json.userData;
                        return geometry
                    }
                }
                class ObjectLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
                        this.resourcePath = this.resourcePath || path;
                        const loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(text) {
                            let json = null;
                            try {
                                json = JSON.parse(text)
                            } catch (error) {
                                if (onError !== undefined) onError(error);
                                console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
                                return
                            }
                            const metadata = json.metadata;
                            if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                                if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
                                console.error('THREE.ObjectLoader: Can\'t load ' + url);
                                return
                            }
                            scope.parse(json, onLoad)
                        }, onProgress, onError)
                    }
                    async loadAsync(url, onProgress) {
                        const scope = this;
                        const path = (this.path === '') ? LoaderUtils.extractUrlBase(url) : this.path;
                        this.resourcePath = this.resourcePath || path;
                        const loader = new FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        const text = await loader.loadAsync(url, onProgress);
                        const json = JSON.parse(text);
                        const metadata = json.metadata;
                        if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
                            throw new Error('THREE.ObjectLoader: Can\'t load ' + url)
                        }
                        return await scope.parseAsync(json)
                    }
                    parse(json, onLoad) {
                        const animations = this.parseAnimations(json.animations);
                        const shapes = this.parseShapes(json.shapes);
                        const geometries = this.parseGeometries(json.geometries, shapes);
                        const images = this.parseImages(json.images, function() {
                            if (onLoad !== undefined) onLoad(object)
                        });
                        const textures = this.parseTextures(json.textures, images);
                        const materials = this.parseMaterials(json.materials, textures);
                        const object = this.parseObject(json.object, geometries, materials, textures, animations);
                        const skeletons = this.parseSkeletons(json.skeletons, object);
                        this.bindSkeletons(object, skeletons);
                        this.bindLightTargets(object);
                        if (onLoad !== undefined) {
                            let hasImages = !1;
                            for (const uuid in images) {
                                if (images[uuid].data instanceof HTMLImageElement) {
                                    hasImages = !0;
                                    break
                                }
                            }
                            if (hasImages === !1) onLoad(object)
                        }
                        return object
                    }
                    async parseAsync(json) {
                        const animations = this.parseAnimations(json.animations);
                        const shapes = this.parseShapes(json.shapes);
                        const geometries = this.parseGeometries(json.geometries, shapes);
                        const images = await this.parseImagesAsync(json.images);
                        const textures = this.parseTextures(json.textures, images);
                        const materials = this.parseMaterials(json.materials, textures);
                        const object = this.parseObject(json.object, geometries, materials, textures, animations);
                        const skeletons = this.parseSkeletons(json.skeletons, object);
                        this.bindSkeletons(object, skeletons);
                        this.bindLightTargets(object);
                        return object
                    }
                    parseShapes(json) {
                        const shapes = {};
                        if (json !== undefined) {
                            for (let i = 0, l = json.length; i < l; i++) {
                                const shape = new Shape().fromJSON(json[i]);
                                shapes[shape.uuid] = shape
                            }
                        }
                        return shapes
                    }
                    parseSkeletons(json, object) {
                        const skeletons = {};
                        const bones = {};
                        object.traverse(function(child) {
                            if (child.isBone) bones[child.uuid] = child
                        });
                        if (json !== undefined) {
                            for (let i = 0, l = json.length; i < l; i++) {
                                const skeleton = new Skeleton().fromJSON(json[i], bones);
                                skeletons[skeleton.uuid] = skeleton
                            }
                        }
                        return skeletons
                    }
                    parseGeometries(json, shapes) {
                        const geometries = {};
                        if (json !== undefined) {
                            const bufferGeometryLoader = new BufferGeometryLoader();
                            for (let i = 0, l = json.length; i < l; i++) {
                                let geometry;
                                const data = json[i];
                                switch (data.type) {
                                    case 'BufferGeometry':
                                    case 'InstancedBufferGeometry':
                                        geometry = bufferGeometryLoader.parse(data);
                                        break;
                                    default:
                                        if (data.type in Geometries) {
                                            geometry = Geometries[data.type].fromJSON(data, shapes)
                                        } else {
                                            console.warn(`THREE.ObjectLoader: Unsupported geometry type "${ data.type }"`)
                                        }
                                }
                                geometry.uuid = data.uuid;
                                if (data.name !== undefined) geometry.name = data.name;
                                if (data.userData !== undefined) geometry.userData = data.userData;
                                geometries[data.uuid] = geometry
                            }
                        }
                        return geometries
                    }
                    parseMaterials(json, textures) {
                        const cache = {};
                        const materials = {};
                        if (json !== undefined) {
                            const loader = new MaterialLoader();
                            loader.setTextures(textures);
                            for (let i = 0, l = json.length; i < l; i++) {
                                const data = json[i];
                                if (cache[data.uuid] === undefined) {
                                    cache[data.uuid] = loader.parse(data)
                                }
                                materials[data.uuid] = cache[data.uuid]
                            }
                        }
                        return materials
                    }
                    parseAnimations(json) {
                        const animations = {};
                        if (json !== undefined) {
                            for (let i = 0; i < json.length; i++) {
                                const data = json[i];
                                const clip = AnimationClip.parse(data);
                                animations[clip.uuid] = clip
                            }
                        }
                        return animations
                    }
                    parseImages(json, onLoad) {
                        const scope = this;
                        const images = {};
                        let loader;

                        function loadImage(url) {
                            scope.manager.itemStart(url);
                            return loader.load(url, function() {
                                scope.manager.itemEnd(url)
                            }, undefined, function() {
                                scope.manager.itemError(url);
                                scope.manager.itemEnd(url)
                            })
                        }

                        function deserializeImage(image) {
                            if (typeof image === 'string') {
                                const url = image;
                                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                                return loadImage(path)
                            } else {
                                if (image.data) {
                                    return {
                                        data: getTypedArray(image.type, image.data),
                                        width: image.width,
                                        height: image.height
                                    }
                                } else {
                                    return null
                                }
                            }
                        }
                        if (json !== undefined && json.length > 0) {
                            const manager = new LoadingManager(onLoad);
                            loader = new ImageLoader(manager);
                            loader.setCrossOrigin(this.crossOrigin);
                            for (let i = 0, il = json.length; i < il; i++) {
                                const image = json[i];
                                const url = image.url;
                                if (Array.isArray(url)) {
                                    const imageArray = [];
                                    for (let j = 0, jl = url.length; j < jl; j++) {
                                        const currentUrl = url[j];
                                        const deserializedImage = deserializeImage(currentUrl);
                                        if (deserializedImage !== null) {
                                            if (deserializedImage instanceof HTMLImageElement) {
                                                imageArray.push(deserializedImage)
                                            } else {
                                                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height))
                                            }
                                        }
                                    }
                                    images[image.uuid] = new Source(imageArray)
                                } else {
                                    const deserializedImage = deserializeImage(image.url);
                                    images[image.uuid] = new Source(deserializedImage)
                                }
                            }
                        }
                        return images
                    }
                    async parseImagesAsync(json) {
                        const scope = this;
                        const images = {};
                        let loader;
                        async function deserializeImage(image) {
                            if (typeof image === 'string') {
                                const url = image;
                                const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
                                return await loader.loadAsync(path)
                            } else {
                                if (image.data) {
                                    return {
                                        data: getTypedArray(image.type, image.data),
                                        width: image.width,
                                        height: image.height
                                    }
                                } else {
                                    return null
                                }
                            }
                        }
                        if (json !== undefined && json.length > 0) {
                            loader = new ImageLoader(this.manager);
                            loader.setCrossOrigin(this.crossOrigin);
                            for (let i = 0, il = json.length; i < il; i++) {
                                const image = json[i];
                                const url = image.url;
                                if (Array.isArray(url)) {
                                    const imageArray = [];
                                    for (let j = 0, jl = url.length; j < jl; j++) {
                                        const currentUrl = url[j];
                                        const deserializedImage = await deserializeImage(currentUrl);
                                        if (deserializedImage !== null) {
                                            if (deserializedImage instanceof HTMLImageElement) {
                                                imageArray.push(deserializedImage)
                                            } else {
                                                imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height))
                                            }
                                        }
                                    }
                                    images[image.uuid] = new Source(imageArray)
                                } else {
                                    const deserializedImage = await deserializeImage(image.url);
                                    images[image.uuid] = new Source(deserializedImage)
                                }
                            }
                        }
                        return images
                    }
                    parseTextures(json, images) {
                        function parseConstant(value, type) {
                            if (typeof value === 'number') return value;
                            console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
                            return type[value]
                        }
                        const textures = {};
                        if (json !== undefined) {
                            for (let i = 0, l = json.length; i < l; i++) {
                                const data = json[i];
                                if (data.image === undefined) {
                                    console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid)
                                }
                                if (images[data.image] === undefined) {
                                    console.warn('THREE.ObjectLoader: Undefined image', data.image)
                                }
                                const source = images[data.image];
                                const image = source.data;
                                let texture;
                                if (Array.isArray(image)) {
                                    texture = new CubeTexture();
                                    if (image.length === 6) texture.needsUpdate = !0
                                } else {
                                    if (image && image.data) {
                                        texture = new DataTexture()
                                    } else {
                                        texture = new Texture()
                                    }
                                    if (image) texture.needsUpdate = !0
                                }
                                texture.source = source;
                                texture.uuid = data.uuid;
                                if (data.name !== undefined) texture.name = data.name;
                                if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
                                if (data.channel !== undefined) texture.channel = data.channel;
                                if (data.offset !== undefined) texture.offset.fromArray(data.offset);
                                if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
                                if (data.center !== undefined) texture.center.fromArray(data.center);
                                if (data.rotation !== undefined) texture.rotation = data.rotation;
                                if (data.wrap !== undefined) {
                                    texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
                                    texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)
                                }
                                if (data.format !== undefined) texture.format = data.format;
                                if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
                                if (data.type !== undefined) texture.type = data.type;
                                if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;
                                if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
                                if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
                                if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
                                if (data.flipY !== undefined) texture.flipY = data.flipY;
                                if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
                                if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
                                if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
                                if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;
                                if (data.userData !== undefined) texture.userData = data.userData;
                                textures[data.uuid] = texture
                            }
                        }
                        return textures
                    }
                    parseObject(data, geometries, materials, textures, animations) {
                        let object;

                        function getGeometry(name) {
                            if (geometries[name] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined geometry', name)
                            }
                            return geometries[name]
                        }

                        function getMaterial(name) {
                            if (name === undefined) return undefined;
                            if (Array.isArray(name)) {
                                const array = [];
                                for (let i = 0, l = name.length; i < l; i++) {
                                    const uuid = name[i];
                                    if (materials[uuid] === undefined) {
                                        console.warn('THREE.ObjectLoader: Undefined material', uuid)
                                    }
                                    array.push(materials[uuid])
                                }
                                return array
                            }
                            if (materials[name] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined material', name)
                            }
                            return materials[name]
                        }

                        function getTexture(uuid) {
                            if (textures[uuid] === undefined) {
                                console.warn('THREE.ObjectLoader: Undefined texture', uuid)
                            }
                            return textures[uuid]
                        }
                        let geometry, material;
                        switch (data.type) {
                            case 'Scene':
                                object = new Scene();
                                if (data.background !== undefined) {
                                    if (Number.isInteger(data.background)) {
                                        object.background = new Color(data.background)
                                    } else {
                                        object.background = getTexture(data.background)
                                    }
                                }
                                if (data.environment !== undefined) {
                                    object.environment = getTexture(data.environment)
                                }
                                if (data.fog !== undefined) {
                                    if (data.fog.type === 'Fog') {
                                        object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far)
                                    } else if (data.fog.type === 'FogExp2') {
                                        object.fog = new FogExp2(data.fog.color, data.fog.density)
                                    }
                                    if (data.fog.name !== '') {
                                        object.fog.name = data.fog.name
                                    }
                                }
                                if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
                                if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
                                if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);
                                if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;
                                if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);
                                break;
                            case 'PerspectiveCamera':
                                object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
                                if (data.focus !== undefined) object.focus = data.focus;
                                if (data.zoom !== undefined) object.zoom = data.zoom;
                                if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
                                if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
                                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                                break;
                            case 'OrthographicCamera':
                                object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
                                if (data.zoom !== undefined) object.zoom = data.zoom;
                                if (data.view !== undefined) object.view = Object.assign({}, data.view);
                                break;
                            case 'AmbientLight':
                                object = new AmbientLight(data.color, data.intensity);
                                break;
                            case 'DirectionalLight':
                                object = new DirectionalLight(data.color, data.intensity);
                                object.target = data.target ||  '';
                                break;
                            case 'PointLight':
                                object = new PointLight(data.color, data.intensity, data.distance, data.decay);
                                break;
                            case 'RectAreaLight':
                                object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
                                break;
                            case 'SpotLight':
                                object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
                                object.target = data.target ||  '';
                                break;
                            case 'HemisphereLight':
                                object = new HemisphereLight(data.color, data.groundColor, data.intensity);
                                break;
                            case 'LightProbe':
                                object = new LightProbe().fromJSON(data);
                                break;
                            case 'SkinnedMesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                object = new SkinnedMesh(geometry, material);
                                if (data.bindMode !== undefined) object.bindMode = data.bindMode;
                                if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
                                if (data.skeleton !== undefined) object.skeleton = data.skeleton;
                                break;
                            case 'Mesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                object = new Mesh(geometry, material);
                                break;
                            case 'InstancedMesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                const count = data.count;
                                const instanceMatrix = data.instanceMatrix;
                                const instanceColor = data.instanceColor;
                                object = new InstancedMesh(geometry, material, count);
                                object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
                                if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
                                break;
                            case 'BatchedMesh':
                                geometry = getGeometry(data.geometry);
                                material = getMaterial(data.material);
                                object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
                                object.geometry = geometry;
                                object.perObjectFrustumCulled = data.perObjectFrustumCulled;
                                object.sortObjects = data.sortObjects;
                                object._drawRanges = data.drawRanges;
                                object._reservedRanges = data.reservedRanges;
                                object._visibility = data.visibility;
                                object._active = data.active;
                                object._bounds = data.bounds.map(bound => {
                                    const box = new Box3();
                                    box.min.fromArray(bound.boxMin);
                                    box.max.fromArray(bound.boxMax);
                                    const sphere = new Sphere();
                                    sphere.radius = bound.sphereRadius;
                                    sphere.center.fromArray(bound.sphereCenter);
                                    return {
                                        boxInitialized: bound.boxInitialized,
                                        box: box,
                                        sphereInitialized: bound.sphereInitialized,
                                        sphere: sphere
                                    }
                                });
                                object._maxInstanceCount = data.maxInstanceCount;
                                object._maxVertexCount = data.maxVertexCount;
                                object._maxIndexCount = data.maxIndexCount;
                                object._geometryInitialized = data.geometryInitialized;
                                object._geometryCount = data.geometryCount;
                                object._matricesTexture = getTexture(data.matricesTexture.uuid);
                                if (data.colorsTexture !== undefined) object._colorsTexture = getTexture(data.colorsTexture.uuid);
                                break;
                            case 'LOD':
                                object = new LOD();
                                break;
                            case 'Line':
                                object = new Line(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'LineLoop':
                                object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'LineSegments':
                                object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'PointCloud':
                            case 'Points':
                                object = new Points(getGeometry(data.geometry), getMaterial(data.material));
                                break;
                            case 'Sprite':
                                object = new Sprite(getMaterial(data.material));
                                break;
                            case 'Group':
                                object = new Group();
                                break;
                            case 'Bone':
                                object = new Bone();
                                break;
                            default:
                                object = new Object3D()
                        }
                        object.uuid = data.uuid;
                        if (data.name !== undefined) object.name = data.name;
                        if (data.matrix !== undefined) {
                            object.matrix.fromArray(data.matrix);
                            if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
                            if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale)
                        } else {
                            if (data.position !== undefined) object.position.fromArray(data.position);
                            if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
                            if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
                            if (data.scale !== undefined) object.scale.fromArray(data.scale)
                        }
                        if (data.up !== undefined) object.up.fromArray(data.up);
                        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
                        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
                        if (data.shadow) {
                            if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;
                            if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
                            if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
                            if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
                            if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
                            if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera)
                        }
                        if (data.visible !== undefined) object.visible = data.visible;
                        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
                        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
                        if (data.userData !== undefined) object.userData = data.userData;
                        if (data.layers !== undefined) object.layers.mask = data.layers;
                        if (data.children !== undefined) {
                            const children = data.children;
                            for (let i = 0; i < children.length; i++) {
                                object.add(this.parseObject(children[i], geometries, materials, textures, animations))
                            }
                        }
                        if (data.animations !== undefined) {
                            const objectAnimations = data.animations;
                            for (let i = 0; i < objectAnimations.length; i++) {
                                const uuid = objectAnimations[i];
                                object.animations.push(animations[uuid])
                            }
                        }
                        if (data.type === 'LOD') {
                            if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
                            const levels = data.levels;
                            for (let l = 0; l < levels.length; l++) {
                                const level = levels[l];
                                const child = object.getObjectByProperty('uuid', level.object);
                                if (child !== undefined) {
                                    object.addLevel(child, level.distance, level.hysteresis)
                                }
                            }
                        }
                        return object
                    }
                    bindSkeletons(object, skeletons) {
                        if (Object.keys(skeletons).length === 0) return;
                        object.traverse(function(child) {
                            if (child.isSkinnedMesh === !0 && child.skeleton !== undefined) {
                                const skeleton = skeletons[child.skeleton];
                                if (skeleton === undefined) {
                                    console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton)
                                } else {
                                    child.bind(skeleton, child.bindMatrix)
                                }
                            }
                        })
                    }
                    bindLightTargets(object) {
                        object.traverse(function(child) {
                            if (child.isDirectionalLight ||  child.isSpotLight) {
                                const uuid = child.target;
                                const target = object.getObjectByProperty('uuid', uuid);
                                if (target !== undefined) {
                                    child.target = target
                                } else {
                                    child.target = new Object3D()
                                }
                            }
                        })
                    }
                }
                const TEXTURE_MAPPING = {
                    UVMapping: UVMapping,
                    CubeReflectionMapping: CubeReflectionMapping,
                    CubeRefractionMapping: CubeRefractionMapping,
                    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
                    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
                    CubeUVReflectionMapping: CubeUVReflectionMapping
                };
                const TEXTURE_WRAPPING = {
                    RepeatWrapping: RepeatWrapping,
                    ClampToEdgeWrapping: ClampToEdgeWrapping,
                    MirroredRepeatWrapping: MirroredRepeatWrapping
                };
                const TEXTURE_FILTER = {
                    NearestFilter: NearestFilter,
                    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
                    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
                    LinearFilter: LinearFilter,
                    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
                    LinearMipmapLinearFilter: LinearMipmapLinearFilter
                };
                class ImageBitmapLoader extends Loader {
                    constructor(manager) {
                        super(manager);
                        this.isImageBitmapLoader = !0;
                        if (typeof createImageBitmap === 'undefined') {
                            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.')
                        }
                        if (typeof fetch === 'undefined') {
                            console.warn('THREE.ImageBitmapLoader: fetch() not supported.')
                        }
                        this.options = {
                            premultiplyAlpha: 'none'
                        }
                    }
                    setOptions(options) {
                        this.options = options;
                        return this
                    }
                    load(url, onLoad, onProgress, onError) {
                        if (url === undefined) url = '';
                        if (this.path !== undefined) url = this.path + url;
                        url = this.manager.resolveURL(url);
                        const scope = this;
                        const cached = Cache.get(url);
                        if (cached !== undefined) {
                            scope.manager.itemStart(url);
                            if (cached.then) {
                                cached.then(imageBitmap => {
                                    if (onLoad) onLoad(imageBitmap);
                                    scope.manager.itemEnd(url)
                                }).catch(e => {
                                    if (onError) onError(e)
                                });
                                return
                            }
                            setTimeout(function() {
                                if (onLoad) onLoad(cached);
                                scope.manager.itemEnd(url)
                            }, 0);
                            return cached
                        }
                        const fetchOptions = {};
                        fetchOptions.credentials = (this.crossOrigin === 'anonymous') ? 'same-origin' : 'include';
                        fetchOptions.headers = this.requestHeader;
                        const promise = fetch(url, fetchOptions).then(function(res) {
                            return res.blob()
                        }).then(function(blob) {
                            return createImageBitmap(blob, Object.assign(scope.options, {
                                colorSpaceConversion: 'none'
                            }))
                        }).then(function(imageBitmap) {
                            Cache.add(url, imageBitmap);
                            if (onLoad) onLoad(imageBitmap);
                            scope.manager.itemEnd(url);
                            return imageBitmap
                        }).catch(function(e) {
                            if (onError) onError(e);
                            Cache.remove(url);
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url)
                        });
                        Cache.add(url, promise);
                        scope.manager.itemStart(url)
                    }
                }
                let _context;
                class AudioContext {
                    static getContext() {
                        if (_context === undefined) {
                            _context = new(window.AudioContext || window.webkitAudioContext)()
                        }
                        return _context
                    }
                    static setContext(value) {
                        _context = value
                    }
                }
                class AudioLoader extends Loader {
                    constructor(manager) {
                        super(manager)
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        const loader = new FileLoader(this.manager);
                        loader.setResponseType('arraybuffer');
                        loader.setPath(this.path);
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(buffer) {
                            try {
                                const bufferCopy = buffer.slice(0);
                                const context = AudioContext.getContext();
                                context.decodeAudioData(bufferCopy, function(audioBuffer) {
                                    onLoad(audioBuffer)
                                }).catch(handleError)
                            } catch (e) {
                                handleError(e)
                            }
                        }, onProgress, onError);

                        function handleError(e) {
                            if (onError) {
                                onError(e)
                            } else {
                                console.error(e)
                            }
                            scope.manager.itemError(url)
                        }
                    }
                }
                const _eyeRight = new Matrix4();
                const _eyeLeft = new Matrix4();
                const _projectionMatrix = new Matrix4();
                class StereoCamera {
                    constructor() {
                        this.type = 'StereoCamera';
                        this.aspect = 1;
                        this.eyeSep = 0.064;
                        this.cameraL = new PerspectiveCamera();
                        this.cameraL.layers.enable(1);
                        this.cameraL.matrixAutoUpdate = !1;
                        this.cameraR = new PerspectiveCamera();
                        this.cameraR.layers.enable(2);
                        this.cameraR.matrixAutoUpdate = !1;
                        this._cache = {
                            focus: null,
                            fov: null,
                            aspect: null,
                            near: null,
                            far: null,
                            zoom: null,
                            eyeSep: null
                        }
                    }
                    update(camera) {
                        const cache = this._cache;
                        const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
                        if (needsUpdate) {
                            cache.focus = camera.focus;
                            cache.fov = camera.fov;
                            cache.aspect = camera.aspect * this.aspect;
                            cache.near = camera.near;
                            cache.far = camera.far;
                            cache.zoom = camera.zoom;
                            cache.eyeSep = this.eyeSep;
                            _projectionMatrix.copy(camera.projectionMatrix);
                            const eyeSepHalf = cache.eyeSep / 2;
                            const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
                            const ymax = (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom;
                            let xmin, xmax;
                            _eyeLeft.elements[12] = -eyeSepHalf;
                            _eyeRight.elements[12] = eyeSepHalf;
                            xmin = -ymax * cache.aspect + eyeSepOnProjection;
                            xmax = ymax * cache.aspect + eyeSepOnProjection;
                            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraL.projectionMatrix.copy(_projectionMatrix);
                            xmin = -ymax * cache.aspect - eyeSepOnProjection;
                            xmax = ymax * cache.aspect - eyeSepOnProjection;
                            _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
                            _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
                            this.cameraR.projectionMatrix.copy(_projectionMatrix)
                        }
                        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
                        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)
                    }
                }
                class Clock {
                    constructor(autoStart = !0) {
                        this.autoStart = autoStart;
                        this.startTime = 0;
                        this.oldTime = 0;
                        this.elapsedTime = 0;
                        this.running = !1
                    }
                    start() {
                        this.startTime = now();
                        this.oldTime = this.startTime;
                        this.elapsedTime = 0;
                        this.running = !0
                    }
                    stop() {
                        this.getElapsedTime();
                        this.running = !1;
                        this.autoStart = !1
                    }
                    getElapsedTime() {
                        this.getDelta();
                        return this.elapsedTime
                    }
                    getDelta() {
                        let diff = 0;
                        if (this.autoStart && !this.running) {
                            this.start();
                            return 0
                        }
                        if (this.running) {
                            const newTime = now();
                            diff = (newTime - this.oldTime) / 1000;
                            this.oldTime = newTime;
                            this.elapsedTime += diff
                        }
                        return diff
                    }
                }

                function now() {
                    return (typeof performance === 'undefined' ? Date : performance).now()
                }
                const _position$1 = new Vector3();
                const _quaternion$1 = new Quaternion();
                const _scale$1 = new Vector3();
                const _orientation$1 = new Vector3();
                class AudioListener extends Object3D {
                    constructor() {
                        super();
                        this.type = 'AudioListener';
                        this.context = AudioContext.getContext();
                        this.gain = this.context.createGain();
                        this.gain.connect(this.context.destination);
                        this.filter = null;
                        this.timeDelta = 0;
                        this._clock = new Clock()
                    }
                    getInput() {
                        return this.gain
                    }
                    removeFilter() {
                        if (this.filter !== null) {
                            this.gain.disconnect(this.filter);
                            this.filter.disconnect(this.context.destination);
                            this.gain.connect(this.context.destination);
                            this.filter = null
                        }
                        return this
                    }
                    getFilter() {
                        return this.filter
                    }
                    setFilter(value) {
                        if (this.filter !== null) {
                            this.gain.disconnect(this.filter);
                            this.filter.disconnect(this.context.destination)
                        } else {
                            this.gain.disconnect(this.context.destination)
                        }
                        this.filter = value;
                        this.gain.connect(this.filter);
                        this.filter.connect(this.context.destination);
                        return this
                    }
                    getMasterVolume() {
                        return this.gain.gain.value
                    }
                    setMasterVolume(value) {
                        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                        return this
                    }
                    updateMatrixWorld(force) {
                        super.updateMatrixWorld(force);
                        const listener = this.context.listener;
                        const up = this.up;
                        this.timeDelta = this._clock.getDelta();
                        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
                        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
                        if (listener.positionX) {
                            const endTime = this.context.currentTime + this.timeDelta;
                            listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
                            listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
                            listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
                            listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
                            listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
                            listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
                            listener.upX.linearRampToValueAtTime(up.x, endTime);
                            listener.upY.linearRampToValueAtTime(up.y, endTime);
                            listener.upZ.linearRampToValueAtTime(up.z, endTime)
                        } else {
                            listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
                            listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z)
                        }
                    }
                }
                class Audio extends Object3D {
                    constructor(listener) {
                        super();
                        this.type = 'Audio';
                        this.listener = listener;
                        this.context = listener.context;
                        this.gain = this.context.createGain();
                        this.gain.connect(listener.getInput());
                        this.autoplay = !1;
                        this.buffer = null;
                        this.detune = 0;
                        this.loop = !1;
                        this.loopStart = 0;
                        this.loopEnd = 0;
                        this.offset = 0;
                        this.duration = undefined;
                        this.playbackRate = 1;
                        this.isPlaying = !1;
                        this.hasPlaybackControl = !0;
                        this.source = null;
                        this.sourceType = 'empty';
                        this._startedAt = 0;
                        this._progress = 0;
                        this._connected = !1;
                        this.filters = []
                    }
                    getOutput() {
                        return this.gain
                    }
                    setNodeSource(audioNode) {
                        this.hasPlaybackControl = !1;
                        this.sourceType = 'audioNode';
                        this.source = audioNode;
                        this.connect();
                        return this
                    }
                    setMediaElementSource(mediaElement) {
                        this.hasPlaybackControl = !1;
                        this.sourceType = 'mediaNode';
                        this.source = this.context.createMediaElementSource(mediaElement);
                        this.connect();
                        return this
                    }
                    setMediaStreamSource(mediaStream) {
                        this.hasPlaybackControl = !1;
                        this.sourceType = 'mediaStreamNode';
                        this.source = this.context.createMediaStreamSource(mediaStream);
                        this.connect();
                        return this
                    }
                    setBuffer(audioBuffer) {
                        this.buffer = audioBuffer;
                        this.sourceType = 'buffer';
                        if (this.autoplay) this.play();
                        return this
                    }
                    play(delay = 0) {
                        if (this.isPlaying === !0) {
                            console.warn('THREE.Audio: Audio is already playing.');
                            return
                        }
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return
                        }
                        this._startedAt = this.context.currentTime + delay;
                        const source = this.context.createBufferSource();
                        source.buffer = this.buffer;
                        source.loop = this.loop;
                        source.loopStart = this.loopStart;
                        source.loopEnd = this.loopEnd;
                        source.onended = this.onEnded.bind(this);
                        source.start(this._startedAt, this._progress + this.offset, this.duration);
                        this.isPlaying = !0;
                        this.source = source;
                        this.setDetune(this.detune);
                        this.setPlaybackRate(this.playbackRate);
                        return this.connect()
                    }
                    pause() {
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return
                        }
                        if (this.isPlaying === !0) {
                            this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
                            if (this.loop === !0) {
                                this._progress = this._progress % (this.duration || this.buffer.duration)
                            }
                            this.source.stop();
                            this.source.onended = null;
                            this.isPlaying = !1
                        }
                        return this
                    }
                    stop() {
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return
                        }
                        this._progress = 0;
                        if (this.source !== null) {
                            this.source.stop();
                            this.source.onended = null
                        }
                        this.isPlaying = !1;
                        return this
                    }
                    connect() {
                        if (this.filters.length > 0) {
                            this.source.connect(this.filters[0]);
                            for (let i = 1, l = this.filters.length; i < l; i++) {
                                this.filters[i - 1].connect(this.filters[i])
                            }
                            this.filters[this.filters.length - 1].connect(this.getOutput())
                        } else {
                            this.source.connect(this.getOutput())
                        }
                        this._connected = !0;
                        return this
                    }
                    disconnect() {
                        if (this._connected === !1) {
                            return
                        }
                        if (this.filters.length > 0) {
                            this.source.disconnect(this.filters[0]);
                            for (let i = 1, l = this.filters.length; i < l; i++) {
                                this.filters[i - 1].disconnect(this.filters[i])
                            }
                            this.filters[this.filters.length - 1].disconnect(this.getOutput())
                        } else {
                            this.source.disconnect(this.getOutput())
                        }
                        this._connected = !1;
                        return this
                    }
                    getFilters() {
                        return this.filters
                    }
                    setFilters(value) {
                        if (!value) value = [];
                        if (this._connected === !0) {
                            this.disconnect();
                            this.filters = value.slice();
                            this.connect()
                        } else {
                            this.filters = value.slice()
                        }
                        return this
                    }
                    setDetune(value) {
                        this.detune = value;
                        if (this.isPlaying === !0 && this.source.detune !== undefined) {
                            this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01)
                        }
                        return this
                    }
                    getDetune() {
                        return this.detune
                    }
                    getFilter() {
                        return this.getFilters()[0]
                    }
                    setFilter(filter) {
                        return this.setFilters(filter ? [filter] : [])
                    }
                    setPlaybackRate(value) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return
                        }
                        this.playbackRate = value;
                        if (this.isPlaying === !0) {
                            this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01)
                        }
                        return this
                    }
                    getPlaybackRate() {
                        return this.playbackRate
                    }
                    onEnded() {
                        this.isPlaying = !1
                    }
                    getLoop() {
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return !1
                        }
                        return this.loop
                    }
                    setLoop(value) {
                        if (this.hasPlaybackControl === !1) {
                            console.warn('THREE.Audio: this Audio has no playback control.');
                            return
                        }
                        this.loop = value;
                        if (this.isPlaying === !0) {
                            this.source.loop = this.loop
                        }
                        return this
                    }
                    setLoopStart(value) {
                        this.loopStart = value;
                        return this
                    }
                    setLoopEnd(value) {
                        this.loopEnd = value;
                        return this
                    }
                    getVolume() {
                        return this.gain.gain.value
                    }
                    setVolume(value) {
                        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
                        return this
                    }
                }
                const _position = new Vector3();
                const _quaternion = new Quaternion();
                const _scale = new Vector3();
                const _orientation = new Vector3();
                class PositionalAudio extends Audio {
                    constructor(listener) {
                        super(listener);
                        this.panner = this.context.createPanner();
                        this.panner.panningModel = 'HRTF';
                        this.panner.connect(this.gain)
                    }
                    connect() {
                        super.connect();
                        this.panner.connect(this.gain)
                    }
                    disconnect() {
                        super.disconnect();
                        this.panner.disconnect(this.gain)
                    }
                    getOutput() {
                        return this.panner
                    }
                    getRefDistance() {
                        return this.panner.refDistance
                    }
                    setRefDistance(value) {
                        this.panner.refDistance = value;
                        return this
                    }
                    getRolloffFactor() {
                        return this.panner.rolloffFactor
                    }
                    setRolloffFactor(value) {
                        this.panner.rolloffFactor = value;
                        return this
                    }
                    getDistanceModel() {
                        return this.panner.distanceModel
                    }
                    setDistanceModel(value) {
                        this.panner.distanceModel = value;
                        return this
                    }
                    getMaxDistance() {
                        return this.panner.maxDistance
                    }
                    setMaxDistance(value) {
                        this.panner.maxDistance = value;
                        return this
                    }
                    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
                        this.panner.coneInnerAngle = coneInnerAngle;
                        this.panner.coneOuterAngle = coneOuterAngle;
                        this.panner.coneOuterGain = coneOuterGain;
                        return this
                    }
                    updateMatrixWorld(force) {
                        super.updateMatrixWorld(force);
                        if (this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
                        this.matrixWorld.decompose(_position, _quaternion, _scale);
                        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
                        const panner = this.panner;
                        if (panner.positionX) {
                            const endTime = this.context.currentTime + this.listener.timeDelta;
                            panner.positionX.linearRampToValueAtTime(_position.x, endTime);
                            panner.positionY.linearRampToValueAtTime(_position.y, endTime);
                            panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
                            panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
                            panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
                            panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime)
                        } else {
                            panner.setPosition(_position.x, _position.y, _position.z);
                            panner.setOrientation(_orientation.x, _orientation.y, _orientation.z)
                        }
                    }
                }
                class AudioAnalyser {
                    constructor(audio, fftSize = 2048) {
                        this.analyser = audio.context.createAnalyser();
                        this.analyser.fftSize = fftSize;
                        this.data = new Uint8Array(this.analyser.frequencyBinCount);
                        audio.getOutput().connect(this.analyser)
                    }
                    getFrequencyData() {
                        this.analyser.getByteFrequencyData(this.data);
                        return this.data
                    }
                    getAverageFrequency() {
                        let value = 0;
                        const data = this.getFrequencyData();
                        for (let i = 0; i < data.length; i++) {
                            value += data[i]
                        }
                        return value / data.length
                    }
                }
                class PropertyMixer {
                    constructor(binding, typeName, valueSize) {
                        this.binding = binding;
                        this.valueSize = valueSize;
                        let mixFunction, mixFunctionAdditive, setIdentity;
                        switch (typeName) {
                            case 'quaternion':
                                mixFunction = this._slerp;
                                mixFunctionAdditive = this._slerpAdditive;
                                setIdentity = this._setAdditiveIdentityQuaternion;
                                this.buffer = new Float64Array(valueSize * 6);
                                this._workIndex = 5;
                                break;
                            case 'string':
                            case 'bool':
                                mixFunction = this._select;
                                mixFunctionAdditive = this._select;
                                setIdentity = this._setAdditiveIdentityOther;
                                this.buffer = new Array(valueSize * 5);
                                break;
                            default:
                                mixFunction = this._lerp;
                                mixFunctionAdditive = this._lerpAdditive;
                                setIdentity = this._setAdditiveIdentityNumeric;
                                this.buffer = new Float64Array(valueSize * 5)
                        }
                        this._mixBufferRegion = mixFunction;
                        this._mixBufferRegionAdditive = mixFunctionAdditive;
                        this._setIdentity = setIdentity;
                        this._origIndex = 3;
                        this._addIndex = 4;
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0;
                        this.useCount = 0;
                        this.referenceCount = 0
                    }
                    accumulate(accuIndex, weight) {
                        const buffer = this.buffer,
                            stride = this.valueSize,
                            offset = accuIndex * stride + stride;
                        let currentWeight = this.cumulativeWeight;
                        if (currentWeight === 0) {
                            for (let i = 0; i !== stride; ++i) {
                                buffer[offset + i] = buffer[i]
                            }
                            currentWeight = weight
                        } else {
                            currentWeight += weight;
                            const mix = weight / currentWeight;
                            this._mixBufferRegion(buffer, offset, 0, mix, stride)
                        }
                        this.cumulativeWeight = currentWeight
                    }
                    accumulateAdditive(weight) {
                        const buffer = this.buffer,
                            stride = this.valueSize,
                            offset = stride * this._addIndex;
                        if (this.cumulativeWeightAdditive === 0) {
                            this._setIdentity()
                        }
                        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
                        this.cumulativeWeightAdditive += weight
                    }
                    apply(accuIndex) {
                        const stride = this.valueSize,
                            buffer = this.buffer,
                            offset = accuIndex * stride + stride,
                            weight = this.cumulativeWeight,
                            weightAdditive = this.cumulativeWeightAdditive,
                            binding = this.binding;
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0;
                        if (weight < 1) {
                            const originalValueOffset = stride * this._origIndex;
                            this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride)
                        }
                        if (weightAdditive > 0) {
                            this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride)
                        }
                        for (let i = stride, e = stride + stride; i !== e; ++i) {
                            if (buffer[i] !== buffer[i + stride]) {
                                binding.setValue(buffer, offset);
                                break
                            }
                        }
                    }
                    saveOriginalState() {
                        const binding = this.binding;
                        const buffer = this.buffer,
                            stride = this.valueSize,
                            originalValueOffset = stride * this._origIndex;
                        binding.getValue(buffer, originalValueOffset);
                        for (let i = stride, e = originalValueOffset; i !== e; ++i) {
                            buffer[i] = buffer[originalValueOffset + (i % stride)]
                        }
                        this._setIdentity();
                        this.cumulativeWeight = 0;
                        this.cumulativeWeightAdditive = 0
                    }
                    restoreOriginalState() {
                        const originalValueOffset = this.valueSize * 3;
                        this.binding.setValue(this.buffer, originalValueOffset)
                    }
                    _setAdditiveIdentityNumeric() {
                        const startIndex = this._addIndex * this.valueSize;
                        const endIndex = startIndex + this.valueSize;
                        for (let i = startIndex; i < endIndex; i++) {
                            this.buffer[i] = 0
                        }
                    }
                    _setAdditiveIdentityQuaternion() {
                        this._setAdditiveIdentityNumeric();
                        this.buffer[this._addIndex * this.valueSize + 3] = 1
                    }
                    _setAdditiveIdentityOther() {
                        const startIndex = this._origIndex * this.valueSize;
                        const targetIndex = this._addIndex * this.valueSize;
                        for (let i = 0; i < this.valueSize; i++) {
                            this.buffer[targetIndex + i] = this.buffer[startIndex + i]
                        }
                    }
                    _select(buffer, dstOffset, srcOffset, t, stride) {
                        if (t >= 0.5) {
                            for (let i = 0; i !== stride; ++i) {
                                buffer[dstOffset + i] = buffer[srcOffset + i]
                            }
                        }
                    }
                    _slerp(buffer, dstOffset, srcOffset, t) {
                        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t)
                    }
                    _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
                        const workOffset = this._workIndex * stride;
                        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);
                        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t)
                    }
                    _lerp(buffer, dstOffset, srcOffset, t, stride) {
                        const s = 1 - t;
                        for (let i = 0; i !== stride; ++i) {
                            const j = dstOffset + i;
                            buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t
                        }
                    }
                    _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
                        for (let i = 0; i !== stride; ++i) {
                            const j = dstOffset + i;
                            buffer[j] = buffer[j] + buffer[srcOffset + i] * t
                        }
                    }
                }
                const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
                const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
                const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
                const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';
                const _directoryRe = /((?:WC+[\/:])*)/.source.replace('WC', _wordChar);
                const _nodeRe = /(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);
                const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);
                const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
                const _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
                const _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
                class Composite {
                    constructor(targetGroup, path, optionalParsedPath) {
                        const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
                        this._targetGroup = targetGroup;
                        this._bindings = targetGroup.subscribe_(path, parsedPath)
                    }
                    getValue(array, offset) {
                        this.bind();
                        const firstValidIndex = this._targetGroup.nCachedObjects_,
                            binding = this._bindings[firstValidIndex];
                        if (binding !== undefined) binding.getValue(array, offset)
                    }
                    setValue(array, offset) {
                        const bindings = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].setValue(array, offset)
                        }
                    }
                    bind() {
                        const bindings = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].bind()
                        }
                    }
                    unbind() {
                        const bindings = this._bindings;
                        for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
                            bindings[i].unbind()
                        }
                    }
                }
                class PropertyBinding {
                    constructor(rootNode, path, parsedPath) {
                        this.path = path;
                        this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
                        this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
                        this.rootNode = rootNode;
                        this.getValue = this._getValue_unbound;
                        this.setValue = this._setValue_unbound
                    }
                    static create(root, path, parsedPath) {
                        if (!(root && root.isAnimationObjectGroup)) {
                            return new PropertyBinding(root, path, parsedPath)
                        } else {
                            return new PropertyBinding.Composite(root, path, parsedPath)
                        }
                    }
                    static sanitizeNodeName(name) {
                        return name.replace(/\s/g, '_').replace(_reservedRe, '')
                    }
                    static parseTrackName(trackName) {
                        const matches = _trackRe.exec(trackName);
                        if (matches === null) {
                            throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName)
                        }
                        const results = {
                            nodeName: matches[2],
                            objectName: matches[3],
                            objectIndex: matches[4],
                            propertyName: matches[5],
                            propertyIndex: matches[6]
                        };
                        const lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
                        if (lastDot !== undefined && lastDot !== -1) {
                            const objectName = results.nodeName.substring(lastDot + 1);
                            if (_supportedObjectNames.indexOf(objectName) !== -1) {
                                results.nodeName = results.nodeName.substring(0, lastDot);
                                results.objectName = objectName
                            }
                        }
                        if (results.propertyName === null || results.propertyName.length === 0) {
                            throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName)
                        }
                        return results
                    }
                    static findNode(root, nodeName) {
                        if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
                            return root
                        }
                        if (root.skeleton) {
                            const bone = root.skeleton.getBoneByName(nodeName);
                            if (bone !== undefined) {
                                return bone
                            }
                        }
                        if (root.children) {
                            const searchNodeSubtree = function(children) {
                                for (let i = 0; i < children.length; i++) {
                                    const childNode = children[i];
                                    if (childNode.name === nodeName || childNode.uuid === nodeName) {
                                        return childNode
                                    }
                                    const result = searchNodeSubtree(childNode.children);
                                    if (result) return result
                                }
                                return null
                            };
                            const subTreeNode = searchNodeSubtree(root.children);
                            if (subTreeNode) {
                                return subTreeNode
                            }
                        }
                        return null
                    }
                    _getValue_unavailable() {}
                    _setValue_unavailable() {}
                    _getValue_direct(buffer, offset) {
                        buffer[offset] = this.targetObject[this.propertyName]
                    }
                    _getValue_array(buffer, offset) {
                        const source = this.resolvedProperty;
                        for (let i = 0, n = source.length; i !== n; ++i) {
                            buffer[offset++] = source[i]
                        }
                    }
                    _getValue_arrayElement(buffer, offset) {
                        buffer[offset] = this.resolvedProperty[this.propertyIndex]
                    }
                    _getValue_toArray(buffer, offset) {
                        this.resolvedProperty.toArray(buffer, offset)
                    }
                    _setValue_direct(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset]
                    }
                    _setValue_direct_setNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.targetObject[this.propertyName] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_array(buffer, offset) {
                        const dest = this.resolvedProperty;
                        for (let i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                    }
                    _setValue_array_setNeedsUpdate(buffer, offset) {
                        const dest = this.resolvedProperty;
                        for (let i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
                        const dest = this.resolvedProperty;
                        for (let i = 0, n = dest.length; i !== n; ++i) {
                            dest[i] = buffer[offset++]
                        }
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_arrayElement(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset]
                    }
                    _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty[this.propertyIndex] = buffer[offset];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _setValue_fromArray(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset)
                    }
                    _setValue_fromArray_setNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.needsUpdate = !0
                    }
                    _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
                        this.resolvedProperty.fromArray(buffer, offset);
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }
                    _getValue_unbound(targetArray, offset) {
                        this.bind();
                        this.getValue(targetArray, offset)
                    }
                    _setValue_unbound(sourceArray, offset) {
                        this.bind();
                        this.setValue(sourceArray, offset)
                    }
                    bind() {
                        let targetObject = this.node;
                        const parsedPath = this.parsedPath;
                        const objectName = parsedPath.objectName;
                        const propertyName = parsedPath.propertyName;
                        let propertyIndex = parsedPath.propertyIndex;
                        if (!targetObject) {
                            targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
                            this.node = targetObject
                        }
                        this.getValue = this._getValue_unavailable;
                        this.setValue = this._setValue_unavailable;
                        if (!targetObject) {
                            console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
                            return
                        }
                        if (objectName) {
                            let objectIndex = parsedPath.objectIndex;
                            switch (objectName) {
                                case 'materials':
                                    if (!targetObject.material) {
                                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                                        return
                                    }
                                    if (!targetObject.material.materials) {
                                        console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                                        return
                                    }
                                    targetObject = targetObject.material.materials;
                                    break;
                                case 'bones':
                                    if (!targetObject.skeleton) {
                                        console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                                        return
                                    }
                                    targetObject = targetObject.skeleton.bones;
                                    for (let i = 0; i < targetObject.length; i++) {
                                        if (targetObject[i].name === objectIndex) {
                                            objectIndex = i;
                                            break
                                        }
                                    }
                                    break;
                                case 'map':
                                    if ('map' in targetObject) {
                                        targetObject = targetObject.map;
                                        break
                                    }
                                    if (!targetObject.material) {
                                        console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                                        return
                                    }
                                    if (!targetObject.material.map) {
                                        console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
                                        return
                                    }
                                    targetObject = targetObject.material.map;
                                    break;
                                default:
                                    if (targetObject[objectName] === undefined) {
                                        console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                                        return
                                    }
                                    targetObject = targetObject[objectName]
                            }
                            if (objectIndex !== undefined) {
                                if (targetObject[objectIndex] === undefined) {
                                    console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
                                    return
                                }
                                targetObject = targetObject[objectIndex]
                            }
                        }
                        const nodeProperty = targetObject[propertyName];
                        if (nodeProperty === undefined) {
                            const nodeName = parsedPath.nodeName;
                            console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
                            return
                        }
                        let versioning = this.Versioning.None;
                        this.targetObject = targetObject;
                        if (targetObject.needsUpdate !== undefined) {
                            versioning = this.Versioning.NeedsUpdate
                        } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
                            versioning = this.Versioning.MatrixWorldNeedsUpdate
                        }
                        let bindingType = this.BindingType.Direct;
                        if (propertyIndex !== undefined) {
                            if (propertyName === 'morphTargetInfluences') {
                                if (!targetObject.geometry) {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
                                    return
                                }
                                if (!targetObject.geometry.morphAttributes) {
                                    console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
                                    return
                                }
                                if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
                                    propertyIndex = targetObject.morphTargetDictionary[propertyIndex]
                                }
                            }
                            bindingType = this.BindingType.ArrayElement;
                            this.resolvedProperty = nodeProperty;
                            this.propertyIndex = propertyIndex
                        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
                            bindingType = this.BindingType.HasFromToArray;
                            this.resolvedProperty = nodeProperty
                        } else if (Array.isArray(nodeProperty)) {
                            bindingType = this.BindingType.EntireArray;
                            this.resolvedProperty = nodeProperty
                        } else {
                            this.propertyName = propertyName
                        }
                        this.getValue = this.GetterByBindingType[bindingType];
                        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning]
                    }
                    unbind() {
                        this.node = null;
                        this.getValue = this._getValue_unbound;
                        this.setValue = this._setValue_unbound
                    }
                }
                PropertyBinding.Composite = Composite;
                PropertyBinding.prototype.BindingType = {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                };
                PropertyBinding.prototype.Versioning = {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                };
                PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray, ];
                PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
                    [PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate, ],
                    [PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate, ],
                    [PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate, ],
                    [PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate, ]
                ];
                class AnimationObjectGroup {
                    constructor() {
                        this.isAnimationObjectGroup = !0;
                        this.uuid = generateUUID();
                        this._objects = Array.prototype.slice.call(arguments);
                        this.nCachedObjects_ = 0;
                        const indices = {};
                        this._indicesByUUID = indices;
                        for (let i = 0, n = arguments.length; i !== n; ++i) {
                            indices[arguments[i].uuid] = i
                        }
                        this._paths = [];
                        this._parsedPaths = [];
                        this._bindings = [];
                        this._bindingsIndicesByPath = {};
                        const scope = this;
                        this.stats = {
                            objects: {
                                get total() {
                                    return scope._objects.length
                                },
                                get inUse() {
                                    return this.total - scope.nCachedObjects_
                                }
                            },
                            get bindingsPerObject() {
                                return scope._bindings.length
                            }
                        }
                    }
                    add() {
                        const objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            paths = this._paths,
                            parsedPaths = this._parsedPaths,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        let knownObject = undefined,
                            nObjects = objects.length,
                            nCachedObjects = this.nCachedObjects_;
                        for (let i = 0, n = arguments.length; i !== n; ++i) {
                            const object = arguments[i],
                                uuid = object.uuid;
                            let index = indicesByUUID[uuid];
                            if (index === undefined) {
                                index = nObjects++;
                                indicesByUUID[uuid] = index;
                                objects.push(object);
                                for (let j = 0, m = nBindings; j !== m; ++j) {
                                    bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]))
                                }
                            } else if (index < nCachedObjects) {
                                knownObject = objects[index];
                                const firstActiveIndex = --nCachedObjects,
                                    lastCachedObject = objects[firstActiveIndex];
                                indicesByUUID[lastCachedObject.uuid] = index;
                                objects[index] = lastCachedObject;
                                indicesByUUID[uuid] = firstActiveIndex;
                                objects[firstActiveIndex] = object;
                                for (let j = 0, m = nBindings; j !== m; ++j) {
                                    const bindingsForPath = bindings[j],
                                        lastCached = bindingsForPath[firstActiveIndex];
                                    let binding = bindingsForPath[index];
                                    bindingsForPath[index] = lastCached;
                                    if (binding === undefined) {
                                        binding = new PropertyBinding(object, paths[j], parsedPaths[j])
                                    }
                                    bindingsForPath[firstActiveIndex] = binding
                                }
                            } else if (objects[index] !== knownObject) {
                                console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.')
                            }
                        }
                        this.nCachedObjects_ = nCachedObjects
                    }
                    remove() {
                        const objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        let nCachedObjects = this.nCachedObjects_;
                        for (let i = 0, n = arguments.length; i !== n; ++i) {
                            const object = arguments[i],
                                uuid = object.uuid,
                                index = indicesByUUID[uuid];
                            if (index !== undefined && index >= nCachedObjects) {
                                const lastCachedIndex = nCachedObjects++,
                                    firstActiveObject = objects[lastCachedIndex];
                                indicesByUUID[firstActiveObject.uuid] = index;
                                objects[index] = firstActiveObject;
                                indicesByUUID[uuid] = lastCachedIndex;
                                objects[lastCachedIndex] = object;
                                for (let j = 0, m = nBindings; j !== m; ++j) {
                                    const bindingsForPath = bindings[j],
                                        firstActive = bindingsForPath[lastCachedIndex],
                                        binding = bindingsForPath[index];
                                    bindingsForPath[index] = firstActive;
                                    bindingsForPath[lastCachedIndex] = binding
                                }
                            }
                        }
                        this.nCachedObjects_ = nCachedObjects
                    }
                    uncache() {
                        const objects = this._objects,
                            indicesByUUID = this._indicesByUUID,
                            bindings = this._bindings,
                            nBindings = bindings.length;
                        let nCachedObjects = this.nCachedObjects_,
                            nObjects = objects.length;
                        for (let i = 0, n = arguments.length; i !== n; ++i) {
                            const object = arguments[i],
                                uuid = object.uuid,
                                index = indicesByUUID[uuid];
                            if (index !== undefined) {
                                delete indicesByUUID[uuid];
                                if (index < nCachedObjects) {
                                    const firstActiveIndex = --nCachedObjects,
                                        lastCachedObject = objects[firstActiveIndex],
                                        lastIndex = --nObjects,
                                        lastObject = objects[lastIndex];
                                    indicesByUUID[lastCachedObject.uuid] = index;
                                    objects[index] = lastCachedObject;
                                    indicesByUUID[lastObject.uuid] = firstActiveIndex;
                                    objects[firstActiveIndex] = lastObject;
                                    objects.pop();
                                    for (let j = 0, m = nBindings; j !== m; ++j) {
                                        const bindingsForPath = bindings[j],
                                            lastCached = bindingsForPath[firstActiveIndex],
                                            last = bindingsForPath[lastIndex];
                                        bindingsForPath[index] = lastCached;
                                        bindingsForPath[firstActiveIndex] = last;
                                        bindingsForPath.pop()
                                    }
                                } else {
                                    const lastIndex = --nObjects,
                                        lastObject = objects[lastIndex];
                                    if (lastIndex > 0) {
                                        indicesByUUID[lastObject.uuid] = index
                                    }
                                    objects[index] = lastObject;
                                    objects.pop();
                                    for (let j = 0, m = nBindings; j !== m; ++j) {
                                        const bindingsForPath = bindings[j];
                                        bindingsForPath[index] = bindingsForPath[lastIndex];
                                        bindingsForPath.pop()
                                    }
                                }
                            }
                        }
                        this.nCachedObjects_ = nCachedObjects
                    }
                    subscribe_(path, parsedPath) {
                        const indicesByPath = this._bindingsIndicesByPath;
                        let index = indicesByPath[path];
                        const bindings = this._bindings;
                        if (index !== undefined) return bindings[index];
                        const paths = this._paths,
                            parsedPaths = this._parsedPaths,
                            objects = this._objects,
                            nObjects = objects.length,
                            nCachedObjects = this.nCachedObjects_,
                            bindingsForPath = new Array(nObjects);
                        index = bindings.length;
                        indicesByPath[path] = index;
                        paths.push(path);
                        parsedPaths.push(parsedPath);
                        bindings.push(bindingsForPath);
                        for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
                            const object = objects[i];
                            bindingsForPath[i] = new PropertyBinding(object, path, parsedPath)
                        }
                        return bindingsForPath
                    }
                    unsubscribe_(path) {
                        const indicesByPath = this._bindingsIndicesByPath,
                            index = indicesByPath[path];
                        if (index !== undefined) {
                            const paths = this._paths,
                                parsedPaths = this._parsedPaths,
                                bindings = this._bindings,
                                lastBindingsIndex = bindings.length - 1,
                                lastBindings = bindings[lastBindingsIndex],
                                lastBindingsPath = path[lastBindingsIndex];
                            indicesByPath[lastBindingsPath] = index;
                            bindings[index] = lastBindings;
                            bindings.pop();
                            parsedPaths[index] = parsedPaths[lastBindingsIndex];
                            parsedPaths.pop();
                            paths[index] = paths[lastBindingsIndex];
                            paths.pop()
                        }
                    }
                }
                class AnimationAction {
                    constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
                        this._mixer = mixer;
                        this._clip = clip;
                        this._localRoot = localRoot;
                        this.blendMode = blendMode;
                        const tracks = clip.tracks,
                            nTracks = tracks.length,
                            interpolants = new Array(nTracks);
                        const interpolantSettings = {
                            endingStart: ZeroCurvatureEnding,
                            endingEnd: ZeroCurvatureEnding
                        };
                        for (let i = 0; i !== nTracks; ++i) {
                            const interpolant = tracks[i].createInterpolant(null);
                            interpolants[i] = interpolant;
                            interpolant.settings = interpolantSettings
                        }
                        this._interpolantSettings = interpolantSettings;
                        this._interpolants = interpolants;
                        this._propertyBindings = new Array(nTracks);
                        this._cacheIndex = null;
                        this._byClipCacheIndex = null;
                        this._timeScaleInterpolant = null;
                        this._weightInterpolant = null;
                        this.loop = LoopRepeat;
                        this._loopCount = -1;
                        this._startTime = null;
                        this.time = 0;
                        this.timeScale = 1;
                        this._effectiveTimeScale = 1;
                        this.weight = 1;
                        this._effectiveWeight = 1;
                        this.repetitions = Infinity;
                        this.paused = !1;
                        this.enabled = !0;
                        this.clampWhenFinished = !1;
                        this.zeroSlopeAtStart = !0;
                        this.zeroSlopeAtEnd = !0
                    }
                    play() {
                        this._mixer._activateAction(this);
                        return this
                    }
                    stop() {
                        this._mixer._deactivateAction(this);
                        return this.reset()
                    }
                    reset() {
                        this.paused = !1;
                        this.enabled = !0;
                        this.time = 0;
                        this._loopCount = -1;
                        this._startTime = null;
                        return this.stopFading().stopWarping()
                    }
                    isRunning() {
                        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
                    }
                    isScheduled() {
                        return this._mixer._isActiveAction(this)
                    }
                    startAt(time) {
                        this._startTime = time;
                        return this
                    }
                    setLoop(mode, repetitions) {
                        this.loop = mode;
                        this.repetitions = repetitions;
                        return this
                    }
                    setEffectiveWeight(weight) {
                        this.weight = weight;
                        this._effectiveWeight = this.enabled ? weight : 0;
                        return this.stopFading()
                    }
                    getEffectiveWeight() {
                        return this._effectiveWeight
                    }
                    fadeIn(duration) {
                        return this._scheduleFading(duration, 0, 1)
                    }
                    fadeOut(duration) {
                        return this._scheduleFading(duration, 1, 0)
                    }
                    crossFadeFrom(fadeOutAction, duration, warp) {
                        fadeOutAction.fadeOut(duration);
                        this.fadeIn(duration);
                        if (warp) {
                            const fadeInDuration = this._clip.duration,
                                fadeOutDuration = fadeOutAction._clip.duration,
                                startEndRatio = fadeOutDuration / fadeInDuration,
                                endStartRatio = fadeInDuration / fadeOutDuration;
                            fadeOutAction.warp(1.0, startEndRatio, duration);
                            this.warp(endStartRatio, 1.0, duration)
                        }
                        return this
                    }
                    crossFadeTo(fadeInAction, duration, warp) {
                        return fadeInAction.crossFadeFrom(this, duration, warp)
                    }
                    stopFading() {
                        const weightInterpolant = this._weightInterpolant;
                        if (weightInterpolant !== null) {
                            this._weightInterpolant = null;
                            this._mixer._takeBackControlInterpolant(weightInterpolant)
                        }
                        return this
                    }
                    setEffectiveTimeScale(timeScale) {
                        this.timeScale = timeScale;
                        this._effectiveTimeScale = this.paused ? 0 : timeScale;
                        return this.stopWarping()
                    }
                    getEffectiveTimeScale() {
                        return this._effectiveTimeScale
                    }
                    setDuration(duration) {
                        this.timeScale = this._clip.duration / duration;
                        return this.stopWarping()
                    }
                    syncWith(action) {
                        this.time = action.time;
                        this.timeScale = action.timeScale;
                        return this.stopWarping()
                    }
                    halt(duration) {
                        return this.warp(this._effectiveTimeScale, 0, duration)
                    }
                    warp(startTimeScale, endTimeScale, duration) {
                        const mixer = this._mixer,
                            now = mixer.time,
                            timeScale = this.timeScale;
                        let interpolant = this._timeScaleInterpolant;
                        if (interpolant === null) {
                            interpolant = mixer._lendControlInterpolant();
                            this._timeScaleInterpolant = interpolant
                        }
                        const times = interpolant.parameterPositions,
                            values = interpolant.sampleValues;
                        times[0] = now;
                        times[1] = now + duration;
                        values[0] = startTimeScale / timeScale;
                        values[1] = endTimeScale / timeScale;
                        return this
                    }
                    stopWarping() {
                        const timeScaleInterpolant = this._timeScaleInterpolant;
                        if (timeScaleInterpolant !== null) {
                            this._timeScaleInterpolant = null;
                            this._mixer._takeBackControlInterpolant(timeScaleInterpolant)
                        }
                        return this
                    }
                    getMixer() {
                        return this._mixer
                    }
                    getClip() {
                        return this._clip
                    }
                    getRoot() {
                        return this._localRoot || this._mixer._root
                    }
                    _update(time, deltaTime, timeDirection, accuIndex) {
                        if (!this.enabled) {
                            this._updateWeight(time);
                            return
                        }
                        const startTime = this._startTime;
                        if (startTime !== null) {
                            const timeRunning = (time - startTime) * timeDirection;
                            if (timeRunning < 0 || timeDirection === 0) {
                                deltaTime = 0
                            } else {
                                this._startTime = null;
                                deltaTime = timeDirection * timeRunning
                            }
                        }
                        deltaTime *= this._updateTimeScale(time);
                        const clipTime = this._updateTime(deltaTime);
                        const weight = this._updateWeight(time);
                        if (weight > 0) {
                            const interpolants = this._interpolants;
                            const propertyMixers = this._propertyBindings;
                            switch (this.blendMode) {
                                case AdditiveAnimationBlendMode:
                                    for (let j = 0, m = interpolants.length; j !== m; ++j) {
                                        interpolants[j].evaluate(clipTime);
                                        propertyMixers[j].accumulateAdditive(weight)
                                    }
                                    break;
                                case NormalAnimationBlendMode:
                                default:
                                    for (let j = 0, m = interpolants.length; j !== m; ++j) {
                                        interpolants[j].evaluate(clipTime);
                                        propertyMixers[j].accumulate(accuIndex, weight)
                                    }
                            }
                        }
                    }
                    _updateWeight(time) {
                        let weight = 0;
                        if (this.enabled) {
                            weight = this.weight;
                            const interpolant = this._weightInterpolant;
                            if (interpolant !== null) {
                                const interpolantValue = interpolant.evaluate(time)[0];
                                weight *= interpolantValue;
                                if (time > interpolant.parameterPositions[1]) {
                                    this.stopFading();
                                    if (interpolantValue === 0) {
                                        this.enabled = !1
                                    }
                                }
                            }
                        }
                        this._effectiveWeight = weight;
                        return weight
                    }
                    _updateTimeScale(time) {
                        let timeScale = 0;
                        if (!this.paused) {
                            timeScale = this.timeScale;
                            const interpolant = this._timeScaleInterpolant;
                            if (interpolant !== null) {
                                const interpolantValue = interpolant.evaluate(time)[0];
                                timeScale *= interpolantValue;
                                if (time > interpolant.parameterPositions[1]) {
                                    this.stopWarping();
                                    if (timeScale === 0) {
                                        this.paused = !0
                                    } else {
                                        this.timeScale = timeScale
                                    }
                                }
                            }
                        }
                        this._effectiveTimeScale = timeScale;
                        return timeScale
                    }
                    _updateTime(deltaTime) {
                        const duration = this._clip.duration;
                        const loop = this.loop;
                        let time = this.time + deltaTime;
                        let loopCount = this._loopCount;
                        const pingPong = (loop === LoopPingPong);
                        if (deltaTime === 0) {
                            if (loopCount === -1) return time;
                            return (pingPong && (loopCount & 1) === 1) ? duration - time : time
                        }
                        if (loop === LoopOnce) {
                            if (loopCount === -1) {
                                this._loopCount = 0;
                                this._setEndings(!0, !0, !1)
                            }
                            handle_stop: {
                                if (time >= duration) {
                                    time = duration
                                } else if (time < 0) {
                                    time = 0
                                } else {
                                    this.time = time;
                                    break handle_stop
                                }
                                if (this.clampWhenFinished) this.paused = !0;
                                else this.enabled = !1;this.time = time;this._mixer.dispatchEvent({
                                    type: 'finished',
                                    action: this,
                                    direction: deltaTime < 0 ? -1 : 1
                                })
                            }
                        } else {
                            if (loopCount === -1) {
                                if (deltaTime >= 0) {
                                    loopCount = 0;
                                    this._setEndings(!0, this.repetitions === 0, pingPong)
                                } else {
                                    this._setEndings(this.repetitions === 0, !0, pingPong)
                                }
                            }
                            if (time >= duration || time < 0) {
                                const loopDelta = Math.floor(time / duration);
                                time -= duration * loopDelta;
                                loopCount += Math.abs(loopDelta);
                                const pending = this.repetitions - loopCount;
                                if (pending <= 0) {
                                    if (this.clampWhenFinished) this.paused = !0;
                                    else this.enabled = !1;
                                    time = deltaTime > 0 ? duration : 0;
                                    this.time = time;
                                    this._mixer.dispatchEvent({
                                        type: 'finished',
                                        action: this,
                                        direction: deltaTime > 0 ? 1 : -1
                                    })
                                } else {
                                    if (pending === 1) {
                                        const atStart = deltaTime < 0;
                                        this._setEndings(atStart, !atStart, pingPong)
                                    } else {
                                        this._setEndings(!1, !1, pingPong)
                                    }
                                    this._loopCount = loopCount;
                                    this.time = time;
                                    this._mixer.dispatchEvent({
                                        type: 'loop',
                                        action: this,
                                        loopDelta: loopDelta
                                    })
                                }
                            } else {
                                this.time = time
                            }
                            if (pingPong && (loopCount & 1) === 1) {
                                return duration - time
                            }
                        }
                        return time
                    }
                    _setEndings(atStart, atEnd, pingPong) {
                        const settings = this._interpolantSettings;
                        if (pingPong) {
                            settings.endingStart = ZeroSlopeEnding;
                            settings.endingEnd = ZeroSlopeEnding
                        } else {
                            if (atStart) {
                                settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding
                            } else {
                                settings.endingStart = WrapAroundEnding
                            }
                            if (atEnd) {
                                settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding
                            } else {
                                settings.endingEnd = WrapAroundEnding
                            }
                        }
                    }
                    _scheduleFading(duration, weightNow, weightThen) {
                        const mixer = this._mixer,
                            now = mixer.time;
                        let interpolant = this._weightInterpolant;
                        if (interpolant === null) {
                            interpolant = mixer._lendControlInterpolant();
                            this._weightInterpolant = interpolant
                        }
                        const times = interpolant.parameterPositions,
                            values = interpolant.sampleValues;
                        times[0] = now;
                        values[0] = weightNow;
                        times[1] = now + duration;
                        values[1] = weightThen;
                        return this
                    }
                }
                const _controlInterpolantsResultBuffer = new Float32Array(1);
                class AnimationMixer extends EventDispatcher {
                    constructor(root) {
                        super();
                        this._root = root;
                        this._initMemoryManager();
                        this._accuIndex = 0;
                        this.time = 0;
                        this.timeScale = 1.0
                    }
                    _bindAction(action, prototypeAction) {
                        const root = action._localRoot || this._root,
                            tracks = action._clip.tracks,
                            nTracks = tracks.length,
                            bindings = action._propertyBindings,
                            interpolants = action._interpolants,
                            rootUuid = root.uuid,
                            bindingsByRoot = this._bindingsByRootAndName;
                        let bindingsByName = bindingsByRoot[rootUuid];
                        if (bindingsByName === undefined) {
                            bindingsByName = {};
                            bindingsByRoot[rootUuid] = bindingsByName
                        }
                        for (let i = 0; i !== nTracks; ++i) {
                            const track = tracks[i],
                                trackName = track.name;
                            let binding = bindingsByName[trackName];
                            if (binding !== undefined) {
                                ++binding.referenceCount;
                                bindings[i] = binding
                            } else {
                                binding = bindings[i];
                                if (binding !== undefined) {
                                    if (binding._cacheIndex === null) {
                                        ++binding.referenceCount;
                                        this._addInactiveBinding(binding, rootUuid, trackName)
                                    }
                                    continue
                                }
                                const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
                                binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
                                ++binding.referenceCount;
                                this._addInactiveBinding(binding, rootUuid, trackName);
                                bindings[i] = binding
                            }
                            interpolants[i].resultBuffer = binding.buffer
                        }
                    }
                    _activateAction(action) {
                        if (!this._isActiveAction(action)) {
                            if (action._cacheIndex === null) {
                                const rootUuid = (action._localRoot || this._root).uuid,
                                    clipUuid = action._clip.uuid,
                                    actionsForClip = this._actionsByClip[clipUuid];
                                this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
                                this._addInactiveAction(action, clipUuid, rootUuid)
                            }
                            const bindings = action._propertyBindings;
                            for (let i = 0, n = bindings.length; i !== n; ++i) {
                                const binding = bindings[i];
                                if (binding.useCount++ === 0) {
                                    this._lendBinding(binding);
                                    binding.saveOriginalState()
                                }
                            }
                            this._lendAction(action)
                        }
                    }
                    _deactivateAction(action) {
                        if (this._isActiveAction(action)) {
                            const bindings = action._propertyBindings;
                            for (let i = 0, n = bindings.length; i !== n; ++i) {
                                const binding = bindings[i];
                                if (--binding.useCount === 0) {
                                    binding.restoreOriginalState();
                                    this._takeBackBinding(binding)
                                }
                            }
                            this._takeBackAction(action)
                        }
                    }
                    _initMemoryManager() {
                        this._actions = [];
                        this._nActiveActions = 0;
                        this._actionsByClip = {};
                        this._bindings = [];
                        this._nActiveBindings = 0;
                        this._bindingsByRootAndName = {};
                        this._controlInterpolants = [];
                        this._nActiveControlInterpolants = 0;
                        const scope = this;
                        this.stats = {
                            actions: {
                                get total() {
                                    return scope._actions.length
                                },
                                get inUse() {
                                    return scope._nActiveActions
                                }
                            },
                            bindings: {
                                get total() {
                                    return scope._bindings.length
                                },
                                get inUse() {
                                    return scope._nActiveBindings
                                }
                            },
                            controlInterpolants: {
                                get total() {
                                    return scope._controlInterpolants.length
                                },
                                get inUse() {
                                    return scope._nActiveControlInterpolants
                                }
                            }
                        }
                    }
                    _isActiveAction(action) {
                        const index = action._cacheIndex;
                        return index !== null && index < this._nActiveActions
                    }
                    _addInactiveAction(action, clipUuid, rootUuid) {
                        const actions = this._actions,
                            actionsByClip = this._actionsByClip;
                        let actionsForClip = actionsByClip[clipUuid];
                        if (actionsForClip === undefined) {
                            actionsForClip = {
                                knownActions: [action],
                                actionByRoot: {}
                            };
                            action._byClipCacheIndex = 0;
                            actionsByClip[clipUuid] = actionsForClip
                        } else {
                            const knownActions = actionsForClip.knownActions;
                            action._byClipCacheIndex = knownActions.length;
                            knownActions.push(action)
                        }
                        action._cacheIndex = actions.length;
                        actions.push(action);
                        actionsForClip.actionByRoot[rootUuid] = action
                    }
                    _removeInactiveAction(action) {
                        const actions = this._actions,
                            lastInactiveAction = actions[actions.length - 1],
                            cacheIndex = action._cacheIndex;
                        lastInactiveAction._cacheIndex = cacheIndex;
                        actions[cacheIndex] = lastInactiveAction;
                        actions.pop();
                        action._cacheIndex = null;
                        const clipUuid = action._clip.uuid,
                            actionsByClip = this._actionsByClip,
                            actionsForClip = actionsByClip[clipUuid],
                            knownActionsForClip = actionsForClip.knownActions,
                            lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
                            byClipCacheIndex = action._byClipCacheIndex;
                        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
                        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
                        knownActionsForClip.pop();
                        action._byClipCacheIndex = null;
                        const actionByRoot = actionsForClip.actionByRoot,
                            rootUuid = (action._localRoot || this._root).uuid;
                        delete actionByRoot[rootUuid];
                        if (knownActionsForClip.length === 0) {
                            delete actionsByClip[clipUuid]
                        }
                        this._removeInactiveBindingsForAction(action)
                    }
                    _removeInactiveBindingsForAction(action) {
                        const bindings = action._propertyBindings;
                        for (let i = 0, n = bindings.length; i !== n; ++i) {
                            const binding = bindings[i];
                            if (--binding.referenceCount === 0) {
                                this._removeInactiveBinding(binding)
                            }
                        }
                    }
                    _lendAction(action) {
                        const actions = this._actions,
                            prevIndex = action._cacheIndex,
                            lastActiveIndex = this._nActiveActions++,
                            firstInactiveAction = actions[lastActiveIndex];
                        action._cacheIndex = lastActiveIndex;
                        actions[lastActiveIndex] = action;
                        firstInactiveAction._cacheIndex = prevIndex;
                        actions[prevIndex] = firstInactiveAction
                    }
                    _takeBackAction(action) {
                        const actions = this._actions,
                            prevIndex = action._cacheIndex,
                            firstInactiveIndex = --this._nActiveActions,
                            lastActiveAction = actions[firstInactiveIndex];
                        action._cacheIndex = firstInactiveIndex;
                        actions[firstInactiveIndex] = action;
                        lastActiveAction._cacheIndex = prevIndex;
                        actions[prevIndex] = lastActiveAction
                    }
                    _addInactiveBinding(binding, rootUuid, trackName) {
                        const bindingsByRoot = this._bindingsByRootAndName,
                            bindings = this._bindings;
                        let bindingByName = bindingsByRoot[rootUuid];
                        if (bindingByName === undefined) {
                            bindingByName = {};
                            bindingsByRoot[rootUuid] = bindingByName
                        }
                        bindingByName[trackName] = binding;
                        binding._cacheIndex = bindings.length;
                        bindings.push(binding)
                    }
                    _removeInactiveBinding(binding) {
                        const bindings = this._bindings,
                            propBinding = binding.binding,
                            rootUuid = propBinding.rootNode.uuid,
                            trackName = propBinding.path,
                            bindingsByRoot = this._bindingsByRootAndName,
                            bindingByName = bindingsByRoot[rootUuid],
                            lastInactiveBinding = bindings[bindings.length - 1],
                            cacheIndex = binding._cacheIndex;
                        lastInactiveBinding._cacheIndex = cacheIndex;
                        bindings[cacheIndex] = lastInactiveBinding;
                        bindings.pop();
                        delete bindingByName[trackName];
                        if (Object.keys(bindingByName).length === 0) {
                            delete bindingsByRoot[rootUuid]
                        }
                    }
                    _lendBinding(binding) {
                        const bindings = this._bindings,
                            prevIndex = binding._cacheIndex,
                            lastActiveIndex = this._nActiveBindings++,
                            firstInactiveBinding = bindings[lastActiveIndex];
                        binding._cacheIndex = lastActiveIndex;
                        bindings[lastActiveIndex] = binding;
                        firstInactiveBinding._cacheIndex = prevIndex;
                        bindings[prevIndex] = firstInactiveBinding
                    }
                    _takeBackBinding(binding) {
                        const bindings = this._bindings,
                            prevIndex = binding._cacheIndex,
                            firstInactiveIndex = --this._nActiveBindings,
                            lastActiveBinding = bindings[firstInactiveIndex];
                        binding._cacheIndex = firstInactiveIndex;
                        bindings[firstInactiveIndex] = binding;
                        lastActiveBinding._cacheIndex = prevIndex;
                        bindings[prevIndex] = lastActiveBinding
                    }
                    _lendControlInterpolant() {
                        const interpolants = this._controlInterpolants,
                            lastActiveIndex = this._nActiveControlInterpolants++;
                        let interpolant = interpolants[lastActiveIndex];
                        if (interpolant === undefined) {
                            interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);
                            interpolant.__cacheIndex = lastActiveIndex;
                            interpolants[lastActiveIndex] = interpolant
                        }
                        return interpolant
                    }
                    _takeBackControlInterpolant(interpolant) {
                        const interpolants = this._controlInterpolants,
                            prevIndex = interpolant.__cacheIndex,
                            firstInactiveIndex = --this._nActiveControlInterpolants,
                            lastActiveInterpolant = interpolants[firstInactiveIndex];
                        interpolant.__cacheIndex = firstInactiveIndex;
                        interpolants[firstInactiveIndex] = interpolant;
                        lastActiveInterpolant.__cacheIndex = prevIndex;
                        interpolants[prevIndex] = lastActiveInterpolant
                    }
                    clipAction(clip, optionalRoot, blendMode) {
                        const root = optionalRoot || this._root,
                            rootUuid = root.uuid;
                        let clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
                        const clipUuid = clipObject !== null ? clipObject.uuid : clip;
                        const actionsForClip = this._actionsByClip[clipUuid];
                        let prototypeAction = null;
                        if (blendMode === undefined) {
                            if (clipObject !== null) {
                                blendMode = clipObject.blendMode
                            } else {
                                blendMode = NormalAnimationBlendMode
                            }
                        }
                        if (actionsForClip !== undefined) {
                            const existingAction = actionsForClip.actionByRoot[rootUuid];
                            if (existingAction !== undefined && existingAction.blendMode === blendMode) {
                                return existingAction
                            }
                            prototypeAction = actionsForClip.knownActions[0];
                            if (clipObject === null)
                                clipObject = prototypeAction._clip
                        }
                        if (clipObject === null) return null;
                        const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
                        this._bindAction(newAction, prototypeAction);
                        this._addInactiveAction(newAction, clipUuid, rootUuid);
                        return newAction
                    }
                    existingAction(clip, optionalRoot) {
                        const root = optionalRoot || this._root,
                            rootUuid = root.uuid,
                            clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
                            clipUuid = clipObject ? clipObject.uuid : clip,
                            actionsForClip = this._actionsByClip[clipUuid];
                        if (actionsForClip !== undefined) {
                            return actionsForClip.actionByRoot[rootUuid] || null
                        }
                        return null
                    }
                    stopAllAction() {
                        const actions = this._actions,
                            nActions = this._nActiveActions;
                        for (let i = nActions - 1; i >= 0; --i) {
                            actions[i].stop()
                        }
                        return this
                    }
                    update(deltaTime) {
                        deltaTime *= this.timeScale;
                        const actions = this._actions,
                            nActions = this._nActiveActions,
                            time = this.time += deltaTime,
                            timeDirection = Math.sign(deltaTime),
                            accuIndex = this._accuIndex ^= 1;
                        for (let i = 0; i !== nActions; ++i) {
                            const action = actions[i];
                            action._update(time, deltaTime, timeDirection, accuIndex)
                        }
                        const bindings = this._bindings,
                            nBindings = this._nActiveBindings;
                        for (let i = 0; i !== nBindings; ++i) {
                            bindings[i].apply(accuIndex)
                        }
                        return this
                    }
                    setTime(timeInSeconds) {
                        this.time = 0;
                        for (let i = 0; i < this._actions.length; i++) {
                            this._actions[i].time = 0
                        }
                        return this.update(timeInSeconds)
                    }
                    getRoot() {
                        return this._root
                    }
                    uncacheClip(clip) {
                        const actions = this._actions,
                            clipUuid = clip.uuid,
                            actionsByClip = this._actionsByClip,
                            actionsForClip = actionsByClip[clipUuid];
                        if (actionsForClip !== undefined) {
                            const actionsToRemove = actionsForClip.knownActions;
                            for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
                                const action = actionsToRemove[i];
                                this._deactivateAction(action);
                                const cacheIndex = action._cacheIndex,
                                    lastInactiveAction = actions[actions.length - 1];
                                action._cacheIndex = null;
                                action._byClipCacheIndex = null;
                                lastInactiveAction._cacheIndex = cacheIndex;
                                actions[cacheIndex] = lastInactiveAction;
                                actions.pop();
                                this._removeInactiveBindingsForAction(action)
                            }
                            delete actionsByClip[clipUuid]
                        }
                    }
                    uncacheRoot(root) {
                        const rootUuid = root.uuid,
                            actionsByClip = this._actionsByClip;
                        for (const clipUuid in actionsByClip) {
                            const actionByRoot = actionsByClip[clipUuid].actionByRoot,
                                action = actionByRoot[rootUuid];
                            if (action !== undefined) {
                                this._deactivateAction(action);
                                this._removeInactiveAction(action)
                            }
                        }
                        const bindingsByRoot = this._bindingsByRootAndName,
                            bindingByName = bindingsByRoot[rootUuid];
                        if (bindingByName !== undefined) {
                            for (const trackName in bindingByName) {
                                const binding = bindingByName[trackName];
                                binding.restoreOriginalState();
                                this._removeInactiveBinding(binding)
                            }
                        }
                    }
                    uncacheAction(clip, optionalRoot) {
                        const action = this.existingAction(clip, optionalRoot);
                        if (action !== null) {
                            this._deactivateAction(action);
                            this._removeInactiveAction(action)
                        }
                    }
                }
                class Uniform {
                    constructor(value) {
                        this.value = value
                    }
                    clone() {
                        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone())
                    }
                }
                let _id = 0;
                class UniformsGroup extends EventDispatcher {
                    constructor() {
                        super();
                        this.isUniformsGroup = !0;
                        Object.defineProperty(this, 'id', {
                            value: _id++
                        });
                        this.name = '';
                        this.usage = StaticDrawUsage;
                        this.uniforms = []
                    }
                    add(uniform) {
                        this.uniforms.push(uniform);
                        return this
                    }
                    remove(uniform) {
                        const index = this.uniforms.indexOf(uniform);
                        if (index !== -1) this.uniforms.splice(index, 1);
                        return this
                    }
                    setName(name) {
                        this.name = name;
                        return this
                    }
                    setUsage(value) {
                        this.usage = value;
                        return this
                    }
                    dispose() {
                        this.dispatchEvent({
                            type: 'dispose'
                        });
                        return this
                    }
                    copy(source) {
                        this.name = source.name;
                        this.usage = source.usage;
                        const uniformsSource = source.uniforms;
                        this.uniforms.length = 0;
                        for (let i = 0, l = uniformsSource.length; i < l; i++) {
                            const uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
                            for (let j = 0; j < uniforms.length; j++) {
                                this.uniforms.push(uniforms[j].clone())
                            }
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                class InstancedInterleavedBuffer extends InterleavedBuffer {
                    constructor(array, stride, meshPerAttribute = 1) {
                        super(array, stride);
                        this.isInstancedInterleavedBuffer = !0;
                        this.meshPerAttribute = meshPerAttribute
                    }
                    copy(source) {
                        super.copy(source);
                        this.meshPerAttribute = source.meshPerAttribute;
                        return this
                    }
                    clone(data) {
                        const ib = super.clone(data);
                        ib.meshPerAttribute = this.meshPerAttribute;
                        return ib
                    }
                    toJSON(data) {
                        const json = super.toJSON(data);
                        json.isInstancedInterleavedBuffer = !0;
                        json.meshPerAttribute = this.meshPerAttribute;
                        return json
                    }
                }
                class GLBufferAttribute {
                    constructor(buffer, type, itemSize, elementSize, count) {
                        this.isGLBufferAttribute = !0;
                        this.name = '';
                        this.buffer = buffer;
                        this.type = type;
                        this.itemSize = itemSize;
                        this.elementSize = elementSize;
                        this.count = count;
                        this.version = 0
                    }
                    set needsUpdate(value) {
                        if (value === !0) this.version++
                    }
                    setBuffer(buffer) {
                        this.buffer = buffer;
                        return this
                    }
                    setType(type, elementSize) {
                        this.type = type;
                        this.elementSize = elementSize;
                        return this
                    }
                    setItemSize(itemSize) {
                        this.itemSize = itemSize;
                        return this
                    }
                    setCount(count) {
                        this.count = count;
                        return this
                    }
                }
                const _matrix = new Matrix4();
                class Raycaster {
                    constructor(origin, direction, near = 0, far = Infinity) {
                        this.ray = new Ray(origin, direction);
                        this.near = near;
                        this.far = far;
                        this.camera = null;
                        this.layers = new Layers();
                        this.params = {
                            Mesh: {},
                            Line: {
                                threshold: 1
                            },
                            LOD: {},
                            Points: {
                                threshold: 1
                            },
                            Sprite: {}
                        }
                    }
                    set(origin, direction) {
                        this.ray.set(origin, direction)
                    }
                    setFromCamera(coords, camera) {
                        if (camera.isPerspectiveCamera) {
                            this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
                            this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
                            this.camera = camera
                        } else if (camera.isOrthographicCamera) {
                            this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
                            this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
                            this.camera = camera
                        } else {
                            console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type)
                        }
                    }
                    setFromXRController(controller) {
                        _matrix.identity().extractRotation(controller.matrixWorld);
                        this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
                        this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
                        return this
                    }
                    intersectObject(object, recursive = !0, intersects = []) {
                        intersect(object, this, intersects, recursive);
                        intersects.sort(ascSort);
                        return intersects
                    }
                    intersectObjects(objects, recursive = !0, intersects = []) {
                        for (let i = 0, l = objects.length; i < l; i++) {
                            intersect(objects[i], this, intersects, recursive)
                        }
                        intersects.sort(ascSort);
                        return intersects
                    }
                }

                function ascSort(a, b) {
                    return a.distance - b.distance
                }

                function intersect(object, raycaster, intersects, recursive) {
                    let propagate = !0;
                    if (object.layers.test(raycaster.layers)) {
                        const result = object.raycast(raycaster, intersects);
                        if (result === !1) propagate = !1
                    }
                    if (propagate === !0 && recursive === !0) {
                        const children = object.children;
                        for (let i = 0, l = children.length; i < l; i++) {
                            intersect(children[i], raycaster, intersects, !0)
                        }
                    }
                }
                class Spherical {
                    constructor(radius = 1, phi = 0, theta = 0) {
                        this.radius = radius;
                        this.phi = phi;
                        this.theta = theta;
                        return this
                    }
                    set(radius, phi, theta) {
                        this.radius = radius;
                        this.phi = phi;
                        this.theta = theta;
                        return this
                    }
                    copy(other) {
                        this.radius = other.radius;
                        this.phi = other.phi;
                        this.theta = other.theta;
                        return this
                    }
                    makeSafe() {
                        const EPS = 0.000001;
                        this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
                        return this
                    }
                    setFromVector3(v) {
                        return this.setFromCartesianCoords(v.x, v.y, v.z)
                    }
                    setFromCartesianCoords(x, y, z) {
                        this.radius = Math.sqrt(x * x + y * y + z * z);
                        if (this.radius === 0) {
                            this.theta = 0;
                            this.phi = 0
                        } else {
                            this.theta = Math.atan2(x, z);
                            this.phi = Math.acos(clamp(y / this.radius, -1, 1))
                        }
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                class Cylindrical {
                    constructor(radius = 1, theta = 0, y = 0) {
                        this.radius = radius;
                        this.theta = theta;
                        this.y = y;
                        return this
                    }
                    set(radius, theta, y) {
                        this.radius = radius;
                        this.theta = theta;
                        this.y = y;
                        return this
                    }
                    copy(other) {
                        this.radius = other.radius;
                        this.theta = other.theta;
                        this.y = other.y;
                        return this
                    }
                    setFromVector3(v) {
                        return this.setFromCartesianCoords(v.x, v.y, v.z)
                    }
                    setFromCartesianCoords(x, y, z) {
                        this.radius = Math.sqrt(x * x + z * z);
                        this.theta = Math.atan2(x, z);
                        this.y = y;
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                class Matrix2 {
                    constructor(n11, n12, n21, n22) {
                        Matrix2.prototype.isMatrix2 = !0;
                        this.elements = [1, 0, 0, 1, ];
                        if (n11 !== undefined) {
                            this.set(n11, n12, n21, n22)
                        }
                    }
                    identity() {
                        this.set(1, 0, 0, 1, );
                        return this
                    }
                    fromArray(array, offset = 0) {
                        for (let i = 0; i < 4; i++) {
                            this.elements[i] = array[i + offset]
                        }
                        return this
                    }
                    set(n11, n12, n21, n22) {
                        const te = this.elements;
                        te[0] = n11;
                        te[2] = n12;
                        te[1] = n21;
                        te[3] = n22;
                        return this
                    }
                }
                const _vector$4 = new Vector2();
                class Box2 {
                    constructor(min = new Vector2(+Infinity, +Infinity), max = new Vector2(-Infinity, -Infinity)) {
                        this.isBox2 = !0;
                        this.min = min;
                        this.max = max
                    }
                    set(min, max) {
                        this.min.copy(min);
                        this.max.copy(max);
                        return this
                    }
                    setFromPoints(points) {
                        this.makeEmpty();
                        for (let i = 0, il = points.length; i < il; i++) {
                            this.expandByPoint(points[i])
                        }
                        return this
                    }
                    setFromCenterAndSize(center, size) {
                        const halfSize = _vector$4.copy(size).multiplyScalar(0.5);
                        this.min.copy(center).sub(halfSize);
                        this.max.copy(center).add(halfSize);
                        return this
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                    copy(box) {
                        this.min.copy(box.min);
                        this.max.copy(box.max);
                        return this
                    }
                    makeEmpty() {
                        this.min.x = this.min.y = +Infinity;
                        this.max.x = this.max.y = -Infinity;
                        return this
                    }
                    isEmpty() {
                        return (this.max.x < this.min.x) || (this.max.y < this.min.y)
                    }
                    getCenter(target) {
                        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5)
                    }
                    getSize(target) {
                        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min)
                    }
                    expandByPoint(point) {
                        this.min.min(point);
                        this.max.max(point);
                        return this
                    }
                    expandByVector(vector) {
                        this.min.sub(vector);
                        this.max.add(vector);
                        return this
                    }
                    expandByScalar(scalar) {
                        this.min.addScalar(-scalar);
                        this.max.addScalar(scalar);
                        return this
                    }
                    containsPoint(point) {
                        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y
                    }
                    containsBox(box) {
                        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y
                    }
                    getParameter(point, target) {
                        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y))
                    }
                    intersectsBox(box) {
                        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y
                    }
                    clampPoint(point, target) {
                        return target.copy(point).clamp(this.min, this.max)
                    }
                    distanceToPoint(point) {
                        return this.clampPoint(point, _vector$4).distanceTo(point)
                    }
                    intersect(box) {
                        this.min.max(box.min);
                        this.max.min(box.max);
                        if (this.isEmpty()) this.makeEmpty();
                        return this
                    }
                    union(box) {
                        this.min.min(box.min);
                        this.max.max(box.max);
                        return this
                    }
                    translate(offset) {
                        this.min.add(offset);
                        this.max.add(offset);
                        return this
                    }
                    equals(box) {
                        return box.min.equals(this.min) && box.max.equals(this.max)
                    }
                }
                const _startP = new Vector3();
                const _startEnd = new Vector3();
                class Line3 {
                    constructor(start = new Vector3(), end = new Vector3()) {
                        this.start = start;
                        this.end = end
                    }
                    set(start, end) {
                        this.start.copy(start);
                        this.end.copy(end);
                        return this
                    }
                    copy(line) {
                        this.start.copy(line.start);
                        this.end.copy(line.end);
                        return this
                    }
                    getCenter(target) {
                        return target.addVectors(this.start, this.end).multiplyScalar(0.5)
                    }
                    delta(target) {
                        return target.subVectors(this.end, this.start)
                    }
                    distanceSq() {
                        return this.start.distanceToSquared(this.end)
                    }
                    distance() {
                        return this.start.distanceTo(this.end)
                    }
                    at(t, target) {
                        return this.delta(target).multiplyScalar(t).add(this.start)
                    }
                    closestPointToPointParameter(point, clampToLine) {
                        _startP.subVectors(point, this.start);
                        _startEnd.subVectors(this.end, this.start);
                        const startEnd2 = _startEnd.dot(_startEnd);
                        const startEnd_startP = _startEnd.dot(_startP);
                        let t = startEnd_startP / startEnd2;
                        if (clampToLine) {
                            t = clamp(t, 0, 1)
                        }
                        return t
                    }
                    closestPointToPoint(point, clampToLine, target) {
                        const t = this.closestPointToPointParameter(point, clampToLine);
                        return this.delta(target).multiplyScalar(t).add(this.start)
                    }
                    applyMatrix4(matrix) {
                        this.start.applyMatrix4(matrix);
                        this.end.applyMatrix4(matrix);
                        return this
                    }
                    equals(line) {
                        return line.start.equals(this.start) && line.end.equals(this.end)
                    }
                    clone() {
                        return new this.constructor().copy(this)
                    }
                }
                const _vector$3 = new Vector3();
                class SpotLightHelper extends Object3D {
                    constructor(light, color) {
                        super();
                        this.light = light;
                        this.matrixAutoUpdate = !1;
                        this.color = color;
                        this.type = 'SpotLightHelper';
                        const geometry = new BufferGeometry();
                        const positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
                        for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
                            const p1 = (i / l) * Math.PI * 2;
                            const p2 = (j / l) * Math.PI * 2;
                            positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1)
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        const material = new LineBasicMaterial({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.cone = new LineSegments(geometry, material);
                        this.add(this.cone);
                        this.update()
                    }
                    dispose() {
                        this.cone.geometry.dispose();
                        this.cone.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1);
                        this.light.target.updateWorldMatrix(!0, !1);
                        if (this.parent) {
                            this.parent.updateWorldMatrix(!0);
                            this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)
                        } else {
                            this.matrix.copy(this.light.matrixWorld)
                        }
                        this.matrixWorld.copy(this.light.matrixWorld);
                        const coneLength = this.light.distance ? this.light.distance : 1000;
                        const coneWidth = coneLength * Math.tan(this.light.angle);
                        this.cone.scale.set(coneWidth, coneWidth, coneLength);
                        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
                        this.cone.lookAt(_vector$3);
                        if (this.color !== undefined) {
                            this.cone.material.color.set(this.color)
                        } else {
                            this.cone.material.color.copy(this.light.color)
                        }
                    }
                }
                const _vector$2 = new Vector3();
                const _boneMatrix = new Matrix4();
                const _matrixWorldInv = new Matrix4();
                class SkeletonHelper extends LineSegments {
                    constructor(object) {
                        const bones = getBoneList(object);
                        const geometry = new BufferGeometry();
                        const vertices = [];
                        const colors = [];
                        const color1 = new Color(0, 0, 1);
                        const color2 = new Color(0, 1, 0);
                        for (let i = 0; i < bones.length; i++) {
                            const bone = bones[i];
                            if (bone.parent && bone.parent.isBone) {
                                vertices.push(0, 0, 0);
                                vertices.push(0, 0, 0);
                                colors.push(color1.r, color1.g, color1.b);
                                colors.push(color2.r, color2.g, color2.b)
                            }
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        const material = new LineBasicMaterial({
                            vertexColors: !0,
                            depthTest: !1,
                            depthWrite: !1,
                            toneMapped: !1,
                            transparent: !0
                        });
                        super(geometry, material);
                        this.isSkeletonHelper = !0;
                        this.type = 'SkeletonHelper';
                        this.root = object;
                        this.bones = bones;
                        this.matrix = object.matrixWorld;
                        this.matrixAutoUpdate = !1
                    }
                    updateMatrixWorld(force) {
                        const bones = this.bones;
                        const geometry = this.geometry;
                        const position = geometry.getAttribute('position');
                        _matrixWorldInv.copy(this.root.matrixWorld).invert();
                        for (let i = 0, j = 0; i < bones.length; i++) {
                            const bone = bones[i];
                            if (bone.parent && bone.parent.isBone) {
                                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
                                _vector$2.setFromMatrixPosition(_boneMatrix);
                                position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
                                _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
                                _vector$2.setFromMatrixPosition(_boneMatrix);
                                position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
                                j += 2
                            }
                        }
                        geometry.getAttribute('position').needsUpdate = !0;
                        super.updateMatrixWorld(force)
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }

                function getBoneList(object) {
                    const boneList = [];
                    if (object.isBone === !0) {
                        boneList.push(object)
                    }
                    for (let i = 0; i < object.children.length; i++) {
                        boneList.push.apply(boneList, getBoneList(object.children[i]))
                    }
                    return boneList
                }
                class PointLightHelper extends Mesh {
                    constructor(light, sphereSize, color) {
                        const geometry = new SphereGeometry(sphereSize, 4, 2);
                        const material = new MeshBasicMaterial({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        super(geometry, material);
                        this.light = light;
                        this.color = color;
                        this.type = 'PointLightHelper';
                        this.matrix = this.light.matrixWorld;
                        this.matrixAutoUpdate = !1;
                        this.update()
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1);
                        if (this.color !== undefined) {
                            this.material.color.set(this.color)
                        } else {
                            this.material.color.copy(this.light.color)
                        }
                    }
                }
                const _vector$1 = new Vector3();
                const _color1 = new Color();
                const _color2 = new Color();
                class HemisphereLightHelper extends Object3D {
                    constructor(light, size, color) {
                        super();
                        this.light = light;
                        this.matrix = light.matrixWorld;
                        this.matrixAutoUpdate = !1;
                        this.color = color;
                        this.type = 'HemisphereLightHelper';
                        const geometry = new OctahedronGeometry(size);
                        geometry.rotateY(Math.PI * 0.5);
                        this.material = new MeshBasicMaterial({
                            wireframe: !0,
                            fog: !1,
                            toneMapped: !1
                        });
                        if (this.color === undefined) this.material.vertexColors = !0;
                        const position = geometry.getAttribute('position');
                        const colors = new Float32Array(position.count * 3);
                        geometry.setAttribute('color', new BufferAttribute(colors, 3));
                        this.add(new Mesh(geometry, this.material));
                        this.update()
                    }
                    dispose() {
                        this.children[0].geometry.dispose();
                        this.children[0].material.dispose()
                    }
                    update() {
                        const mesh = this.children[0];
                        if (this.color !== undefined) {
                            this.material.color.set(this.color)
                        } else {
                            const colors = mesh.geometry.getAttribute('color');
                            _color1.copy(this.light.color);
                            _color2.copy(this.light.groundColor);
                            for (let i = 0, l = colors.count; i < l; i++) {
                                const color = (i < (l / 2)) ? _color1 : _color2;
                                colors.setXYZ(i, color.r, color.g, color.b)
                            }
                            colors.needsUpdate = !0
                        }
                        this.light.updateWorldMatrix(!0, !1);
                        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())
                    }
                }
                class GridHelper extends LineSegments {
                    constructor(size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888) {
                        color1 = new Color(color1);
                        color2 = new Color(color2);
                        const center = divisions / 2;
                        const step = size / divisions;
                        const halfSize = size / 2;
                        const vertices = [],
                            colors = [];
                        for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
                            vertices.push(-halfSize, 0, k, halfSize, 0, k);
                            vertices.push(k, 0, -halfSize, k, 0, halfSize);
                            const color = i === center ? color1 : color2;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3;
                            color.toArray(colors, j);
                            j += 3
                        }
                        const geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        const material = new LineBasicMaterial({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(geometry, material);
                        this.type = 'GridHelper'
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }
                class PolarGridHelper extends LineSegments {
                    constructor(radius = 10, sectors = 16, rings = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888) {
                        color1 = new Color(color1);
                        color2 = new Color(color2);
                        const vertices = [];
                        const colors = [];
                        if (sectors > 1) {
                            for (let i = 0; i < sectors; i++) {
                                const v = (i / sectors) * (Math.PI * 2);
                                const x = Math.sin(v) * radius;
                                const z = Math.cos(v) * radius;
                                vertices.push(0, 0, 0);
                                vertices.push(x, 0, z);
                                const color = (i & 1) ? color1 : color2;
                                colors.push(color.r, color.g, color.b);
                                colors.push(color.r, color.g, color.b)
                            }
                        }
                        for (let i = 0; i < rings; i++) {
                            const color = (i & 1) ? color1 : color2;
                            const r = radius - (radius / rings * i);
                            for (let j = 0; j < divisions; j++) {
                                let v = (j / divisions) * (Math.PI * 2);
                                let x = Math.sin(v) * r;
                                let z = Math.cos(v) * r;
                                vertices.push(x, 0, z);
                                colors.push(color.r, color.g, color.b);
                                v = ((j + 1) / divisions) * (Math.PI * 2);
                                x = Math.sin(v) * r;
                                z = Math.cos(v) * r;
                                vertices.push(x, 0, z);
                                colors.push(color.r, color.g, color.b)
                            }
                        }
                        const geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        const material = new LineBasicMaterial({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(geometry, material);
                        this.type = 'PolarGridHelper'
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }
                const _v1 = new Vector3();
                const _v2 = new Vector3();
                const _v3 = new Vector3();
                class DirectionalLightHelper extends Object3D {
                    constructor(light, size, color) {
                        super();
                        this.light = light;
                        this.matrix = light.matrixWorld;
                        this.matrixAutoUpdate = !1;
                        this.color = color;
                        this.type = 'DirectionalLightHelper';
                        if (size === undefined) size = 1;
                        let geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
                        const material = new LineBasicMaterial({
                            fog: !1,
                            toneMapped: !1
                        });
                        this.lightPlane = new Line(geometry, material);
                        this.add(this.lightPlane);
                        geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
                        this.targetLine = new Line(geometry, material);
                        this.add(this.targetLine);
                        this.update()
                    }
                    dispose() {
                        this.lightPlane.geometry.dispose();
                        this.lightPlane.material.dispose();
                        this.targetLine.geometry.dispose();
                        this.targetLine.material.dispose()
                    }
                    update() {
                        this.light.updateWorldMatrix(!0, !1);
                        this.light.target.updateWorldMatrix(!0, !1);
                        _v1.setFromMatrixPosition(this.light.matrixWorld);
                        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
                        _v3.subVectors(_v2, _v1);
                        this.lightPlane.lookAt(_v2);
                        if (this.color !== undefined) {
                            this.lightPlane.material.color.set(this.color);
                            this.targetLine.material.color.set(this.color)
                        } else {
                            this.lightPlane.material.color.copy(this.light.color);
                            this.targetLine.material.color.copy(this.light.color)
                        }
                        this.targetLine.lookAt(_v2);
                        this.targetLine.scale.z = _v3.length()
                    }
                }
                const _vector = new Vector3();
                const _camera = new Camera();
                class CameraHelper extends LineSegments {
                    constructor(camera) {
                        const geometry = new BufferGeometry();
                        const material = new LineBasicMaterial({
                            color: 0xffffff,
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        const vertices = [];
                        const colors = [];
                        const pointMap = {};
                        addLine('n1', 'n2');
                        addLine('n2', 'n4');
                        addLine('n4', 'n3');
                        addLine('n3', 'n1');
                        addLine('f1', 'f2');
                        addLine('f2', 'f4');
                        addLine('f4', 'f3');
                        addLine('f3', 'f1');
                        addLine('n1', 'f1');
                        addLine('n2', 'f2');
                        addLine('n3', 'f3');
                        addLine('n4', 'f4');
                        addLine('p', 'n1');
                        addLine('p', 'n2');
                        addLine('p', 'n3');
                        addLine('p', 'n4');
                        addLine('u1', 'u2');
                        addLine('u2', 'u3');
                        addLine('u3', 'u1');
                        addLine('c', 't');
                        addLine('p', 'c');
                        addLine('cn1', 'cn2');
                        addLine('cn3', 'cn4');
                        addLine('cf1', 'cf2');
                        addLine('cf3', 'cf4');

                        function addLine(a, b) {
                            addPoint(a);
                            addPoint(b)
                        }

                        function addPoint(id) {
                            vertices.push(0, 0, 0);
                            colors.push(0, 0, 0);
                            if (pointMap[id] === undefined) {
                                pointMap[id] = []
                            }
                            pointMap[id].push((vertices.length / 3) - 1)
                        }
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        super(geometry, material);
                        this.type = 'CameraHelper';
                        this.camera = camera;
                        if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
                        this.matrix = camera.matrixWorld;
                        this.matrixAutoUpdate = !1;
                        this.pointMap = pointMap;
                        this.update();
                        const colorFrustum = new Color(0xffaa00);
                        const colorCone = new Color(0xff0000);
                        const colorUp = new Color(0x00aaff);
                        const colorTarget = new Color(0xffffff);
                        const colorCross = new Color(0x333333);
                        this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross)
                    }
                    setColors(frustum, cone, up, target, cross) {
                        const geometry = this.geometry;
                        const colorAttribute = geometry.getAttribute('color');
                        colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b);
                        colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(25, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(27, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(29, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(31, cone.r, cone.g, cone.b);
                        colorAttribute.setXYZ(32, up.r, up.g, up.b);
                        colorAttribute.setXYZ(33, up.r, up.g, up.b);
                        colorAttribute.setXYZ(34, up.r, up.g, up.b);
                        colorAttribute.setXYZ(35, up.r, up.g, up.b);
                        colorAttribute.setXYZ(36, up.r, up.g, up.b);
                        colorAttribute.setXYZ(37, up.r, up.g, up.b);
                        colorAttribute.setXYZ(38, target.r, target.g, target.b);
                        colorAttribute.setXYZ(39, target.r, target.g, target.b);
                        colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(41, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(43, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(45, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(47, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
                        colorAttribute.setXYZ(49, cross.r, cross.g, cross.b);
                        colorAttribute.needsUpdate = !0
                    }
                    update() {
                        const geometry = this.geometry;
                        const pointMap = this.pointMap;
                        const w = 1,
                            h = 1;
                        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
                        setPoint('c', pointMap, geometry, _camera, 0, 0, -1);
                        setPoint('t', pointMap, geometry, _camera, 0, 0, 1);
                        setPoint('n1', pointMap, geometry, _camera, -w, -h, -1);
                        setPoint('n2', pointMap, geometry, _camera, w, -h, -1);
                        setPoint('n3', pointMap, geometry, _camera, -w, h, -1);
                        setPoint('n4', pointMap, geometry, _camera, w, h, -1);
                        setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
                        setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
                        setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
                        setPoint('f4', pointMap, geometry, _camera, w, h, 1);
                        setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
                        setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
                        setPoint('u3', pointMap, geometry, _camera, 0, h * 2, -1);
                        setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
                        setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
                        setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
                        setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
                        setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1);
                        setPoint('cn2', pointMap, geometry, _camera, w, 0, -1);
                        setPoint('cn3', pointMap, geometry, _camera, 0, -h, -1);
                        setPoint('cn4', pointMap, geometry, _camera, 0, h, -1);
                        geometry.getAttribute('position').needsUpdate = !0
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }

                function setPoint(point, pointMap, geometry, camera, x, y, z) {
                    _vector.set(x, y, z).unproject(camera);
                    const points = pointMap[point];
                    if (points !== undefined) {
                        const position = geometry.getAttribute('position');
                        for (let i = 0, l = points.length; i < l; i++) {
                            position.setXYZ(points[i], _vector.x, _vector.y, _vector.z)
                        }
                    }
                }
                const _box = new Box3();
                class BoxHelper extends LineSegments {
                    constructor(object, color = 0xffff00) {
                        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                        const positions = new Float32Array(8 * 3);
                        const geometry = new BufferGeometry();
                        geometry.setIndex(new BufferAttribute(indices, 1));
                        geometry.setAttribute('position', new BufferAttribute(positions, 3));
                        super(geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: !1
                        }));
                        this.object = object;
                        this.type = 'BoxHelper';
                        this.matrixAutoUpdate = !1;
                        this.update()
                    }
                    update(object) {
                        if (object !== undefined) {
                            console.warn('THREE.BoxHelper: .update() has no longer arguments.')
                        }
                        if (this.object !== undefined) {
                            _box.setFromObject(this.object)
                        }
                        if (_box.isEmpty()) return;
                        const min = _box.min;
                        const max = _box.max;
                        const position = this.geometry.attributes.position;
                        const array = position.array;
                        array[0] = max.x;
                        array[1] = max.y;
                        array[2] = max.z;
                        array[3] = min.x;
                        array[4] = max.y;
                        array[5] = max.z;
                        array[6] = min.x;
                        array[7] = min.y;
                        array[8] = max.z;
                        array[9] = max.x;
                        array[10] = min.y;
                        array[11] = max.z;
                        array[12] = max.x;
                        array[13] = max.y;
                        array[14] = min.z;
                        array[15] = min.x;
                        array[16] = max.y;
                        array[17] = min.z;
                        array[18] = min.x;
                        array[19] = min.y;
                        array[20] = min.z;
                        array[21] = max.x;
                        array[22] = min.y;
                        array[23] = min.z;
                        position.needsUpdate = !0;
                        this.geometry.computeBoundingSphere()
                    }
                    setFromObject(object) {
                        this.object = object;
                        this.update();
                        return this
                    }
                    copy(source, recursive) {
                        super.copy(source, recursive);
                        this.object = source.object;
                        return this
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }
                class Box3Helper extends LineSegments {
                    constructor(box, color = 0xffff00) {
                        const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
                        const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
                        const geometry = new BufferGeometry();
                        geometry.setIndex(new BufferAttribute(indices, 1));
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        super(geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: !1
                        }));
                        this.box = box;
                        this.type = 'Box3Helper';
                        this.geometry.computeBoundingSphere()
                    }
                    updateMatrixWorld(force) {
                        const box = this.box;
                        if (box.isEmpty()) return;
                        box.getCenter(this.position);
                        box.getSize(this.scale);
                        this.scale.multiplyScalar(0.5);
                        super.updateMatrixWorld(force)
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }
                class PlaneHelper extends Line {
                    constructor(plane, size = 1, hex = 0xffff00) {
                        const color = hex;
                        const positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
                        const geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
                        geometry.computeBoundingSphere();
                        super(geometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: !1
                        }));
                        this.type = 'PlaneHelper';
                        this.plane = plane;
                        this.size = size;
                        const positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
                        const geometry2 = new BufferGeometry();
                        geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
                        geometry2.computeBoundingSphere();
                        this.add(new Mesh(geometry2, new MeshBasicMaterial({
                            color: color,
                            opacity: 0.2,
                            transparent: !0,
                            depthWrite: !1,
                            toneMapped: !1
                        })))
                    }
                    updateMatrixWorld(force) {
                        this.position.set(0, 0, 0);
                        this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
                        this.lookAt(this.plane.normal);
                        this.translateZ(-this.plane.constant);
                        super.updateMatrixWorld(force)
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose();
                        this.children[0].geometry.dispose();
                        this.children[0].material.dispose()
                    }
                }
                const _axis = new Vector3();
                let _lineGeometry, _coneGeometry;
                class ArrowHelper extends Object3D {
                    constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2) {
                        super();
                        this.type = 'ArrowHelper';
                        if (_lineGeometry === undefined) {
                            _lineGeometry = new BufferGeometry();
                            _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
                            _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
                            _coneGeometry.translate(0, -0.5, 0)
                        }
                        this.position.copy(origin);
                        this.line = new Line(_lineGeometry, new LineBasicMaterial({
                            color: color,
                            toneMapped: !1
                        }));
                        this.line.matrixAutoUpdate = !1;
                        this.add(this.line);
                        this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
                            color: color,
                            toneMapped: !1
                        }));
                        this.cone.matrixAutoUpdate = !1;
                        this.add(this.cone);
                        this.setDirection(dir);
                        this.setLength(length, headLength, headWidth)
                    }
                    setDirection(dir) {
                        if (dir.y > 0.99999) {
                            this.quaternion.set(0, 0, 0, 1)
                        } else if (dir.y < -0.99999) {
                            this.quaternion.set(1, 0, 0, 0)
                        } else {
                            _axis.set(dir.z, 0, -dir.x).normalize();
                            const radians = Math.acos(dir.y);
                            this.quaternion.setFromAxisAngle(_axis, radians)
                        }
                    }
                    setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
                        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1);
                        this.line.updateMatrix();
                        this.cone.scale.set(headWidth, headLength, headWidth);
                        this.cone.position.y = length;
                        this.cone.updateMatrix()
                    }
                    setColor(color) {
                        this.line.material.color.set(color);
                        this.cone.material.color.set(color)
                    }
                    copy(source) {
                        super.copy(source, !1);
                        this.line.copy(source.line);
                        this.cone.copy(source.cone);
                        return this
                    }
                    dispose() {
                        this.line.geometry.dispose();
                        this.line.material.dispose();
                        this.cone.geometry.dispose();
                        this.cone.material.dispose()
                    }
                }
                class AxesHelper extends LineSegments {
                    constructor(size = 1) {
                        const vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
                        const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
                        const geometry = new BufferGeometry();
                        geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
                        geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
                        const material = new LineBasicMaterial({
                            vertexColors: !0,
                            toneMapped: !1
                        });
                        super(geometry, material);
                        this.type = 'AxesHelper'
                    }
                    setColors(xAxisColor, yAxisColor, zAxisColor) {
                        const color = new Color();
                        const array = this.geometry.attributes.color.array;
                        color.set(xAxisColor);
                        color.toArray(array, 0);
                        color.toArray(array, 3);
                        color.set(yAxisColor);
                        color.toArray(array, 6);
                        color.toArray(array, 9);
                        color.set(zAxisColor);
                        color.toArray(array, 12);
                        color.toArray(array, 15);
                        this.geometry.attributes.color.needsUpdate = !0;
                        return this
                    }
                    dispose() {
                        this.geometry.dispose();
                        this.material.dispose()
                    }
                }
                class ShapePath {
                    constructor() {
                        this.type = 'ShapePath';
                        this.color = new Color();
                        this.subPaths = [];
                        this.currentPath = null
                    }
                    moveTo(x, y) {
                        this.currentPath = new Path();
                        this.subPaths.push(this.currentPath);
                        this.currentPath.moveTo(x, y);
                        return this
                    }
                    lineTo(x, y) {
                        this.currentPath.lineTo(x, y);
                        return this
                    }
                    quadraticCurveTo(aCPx, aCPy, aX, aY) {
                        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
                        return this
                    }
                    bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
                        return this
                    }
                    splineThru(pts) {
                        this.currentPath.splineThru(pts);
                        return this
                    }
                    toShapes(isCCW) {
                        function toShapesNoHoles(inSubpaths) {
                            const shapes = [];
                            for (let i = 0, l = inSubpaths.length; i < l; i++) {
                                const tmpPath = inSubpaths[i];
                                const tmpShape = new Shape();
                                tmpShape.curves = tmpPath.curves;
                                shapes.push(tmpShape)
                            }
                            return shapes
                        }

                        function isPointInsidePolygon(inPt, inPolygon) {
                            const polyLen = inPolygon.length;
                            let inside = !1;
                            for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {
                                let edgeLowPt = inPolygon[p];
                                let edgeHighPt = inPolygon[q];
                                let edgeDx = edgeHighPt.x - edgeLowPt.x;
                                let edgeDy = edgeHighPt.y - edgeLowPt.y;
                                if (Math.abs(edgeDy) > Number.EPSILON) {
                                    if (edgeDy < 0) {
                                        edgeLowPt = inPolygon[q];
                                        edgeDx = -edgeDx;
                                        edgeHighPt = inPolygon[p];
                                        edgeDy = -edgeDy
                                    }
                                    if ((inPt.y < edgeLowPt.y) || (inPt.y > edgeHighPt.y)) continue;
                                    if (inPt.y === edgeLowPt.y) {
                                        if (inPt.x === edgeLowPt.x) return !0
                                    } else {
                                        const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                                        if (perpEdge === 0) return !0;
                                        if (perpEdge < 0) continue;
                                        inside = !inside
                                    }
                                } else {
                                    if (inPt.y !== edgeLowPt.y) continue;
                                    if (((edgeHighPt.x <= inPt.x) && (inPt.x <= edgeLowPt.x)) || ((edgeLowPt.x <= inPt.x) && (inPt.x <= edgeHighPt.x))) return !0
                                }
                            }
                            return inside
                        }
                        const isClockWise = ShapeUtils.isClockWise;
                        const subPaths = this.subPaths;
                        if (subPaths.length === 0) return [];
                        let solid, tmpPath, tmpShape;
                        const shapes = [];
                        if (subPaths.length === 1) {
                            tmpPath = subPaths[0];
                            tmpShape = new Shape();
                            tmpShape.curves = tmpPath.curves;
                            shapes.push(tmpShape);
                            return shapes
                        }
                        let holesFirst = !isClockWise(subPaths[0].getPoints());
                        holesFirst = isCCW ? !holesFirst : holesFirst;
                        const betterShapeHoles = [];
                        const newShapes = [];
                        let newShapeHoles = [];
                        let mainIdx = 0;
                        let tmpPoints;
                        newShapes[mainIdx] = undefined;
                        newShapeHoles[mainIdx] = [];
                        for (let i = 0, l = subPaths.length; i < l; i++) {
                            tmpPath = subPaths[i];
                            tmpPoints = tmpPath.getPoints();
                            solid = isClockWise(tmpPoints);
                            solid = isCCW ? !solid : solid;
                            if (solid) {
                                if ((!holesFirst) && (newShapes[mainIdx])) mainIdx++;
                                newShapes[mainIdx] = {
                                    s: new Shape(),
                                    p: tmpPoints
                                };
                                newShapes[mainIdx].s.curves = tmpPath.curves;
                                if (holesFirst) mainIdx++;
                                newShapeHoles[mainIdx] = []
                            } else {
                                newShapeHoles[mainIdx].push({
                                    h: tmpPath,
                                    p: tmpPoints[0]
                                })
                            }
                        }
                        if (!newShapes[0]) return toShapesNoHoles(subPaths);
                        if (newShapes.length > 1) {
                            let ambiguous = !1;
                            let toChange = 0;
                            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                                betterShapeHoles[sIdx] = []
                            }
                            for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
                                const sho = newShapeHoles[sIdx];
                                for (let hIdx = 0; hIdx < sho.length; hIdx++) {
                                    const ho = sho[hIdx];
                                    let hole_unassigned = !0;
                                    for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                                        if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                                            if (sIdx !== s2Idx) toChange++;
                                            if (hole_unassigned) {
                                                hole_unassigned = !1;
                                                betterShapeHoles[s2Idx].push(ho)
                                            } else {
                                                ambiguous = !0
                                            }
                                        }
                                    }
                                    if (hole_unassigned) {
                                        betterShapeHoles[sIdx].push(ho)
                                    }
                                }
                            }
                            if (toChange > 0 && ambiguous === !1) {
                                newShapeHoles = betterShapeHoles
                            }
                        }
                        let tmpHoles;
                        for (let i = 0, il = newShapes.length; i < il; i++) {
                            tmpShape = newShapes[i].s;
                            shapes.push(tmpShape);
                            tmpHoles = newShapeHoles[i];
                            for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
                                tmpShape.holes.push(tmpHoles[j].h)
                            }
                        }
                        return shapes
                    }
                }
                class WebGLMultipleRenderTargets extends WebGLRenderTarget {
                    constructor(width = 1, height = 1, count = 1, options = {}) {
                        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.');
                        super(width, height, { ...options,
                            count
                        });
                        this.isWebGLMultipleRenderTargets = !0
                    }
                    get texture() {
                        return this.textures
                    }
                }
                if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
                    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
                        detail: {
                            revision: REVISION,
                        }
                    }))
                }
                if (typeof window !== 'undefined') {
                    if (window.__THREE__) {
                        console.warn('WARNING: Multiple instances of Three.js being imported.')
                    } else {
                        window.__THREE__ = REVISION
                    }
                }
            }),
        "./node_modules/three/examples/jsm/loaders/DRACOLoader.js":
            /*!****************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/DRACOLoader.js ***!
              \****************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    DRACOLoader: () => (DRACOLoader)
                });
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                const _taskCache = new WeakMap();
                class DRACOLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
                    constructor(manager) {
                        super(manager);
                        this.decoderPath = '';
                        this.decoderConfig = {};
                        this.decoderBinary = null;
                        this.decoderPending = null;
                        this.workerLimit = 4;
                        this.workerPool = [];
                        this.workerNextTaskID = 1;
                        this.workerSourceURL = '';
                        this.defaultAttributeIDs = {
                            position: 'POSITION',
                            normal: 'NORMAL',
                            color: 'COLOR',
                            uv: 'TEX_COORD'
                        };
                        this.defaultAttributeTypes = {
                            position: 'Float32Array',
                            normal: 'Float32Array',
                            color: 'Float32Array',
                            uv: 'Float32Array'
                        }
                    }
                    setDecoderPath(path) {
                        this.decoderPath = path;
                        return this
                    }
                    setDecoderConfig(config) {
                        this.decoderConfig = config;
                        return this
                    }
                    setWorkerLimit(workerLimit) {
                        this.workerLimit = workerLimit;
                        return this
                    }
                    load(url, onLoad, onProgress, onError) {
                        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, (buffer) => {
                            this.parse(buffer, onLoad, onError)
                        }, onProgress, onError)
                    }
                    parse(buffer, onLoad, onError = () => {}) {
                        this.decodeDracoFile(buffer, onLoad, null, null, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace, onError).catch(onError)
                    }
                    decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace, onError = () => {}) {
                        const taskConfig = {
                            attributeIDs: attributeIDs || this.defaultAttributeIDs,
                            attributeTypes: attributeTypes || this.defaultAttributeTypes,
                            useUniqueIDs: !!attributeIDs,
                            vertexColorSpace: vertexColorSpace,
                        };
                        return this.decodeGeometry(buffer, taskConfig).then(callback).catch(onError)
                    }
                    decodeGeometry(buffer, taskConfig) {
                        const taskKey = JSON.stringify(taskConfig);
                        if (_taskCache.has(buffer)) {
                            const cachedTask = _taskCache.get(buffer);
                            if (cachedTask.key === taskKey) {
                                return cachedTask.promise
                            } else if (buffer.byteLength === 0) {
                                throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.')
                            }
                        }
                        let worker;
                        const taskID = this.workerNextTaskID++;
                        const taskCost = buffer.byteLength;
                        const geometryPending = this._getWorker(taskID, taskCost).then((_worker) => {
                            worker = _worker;
                            return new Promise((resolve, reject) => {
                                worker._callbacks[taskID] = {
                                    resolve,
                                    reject
                                };
                                worker.postMessage({
                                    type: 'decode',
                                    id: taskID,
                                    taskConfig,
                                    buffer
                                }, [buffer])
                            })
                        }).then((message) => this._createGeometry(message.geometry));
                        geometryPending.catch(() => !0).then(() => {
                            if (worker && taskID) {
                                this._releaseTask(worker, taskID)
                            }
                        });
                        _taskCache.set(buffer, {
                            key: taskKey,
                            promise: geometryPending
                        });
                        return geometryPending
                    }
                    _createGeometry(geometryData) {
                        const geometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                        if (geometryData.index) {
                            geometry.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(geometryData.index.array, 1))
                        }
                        for (let i = 0; i < geometryData.attributes.length; i++) {
                            const result = geometryData.attributes[i];
                            const name = result.name;
                            const array = result.array;
                            const itemSize = result.itemSize;
                            const attribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize);
                            if (name === 'color') {
                                this._assignVertexColorSpace(attribute, result.vertexColorSpace);
                                attribute.normalized = (array instanceof Float32Array) === !1
                            }
                            geometry.setAttribute(name, attribute)
                        }
                        return geometry
                    }
                    _assignVertexColorSpace(attribute, inputColorSpace) {
                        if (inputColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace) return;
                        const _color = new three__WEBPACK_IMPORTED_MODULE_0__.Color();
                        for (let i = 0, il = attribute.count; i < il; i++) {
                            _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();
                            attribute.setXYZ(i, _color.r, _color.g, _color.b)
                        }
                    }
                    _loadLibrary(url, responseType) {
                        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                        loader.setPath(this.decoderPath);
                        loader.setResponseType(responseType);
                        loader.setWithCredentials(this.withCredentials);
                        return new Promise((resolve, reject) => {
                            loader.load(url, resolve, undefined, reject)
                        })
                    }
                    preload() {
                        this._initDecoder();
                        return this
                    }
                    _initDecoder() {
                        if (this.decoderPending) return this.decoderPending;
                        const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
                        const librariesPending = [];
                        if (useJS) {
                            librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))
                        } else {
                            librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));
                            librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'))
                        }
                        this.decoderPending = Promise.all(librariesPending).then((libraries) => {
                            const jsContent = libraries[0];
                            if (!useJS) {
                                this.decoderConfig.wasmBinary = libraries[1]
                            }
                            const fn = DRACOWorker.toString();
                            const body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\n');
                            this.workerSourceURL = URL.createObjectURL(new Blob([body]))
                        });
                        return this.decoderPending
                    }
                    _getWorker(taskID, taskCost) {
                        return this._initDecoder().then(() => {
                            if (this.workerPool.length < this.workerLimit) {
                                const worker = new Worker(this.workerSourceURL);
                                worker._callbacks = {};
                                worker._taskCosts = {};
                                worker._taskLoad = 0;
                                worker.postMessage({
                                    type: 'init',
                                    decoderConfig: this.decoderConfig
                                });
                                worker.onmessage = function(e) {
                                    const message = e.data;
                                    switch (message.type) {
                                        case 'decode':
                                            worker._callbacks[message.id].resolve(message);
                                            break;
                                        case 'error':
                                            worker._callbacks[message.id].reject(message);
                                            break;
                                        default:
                                            console.error('THREE.DRACOLoader: Unexpected message, "' + message.type + '"')
                                    }
                                };
                                this.workerPool.push(worker)
                            } else {
                                this.workerPool.sort(function(a, b) {
                                    return a._taskLoad > b._taskLoad ? -1 : 1
                                })
                            }
                            const worker = this.workerPool[this.workerPool.length - 1];
                            worker._taskCosts[taskID] = taskCost;
                            worker._taskLoad += taskCost;
                            return worker
                        })
                    }
                    _releaseTask(worker, taskID) {
                        worker._taskLoad -= worker._taskCosts[taskID];
                        delete worker._callbacks[taskID];
                        delete worker._taskCosts[taskID]
                    }
                    debug() {
                        console.log('Task load: ', this.workerPool.map((worker) => worker._taskLoad))
                    }
                    dispose() {
                        for (let i = 0; i < this.workerPool.length; ++i) {
                            this.workerPool[i].terminate()
                        }
                        this.workerPool.length = 0;
                        if (this.workerSourceURL !== '') {
                            URL.revokeObjectURL(this.workerSourceURL)
                        }
                        return this
                    }
                }

                function DRACOWorker() {
                    let decoderConfig;
                    let decoderPending;
                    onmessage = function(e) {
                        const message = e.data;
                        switch (message.type) {
                            case 'init':
                                decoderConfig = message.decoderConfig;
                                decoderPending = new Promise(function(resolve) {
                                    decoderConfig.onModuleLoaded = function(draco) {
                                        resolve({
                                            draco: draco
                                        })
                                    };
                                    DracoDecoderModule(decoderConfig)
                                });
                                break;
                            case 'decode':
                                const buffer = message.buffer;
                                const taskConfig = message.taskConfig;
                                decoderPending.then((module) => {
                                    const draco = module.draco;
                                    const decoder = new draco.Decoder();
                                    try {
                                        const geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);
                                        const buffers = geometry.attributes.map((attr) => attr.array.buffer);
                                        if (geometry.index) buffers.push(geometry.index.array.buffer);
                                        self.postMessage({
                                            type: 'decode',
                                            id: message.id,
                                            geometry
                                        }, buffers)
                                    } catch (error) {
                                        console.error(error);
                                        self.postMessage({
                                            type: 'error',
                                            id: message.id,
                                            error: error.message
                                        })
                                    } finally {
                                        draco.destroy(decoder)
                                    }
                                });
                                break
                        }
                    };

                    function decodeGeometry(draco, decoder, array, taskConfig) {
                        const attributeIDs = taskConfig.attributeIDs;
                        const attributeTypes = taskConfig.attributeTypes;
                        let dracoGeometry;
                        let decodingStatus;
                        const geometryType = decoder.GetEncodedGeometryType(array);
                        if (geometryType === draco.TRIANGULAR_MESH) {
                            dracoGeometry = new draco.Mesh();
                            decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry)
                        } else if (geometryType === draco.POINT_CLOUD) {
                            dracoGeometry = new draco.PointCloud();
                            decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry)
                        } else {
                            throw new Error('THREE.DRACOLoader: Unexpected geometry type.')
                        }
                        if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
                            throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg())
                        }
                        const geometry = {
                            index: null,
                            attributes: []
                        };
                        for (const attributeName in attributeIDs) {
                            const attributeType = self[attributeTypes[attributeName]];
                            let attribute;
                            let attributeID;
                            if (taskConfig.useUniqueIDs) {
                                attributeID = attributeIDs[attributeName];
                                attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)
                            } else {
                                attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);
                                if (attributeID === -1) continue;
                                attribute = decoder.GetAttribute(dracoGeometry, attributeID)
                            }
                            const attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);
                            if (attributeName === 'color') {
                                attributeResult.vertexColorSpace = taskConfig.vertexColorSpace
                            }
                            geometry.attributes.push(attributeResult)
                        }
                        if (geometryType === draco.TRIANGULAR_MESH) {
                            geometry.index = decodeIndex(draco, decoder, dracoGeometry)
                        }
                        draco.destroy(dracoGeometry);
                        return geometry
                    }

                    function decodeIndex(draco, decoder, dracoGeometry) {
                        const numFaces = dracoGeometry.num_faces();
                        const numIndices = numFaces * 3;
                        const byteLength = numIndices * 4;
                        const ptr = draco._malloc(byteLength);
                        decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);
                        const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();
                        draco._free(ptr);
                        return {
                            array: index,
                            itemSize: 1
                        }
                    }

                    function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {
                        const numComponents = attribute.num_components();
                        const numPoints = dracoGeometry.num_points();
                        const numValues = numPoints * numComponents;
                        const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
                        const dataType = getDracoDataType(draco, attributeType);
                        const ptr = draco._malloc(byteLength);
                        decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);
                        const array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();
                        draco._free(ptr);
                        return {
                            name: attributeName,
                            array: array,
                            itemSize: numComponents
                        }
                    }

                    function getDracoDataType(draco, attributeType) {
                        switch (attributeType) {
                            case Float32Array:
                                return draco.DT_FLOAT32;
                            case Int8Array:
                                return draco.DT_INT8;
                            case Int16Array:
                                return draco.DT_INT16;
                            case Int32Array:
                                return draco.DT_INT32;
                            case Uint8Array:
                                return draco.DT_UINT8;
                            case Uint16Array:
                                return draco.DT_UINT16;
                            case Uint32Array:
                                return draco.DT_UINT32
                        }
                    }
                }
            }),
        "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
            /*!***************************************************************!*\
              !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
              \***************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    GLTFLoader: () => (GLTFLoader)
                });
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");
                var _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ../utils/BufferGeometryUtils.js */ "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");
                class GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {
                    constructor(manager) {
                        super(manager);
                        this.dracoLoader = null;
                        this.ktx2Loader = null;
                        this.meshoptDecoder = null;
                        this.pluginCallbacks = [];
                        this.register(function(parser) {
                            return new GLTFMaterialsClearcoatExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsDispersionExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFTextureBasisUExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFTextureWebPExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFTextureAVIFExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsSheenExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsTransmissionExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsVolumeExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsIorExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsEmissiveStrengthExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsSpecularExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsIridescenceExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsAnisotropyExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMaterialsBumpExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFLightsExtension(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMeshoptCompression(parser)
                        });
                        this.register(function(parser) {
                            return new GLTFMeshGpuInstancing(parser)
                        })
                    }
                    load(url, onLoad, onProgress, onError) {
                        const scope = this;
                        let resourcePath;
                        if (this.resourcePath !== '') {
                            resourcePath = this.resourcePath
                        } else if (this.path !== '') {
                            const relativeUrl = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);
                            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(relativeUrl, this.path)
                        } else {
                            resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url)
                        }
                        this.manager.itemStart(url);
                        const _onError = function(e) {
                            if (onError) {
                                onError(e)
                            } else {
                                console.error(e)
                            }
                            scope.manager.itemError(url);
                            scope.manager.itemEnd(url)
                        };
                        const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);
                        loader.setPath(this.path);
                        loader.setResponseType('arraybuffer');
                        loader.setRequestHeader(this.requestHeader);
                        loader.setWithCredentials(this.withCredentials);
                        loader.load(url, function(data) {
                            try {
                                scope.parse(data, resourcePath, function(gltf) {
                                    onLoad(gltf);
                                    scope.manager.itemEnd(url)
                                }, _onError)
                            } catch (e) {
                                _onError(e)
                            }
                        }, onProgress, _onError)
                    }
                    setDRACOLoader(dracoLoader) {
                        this.dracoLoader = dracoLoader;
                        return this
                    }
                    setDDSLoader() {
                        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
                    }
                    setKTX2Loader(ktx2Loader) {
                        this.ktx2Loader = ktx2Loader;
                        return this
                    }
                    setMeshoptDecoder(meshoptDecoder) {
                        this.meshoptDecoder = meshoptDecoder;
                        return this
                    }
                    register(callback) {
                        if (this.pluginCallbacks.indexOf(callback) === -1) {
                            this.pluginCallbacks.push(callback)
                        }
                        return this
                    }
                    unregister(callback) {
                        if (this.pluginCallbacks.indexOf(callback) !== -1) {
                            this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)
                        }
                        return this
                    }
                    parse(data, path, onLoad, onError) {
                        let json;
                        const extensions = {};
                        const plugins = {};
                        const textDecoder = new TextDecoder();
                        if (typeof data === 'string') {
                            json = JSON.parse(data)
                        } else if (data instanceof ArrayBuffer) {
                            const magic = textDecoder.decode(new Uint8Array(data, 0, 4));
                            if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
                                try {
                                    extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)
                                } catch (error) {
                                    if (onError) onError(error);
                                    return
                                }
                                json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content)
                            } else {
                                json = JSON.parse(textDecoder.decode(data))
                            }
                        } else {
                            json = data
                        }
                        if (json.asset === undefined || json.asset.version[0] < 2) {
                            if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
                            return
                        }
                        const parser = new GLTFParser(json, {
                            path: path || this.resourcePath || '',
                            crossOrigin: this.crossOrigin,
                            requestHeader: this.requestHeader,
                            manager: this.manager,
                            ktx2Loader: this.ktx2Loader,
                            meshoptDecoder: this.meshoptDecoder
                        });
                        parser.fileLoader.setRequestHeader(this.requestHeader);
                        for (let i = 0; i < this.pluginCallbacks.length; i++) {
                            const plugin = this.pluginCallbacks[i](parser);
                            if (!plugin.name) console.error('THREE.GLTFLoader: Invalid plugin found: missing name');
                            plugins[plugin.name] = plugin;
                            extensions[plugin.name] = !0
                        }
                        if (json.extensionsUsed) {
                            for (let i = 0; i < json.extensionsUsed.length; ++i) {
                                const extensionName = json.extensionsUsed[i];
                                const extensionsRequired = json.extensionsRequired || [];
                                switch (extensionName) {
                                    case EXTENSIONS.KHR_MATERIALS_UNLIT:
                                        extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                                        break;
                                    case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                                        extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                                        break;
                                    case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                                        extensions[extensionName] = new GLTFTextureTransformExtension();
                                        break;
                                    case EXTENSIONS.KHR_MESH_QUANTIZATION:
                                        extensions[extensionName] = new GLTFMeshQuantizationExtension();
                                        break;
                                    default:
                                        if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {
                                            console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".')
                                        }
                                }
                            }
                        }
                        parser.setExtensions(extensions);
                        parser.setPlugins(plugins);
                        parser.parse(onLoad, onError)
                    }
                    parseAsync(data, path) {
                        const scope = this;
                        return new Promise(function(resolve, reject) {
                            scope.parse(data, path, resolve, reject)
                        })
                    }
                }

                function GLTFRegistry() {
                    let objects = {};
                    return {
                        get: function(key) {
                            return objects[key]
                        },
                        add: function(key, object) {
                            objects[key] = object
                        },
                        remove: function(key) {
                            delete objects[key]
                        },
                        removeAll: function() {
                            objects = {}
                        }
                    }
                }
                const EXTENSIONS = {
                    KHR_BINARY_GLTF: 'KHR_binary_glTF',
                    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
                    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
                    KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
                    KHR_MATERIALS_DISPERSION: 'KHR_materials_dispersion',
                    KHR_MATERIALS_IOR: 'KHR_materials_ior',
                    KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
                    KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
                    KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
                    KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
                    KHR_MATERIALS_ANISOTROPY: 'KHR_materials_anisotropy',
                    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
                    KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
                    KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
                    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
                    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
                    KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
                    EXT_MATERIALS_BUMP: 'EXT_materials_bump',
                    EXT_TEXTURE_WEBP: 'EXT_texture_webp',
                    EXT_TEXTURE_AVIF: 'EXT_texture_avif',
                    EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
                    EXT_MESH_GPU_INSTANCING: 'EXT_mesh_gpu_instancing'
                };
                class GLTFLightsExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
                        this.cache = {
                            refs: {},
                            uses: {}
                        }
                    }
                    _markDefs() {
                        const parser = this.parser;
                        const nodeDefs = this.parser.json.nodes || [];
                        for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
                            const nodeDef = nodeDefs[nodeIndex];
                            if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== undefined) {
                                parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)
                            }
                        }
                    }
                    _loadLight(lightIndex) {
                        const parser = this.parser;
                        const cacheKey = 'light:' + lightIndex;
                        let dependency = parser.cache.get(cacheKey);
                        if (dependency) return dependency;
                        const json = parser.json;
                        const extensions = (json.extensions && json.extensions[this.name]) || {};
                        const lightDefs = extensions.lights || [];
                        const lightDef = lightDefs[lightIndex];
                        let lightNode;
                        const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0xffffff);
                        if (lightDef.color !== undefined) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
                        const range = lightDef.range !== undefined ? lightDef.range : 0;
                        switch (lightDef.type) {
                            case 'directional':
                                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);
                                lightNode.target.position.set(0, 0, -1);
                                lightNode.add(lightNode.target);
                                break;
                            case 'point':
                                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);
                                lightNode.distance = range;
                                break;
                            case 'spot':
                                lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);
                                lightNode.distance = range;
                                lightDef.spot = lightDef.spot || {};
                                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                                lightNode.angle = lightDef.spot.outerConeAngle;
                                lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                                lightNode.target.position.set(0, 0, -1);
                                lightNode.add(lightNode.target);
                                break;
                            default:
                                throw new Error('THREE.GLTFLoader: Unexpected light type: ' + lightDef.type)
                        }
                        lightNode.position.set(0, 0, 0);
                        lightNode.decay = 2;
                        assignExtrasToUserData(lightNode, lightDef);
                        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
                        lightNode.name = parser.createUniqueName(lightDef.name || ('light_' + lightIndex));
                        dependency = Promise.resolve(lightNode);
                        parser.cache.add(cacheKey, dependency);
                        return dependency
                    }
                    getDependency(type, index) {
                        if (type !== 'light') return;
                        return this._loadLight(index)
                    }
                    createNodeAttachment(nodeIndex) {
                        const self = this;
                        const parser = this.parser;
                        const json = parser.json;
                        const nodeDef = json.nodes[nodeIndex];
                        const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {};
                        const lightIndex = lightDef.light;
                        if (lightIndex === undefined) return null;
                        return this._loadLight(lightIndex).then(function(light) {
                            return parser._getNodeRef(self.cache, lightIndex, light)
                        })
                    }
                }
                class GLTFMaterialsUnlitExtension {
                    constructor() {
                        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
                    }
                    getMaterialType() {
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial
                    }
                    extendParams(materialParams, materialDef, parser) {
                        const pending = [];
                        materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0);
                        materialParams.opacity = 1.0;
                        const metallicRoughness = materialDef.pbrMetallicRoughness;
                        if (metallicRoughness) {
                            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                                const array = metallicRoughness.baseColorFactor;
                                materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
                                materialParams.opacity = array[3]
                            }
                            if (metallicRoughness.baseColorTexture !== undefined) {
                                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace))
                            }
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsEmissiveStrengthExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
                        if (emissiveStrength !== undefined) {
                            materialParams.emissiveIntensity = emissiveStrength
                        }
                        return Promise.resolve()
                    }
                }
                class GLTFMaterialsClearcoatExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        if (extension.clearcoatFactor !== undefined) {
                            materialParams.clearcoat = extension.clearcoatFactor
                        }
                        if (extension.clearcoatTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture))
                        }
                        if (extension.clearcoatRoughnessFactor !== undefined) {
                            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor
                        }
                        if (extension.clearcoatRoughnessTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture))
                        }
                        if (extension.clearcoatNormalTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));
                            if (extension.clearcoatNormalTexture.scale !== undefined) {
                                const scale = extension.clearcoatNormalTexture.scale;
                                materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, scale)
                            }
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsDispersionExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const extension = materialDef.extensions[this.name];
                        materialParams.dispersion = extension.dispersion !== undefined ? extension.dispersion : 0;
                        return Promise.resolve()
                    }
                }
                class GLTFMaterialsIridescenceExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        if (extension.iridescenceFactor !== undefined) {
                            materialParams.iridescence = extension.iridescenceFactor
                        }
                        if (extension.iridescenceTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'iridescenceMap', extension.iridescenceTexture))
                        }
                        if (extension.iridescenceIor !== undefined) {
                            materialParams.iridescenceIOR = extension.iridescenceIor
                        }
                        if (materialParams.iridescenceThicknessRange === undefined) {
                            materialParams.iridescenceThicknessRange = [100, 400]
                        }
                        if (extension.iridescenceThicknessMinimum !== undefined) {
                            materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum
                        }
                        if (extension.iridescenceThicknessMaximum !== undefined) {
                            materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum
                        }
                        if (extension.iridescenceThicknessTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsSheenExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        materialParams.sheenColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);
                        materialParams.sheenRoughness = 0;
                        materialParams.sheen = 1;
                        const extension = materialDef.extensions[this.name];
                        if (extension.sheenColorFactor !== undefined) {
                            const colorFactor = extension.sheenColorFactor;
                            materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace)
                        }
                        if (extension.sheenRoughnessFactor !== undefined) {
                            materialParams.sheenRoughness = extension.sheenRoughnessFactor
                        }
                        if (extension.sheenColorTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'sheenColorMap', extension.sheenColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace))
                        }
                        if (extension.sheenRoughnessTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsTransmissionExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        if (extension.transmissionFactor !== undefined) {
                            materialParams.transmission = extension.transmissionFactor
                        }
                        if (extension.transmissionTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsVolumeExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;
                        if (extension.thicknessTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'thicknessMap', extension.thicknessTexture))
                        }
                        materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
                        const colorArray = extension.attenuationColor || [1, 1, 1];
                        materialParams.attenuationColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsIorExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_IOR
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const extension = materialDef.extensions[this.name];
                        materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;
                        return Promise.resolve()
                    }
                }
                class GLTFMaterialsSpecularExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;
                        if (extension.specularTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'specularIntensityMap', extension.specularTexture))
                        }
                        const colorArray = extension.specularColorFactor || [1, 1, 1];
                        materialParams.specularColor = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(colorArray[0], colorArray[1], colorArray[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
                        if (extension.specularColorTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'specularColorMap', extension.specularColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsBumpExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.EXT_MATERIALS_BUMP
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        materialParams.bumpScale = extension.bumpFactor !== undefined ? extension.bumpFactor : 1.0;
                        if (extension.bumpTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'bumpMap', extension.bumpTexture))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFMaterialsAnisotropyExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY
                    }
                    getMaterialType(materialIndex) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial
                    }
                    extendMaterialParams(materialIndex, materialParams) {
                        const parser = this.parser;
                        const materialDef = parser.json.materials[materialIndex];
                        if (!materialDef.extensions || !materialDef.extensions[this.name]) {
                            return Promise.resolve()
                        }
                        const pending = [];
                        const extension = materialDef.extensions[this.name];
                        if (extension.anisotropyStrength !== undefined) {
                            materialParams.anisotropy = extension.anisotropyStrength
                        }
                        if (extension.anisotropyRotation !== undefined) {
                            materialParams.anisotropyRotation = extension.anisotropyRotation
                        }
                        if (extension.anisotropyTexture !== undefined) {
                            pending.push(parser.assignTexture(materialParams, 'anisotropyMap', extension.anisotropyTexture))
                        }
                        return Promise.all(pending)
                    }
                }
                class GLTFTextureBasisUExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.KHR_TEXTURE_BASISU
                    }
                    loadTexture(textureIndex) {
                        const parser = this.parser;
                        const json = parser.json;
                        const textureDef = json.textures[textureIndex];
                        if (!textureDef.extensions || !textureDef.extensions[this.name]) {
                            return null
                        }
                        const extension = textureDef.extensions[this.name];
                        const loader = parser.options.ktx2Loader;
                        if (!loader) {
                            if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                                throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures')
                            } else {
                                return null
                            }
                        }
                        return parser.loadTextureImage(textureIndex, extension.source, loader)
                    }
                }
                class GLTFTextureWebPExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
                        this.isSupported = null
                    }
                    loadTexture(textureIndex) {
                        const name = this.name;
                        const parser = this.parser;
                        const json = parser.json;
                        const textureDef = json.textures[textureIndex];
                        if (!textureDef.extensions || !textureDef.extensions[name]) {
                            return null
                        }
                        const extension = textureDef.extensions[name];
                        const source = json.images[extension.source];
                        let loader = parser.textureLoader;
                        if (source.uri) {
                            const handler = parser.options.manager.getHandler(source.uri);
                            if (handler !== null) loader = handler
                        }
                        return this.detectSupport().then(function(isSupported) {
                            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
                            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                                throw new Error('THREE.GLTFLoader: WebP required by asset but unsupported.')
                            }
                            return parser.loadTexture(textureIndex)
                        })
                    }
                    detectSupport() {
                        if (!this.isSupported) {
                            this.isSupported = new Promise(function(resolve) {
                                const image = new Image();
                                image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';
                                image.onload = image.onerror = function() {
                                    resolve(image.height === 1)
                                }
                            })
                        }
                        return this.isSupported
                    }
                }
                class GLTFTextureAVIFExtension {
                    constructor(parser) {
                        this.parser = parser;
                        this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
                        this.isSupported = null
                    }
                    loadTexture(textureIndex) {
                        const name = this.name;
                        const parser = this.parser;
                        const json = parser.json;
                        const textureDef = json.textures[textureIndex];
                        if (!textureDef.extensions || !textureDef.extensions[name]) {
                            return null
                        }
                        const extension = textureDef.extensions[name];
                        const source = json.images[extension.source];
                        let loader = parser.textureLoader;
                        if (source.uri) {
                            const handler = parser.options.manager.getHandler(source.uri);
                            if (handler !== null) loader = handler
                        }
                        return this.detectSupport().then(function(isSupported) {
                            if (isSupported) return parser.loadTextureImage(textureIndex, extension.source, loader);
                            if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {
                                throw new Error('THREE.GLTFLoader: AVIF required by asset but unsupported.')
                            }
                            return parser.loadTexture(textureIndex)
                        })
                    }
                    detectSupport() {
                        if (!this.isSupported) {
                            this.isSupported = new Promise(function(resolve) {
                                const image = new Image();
                                image.src = 'data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=';
                                image.onload = image.onerror = function() {
                                    resolve(image.height === 1)
                                }
                            })
                        }
                        return this.isSupported
                    }
                }
                class GLTFMeshoptCompression {
                    constructor(parser) {
                        this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
                        this.parser = parser
                    }
                    loadBufferView(index) {
                        const json = this.parser.json;
                        const bufferView = json.bufferViews[index];
                        if (bufferView.extensions && bufferView.extensions[this.name]) {
                            const extensionDef = bufferView.extensions[this.name];
                            const buffer = this.parser.getDependency('buffer', extensionDef.buffer);
                            const decoder = this.parser.options.meshoptDecoder;
                            if (!decoder || !decoder.supported) {
                                if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
                                    throw new Error('THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files')
                                } else {
                                    return null
                                }
                            }
                            return buffer.then(function(res) {
                                const byteOffset = extensionDef.byteOffset || 0;
                                const byteLength = extensionDef.byteLength || 0;
                                const count = extensionDef.count;
                                const stride = extensionDef.byteStride;
                                const source = new Uint8Array(res, byteOffset, byteLength);
                                if (decoder.decodeGltfBufferAsync) {
                                    return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res) {
                                        return res.buffer
                                    })
                                } else {
                                    return decoder.ready.then(function() {
                                        const result = new ArrayBuffer(count * stride);
                                        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
                                        return result
                                    })
                                }
                            })
                        } else {
                            return null
                        }
                    }
                }
                class GLTFMeshGpuInstancing {
                    constructor(parser) {
                        this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
                        this.parser = parser
                    }
                    createNodeMesh(nodeIndex) {
                        const json = this.parser.json;
                        const nodeDef = json.nodes[nodeIndex];
                        if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === undefined) {
                            return null
                        }
                        const meshDef = json.meshes[nodeDef.mesh];
                        for (const primitive of meshDef.primitives) {
                            if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== undefined) {
                                return null
                            }
                        }
                        const extensionDef = nodeDef.extensions[this.name];
                        const attributesDef = extensionDef.attributes;
                        const pending = [];
                        const attributes = {};
                        for (const key in attributesDef) {
                            pending.push(this.parser.getDependency('accessor', attributesDef[key]).then(accessor => {
                                attributes[key] = accessor;
                                return attributes[key]
                            }))
                        }
                        if (pending.length < 1) {
                            return null
                        }
                        pending.push(this.parser.createNodeMesh(nodeIndex));
                        return Promise.all(pending).then(results => {
                            const nodeObject = results.pop();
                            const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
                            const count = results[0].count;
                            const instancedMeshes = [];
                            for (const mesh of meshes) {
                                const m = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                                const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                                const q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
                                const s = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 1, 1);
                                const instancedMesh = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedMesh(mesh.geometry, mesh.material, count);
                                for (let i = 0; i < count; i++) {
                                    if (attributes.TRANSLATION) {
                                        p.fromBufferAttribute(attributes.TRANSLATION, i)
                                    }
                                    if (attributes.ROTATION) {
                                        q.fromBufferAttribute(attributes.ROTATION, i)
                                    }
                                    if (attributes.SCALE) {
                                        s.fromBufferAttribute(attributes.SCALE, i)
                                    }
                                    instancedMesh.setMatrixAt(i, m.compose(p, q, s))
                                }
                                for (const attributeName in attributes) {
                                    if (attributeName === '_COLOR_0') {
                                        const attr = attributes[attributeName];
                                        instancedMesh.instanceColor = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized)
                                    } else if (attributeName !== 'TRANSLATION' && attributeName !== 'ROTATION' && attributeName !== 'SCALE') {
                                        mesh.geometry.setAttribute(attributeName, attributes[attributeName])
                                    }
                                }
                                three__WEBPACK_IMPORTED_MODULE_0__.Object3D.prototype.copy.call(instancedMesh, mesh);
                                this.parser.assignFinalMaterial(instancedMesh);
                                instancedMeshes.push(instancedMesh)
                            }
                            if (nodeObject.isGroup) {
                                nodeObject.clear();
                                nodeObject.add(...instancedMeshes);
                                return nodeObject
                            }
                            return instancedMeshes[0]
                        })
                    }
                }
                const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
                const BINARY_EXTENSION_HEADER_LENGTH = 12;
                const BINARY_EXTENSION_CHUNK_TYPES = {
                    JSON: 0x4E4F534A,
                    BIN: 0x004E4942
                };
                class GLTFBinaryExtension {
                    constructor(data) {
                        this.name = EXTENSIONS.KHR_BINARY_GLTF;
                        this.content = null;
                        this.body = null;
                        const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
                        const textDecoder = new TextDecoder();
                        this.header = {
                            magic: textDecoder.decode(new Uint8Array(data.slice(0, 4))),
                            version: headerView.getUint32(4, !0),
                            length: headerView.getUint32(8, !0)
                        };
                        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
                            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
                        } else if (this.header.version < 2.0) {
                            throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
                        }
                        const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
                        const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
                        let chunkIndex = 0;
                        while (chunkIndex < chunkContentsLength) {
                            const chunkLength = chunkView.getUint32(chunkIndex, !0);
                            chunkIndex += 4;
                            const chunkType = chunkView.getUint32(chunkIndex, !0);
                            chunkIndex += 4;
                            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
                                const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                                this.content = textDecoder.decode(contentArray)
                            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
                                const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                                this.body = data.slice(byteOffset, byteOffset + chunkLength)
                            }
                            chunkIndex += chunkLength
                        }
                        if (this.content === null) {
                            throw new Error('THREE.GLTFLoader: JSON content not found.')
                        }
                    }
                }
                class GLTFDracoMeshCompressionExtension {
                    constructor(json, dracoLoader) {
                        if (!dracoLoader) {
                            throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
                        }
                        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
                        this.json = json;
                        this.dracoLoader = dracoLoader;
                        this.dracoLoader.preload()
                    }
                    decodePrimitive(primitive, parser) {
                        const json = this.json;
                        const dracoLoader = this.dracoLoader;
                        const bufferViewIndex = primitive.extensions[this.name].bufferView;
                        const gltfAttributeMap = primitive.extensions[this.name].attributes;
                        const threeAttributeMap = {};
                        const attributeNormalizedMap = {};
                        const attributeTypeMap = {};
                        for (const attributeName in gltfAttributeMap) {
                            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
                            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]
                        }
                        for (const attributeName in primitive.attributes) {
                            const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
                            if (gltfAttributeMap[attributeName] !== undefined) {
                                const accessorDef = json.accessors[primitive.attributes[attributeName]];
                                const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                                attributeTypeMap[threeAttributeName] = componentType.name;
                                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === !0
                            }
                        }
                        return parser.getDependency('bufferView', bufferViewIndex).then(function(bufferView) {
                            return new Promise(function(resolve, reject) {
                                dracoLoader.decodeDracoFile(bufferView, function(geometry) {
                                    for (const attributeName in geometry.attributes) {
                                        const attribute = geometry.attributes[attributeName];
                                        const normalized = attributeNormalizedMap[attributeName];
                                        if (normalized !== undefined) attribute.normalized = normalized
                                    }
                                    resolve(geometry)
                                }, threeAttributeMap, attributeTypeMap, three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace, reject)
                            })
                        })
                    }
                }
                class GLTFTextureTransformExtension {
                    constructor() {
                        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
                    }
                    extendTexture(texture, transform) {
                        if ((transform.texCoord === undefined || transform.texCoord === texture.channel) && transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined) {
                            return texture
                        }
                        texture = texture.clone();
                        if (transform.texCoord !== undefined) {
                            texture.channel = transform.texCoord
                        }
                        if (transform.offset !== undefined) {
                            texture.offset.fromArray(transform.offset)
                        }
                        if (transform.rotation !== undefined) {
                            texture.rotation = transform.rotation
                        }
                        if (transform.scale !== undefined) {
                            texture.repeat.fromArray(transform.scale)
                        }
                        texture.needsUpdate = !0;
                        return texture
                    }
                }
                class GLTFMeshQuantizationExtension {
                    constructor() {
                        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
                    }
                }
                class GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {
                    constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
                        super(parameterPositions, sampleValues, sampleSize, resultBuffer)
                    }
                    copySampleValue_(index) {
                        const result = this.resultBuffer,
                            values = this.sampleValues,
                            valueSize = this.valueSize,
                            offset = index * valueSize * 3 + valueSize;
                        for (let i = 0; i !== valueSize; i++) {
                            result[i] = values[offset + i]
                        }
                        return result
                    }
                    interpolate_(i1, t0, t, t1) {
                        const result = this.resultBuffer;
                        const values = this.sampleValues;
                        const stride = this.valueSize;
                        const stride2 = stride * 2;
                        const stride3 = stride * 3;
                        const td = t1 - t0;
                        const p = (t - t0) / td;
                        const pp = p * p;
                        const ppp = pp * p;
                        const offset1 = i1 * stride3;
                        const offset0 = offset1 - stride3;
                        const s2 = -2 * ppp + 3 * pp;
                        const s3 = ppp - pp;
                        const s0 = 1 - s2;
                        const s1 = s3 - pp + p;
                        for (let i = 0; i !== stride; i++) {
                            const p0 = values[offset0 + i + stride];
                            const m0 = values[offset0 + i + stride2] * td;
                            const p1 = values[offset1 + i + stride];
                            const m1 = values[offset1 + i] * td;
                            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1
                        }
                        return result
                    }
                }
                const _q = new three__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
                class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
                    interpolate_(i1, t0, t, t1) {
                        const result = super.interpolate_(i1, t0, t, t1);
                        _q.fromArray(result).normalize().toArray(result);
                        return result
                    }
                }
                const WEBGL_CONSTANTS = {
                    FLOAT: 5126,
                    FLOAT_MAT3: 35675,
                    FLOAT_MAT4: 35676,
                    FLOAT_VEC2: 35664,
                    FLOAT_VEC3: 35665,
                    FLOAT_VEC4: 35666,
                    LINEAR: 9729,
                    REPEAT: 10497,
                    SAMPLER_2D: 35678,
                    POINTS: 0,
                    LINES: 1,
                    LINE_LOOP: 2,
                    LINE_STRIP: 3,
                    TRIANGLES: 4,
                    TRIANGLE_STRIP: 5,
                    TRIANGLE_FAN: 6,
                    UNSIGNED_BYTE: 5121,
                    UNSIGNED_SHORT: 5123
                };
                const WEBGL_COMPONENT_TYPES = {
                    5120: Int8Array,
                    5121: Uint8Array,
                    5122: Int16Array,
                    5123: Uint16Array,
                    5125: Uint32Array,
                    5126: Float32Array
                };
                const WEBGL_FILTERS = {
                    9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,
                    9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,
                    9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,
                    9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,
                    9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,
                    9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter
                };
                const WEBGL_WRAPPINGS = {
                    33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,
                    33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,
                    10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping
                };
                const WEBGL_TYPE_SIZES = {
                    'SCALAR': 1,
                    'VEC2': 2,
                    'VEC3': 3,
                    'VEC4': 4,
                    'MAT2': 4,
                    'MAT3': 9,
                    'MAT4': 16
                };
                const ATTRIBUTES = {
                    POSITION: 'position',
                    NORMAL: 'normal',
                    TANGENT: 'tangent',
                    TEXCOORD_0: 'uv',
                    TEXCOORD_1: 'uv1',
                    TEXCOORD_2: 'uv2',
                    TEXCOORD_3: 'uv3',
                    COLOR_0: 'color',
                    WEIGHTS_0: 'skinWeight',
                    JOINTS_0: 'skinIndex',
                };
                const PATH_PROPERTIES = {
                    scale: 'scale',
                    translation: 'position',
                    rotation: 'quaternion',
                    weights: 'morphTargetInfluences'
                };
                const INTERPOLATION = {
                    CUBICSPLINE: undefined,
                    LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,
                    STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete
                };
                const ALPHA_MODES = {
                    OPAQUE: 'OPAQUE',
                    MASK: 'MASK',
                    BLEND: 'BLEND'
                };

                function createDefaultMaterial(cache) {
                    if (cache.DefaultMaterial === undefined) {
                        cache.DefaultMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({
                            color: 0xFFFFFF,
                            emissive: 0x000000,
                            metalness: 1,
                            roughness: 1,
                            transparent: !1,
                            depthTest: !0,
                            side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide
                        })
                    }
                    return cache.DefaultMaterial
                }

                function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
                    for (const name in objectDef.extensions) {
                        if (knownExtensions[name] === undefined) {
                            object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                            object.userData.gltfExtensions[name] = objectDef.extensions[name]
                        }
                    }
                }

                function assignExtrasToUserData(object, gltfDef) {
                    if (gltfDef.extras !== undefined) {
                        if (typeof gltfDef.extras === 'object') {
                            Object.assign(object.userData, gltfDef.extras)
                        } else {
                            console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras)
                        }
                    }
                }

                function addMorphTargets(geometry, targets, parser) {
                    let hasMorphPosition = !1;
                    let hasMorphNormal = !1;
                    let hasMorphColor = !1;
                    for (let i = 0, il = targets.length; i < il; i++) {
                        const target = targets[i];
                        if (target.POSITION !== undefined) hasMorphPosition = !0;
                        if (target.NORMAL !== undefined) hasMorphNormal = !0;
                        if (target.COLOR_0 !== undefined) hasMorphColor = !0;
                        if (hasMorphPosition && hasMorphNormal && hasMorphColor) break
                    }
                    if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
                    const pendingPositionAccessors = [];
                    const pendingNormalAccessors = [];
                    const pendingColorAccessors = [];
                    for (let i = 0, il = targets.length; i < il; i++) {
                        const target = targets[i];
                        if (hasMorphPosition) {
                            const pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
                            pendingPositionAccessors.push(pendingAccessor)
                        }
                        if (hasMorphNormal) {
                            const pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
                            pendingNormalAccessors.push(pendingAccessor)
                        }
                        if (hasMorphColor) {
                            const pendingAccessor = target.COLOR_0 !== undefined ? parser.getDependency('accessor', target.COLOR_0) : geometry.attributes.color;
                            pendingColorAccessors.push(pendingAccessor)
                        }
                    }
                    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors), Promise.all(pendingColorAccessors)]).then(function(accessors) {
                        const morphPositions = accessors[0];
                        const morphNormals = accessors[1];
                        const morphColors = accessors[2];
                        if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
                        if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
                        if (hasMorphColor) geometry.morphAttributes.color = morphColors;
                        geometry.morphTargetsRelative = !0;
                        return geometry
                    })
                }

                function updateMorphTargets(mesh, meshDef) {
                    mesh.updateMorphTargets();
                    if (meshDef.weights !== undefined) {
                        for (let i = 0, il = meshDef.weights.length; i < il; i++) {
                            mesh.morphTargetInfluences[i] = meshDef.weights[i]
                        }
                    }
                    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
                        const targetNames = meshDef.extras.targetNames;
                        if (mesh.morphTargetInfluences.length === targetNames.length) {
                            mesh.morphTargetDictionary = {};
                            for (let i = 0, il = targetNames.length; i < il; i++) {
                                mesh.morphTargetDictionary[targetNames[i]] = i
                            }
                        } else {
                            console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.')
                        }
                    }
                }

                function createPrimitiveKey(primitiveDef) {
                    let geometryKey;
                    const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
                    if (dracoExtension) {
                        geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes)
                    } else {
                        geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode
                    }
                    if (primitiveDef.targets !== undefined) {
                        for (let i = 0, il = primitiveDef.targets.length; i < il; i++) {
                            geometryKey += ':' + createAttributesKey(primitiveDef.targets[i])
                        }
                    }
                    return geometryKey
                }

                function createAttributesKey(attributes) {
                    let attributesKey = '';
                    const keys = Object.keys(attributes).sort();
                    for (let i = 0, il = keys.length; i < il; i++) {
                        attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'
                    }
                    return attributesKey
                }

                function getNormalizedComponentScale(constructor) {
                    switch (constructor) {
                        case Int8Array:
                            return 1 / 127;
                        case Uint8Array:
                            return 1 / 255;
                        case Int16Array:
                            return 1 / 32767;
                        case Uint16Array:
                            return 1 / 65535;
                        default:
                            throw new Error('THREE.GLTFLoader: Unsupported normalized accessor component type.')
                    }
                }

                function getImageURIMimeType(uri) {
                    if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return 'image/jpeg';
                    if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return 'image/webp';
                    return 'image/png'
                }
                const _identityMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                class GLTFParser {
                    constructor(json = {}, options = {}) {
                        this.json = json;
                        this.extensions = {};
                        this.plugins = {};
                        this.options = options;
                        this.cache = new GLTFRegistry();
                        this.associations = new Map();
                        this.primitiveCache = {};
                        this.nodeCache = {};
                        this.meshCache = {
                            refs: {},
                            uses: {}
                        };
                        this.cameraCache = {
                            refs: {},
                            uses: {}
                        };
                        this.lightCache = {
                            refs: {},
                            uses: {}
                        };
                        this.sourceCache = {};
                        this.textureCache = {};
                        this.nodeNamesUsed = {};
                        let isSafari = !1;
                        let safariVersion = -1;
                        let isFirefox = !1;
                        let firefoxVersion = -1;
                        if (typeof navigator !== 'undefined') {
                            const userAgent = navigator.userAgent;
                            isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === !0;
                            const safariMatch = userAgent.match(/Version\/(\d+)/);
                            safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
                            isFirefox = userAgent.indexOf('Firefox') > -1;
                            firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1
                        }
                        if (typeof createImageBitmap === 'undefined' || (isSafari && safariVersion < 17) || (isFirefox && firefoxVersion < 98)) {
                            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager)
                        } else {
                            this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager)
                        }
                        this.textureLoader.setCrossOrigin(this.options.crossOrigin);
                        this.textureLoader.setRequestHeader(this.options.requestHeader);
                        this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);
                        this.fileLoader.setResponseType('arraybuffer');
                        if (this.options.crossOrigin === 'use-credentials') {
                            this.fileLoader.setWithCredentials(!0)
                        }
                    }
                    setExtensions(extensions) {
                        this.extensions = extensions
                    }
                    setPlugins(plugins) {
                        this.plugins = plugins
                    }
                    parse(onLoad, onError) {
                        const parser = this;
                        const json = this.json;
                        const extensions = this.extensions;
                        this.cache.removeAll();
                        this.nodeCache = {};
                        this._invokeAll(function(ext) {
                            return ext._markDefs && ext._markDefs()
                        });
                        Promise.all(this._invokeAll(function(ext) {
                            return ext.beforeRoot && ext.beforeRoot()
                        })).then(function() {
                            return Promise.all([parser.getDependencies('scene'), parser.getDependencies('animation'), parser.getDependencies('camera'), ])
                        }).then(function(dependencies) {
                            const result = {
                                scene: dependencies[0][json.scene || 0],
                                scenes: dependencies[0],
                                animations: dependencies[1],
                                cameras: dependencies[2],
                                asset: json.asset,
                                parser: parser,
                                userData: {}
                            };
                            addUnknownExtensionsToUserData(extensions, result, json);
                            assignExtrasToUserData(result, json);
                            return Promise.all(parser._invokeAll(function(ext) {
                                return ext.afterRoot && ext.afterRoot(result)
                            })).then(function() {
                                for (const scene of result.scenes) {
                                    scene.updateMatrixWorld()
                                }
                                onLoad(result)
                            })
                        }).catch(onError)
                    }
                    _markDefs() {
                        const nodeDefs = this.json.nodes || [];
                        const skinDefs = this.json.skins || [];
                        const meshDefs = this.json.meshes || [];
                        for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
                            const joints = skinDefs[skinIndex].joints;
                            for (let i = 0, il = joints.length; i < il; i++) {
                                nodeDefs[joints[i]].isBone = !0
                            }
                        }
                        for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
                            const nodeDef = nodeDefs[nodeIndex];
                            if (nodeDef.mesh !== undefined) {
                                this._addNodeRef(this.meshCache, nodeDef.mesh);
                                if (nodeDef.skin !== undefined) {
                                    meshDefs[nodeDef.mesh].isSkinnedMesh = !0
                                }
                            }
                            if (nodeDef.camera !== undefined) {
                                this._addNodeRef(this.cameraCache, nodeDef.camera)
                            }
                        }
                    }
                    _addNodeRef(cache, index) {
                        if (index === undefined) return;
                        if (cache.refs[index] === undefined) {
                            cache.refs[index] = cache.uses[index] = 0
                        }
                        cache.refs[index]++
                    }
                    _getNodeRef(cache, index, object) {
                        if (cache.refs[index] <= 1) return object;
                        const ref = object.clone();
                        const updateMappings = (original, clone) => {
                            const mappings = this.associations.get(original);
                            if (mappings != null) {
                                this.associations.set(clone, mappings)
                            }
                            for (const [i, child] of original.children.entries()) {
                                updateMappings(child, clone.children[i])
                            }
                        };
                        updateMappings(object, ref);
                        ref.name += '_instance_' + (cache.uses[index]++);
                        return ref
                    }
                    _invokeOne(func) {
                        const extensions = Object.values(this.plugins);
                        extensions.push(this);
                        for (let i = 0; i < extensions.length; i++) {
                            const result = func(extensions[i]);
                            if (result) return result
                        }
                        return null
                    }
                    _invokeAll(func) {
                        const extensions = Object.values(this.plugins);
                        extensions.unshift(this);
                        const pending = [];
                        for (let i = 0; i < extensions.length; i++) {
                            const result = func(extensions[i]);
                            if (result) pending.push(result)
                        }
                        return pending
                    }
                    getDependency(type, index) {
                        const cacheKey = type + ':' + index;
                        let dependency = this.cache.get(cacheKey);
                        if (!dependency) {
                            switch (type) {
                                case 'scene':
                                    dependency = this.loadScene(index);
                                    break;
                                case 'node':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadNode && ext.loadNode(index)
                                    });
                                    break;
                                case 'mesh':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadMesh && ext.loadMesh(index)
                                    });
                                    break;
                                case 'accessor':
                                    dependency = this.loadAccessor(index);
                                    break;
                                case 'bufferView':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadBufferView && ext.loadBufferView(index)
                                    });
                                    break;
                                case 'buffer':
                                    dependency = this.loadBuffer(index);
                                    break;
                                case 'material':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadMaterial && ext.loadMaterial(index)
                                    });
                                    break;
                                case 'texture':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadTexture && ext.loadTexture(index)
                                    });
                                    break;
                                case 'skin':
                                    dependency = this.loadSkin(index);
                                    break;
                                case 'animation':
                                    dependency = this._invokeOne(function(ext) {
                                        return ext.loadAnimation && ext.loadAnimation(index)
                                    });
                                    break;
                                case 'camera':
                                    dependency = this.loadCamera(index);
                                    break;
                                default:
                                    dependency = this._invokeOne(function(ext) {
                                        return ext != this && ext.getDependency && ext.getDependency(type, index)
                                    });
                                    if (!dependency) {
                                        throw new Error('Unknown type: ' + type)
                                    }
                                    break
                            }
                            this.cache.add(cacheKey, dependency)
                        }
                        return dependency
                    }
                    getDependencies(type) {
                        let dependencies = this.cache.get(type);
                        if (!dependencies) {
                            const parser = this;
                            const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
                            dependencies = Promise.all(defs.map(function(def, index) {
                                return parser.getDependency(type, index)
                            }));
                            this.cache.add(type, dependencies)
                        }
                        return dependencies
                    }
                    loadBuffer(bufferIndex) {
                        const bufferDef = this.json.buffers[bufferIndex];
                        const loader = this.fileLoader;
                        if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
                            throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.')
                        }
                        if (bufferDef.uri === undefined && bufferIndex === 0) {
                            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)
                        }
                        const options = this.options;
                        return new Promise(function(resolve, reject) {
                            loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, undefined, function() {
                                reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'))
                            })
                        })
                    }
                    loadBufferView(bufferViewIndex) {
                        const bufferViewDef = this.json.bufferViews[bufferViewIndex];
                        return this.getDependency('buffer', bufferViewDef.buffer).then(function(buffer) {
                            const byteLength = bufferViewDef.byteLength || 0;
                            const byteOffset = bufferViewDef.byteOffset || 0;
                            return buffer.slice(byteOffset, byteOffset + byteLength)
                        })
                    }
                    loadAccessor(accessorIndex) {
                        const parser = this;
                        const json = this.json;
                        const accessorDef = this.json.accessors[accessorIndex];
                        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
                            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                            const normalized = accessorDef.normalized === !0;
                            const array = new TypedArray(accessorDef.count * itemSize);
                            return Promise.resolve(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized))
                        }
                        const pendingBufferViews = [];
                        if (accessorDef.bufferView !== undefined) {
                            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView))
                        } else {
                            pendingBufferViews.push(null)
                        }
                        if (accessorDef.sparse !== undefined) {
                            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
                            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView))
                        }
                        return Promise.all(pendingBufferViews).then(function(bufferViews) {
                            const bufferView = bufferViews[0];
                            const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
                            const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
                            const elementBytes = TypedArray.BYTES_PER_ELEMENT;
                            const itemBytes = elementBytes * itemSize;
                            const byteOffset = accessorDef.byteOffset || 0;
                            const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
                            const normalized = accessorDef.normalized === !0;
                            let array, bufferAttribute;
                            if (byteStride && byteStride !== itemBytes) {
                                const ibSlice = Math.floor(byteOffset / byteStride);
                                const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                                let ib = parser.cache.get(ibCacheKey);
                                if (!ib) {
                                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
                                    ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);
                                    parser.cache.add(ibCacheKey, ib)
                                }
                                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, (byteOffset % byteStride) / elementBytes, normalized)
                            } else {
                                if (bufferView === null) {
                                    array = new TypedArray(accessorDef.count * itemSize)
                                } else {
                                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize)
                                }
                                bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized)
                            }
                            if (accessorDef.sparse !== undefined) {
                                const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                                const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
                                const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                                const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
                                const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                                const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
                                if (bufferView !== null) {
                                    bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized)
                                }
                                for (let i = 0, il = sparseIndices.length; i < il; i++) {
                                    const index = sparseIndices[i];
                                    bufferAttribute.setX(index, sparseValues[i * itemSize]);
                                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                                    if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.')
                                }
                            }
                            return bufferAttribute
                        })
                    }
                    loadTexture(textureIndex) {
                        const json = this.json;
                        const options = this.options;
                        const textureDef = json.textures[textureIndex];
                        const sourceIndex = textureDef.source;
                        const sourceDef = json.images[sourceIndex];
                        let loader = this.textureLoader;
                        if (sourceDef.uri) {
                            const handler = options.manager.getHandler(sourceDef.uri);
                            if (handler !== null) loader = handler
                        }
                        return this.loadTextureImage(textureIndex, sourceIndex, loader)
                    }
                    loadTextureImage(textureIndex, sourceIndex, loader) {
                        const parser = this;
                        const json = this.json;
                        const textureDef = json.textures[textureIndex];
                        const sourceDef = json.images[sourceIndex];
                        const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler;
                        if (this.textureCache[cacheKey]) {
                            return this.textureCache[cacheKey]
                        }
                        const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
                            texture.flipY = !1;
                            texture.name = textureDef.name || sourceDef.name || '';
                            if (texture.name === '' && typeof sourceDef.uri === 'string' && sourceDef.uri.startsWith('data:image/') === !1) {
                                texture.name = sourceDef.uri
                            }
                            const samplers = json.samplers || {};
                            const sampler = samplers[textureDef.sampler] || {};
                            texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;
                            texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;
                            texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;
                            texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;
                            parser.associations.set(texture, {
                                textures: textureIndex
                            });
                            return texture
                        }).catch(function() {
                            return null
                        });
                        this.textureCache[cacheKey] = promise;
                        return promise
                    }
                    loadImageSource(sourceIndex, loader) {
                        const parser = this;
                        const json = this.json;
                        const options = this.options;
                        if (this.sourceCache[sourceIndex] !== undefined) {
                            return this.sourceCache[sourceIndex].then((texture) => texture.clone())
                        }
                        const sourceDef = json.images[sourceIndex];
                        const URL = self.URL || self.webkitURL;
                        let sourceURI = sourceDef.uri || '';
                        let isObjectURL = !1;
                        if (sourceDef.bufferView !== undefined) {
                            sourceURI = parser.getDependency('bufferView', sourceDef.bufferView).then(function(bufferView) {
                                isObjectURL = !0;
                                const blob = new Blob([bufferView], {
                                    type: sourceDef.mimeType
                                });
                                sourceURI = URL.createObjectURL(blob);
                                return sourceURI
                            })
                        } else if (sourceDef.uri === undefined) {
                            throw new Error('THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView')
                        }
                        const promise = Promise.resolve(sourceURI).then(function(sourceURI) {
                            return new Promise(function(resolve, reject) {
                                let onLoad = resolve;
                                if (loader.isImageBitmapLoader === !0) {
                                    onLoad = function(imageBitmap) {
                                        const texture = new three__WEBPACK_IMPORTED_MODULE_0__.Texture(imageBitmap);
                                        texture.needsUpdate = !0;
                                        resolve(texture)
                                    }
                                }
                                loader.load(three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.resolveURL(sourceURI, options.path), onLoad, undefined, reject)
                            })
                        }).then(function(texture) {
                            if (isObjectURL === !0) {
                                URL.revokeObjectURL(sourceURI)
                            }
                            assignExtrasToUserData(texture, sourceDef);
                            texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
                            return texture
                        }).catch(function(error) {
                            console.error('THREE.GLTFLoader: Couldn\'t load texture', sourceURI);
                            throw error
                        });
                        this.sourceCache[sourceIndex] = promise;
                        return promise
                    }
                    assignTexture(materialParams, mapName, mapDef, colorSpace) {
                        const parser = this;
                        return this.getDependency('texture', mapDef.index).then(function(texture) {
                            if (!texture) return null;
                            if (mapDef.texCoord !== undefined && mapDef.texCoord > 0) {
                                texture = texture.clone();
                                texture.channel = mapDef.texCoord
                            }
                            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
                                const transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;
                                if (transform) {
                                    const gltfReference = parser.associations.get(texture);
                                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                                    parser.associations.set(texture, gltfReference)
                                }
                            }
                            if (colorSpace !== undefined) {
                                texture.colorSpace = colorSpace
                            }
                            materialParams[mapName] = texture;
                            return texture
                        })
                    }
                    assignFinalMaterial(mesh) {
                        const geometry = mesh.geometry;
                        let material = mesh.material;
                        const useDerivativeTangents = geometry.attributes.tangent === undefined;
                        const useVertexColors = geometry.attributes.color !== undefined;
                        const useFlatShading = geometry.attributes.normal === undefined;
                        if (mesh.isPoints) {
                            const cacheKey = 'PointsMaterial:' + material.uuid;
                            let pointsMaterial = this.cache.get(cacheKey);
                            if (!pointsMaterial) {
                                pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();
                                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);
                                pointsMaterial.color.copy(material.color);
                                pointsMaterial.map = material.map;
                                pointsMaterial.sizeAttenuation = !1;
                                this.cache.add(cacheKey, pointsMaterial)
                            }
                            material = pointsMaterial
                        } else if (mesh.isLine) {
                            const cacheKey = 'LineBasicMaterial:' + material.uuid;
                            let lineMaterial = this.cache.get(cacheKey);
                            if (!lineMaterial) {
                                lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();
                                three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);
                                lineMaterial.color.copy(material.color);
                                lineMaterial.map = material.map;
                                this.cache.add(cacheKey, lineMaterial)
                            }
                            material = lineMaterial
                        }
                        if (useDerivativeTangents || useVertexColors || useFlatShading) {
                            let cacheKey = 'ClonedMaterial:' + material.uuid + ':';
                            if (useDerivativeTangents) cacheKey += 'derivative-tangents:';
                            if (useVertexColors) cacheKey += 'vertex-colors:';
                            if (useFlatShading) cacheKey += 'flat-shading:';
                            let cachedMaterial = this.cache.get(cacheKey);
                            if (!cachedMaterial) {
                                cachedMaterial = material.clone();
                                if (useVertexColors) cachedMaterial.vertexColors = !0;
                                if (useFlatShading) cachedMaterial.flatShading = !0;
                                if (useDerivativeTangents) {
                                    if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
                                    if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1
                                }
                                this.cache.add(cacheKey, cachedMaterial);
                                this.associations.set(cachedMaterial, this.associations.get(material))
                            }
                            material = cachedMaterial
                        }
                        mesh.material = material
                    }
                    getMaterialType() {
                        return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial
                    }
                    loadMaterial(materialIndex) {
                        const parser = this;
                        const json = this.json;
                        const extensions = this.extensions;
                        const materialDef = json.materials[materialIndex];
                        let materialType;
                        const materialParams = {};
                        const materialExtensions = materialDef.extensions || {};
                        const pending = [];
                        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
                            const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
                            materialType = kmuExtension.getMaterialType();
                            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser))
                        } else {
                            const metallicRoughness = materialDef.pbrMetallicRoughness || {};
                            materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1.0, 1.0, 1.0);
                            materialParams.opacity = 1.0;
                            if (Array.isArray(metallicRoughness.baseColorFactor)) {
                                const array = metallicRoughness.baseColorFactor;
                                materialParams.color.setRGB(array[0], array[1], array[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace);
                                materialParams.opacity = array[3]
                            }
                            if (metallicRoughness.baseColorTexture !== undefined) {
                                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace))
                            }
                            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
                            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
                            if (metallicRoughness.metallicRoughnessTexture !== undefined) {
                                pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
                                pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture))
                            }
                            materialType = this._invokeOne(function(ext) {
                                return ext.getMaterialType && ext.getMaterialType(materialIndex)
                            });
                            pending.push(Promise.all(this._invokeAll(function(ext) {
                                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams)
                            })))
                        }
                        if (materialDef.doubleSided === !0) {
                            materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide
                        }
                        const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
                        if (alphaMode === ALPHA_MODES.BLEND) {
                            materialParams.transparent = !0;
                            materialParams.depthWrite = !1
                        } else {
                            materialParams.transparent = !1;
                            if (alphaMode === ALPHA_MODES.MASK) {
                                materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5
                            }
                        }
                        if (materialDef.normalTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {
                            pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
                            materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, 1);
                            if (materialDef.normalTexture.scale !== undefined) {
                                const scale = materialDef.normalTexture.scale;
                                materialParams.normalScale.set(scale, scale)
                            }
                        }
                        if (materialDef.occlusionTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {
                            pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));
                            if (materialDef.occlusionTexture.strength !== undefined) {
                                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength
                            }
                        }
                        if (materialDef.emissiveFactor !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {
                            const emissiveFactor = materialDef.emissiveFactor;
                            materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace)
                        }
                        if (materialDef.emissiveTexture !== undefined && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {
                            pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture, three__WEBPACK_IMPORTED_MODULE_0__.SRGBColorSpace))
                        }
                        return Promise.all(pending).then(function() {
                            const material = new materialType(materialParams);
                            if (materialDef.name) material.name = materialDef.name;
                            assignExtrasToUserData(material, materialDef);
                            parser.associations.set(material, {
                                materials: materialIndex
                            });
                            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
                            return material
                        })
                    }
                    createUniqueName(originalName) {
                        const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || '');
                        if (sanitizedName in this.nodeNamesUsed) {
                            return sanitizedName + '_' + (++this.nodeNamesUsed[sanitizedName])
                        } else {
                            this.nodeNamesUsed[sanitizedName] = 0;
                            return sanitizedName
                        }
                    }
                    loadGeometries(primitives) {
                        const parser = this;
                        const extensions = this.extensions;
                        const cache = this.primitiveCache;

                        function createDracoPrimitive(primitive) {
                            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
                                return addPrimitiveAttributes(geometry, primitive, parser)
                            })
                        }
                        const pending = [];
                        for (let i = 0, il = primitives.length; i < il; i++) {
                            const primitive = primitives[i];
                            const cacheKey = createPrimitiveKey(primitive);
                            const cached = cache[cacheKey];
                            if (cached) {
                                pending.push(cached.promise)
                            } else {
                                let geometryPromise;
                                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
                                    geometryPromise = createDracoPrimitive(primitive)
                                } else {
                                    geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser)
                                }
                                cache[cacheKey] = {
                                    primitive: primitive,
                                    promise: geometryPromise
                                };
                                pending.push(geometryPromise)
                            }
                        }
                        return Promise.all(pending)
                    }
                    loadMesh(meshIndex) {
                        const parser = this;
                        const json = this.json;
                        const extensions = this.extensions;
                        const meshDef = json.meshes[meshIndex];
                        const primitives = meshDef.primitives;
                        const pending = [];
                        for (let i = 0, il = primitives.length; i < il; i++) {
                            const material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
                            pending.push(material)
                        }
                        pending.push(parser.loadGeometries(primitives));
                        return Promise.all(pending).then(function(results) {
                            const materials = results.slice(0, results.length - 1);
                            const geometries = results[results.length - 1];
                            const meshes = [];
                            for (let i = 0, il = geometries.length; i < il; i++) {
                                const geometry = geometries[i];
                                const primitive = primitives[i];
                                let mesh;
                                const material = materials[i];
                                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
                                    mesh = meshDef.isSkinnedMesh === !0 ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);
                                    if (mesh.isSkinnedMesh === !0) {
                                        mesh.normalizeSkinWeights()
                                    }
                                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
                                        mesh.geometry = (0, _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode)
                                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
                                        mesh.geometry = (0, _utils_BufferGeometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.toTrianglesDrawMode)(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode)
                                    }
                                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
                                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material)
                                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
                                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material)
                                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
                                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material)
                                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
                                    mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material)
                                } else {
                                    throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode)
                                }
                                if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
                                    updateMorphTargets(mesh, meshDef)
                                }
                                mesh.name = parser.createUniqueName(meshDef.name || ('mesh_' + meshIndex));
                                assignExtrasToUserData(mesh, meshDef);
                                if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
                                parser.assignFinalMaterial(mesh);
                                meshes.push(mesh)
                            }
                            for (let i = 0, il = meshes.length; i < il; i++) {
                                parser.associations.set(meshes[i], {
                                    meshes: meshIndex,
                                    primitives: i
                                })
                            }
                            if (meshes.length === 1) {
                                if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
                                return meshes[0]
                            }
                            const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
                            if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
                            parser.associations.set(group, {
                                meshes: meshIndex
                            });
                            for (let i = 0, il = meshes.length; i < il; i++) {
                                group.add(meshes[i])
                            }
                            return group
                        })
                    }
                    loadCamera(cameraIndex) {
                        let camera;
                        const cameraDef = this.json.cameras[cameraIndex];
                        const params = cameraDef[cameraDef.type];
                        if (!params) {
                            console.warn('THREE.GLTFLoader: Missing camera parameters.');
                            return
                        }
                        if (cameraDef.type === 'perspective') {
                            camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6)
                        } else if (cameraDef.type === 'orthographic') {
                            camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar)
                        }
                        if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
                        assignExtrasToUserData(camera, cameraDef);
                        return Promise.resolve(camera)
                    }
                    loadSkin(skinIndex) {
                        const skinDef = this.json.skins[skinIndex];
                        const pending = [];
                        for (let i = 0, il = skinDef.joints.length; i < il; i++) {
                            pending.push(this._loadNodeShallow(skinDef.joints[i]))
                        }
                        if (skinDef.inverseBindMatrices !== undefined) {
                            pending.push(this.getDependency('accessor', skinDef.inverseBindMatrices))
                        } else {
                            pending.push(null)
                        }
                        return Promise.all(pending).then(function(results) {
                            const inverseBindMatrices = results.pop();
                            const jointNodes = results;
                            const bones = [];
                            const boneInverses = [];
                            for (let i = 0, il = jointNodes.length; i < il; i++) {
                                const jointNode = jointNodes[i];
                                if (jointNode) {
                                    bones.push(jointNode);
                                    const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                                    if (inverseBindMatrices !== null) {
                                        mat.fromArray(inverseBindMatrices.array, i * 16)
                                    }
                                    boneInverses.push(mat)
                                } else {
                                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i])
                                }
                            }
                            return new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses)
                        })
                    }
                    loadAnimation(animationIndex) {
                        const json = this.json;
                        const parser = this;
                        const animationDef = json.animations[animationIndex];
                        const animationName = animationDef.name ? animationDef.name : 'animation_' + animationIndex;
                        const pendingNodes = [];
                        const pendingInputAccessors = [];
                        const pendingOutputAccessors = [];
                        const pendingSamplers = [];
                        const pendingTargets = [];
                        for (let i = 0, il = animationDef.channels.length; i < il; i++) {
                            const channel = animationDef.channels[i];
                            const sampler = animationDef.samplers[channel.sampler];
                            const target = channel.target;
                            const name = target.node;
                            const input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
                            const output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
                            if (target.node === undefined) continue;
                            pendingNodes.push(this.getDependency('node', name));
                            pendingInputAccessors.push(this.getDependency('accessor', input));
                            pendingOutputAccessors.push(this.getDependency('accessor', output));
                            pendingSamplers.push(sampler);
                            pendingTargets.push(target)
                        }
                        return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function(dependencies) {
                            const nodes = dependencies[0];
                            const inputAccessors = dependencies[1];
                            const outputAccessors = dependencies[2];
                            const samplers = dependencies[3];
                            const targets = dependencies[4];
                            const tracks = [];
                            for (let i = 0, il = nodes.length; i < il; i++) {
                                const node = nodes[i];
                                const inputAccessor = inputAccessors[i];
                                const outputAccessor = outputAccessors[i];
                                const sampler = samplers[i];
                                const target = targets[i];
                                if (node === undefined) continue;
                                if (node.updateMatrix) {
                                    node.updateMatrix()
                                }
                                const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
                                if (createdTracks) {
                                    for (let k = 0; k < createdTracks.length; k++) {
                                        tracks.push(createdTracks[k])
                                    }
                                }
                            }
                            return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(animationName, undefined, tracks)
                        })
                    }
                    createNodeMesh(nodeIndex) {
                        const json = this.json;
                        const parser = this;
                        const nodeDef = json.nodes[nodeIndex];
                        if (nodeDef.mesh === undefined) return null;
                        return parser.getDependency('mesh', nodeDef.mesh).then(function(mesh) {
                            const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
                            if (nodeDef.weights !== undefined) {
                                node.traverse(function(o) {
                                    if (!o.isMesh) return;
                                    for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
                                        o.morphTargetInfluences[i] = nodeDef.weights[i]
                                    }
                                })
                            }
                            return node
                        })
                    }
                    loadNode(nodeIndex) {
                        const json = this.json;
                        const parser = this;
                        const nodeDef = json.nodes[nodeIndex];
                        const nodePending = parser._loadNodeShallow(nodeIndex);
                        const childPending = [];
                        const childrenDef = nodeDef.children || [];
                        for (let i = 0, il = childrenDef.length; i < il; i++) {
                            childPending.push(parser.getDependency('node', childrenDef[i]))
                        }
                        const skeletonPending = nodeDef.skin === undefined ? Promise.resolve(null) : parser.getDependency('skin', nodeDef.skin);
                        return Promise.all([nodePending, Promise.all(childPending), skeletonPending]).then(function(results) {
                            const node = results[0];
                            const children = results[1];
                            const skeleton = results[2];
                            if (skeleton !== null) {
                                node.traverse(function(mesh) {
                                    if (!mesh.isSkinnedMesh) return;
                                    mesh.bind(skeleton, _identityMatrix)
                                })
                            }
                            for (let i = 0, il = children.length; i < il; i++) {
                                node.add(children[i])
                            }
                            return node
                        })
                    }
                    _loadNodeShallow(nodeIndex) {
                        const json = this.json;
                        const extensions = this.extensions;
                        const parser = this;
                        if (this.nodeCache[nodeIndex] !== undefined) {
                            return this.nodeCache[nodeIndex]
                        }
                        const nodeDef = json.nodes[nodeIndex];
                        const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : '';
                        const pending = [];
                        const meshPromise = parser._invokeOne(function(ext) {
                            return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)
                        });
                        if (meshPromise) {
                            pending.push(meshPromise)
                        }
                        if (nodeDef.camera !== undefined) {
                            pending.push(parser.getDependency('camera', nodeDef.camera).then(function(camera) {
                                return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera)
                            }))
                        }
                        parser._invokeAll(function(ext) {
                            return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)
                        }).forEach(function(promise) {
                            pending.push(promise)
                        });
                        this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
                            let node;
                            if (nodeDef.isBone === !0) {
                                node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone()
                            } else if (objects.length > 1) {
                                node = new three__WEBPACK_IMPORTED_MODULE_0__.Group()
                            } else if (objects.length === 1) {
                                node = objects[0]
                            } else {
                                node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D()
                            }
                            if (node !== objects[0]) {
                                for (let i = 0, il = objects.length; i < il; i++) {
                                    node.add(objects[i])
                                }
                            }
                            if (nodeDef.name) {
                                node.userData.name = nodeDef.name;
                                node.name = nodeName
                            }
                            assignExtrasToUserData(node, nodeDef);
                            if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
                            if (nodeDef.matrix !== undefined) {
                                const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();
                                matrix.fromArray(nodeDef.matrix);
                                node.applyMatrix4(matrix)
                            } else {
                                if (nodeDef.translation !== undefined) {
                                    node.position.fromArray(nodeDef.translation)
                                }
                                if (nodeDef.rotation !== undefined) {
                                    node.quaternion.fromArray(nodeDef.rotation)
                                }
                                if (nodeDef.scale !== undefined) {
                                    node.scale.fromArray(nodeDef.scale)
                                }
                            }
                            if (!parser.associations.has(node)) {
                                parser.associations.set(node, {})
                            }
                            parser.associations.get(node).nodes = nodeIndex;
                            return node
                        });
                        return this.nodeCache[nodeIndex]
                    }
                    loadScene(sceneIndex) {
                        const extensions = this.extensions;
                        const sceneDef = this.json.scenes[sceneIndex];
                        const parser = this;
                        const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();
                        if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
                        assignExtrasToUserData(scene, sceneDef);
                        if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
                        const nodeIds = sceneDef.nodes || [];
                        const pending = [];
                        for (let i = 0, il = nodeIds.length; i < il; i++) {
                            pending.push(parser.getDependency('node', nodeIds[i]))
                        }
                        return Promise.all(pending).then(function(nodes) {
                            for (let i = 0, il = nodes.length; i < il; i++) {
                                scene.add(nodes[i])
                            }
                            const reduceAssociations = (node) => {
                                const reducedAssociations = new Map();
                                for (const [key, value] of parser.associations) {
                                    if (key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Material || key instanceof three__WEBPACK_IMPORTED_MODULE_0__.Texture) {
                                        reducedAssociations.set(key, value)
                                    }
                                }
                                node.traverse((node) => {
                                    const mappings = parser.associations.get(node);
                                    if (mappings != null) {
                                        reducedAssociations.set(node, mappings)
                                    }
                                });
                                return reducedAssociations
                            };
                            parser.associations = reduceAssociations(scene);
                            return scene
                        })
                    }
                    _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
                        const tracks = [];
                        const targetName = node.name ? node.name : node.uuid;
                        const targetNames = [];
                        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
                            node.traverse(function(object) {
                                if (object.morphTargetInfluences) {
                                    targetNames.push(object.name ? object.name : object.uuid)
                                }
                            })
                        } else {
                            targetNames.push(targetName)
                        }
                        let TypedKeyframeTrack;
                        switch (PATH_PROPERTIES[target.path]) {
                            case PATH_PROPERTIES.weights:
                                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
                                break;
                            case PATH_PROPERTIES.rotation:
                                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;
                                break;
                            case PATH_PROPERTIES.position:
                            case PATH_PROPERTIES.scale:
                                TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
                                break;
                            default:
                                switch (outputAccessor.itemSize) {
                                    case 1:
                                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;
                                        break;
                                    case 2:
                                    case 3:
                                    default:
                                        TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;
                                        break
                                }
                                break
                        }
                        const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;
                        const outputArray = this._getArrayFromAccessor(outputAccessor);
                        for (let j = 0, jl = targetNames.length; j < jl; j++) {
                            const track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);
                            if (sampler.interpolation === 'CUBICSPLINE') {
                                this._createCubicSplineTrackInterpolant(track)
                            }
                            tracks.push(track)
                        }
                        return tracks
                    }
                    _getArrayFromAccessor(accessor) {
                        let outputArray = accessor.array;
                        if (accessor.normalized) {
                            const scale = getNormalizedComponentScale(outputArray.constructor);
                            const scaled = new Float32Array(outputArray.length);
                            for (let j = 0, jl = outputArray.length; j < jl; j++) {
                                scaled[j] = outputArray[j] * scale
                            }
                            outputArray = scaled
                        }
                        return outputArray
                    }
                    _createCubicSplineTrackInterpolant(track) {
                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
                            const interpolantType = (this instanceof three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
                            return new interpolantType(this.times, this.values, this.getValueSize() / 3, result)
                        };
                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
                    }
                }

                function computeBounds(geometry, primitiveDef, parser) {
                    const attributes = primitiveDef.attributes;
                    const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();
                    if (attributes.POSITION !== undefined) {
                        const accessor = parser.json.accessors[attributes.POSITION];
                        const min = accessor.min;
                        const max = accessor.max;
                        if (min !== undefined && max !== undefined) {
                            box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));
                            if (accessor.normalized) {
                                const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                                box.min.multiplyScalar(boxScale);
                                box.max.multiplyScalar(boxScale)
                            }
                        } else {
                            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
                            return
                        }
                    } else {
                        return
                    }
                    const targets = primitiveDef.targets;
                    if (targets !== undefined) {
                        const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                        for (let i = 0, il = targets.length; i < il; i++) {
                            const target = targets[i];
                            if (target.POSITION !== undefined) {
                                const accessor = parser.json.accessors[target.POSITION];
                                const min = accessor.min;
                                const max = accessor.max;
                                if (min !== undefined && max !== undefined) {
                                    vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                                    vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                                    vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
                                    if (accessor.normalized) {
                                        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
                                        vector.multiplyScalar(boxScale)
                                    }
                                    maxDisplacement.max(vector)
                                } else {
                                    console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.')
                                }
                            }
                        }
                        box.expandByVector(maxDisplacement)
                    }
                    geometry.boundingBox = box;
                    const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();
                    box.getCenter(sphere.center);
                    sphere.radius = box.min.distanceTo(box.max) / 2;
                    geometry.boundingSphere = sphere
                }

                function addPrimitiveAttributes(geometry, primitiveDef, parser) {
                    const attributes = primitiveDef.attributes;
                    const pending = [];

                    function assignAttributeAccessor(accessorIndex, attributeName) {
                        return parser.getDependency('accessor', accessorIndex).then(function(accessor) {
                            geometry.setAttribute(attributeName, accessor)
                        })
                    }
                    for (const gltfAttributeName in attributes) {
                        const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
                        if (threeAttributeName in geometry.attributes) continue;
                        pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName))
                    }
                    if (primitiveDef.indices !== undefined && !geometry.index) {
                        const accessor = parser.getDependency('accessor', primitiveDef.indices).then(function(accessor) {
                            geometry.setIndex(accessor)
                        });
                        pending.push(accessor)
                    }
                    if (three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace !== three__WEBPACK_IMPORTED_MODULE_0__.LinearSRGBColorSpace && 'COLOR_0' in attributes) {
                        console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${three__WEBPACK_IMPORTED_MODULE_0__.ColorManagement.workingColorSpace}" not supported.`)
                    }
                    assignExtrasToUserData(geometry, primitiveDef);
                    computeBounds(geometry, primitiveDef, parser);
                    return Promise.all(pending).then(function() {
                        return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry
                    })
                }
            }),
        "./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js":
            /*!**********************************************************************!*\
              !*** ./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js ***!
              \**********************************************************************/
            ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
                "use strict";
                __webpack_require__.d(__webpack_exports__, {
                    toTrianglesDrawMode: () => (toTrianglesDrawMode)
                });
                var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! three */ "./node_modules/three/build/three.module.js");

                function computeMikkTSpaceTangents(geometry, MikkTSpace, negateSign = !0) {
                    if (!MikkTSpace || !MikkTSpace.isReady) {
                        throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.')
                    }
                    if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {
                        throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.')
                    }

                    function getAttributeArray(attribute) {
                        if (attribute.normalized || attribute.isInterleavedBufferAttribute) {
                            const dstArray = new Float32Array(attribute.count * attribute.itemSize);
                            for (let i = 0, j = 0; i < attribute.count; i++) {
                                dstArray[j++] = attribute.getX(i);
                                dstArray[j++] = attribute.getY(i);
                                if (attribute.itemSize > 2) {
                                    dstArray[j++] = attribute.getZ(i)
                                }
                            }
                            return dstArray
                        }
                        if (attribute.array instanceof Float32Array) {
                            return attribute.array
                        }
                        return new Float32Array(attribute.array)
                    }
                    const _geometry = geometry.index ? geometry.toNonIndexed() : geometry;
                    const tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));
                    if (negateSign) {
                        for (let i = 3; i < tangents.length; i += 4) {
                            tangents[i] *= -1
                        }
                    }
                    _geometry.setAttribute('tangent', new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(tangents, 4));
                    if (geometry !== _geometry) {
                        geometry.copy(_geometry)
                    }
                    return geometry
                }

                function mergeGeometries(geometries, useGroups = !1) {
                    const isIndexed = geometries[0].index !== null;
                    const attributesUsed = new Set(Object.keys(geometries[0].attributes));
                    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
                    const attributes = {};
                    const morphAttributes = {};
                    const morphTargetsRelative = geometries[0].morphTargetsRelative;
                    const mergedGeometry = new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry();
                    let offset = 0;
                    for (let i = 0; i < geometries.length; ++i) {
                        const geometry = geometries[i];
                        let attributesCount = 0;
                        if (isIndexed !== (geometry.index !== null)) {
                            console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');
                            return null
                        }
                        for (const name in geometry.attributes) {
                            if (!attributesUsed.has(name)) {
                                console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
                                return null
                            }
                            if (attributes[name] === undefined) attributes[name] = [];
                            attributes[name].push(geometry.attributes[name]);
                            attributesCount++
                        }
                        if (attributesCount !== attributesUsed.size) {
                            console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');
                            return null
                        }
                        if (morphTargetsRelative !== geometry.morphTargetsRelative) {
                            console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');
                            return null
                        }
                        for (const name in geometry.morphAttributes) {
                            if (!morphAttributesUsed.has(name)) {
                                console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');
                                return null
                            }
                            if (morphAttributes[name] === undefined) morphAttributes[name] = [];
                            morphAttributes[name].push(geometry.morphAttributes[name])
                        }
                        if (useGroups) {
                            let count;
                            if (isIndexed) {
                                count = geometry.index.count
                            } else if (geometry.attributes.position !== undefined) {
                                count = geometry.attributes.position.count
                            } else {
                                console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');
                                return null
                            }
                            mergedGeometry.addGroup(offset, count, i);
                            offset += count
                        }
                    }
                    if (isIndexed) {
                        let indexOffset = 0;
                        const mergedIndex = [];
                        for (let i = 0; i < geometries.length; ++i) {
                            const index = geometries[i].index;
                            for (let j = 0; j < index.count; ++j) {
                                mergedIndex.push(index.getX(j) + indexOffset)
                            }
                            indexOffset += geometries[i].attributes.position.count
                        }
                        mergedGeometry.setIndex(mergedIndex)
                    }
                    for (const name in attributes) {
                        const mergedAttribute = mergeAttributes(attributes[name]);
                        if (!mergedAttribute) {
                            console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' attribute.');
                            return null
                        }
                        mergedGeometry.setAttribute(name, mergedAttribute)
                    }
                    for (const name in morphAttributes) {
                        const numMorphTargets = morphAttributes[name][0].length;
                        if (numMorphTargets === 0) break;
                        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
                        mergedGeometry.morphAttributes[name] = [];
                        for (let i = 0; i < numMorphTargets; ++i) {
                            const morphAttributesToMerge = [];
                            for (let j = 0; j < morphAttributes[name].length; ++j) {
                                morphAttributesToMerge.push(morphAttributes[name][j][i])
                            }
                            const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
                            if (!mergedMorphAttribute) {
                                console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + name + ' morphAttribute.');
                                return null
                            }
                            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)
                        }
                    }
                    return mergedGeometry
                }

                function mergeAttributes(attributes) {
                    let TypedArray;
                    let itemSize;
                    let normalized;
                    let gpuType = -1;
                    let arrayLength = 0;
                    for (let i = 0; i < attributes.length; ++i) {
                        const attribute = attributes[i];
                        if (TypedArray === undefined) TypedArray = attribute.array.constructor;
                        if (TypedArray !== attribute.array.constructor) {
                            console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');
                            return null
                        }
                        if (itemSize === undefined) itemSize = attribute.itemSize;
                        if (itemSize !== attribute.itemSize) {
                            console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');
                            return null
                        }
                        if (normalized === undefined) normalized = attribute.normalized;
                        if (normalized !== attribute.normalized) {
                            console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');
                            return null
                        }
                        if (gpuType === -1) gpuType = attribute.gpuType;
                        if (gpuType !== attribute.gpuType) {
                            console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.');
                            return null
                        }
                        arrayLength += attribute.count * itemSize
                    }
                    const array = new TypedArray(arrayLength);
                    const result = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);
                    let offset = 0;
                    for (let i = 0; i < attributes.length; ++i) {
                        const attribute = attributes[i];
                        if (attribute.isInterleavedBufferAttribute) {
                            const tupleOffset = offset / itemSize;
                            for (let j = 0, l = attribute.count; j < l; j++) {
                                for (let c = 0; c < itemSize; c++) {
                                    const value = attribute.getComponent(j, c);
                                    result.setComponent(j + tupleOffset, c, value)
                                }
                            }
                        } else {
                            array.set(attribute.array, offset)
                        }
                        offset += attribute.count * itemSize
                    }
                    if (gpuType !== undefined) {
                        result.gpuType = gpuType
                    }
                    return result
                }

                function deepCloneAttribute(attribute) {
                    if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {
                        return deinterleaveAttribute(attribute)
                    }
                    if (attribute.isInstancedBufferAttribute) {
                        return new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute().copy(attribute)
                    }
                    return new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute().copy(attribute)
                }

                function interleaveAttributes(attributes) {
                    let TypedArray;
                    let arrayLength = 0;
                    let stride = 0;
                    for (let i = 0, l = attributes.length; i < l; ++i) {
                        const attribute = attributes[i];
                        if (TypedArray === undefined) TypedArray = attribute.array.constructor;
                        if (TypedArray !== attribute.array.constructor) {
                            console.error('AttributeBuffers of different types cannot be interleaved');
                            return null
                        }
                        arrayLength += attribute.array.length;
                        stride += attribute.itemSize
                    }
                    const interleavedBuffer = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(new TypedArray(arrayLength), stride);
                    let offset = 0;
                    const res = [];
                    const getters = ['getX', 'getY', 'getZ', 'getW'];
                    const setters = ['setX', 'setY', 'setZ', 'setW'];
                    for (let j = 0, l = attributes.length; j < l; j++) {
                        const attribute = attributes[j];
                        const itemSize = attribute.itemSize;
                        const count = attribute.count;
                        const iba = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);
                        res.push(iba);
                        offset += itemSize;
                        for (let c = 0; c < count; c++) {
                            for (let k = 0; k < itemSize; k++) {
                                iba[setters[k]](c, attribute[getters[k]](c))
                            }
                        }
                    }
                    return res
                }

                function deinterleaveAttribute(attribute) {
                    const cons = attribute.data.array.constructor;
                    const count = attribute.count;
                    const itemSize = attribute.itemSize;
                    const normalized = attribute.normalized;
                    const array = new cons(count * itemSize);
                    let newAttribute;
                    if (attribute.isInstancedInterleavedBufferAttribute) {
                        newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InstancedBufferAttribute(array, itemSize, normalized, attribute.meshPerAttribute)
                    } else {
                        newAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized)
                    }
                    for (let i = 0; i < count; i++) {
                        newAttribute.setX(i, attribute.getX(i));
                        if (itemSize >= 2) {
                            newAttribute.setY(i, attribute.getY(i))
                        }
                        if (itemSize >= 3) {
                            newAttribute.setZ(i, attribute.getZ(i))
                        }
                        if (itemSize >= 4) {
                            newAttribute.setW(i, attribute.getW(i))
                        }
                    }
                    return newAttribute
                }

                function deinterleaveGeometry(geometry) {
                    const attributes = geometry.attributes;
                    const morphTargets = geometry.morphTargets;
                    const attrMap = new Map();
                    for (const key in attributes) {
                        const attr = attributes[key];
                        if (attr.isInterleavedBufferAttribute) {
                            if (!attrMap.has(attr)) {
                                attrMap.set(attr, deinterleaveAttribute(attr))
                            }
                            attributes[key] = attrMap.get(attr)
                        }
                    }
                    for (const key in morphTargets) {
                        const attr = morphTargets[key];
                        if (attr.isInterleavedBufferAttribute) {
                            if (!attrMap.has(attr)) {
                                attrMap.set(attr, deinterleaveAttribute(attr))
                            }
                            morphTargets[key] = attrMap.get(attr)
                        }
                    }
                }

                function estimateBytesUsed(geometry) {
                    let mem = 0;
                    for (const name in geometry.attributes) {
                        const attr = geometry.getAttribute(name);
                        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT
                    }
                    const indices = geometry.getIndex();
                    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
                    return mem
                }

                function mergeVertices(geometry, tolerance = 1e-4) {
                    tolerance = Math.max(tolerance, Number.EPSILON);
                    const hashToIndex = {};
                    const indices = geometry.getIndex();
                    const positions = geometry.getAttribute('position');
                    const vertexCount = indices ? indices.count : positions.count;
                    let nextIndex = 0;
                    const attributeNames = Object.keys(geometry.attributes);
                    const tmpAttributes = {};
                    const tmpMorphAttributes = {};
                    const newIndices = [];
                    const getters = ['getX', 'getY', 'getZ', 'getW'];
                    const setters = ['setX', 'setY', 'setZ', 'setW'];
                    for (let i = 0, l = attributeNames.length; i < l; i++) {
                        const name = attributeNames[i];
                        const attr = geometry.attributes[name];
                        tmpAttributes[name] = new attr.constructor(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);
                        const morphAttributes = geometry.morphAttributes[name];
                        if (morphAttributes) {
                            if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];
                            morphAttributes.forEach((morphAttr, i) => {
                                const array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);
                                tmpMorphAttributes[name][i] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized)
                            })
                        }
                    }
                    const halfTolerance = tolerance * 0.5;
                    const exponent = Math.log10(1 / tolerance);
                    const hashMultiplier = Math.pow(10, exponent);
                    const hashAdditive = halfTolerance * hashMultiplier;
                    for (let i = 0; i < vertexCount; i++) {
                        const index = indices ? indices.getX(i) : i;
                        let hash = '';
                        for (let j = 0, l = attributeNames.length; j < l; j++) {
                            const name = attributeNames[j];
                            const attribute = geometry.getAttribute(name);
                            const itemSize = attribute.itemSize;
                            for (let k = 0; k < itemSize; k++) {
                                hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * hashMultiplier + hashAdditive ) },`
                            }
                        }
                        if (hash in hashToIndex) {
                            newIndices.push(hashToIndex[hash])
                        } else {
                            for (let j = 0, l = attributeNames.length; j < l; j++) {
                                const name = attributeNames[j];
                                const attribute = geometry.getAttribute(name);
                                const morphAttributes = geometry.morphAttributes[name];
                                const itemSize = attribute.itemSize;
                                const newArray = tmpAttributes[name];
                                const newMorphArrays = tmpMorphAttributes[name];
                                for (let k = 0; k < itemSize; k++) {
                                    const getterFunc = getters[k];
                                    const setterFunc = setters[k];
                                    newArray[setterFunc](nextIndex, attribute[getterFunc](index));
                                    if (morphAttributes) {
                                        for (let m = 0, ml = morphAttributes.length; m < ml; m++) {
                                            newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index))
                                        }
                                    }
                                }
                            }
                            hashToIndex[hash] = nextIndex;
                            newIndices.push(nextIndex);
                            nextIndex++
                        }
                    }
                    const result = geometry.clone();
                    for (const name in geometry.attributes) {
                        const tmpAttribute = tmpAttributes[name];
                        result.setAttribute(name, new tmpAttribute.constructor(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized, ));
                        if (!(name in tmpMorphAttributes)) continue;
                        for (let j = 0; j < tmpMorphAttributes[name].length; j++) {
                            const tmpMorphAttribute = tmpMorphAttributes[name][j];
                            result.morphAttributes[name][j] = new tmpMorphAttribute.constructor(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized, )
                        }
                    }
                    result.setIndex(newIndices);
                    return result
                }

                function toTrianglesDrawMode(geometry, drawMode) {
                    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TrianglesDrawMode) {
                        console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');
                        return geometry
                    }
                    if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode || drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode) {
                        let index = geometry.getIndex();
                        if (index === null) {
                            const indices = [];
                            const position = geometry.getAttribute('position');
                            if (position !== undefined) {
                                for (let i = 0; i < position.count; i++) {
                                    indices.push(i)
                                }
                                geometry.setIndex(indices);
                                index = geometry.getIndex()
                            } else {
                                console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
                                return geometry
                            }
                        }
                        const numberOfTriangles = index.count - 2;
                        const newIndices = [];
                        if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {
                            for (let i = 1; i <= numberOfTriangles; i++) {
                                newIndices.push(index.getX(0));
                                newIndices.push(index.getX(i));
                                newIndices.push(index.getX(i + 1))
                            }
                        } else {
                            for (let i = 0; i < numberOfTriangles; i++) {
                                if (i % 2 === 0) {
                                    newIndices.push(index.getX(i));
                                    newIndices.push(index.getX(i + 1));
                                    newIndices.push(index.getX(i + 2))
                                } else {
                                    newIndices.push(index.getX(i + 2));
                                    newIndices.push(index.getX(i + 1));
                                    newIndices.push(index.getX(i))
                                }
                            }
                        }
                        if ((newIndices.length / 3) !== numberOfTriangles) {
                            console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')
                        }
                        const newGeometry = geometry.clone();
                        newGeometry.setIndex(newIndices);
                        newGeometry.clearGroups();
                        return newGeometry
                    } else {
                        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);
                        return geometry
                    }
                }

                function computeMorphedAttributes(object) {
                    const _vA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _vB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _vC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _tempA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _tempB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _tempC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _morphA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _morphB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const _morphC = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

                    function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {
                        _vA.fromBufferAttribute(attribute, a);
                        _vB.fromBufferAttribute(attribute, b);
                        _vC.fromBufferAttribute(attribute, c);
                        const morphInfluences = object.morphTargetInfluences;
                        if (morphAttribute && morphInfluences) {
                            _morphA.set(0, 0, 0);
                            _morphB.set(0, 0, 0);
                            _morphC.set(0, 0, 0);
                            for (let i = 0, il = morphAttribute.length; i < il; i++) {
                                const influence = morphInfluences[i];
                                const morph = morphAttribute[i];
                                if (influence === 0) continue;
                                _tempA.fromBufferAttribute(morph, a);
                                _tempB.fromBufferAttribute(morph, b);
                                _tempC.fromBufferAttribute(morph, c);
                                if (morphTargetsRelative) {
                                    _morphA.addScaledVector(_tempA, influence);
                                    _morphB.addScaledVector(_tempB, influence);
                                    _morphC.addScaledVector(_tempC, influence)
                                } else {
                                    _morphA.addScaledVector(_tempA.sub(_vA), influence);
                                    _morphB.addScaledVector(_tempB.sub(_vB), influence);
                                    _morphC.addScaledVector(_tempC.sub(_vC), influence)
                                }
                            }
                            _vA.add(_morphA);
                            _vB.add(_morphB);
                            _vC.add(_morphC)
                        }
                        if (object.isSkinnedMesh) {
                            object.applyBoneTransform(a, _vA);
                            object.applyBoneTransform(b, _vB);
                            object.applyBoneTransform(c, _vC)
                        }
                        modifiedAttributeArray[a * 3 + 0] = _vA.x;
                        modifiedAttributeArray[a * 3 + 1] = _vA.y;
                        modifiedAttributeArray[a * 3 + 2] = _vA.z;
                        modifiedAttributeArray[b * 3 + 0] = _vB.x;
                        modifiedAttributeArray[b * 3 + 1] = _vB.y;
                        modifiedAttributeArray[b * 3 + 2] = _vB.z;
                        modifiedAttributeArray[c * 3 + 0] = _vC.x;
                        modifiedAttributeArray[c * 3 + 1] = _vC.y;
                        modifiedAttributeArray[c * 3 + 2] = _vC.z
                    }
                    const geometry = object.geometry;
                    const material = object.material;
                    let a, b, c;
                    const index = geometry.index;
                    const positionAttribute = geometry.attributes.position;
                    const morphPosition = geometry.morphAttributes.position;
                    const morphTargetsRelative = geometry.morphTargetsRelative;
                    const normalAttribute = geometry.attributes.normal;
                    const morphNormal = geometry.morphAttributes.position;
                    const groups = geometry.groups;
                    const drawRange = geometry.drawRange;
                    let i, j, il, jl;
                    let group;
                    let start, end;
                    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
                    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
                    if (index !== null) {
                        if (Array.isArray(material)) {
                            for (i = 0, il = groups.length; i < il; i++) {
                                group = groups[i];
                                start = Math.max(group.start, drawRange.start);
                                end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));
                                for (j = start, jl = end; j < jl; j += 3) {
                                    a = index.getX(j);
                                    b = index.getX(j + 1);
                                    c = index.getX(j + 2);
                                    _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                                    _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal)
                                }
                            }
                        } else {
                            start = Math.max(0, drawRange.start);
                            end = Math.min(index.count, (drawRange.start + drawRange.count));
                            for (i = start, il = end; i < il; i += 3) {
                                a = index.getX(i);
                                b = index.getX(i + 1);
                                c = index.getX(i + 2);
                                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal)
                            }
                        }
                    } else {
                        if (Array.isArray(material)) {
                            for (i = 0, il = groups.length; i < il; i++) {
                                group = groups[i];
                                start = Math.max(group.start, drawRange.start);
                                end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));
                                for (j = start, jl = end; j < jl; j += 3) {
                                    a = j;
                                    b = j + 1;
                                    c = j + 2;
                                    _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                                    _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal)
                                }
                            }
                        } else {
                            start = Math.max(0, drawRange.start);
                            end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));
                            for (i = start, il = end; i < il; i += 3) {
                                a = i;
                                b = i + 1;
                                c = i + 2;
                                _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
                                _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal)
                            }
                        }
                    }
                    const morphedPositionAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedPosition, 3);
                    const morphedNormalAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.Float32BufferAttribute(modifiedNormal, 3);
                    return {
                        positionAttribute: positionAttribute,
                        normalAttribute: normalAttribute,
                        morphedPositionAttribute: morphedPositionAttribute,
                        morphedNormalAttribute: morphedNormalAttribute
                    }
                }

                function mergeGroups(geometry) {
                    if (geometry.groups.length === 0) {
                        console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');
                        return geometry
                    }
                    let groups = geometry.groups;
                    groups = groups.sort((a, b) => {
                        if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;
                        return a.start - b.start
                    });
                    if (geometry.getIndex() === null) {
                        const positionAttribute = geometry.getAttribute('position');
                        const indices = [];
                        for (let i = 0; i < positionAttribute.count; i += 3) {
                            indices.push(i, i + 1, i + 2)
                        }
                        geometry.setIndex(indices)
                    }
                    const index = geometry.getIndex();
                    const newIndices = [];
                    for (let i = 0; i < groups.length; i++) {
                        const group = groups[i];
                        const groupStart = group.start;
                        const groupLength = groupStart + group.count;
                        for (let j = groupStart; j < groupLength; j++) {
                            newIndices.push(index.getX(j))
                        }
                    }
                    geometry.dispose();
                    geometry.setIndex(newIndices);
                    let start = 0;
                    for (let i = 0; i < groups.length; i++) {
                        const group = groups[i];
                        group.start = start;
                        start += group.count
                    }
                    let currentGroup = groups[0];
                    geometry.groups = [currentGroup];
                    for (let i = 1; i < groups.length; i++) {
                        const group = groups[i];
                        if (currentGroup.materialIndex === group.materialIndex) {
                            currentGroup.count += group.count
                        } else {
                            currentGroup = group;
                            geometry.groups.push(currentGroup)
                        }
                    }
                    return geometry
                }

                function toCreasedNormals(geometry, creaseAngle = Math.PI / 3) {
                    const creaseDot = Math.cos(creaseAngle);
                    const hashMultiplier = (1 + 1e-10) * 1e2;
                    const verts = [new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()];
                    const tempVec1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const tempVec2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const tempNorm = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();
                    const tempNorm2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();

                    function hashVertex(v) {
                        const x = ~~(v.x * hashMultiplier);
                        const y = ~~(v.y * hashMultiplier);
                        const z = ~~(v.z * hashMultiplier);
                        return `${x},${y},${z}`
                    }
                    const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
                    const posAttr = resultGeometry.attributes.position;
                    const vertexMap = {};
                    for (let i = 0, l = posAttr.count / 3; i < l; i++) {
                        const i3 = 3 * i;
                        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
                        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
                        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
                        tempVec1.subVectors(c, b);
                        tempVec2.subVectors(a, b);
                        const normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3().crossVectors(tempVec1, tempVec2).normalize();
                        for (let n = 0; n < 3; n++) {
                            const vert = verts[n];
                            const hash = hashVertex(vert);
                            if (!(hash in vertexMap)) {
                                vertexMap[hash] = []
                            }
                            vertexMap[hash].push(normal)
                        }
                    }
                    const normalArray = new Float32Array(posAttr.count * 3);
                    const normAttr = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(normalArray, 3, !1);
                    for (let i = 0, l = posAttr.count / 3; i < l; i++) {
                        const i3 = 3 * i;
                        const a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
                        const b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
                        const c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
                        tempVec1.subVectors(c, b);
                        tempVec2.subVectors(a, b);
                        tempNorm.crossVectors(tempVec1, tempVec2).normalize();
                        for (let n = 0; n < 3; n++) {
                            const vert = verts[n];
                            const hash = hashVertex(vert);
                            const otherNormals = vertexMap[hash];
                            tempNorm2.set(0, 0, 0);
                            for (let k = 0, lk = otherNormals.length; k < lk; k++) {
                                const otherNorm = otherNormals[k];
                                if (tempNorm.dot(otherNorm) > creaseDot) {
                                    tempNorm2.add(otherNorm)
                                }
                            }
                            tempNorm2.normalize();
                            normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)
                        }
                    }
                    resultGeometry.setAttribute('normal', normAttr);
                    return resultGeometry
                }
            })
    });
    var __webpack_module_cache__ = {};

    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== undefined) {
            return cachedModule.exports
        }
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports
    }(() => {
        __webpack_require__.n = (module) => {
            var getter = module && module.__esModule ? () => (module['default']) : () => (module);
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter
        }
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
                    Object.defineProperty(exports, key, {
                        enumerable: !0,
                        get: definition[key]
                    })
                }
            }
        }
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    })();
    (() => {
        __webpack_require__.r = (exports) => {
            if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
                Object.defineProperty(exports, Symbol.toStringTag, {
                    value: 'Module'
                })
            }
            Object.defineProperty(exports, '__esModule', {
                value: !0
            })
        }
    })();
    var __webpack_exports__ = {};
    (() => {
        "use strict";
        /*!******************************!*\
          !*** ./src/scripts/index.js ***!
          \******************************/
        var _styles_main_scss__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ../styles/main.scss */ "./src/styles/main.scss");
        var _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./helpers/R2Dom */ "./src/scripts/helpers/R2Dom.js");
        var _helpers_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./helpers/globals */ "./src/scripts/helpers/globals.js");
        var _helpers_Animations_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./helpers/Animations.js */ "./src/scripts/helpers/Animations.js");
        let isChrome;
        const userAgent = navigator.userAgent.toLowerCase();
        if (userAgent.indexOf("chrome") > -1) {
            isChrome = !0
        } else {
            isChrome = !1
        }

        function importAll(r) {
            r.keys().forEach(r)
        }
        importAll(__webpack_require__("./src/scripts/methods-global sync recursive \\.js$"));
        if (!window.isFirstTime) {
            _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_1__["default"].Init();
            setTimeout(() => {
                (0, _helpers_Animations_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
                document.documentElement.classList.add("loaded")
            }, 500)
        } else {
            window.initR2DOM = () => {
                _helpers_R2Dom__WEBPACK_IMPORTED_MODULE_1__["default"].Init();
                setTimeout(() => {
                    (0, _helpers_Animations_js__WEBPACK_IMPORTED_MODULE_3__["default"])();
                    document.documentElement.classList.add("loaded")
                }, 500)
            }
        }
    })()
})()